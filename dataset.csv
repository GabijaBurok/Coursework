language;code;text
Python;def maxPresum ( a , b ) : NEW_LINE INDENT X = max ( a [ 0 ] , 0 ) NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT a [ i ] += a [ i - 1 ] NEW_LINE X = max ( X , a [ i ] ) NEW_LINE DEDENT Y = max ( b [ 0 ] , 0 ) NEW_LINE for i in range ( 1 , len ( b ) ) : NEW_LINE INDENT b [ i ] += b [ i - 1 ] NEW_LINE Y = max ( Y , b [ i ] ) NEW_LINE DEDENT return X + Y NEW_LINE DEDENT A = [ 2 , - 1 , 4 , - 5 ] NEW_LINE B = [ 4 , - 3 , 12 , 4 , - 3 ] NEW_LINE print ( maxPresum ( A , B ) ) NEW_LINE;"Maximum Prefix Sum possible by merging two given arrays | Python3 implementation of the above approach ; Stores the maximum prefix sum of the array A [ ] ; Traverse the array A [ ] ; Stores the maximum prefix sum of the array B [ ] ; Traverse the array B [ ] ; Driver code"
Python;"import math NEW_LINE def sumOfTwoCubes ( n ) : NEW_LINE INDENT lo = 1 NEW_LINE hi = round ( math . pow ( n , 1 / 3 ) ) NEW_LINE while ( lo <= hi ) : NEW_LINE INDENT curr = ( lo * lo * lo + hi * hi * hi ) NEW_LINE if ( curr == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( curr < n ) : NEW_LINE INDENT lo += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hi -= 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT N = 28 NEW_LINE if ( sumOfTwoCubes ( N ) ) : NEW_LINE INDENT print ( "" True "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" False "" ) NEW_LINE DEDENT";"Check if a number can be represented as sum of two positive perfect cubes | Python3 program for the above approach ; Function to check if N can be represented as sum of two perfect cubes or not ; If it is same return true ; ; If the curr smaller than n increment the lo ; If the curr is greater than curr decrement the hi ; Driver Code ; Function call to check if N can be represented as sum of two perfect cubes or not"
Python;"sieve = [ 1 ] * ( 1000000 + 1 ) NEW_LINE def sieveOfPrimes ( ) : NEW_LINE INDENT global sieve NEW_LINE N = 1000000 NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT if i * i > N : NEW_LINE INDENT break NEW_LINE DEDENT if ( sieve [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( i * i , N + 1 , i ) : NEW_LINE INDENT sieve [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT def getArray ( arr , N ) : NEW_LINE INDENT global sieve NEW_LINE A = [ 0 ] * N NEW_LINE v = [ ] NEW_LINE sieveOfPrimes ( ) NEW_LINE for i in range ( 2 , int ( 1e5 ) + 1 ) : NEW_LINE INDENT if ( sieve [ i ] ) : NEW_LINE INDENT v . append ( i ) NEW_LINE DEDENT DEDENT j = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ind = arr [ i ] NEW_LINE if ( A [ i ] != 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( A [ ind ] != 0 ) : NEW_LINE INDENT A [ i ] = A [ ind ] NEW_LINE DEDENT else : NEW_LINE INDENT prime = v [ j ] NEW_LINE A [ i ] = prime NEW_LINE A [ ind ] = A [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT print ( A [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 1 , 2 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE getArray ( arr , N ) NEW_LINE DEDENT";"Generate an N | Python3 program for the above approach ; Function to generate all prime numbers upto 10 ^ 6 ; Initialize sieve [ ] as 1 ; Iterate over the range [ 2 , N ] ; If current element is non - prime ; Make all multiples of i as 0 ; Function to construct an array A [ ] satisfying the given conditions ; Stores the resultant array ; Stores all prime numbers ; Sieve of Erastosthenes ; Append the integer i if it is a prime ; Indicates current position in list of prime numbers ; Traverse the array arr [ ] ; If already filled with another prime number ; If A [ i ] is not filled but A [ ind ] is filled ; Store A [ i ] = A [ ind ] ; If none of them were filled ; To make sure A [ i ] does not affect other values , store next prime number ; Print the resultant array ; Driver Code ; Function Call"
Python;def findNthNumber ( N ) : NEW_LINE INDENT result = 0 NEW_LINE p = 1 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT result += ( p * ( N % 9 ) ) NEW_LINE N = N // 9 NEW_LINE p = p * 10 NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9 NEW_LINE print ( findNthNumber ( N ) ) NEW_LINE DEDENT;"Nth natural number after removing all numbers consisting of the digit 9 | Function to find Nth number in base 9 ; Stores the Nth number ; Iterate while N is greater than 0 ; Update result ; Divide N by 9 ; Multiply p by 10 ; Return result ; Driver Code"
Python;"import math NEW_LINE def check ( A , B ) : NEW_LINE INDENT if ( A == B ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT dig1 = math . floor ( math . log10 ( A ) + 1 ) NEW_LINE dig2 = math . floor ( math . log10 ( B ) + 1 ) NEW_LINE if ( dig1 != dig2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT temp = A NEW_LINE while ( True ) : NEW_LINE INDENT power = pow ( 10 , dig1 - 1 ) NEW_LINE firstdigit = A // power NEW_LINE A = A - firstdigit * power NEW_LINE A = A * 10 + firstdigit NEW_LINE if ( A == B ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( A == temp ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT A , B = 967 , 679 NEW_LINE if ( check ( A , B ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Check if an integer is rotation of another given integer | Python3 implementation of the approach ; Function to check if the integer A is a rotation of the integer B ; Stores the count of digits in A ; Stores the count of digits in B ; If dig1 not equal to dig2 ; Stores position of first digit ; Stores the first digit ; Rotate the digits of the integer ; If A is equal to B ; If A is equal to the initial value of integer A ; Driver code"
Python;"def sameProductQuadruples ( nums , N ) : NEW_LINE INDENT umap = { } ; NEW_LINE res = 0 ; NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT prod = nums [ i ] * nums [ j ] ; NEW_LINE if prod in umap : NEW_LINE INDENT res += 8 * umap [ prod ] ; NEW_LINE umap [ prod ] += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT umap [ prod ] = 1 NEW_LINE DEDENT DEDENT DEDENT print ( res ) ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 6 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE sameProductQuadruples ( arr , N ) ; NEW_LINE DEDENT";"Count of quadruples with product of a pair equal to the product of the remaining pair | Function to count the number of unique quadruples from an array that satisfies the given condition ; Hashmap to store the product of pairs ; Store the count of required quadruples ; Traverse the array arr [ ] and generate all possible pairs ; Store their product ; Pair ( a , b ) can be used to generate 8 unique permutations with another pair ( c , d ) ; Increment umap [ prod ] by 1 ; Print the result ; Driver Code"
Python;MOD = 1000000007 NEW_LINE def power ( x , y , p = MOD ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def totalWays ( N , M ) : NEW_LINE INDENT X = N // 2 NEW_LINE S = ( X * ( X + 1 ) ) % MOD NEW_LINE print ( power ( S , M , MOD ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N , M = 5 , 2 NEW_LINE totalWays ( N , M ) NEW_LINE DEDENT;"Count ways to place M objects in distinct partitions of N boxes | Python3 implementation of the above Approach ; Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; Initialize Result ; Update x if x >= MOD to avoid multiplication overflow ; If y is odd , multiply x with result ; y = y / 2 ; Change x to x ^ 2 ; Utility function to find the Total Number of Ways ; Number of Even Indexed Boxes ; Number of partitions of Even Indexed Boxes ; Number of ways to distribute objects ; Driver Code ; N = number of boxes M = number of distinct objects ; Function call to get Total Number of Ways"
Python;"def isCycleExists ( arr , N ) : NEW_LINE INDENT valley = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] and arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( "" No "" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 4 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE isCycleExists ( arr , N ) NEW_LINE DEDENT";"Check if a graph constructed from an array based on given conditions consists of a cycle or not | Function to check if the graph constructed from given array contains a cycle or not ; Traverse the array ; If arr [ i ] is less than arr [ i - 1 ] and arr [ i ] ; Driver Code ; Given array ; Size of the array"
Python;def getMax ( arr , N , K ) : NEW_LINE INDENT for i in range ( 1 , N , 1 ) : NEW_LINE INDENT cur_val = arr [ i ] NEW_LINE while ( K >= i ) : NEW_LINE INDENT if ( cur_val > 0 ) : NEW_LINE INDENT arr [ 0 ] = arr [ 0 ] + 1 NEW_LINE cur_val = cur_val - 1 NEW_LINE K = K - i NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT print ( arr [ 0 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 , 3 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE K = 5 NEW_LINE getMax ( arr , N , K ) NEW_LINE DEDENT;"Maximize first array element by performing given operations at most K times | Function to maximize the first array element ; Traverse the array ; Initialize cur_val to a [ i ] ; If all operations are not over yet ; If current value is greater than zero ; Incrementing first element of array by 1 ; Decrementing current value of array by 1 ; Decrementing number of operations by i ; If current value is zero , then break ; Print first array element ; Driver Code ; Given array ; Size of the array ; Given K ; Prints the maximum possible value of the first array element"
Python;import sys NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def DistinctValues ( arr , N ) : NEW_LINE INDENT max_value = - sys . maxsize - 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE max_value = max ( arr ) NEW_LINE GCDArr = arr [ 0 ] NEW_LINE INDENT GCDArr = gcd ( GCDArr , arr [ i ] ) NEW_LINE DEDENT answer = max_value // GCDArr NEW_LINE return answer + 1 NEW_LINE DEDENT arr = [ 4 , 12 , 16 , 24 ] NEW_LINE N = len ( arr ) NEW_LINE print ( DistinctValues ( arr , N ) ) NEW_LINE;"Count Non | Python3 program of the above approach ; Function to find the gcd of the two numbers ; Function to find distinct elements in the array by repeatidely inserting the absolute difference of all possible pairs ; Stores largest element of the array ; Traverse the array , arr [ ] ; Update max_value ; Stores GCD of array ; Update GCDArr ; Stores distinct elements in the array by repeatedely inserting absolute difference of all possible pairs ; Given array arr [ ]"
Python;"def minSwaps ( b ) : NEW_LINE INDENT n = len ( b ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( b [ 0 ] [ 0 ] ^ b [ 0 ] [ j ] ^ b [ i ] [ 0 ] ^ b [ i ] [ j ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT DEDENT rowSum = 0 NEW_LINE colSum = 0 NEW_LINE rowSwap = 0 NEW_LINE colSwap = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT rowSum += b [ i ] [ 0 ] NEW_LINE colSum += b [ 0 ] [ i ] NEW_LINE rowSwap += b [ i ] [ 0 ] == i % 2 NEW_LINE colSwap += b [ 0 ] [ i ] == i % 2 NEW_LINE DEDENT if ( rowSum != n // 2 and rowSum != ( n + 1 ) // 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( colSum != n // 2 and colSum != ( n + 1 ) // 2 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT if ( colSwap % 2 ) : NEW_LINE INDENT colSwap = n - colSwap NEW_LINE DEDENT if ( rowSwap % 2 ) : NEW_LINE INDENT rowSwap = n - rowSwap NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT colSwap = min ( colSwap , n - colSwap ) NEW_LINE rowSwap = min ( rowSwap , n - rowSwap ) NEW_LINE DEDENT return ( rowSwap + colSwap ) // 2 NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT M = [ [ 0 , 1 , 1 , 0 ] , [ 0 , 1 , 1 , 0 ] , [ 1 , 0 , 0 , 1 ] , [ 1 , 0 , 0 , 1 ] ] NEW_LINE ans = minSwaps ( M ) NEW_LINE print ( ans ) NEW_LINE DEDENT";"Minimum row or column swaps required to make every pair of adjacent cell of a Binary Matrix distinct | Function to return number of moves to convert matrix into chessboard ; Size of the matrix ; Traverse the matrix ; Initialize rowSum to count 1 s in row ; Initialize colSum to count 1 s in column ; To store no . of rows to be corrected ; To store no . of columns to be corrected ; Traverse in the range [ 0 , N - 1 ] ; Check if rows is either N / 2 or ( N + 1 ) / 2 and return - 1 ; Check if rows is either N / 2 or ( N + 1 ) / 2 and return - 1 ; Check if N is odd ; Check if column required to be corrected is odd and then assign N - colSwap to colSwap ; Check if rows required to be corrected is odd and then assign N - rowSwap to rowSwap ; Take min of colSwap and N - colSwap ; Take min of rowSwap and N - rowSwap ; Finally return answer ; Driver Code ; Given matrix ; Function Call ; Print answer"
Python;def count_setbit ( N ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 32 ) : NEW_LINE if ( ( 1 << i ) & N ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 43 NEW_LINE count_setbit ( N ) NEW_LINE DEDENT;"Minimum number of coins having value equal to powers of 2 required to obtain N | Function to count of set bit in N ; Stores count of set bit in N ; Iterate over the range [ 0 , 31 ] ; If current bit is set ; Update result ; Driver Code"
Python;mod = 1000000007 NEW_LINE def ValOfTheExpression ( n ) : NEW_LINE INDENT global mod NEW_LINE factorial = [ 0 for i in range ( n + 1 ) ] NEW_LINE factorial [ 0 ] = 1 NEW_LINE factorial [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT factorial [ i ] = ( ( factorial [ i - 1 ] % mod ) * ( i % mod ) ) % mod NEW_LINE DEDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT dp [ i ] = ( ( dp [ i - 1 ] % mod ) * ( factorial [ i ] % mod ) ) % mod NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print ( ValOfTheExpression ( n ) ) NEW_LINE DEDENT;"Evaluate the expression ( N1 * ( N | Python 3 program to implement the above approach ; Function to find the value of the expression ( N ^ 1 * ( N 1 ) ^ 2 * ... * 1 ^ N ) % ( 109 + 7 ) . ; factorial [ i ] : Stores factorial of i ; Base Case for factorial ; Precompute the factorial ; dp [ N ] : Stores the value of the expression ( N ^ 1 * ( N 1 ) ^ 2 * ... * 1 ^ N ) % ( 109 + 7 ) . ; Update dp [ i ] ; Return the answer . ; Driver Code ; Function call"
Python;def minChocolates ( A , N ) : NEW_LINE INDENT B = [ 1 for i in range ( N ) ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( A [ i ] > A [ i - 1 ] ) : NEW_LINE INDENT B [ i ] = B [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT B [ i ] = 1 NEW_LINE DEDENT DEDENT for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( A [ i ] > A [ i + 1 ] ) : NEW_LINE INDENT B [ i ] = max ( B [ i + 1 ] + 1 , B [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT B [ i ] = max ( B [ i ] , 1 ) NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += B [ i ] NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 23 , 14 , 15 , 14 , 56 , 29 , 14 ] NEW_LINE N = len ( A ) NEW_LINE minChocolates ( A , N ) NEW_LINE DEDENT;"Chocolate Distribution Problem | Set 2 | Function to print minimum number of candies required ; Distribute 1 chocolate to each ; Traverse from left to right ; Traverse from right to left ; Initialize sum ; Find total sum ; Return sum ; Driver Code ; Given array ; Size of the given array"
Python;"from math import sqrt , ceil , floor NEW_LINE def constructArrayWithGivenLCM ( N ) : NEW_LINE INDENT newArr = [ ] NEW_LINE for i in range ( 1 , ceil ( sqrt ( N + 1 ) ) ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT newArr . append ( i ) NEW_LINE if ( N // i != i ) : NEW_LINE INDENT newArr . append ( N // i ) NEW_LINE DEDENT DEDENT DEDENT newArr = sorted ( newArr ) NEW_LINE for i in newArr : NEW_LINE INDENT print ( i , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE constructArrayWithGivenLCM ( N ) NEW_LINE DEDENT";"Construct longest possible sequence of unique elements with given LCM | Python3 program to implement the above approach ; Function to construct an array of unique elements whose LCM is N ; Stores array elements whose LCM is N ; Iterate over the range [ 1 , sqrt ( N ) ] ; If N is divisible by i ; Insert i into newArr [ ] ; If N is not perfect square ; Sort the array newArr [ ] ; Print array elements ; Driver Code ; Given N ; Function Call"
Python;def getPower ( p ) : NEW_LINE INDENT res = 1 NEW_LINE while ( p ) : NEW_LINE INDENT res *= 5 NEW_LINE p -= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def countNumbersUtil ( N ) : NEW_LINE INDENT count = 0 NEW_LINE digits = [ ] NEW_LINE while ( N ) : NEW_LINE INDENT digits . append ( N % 10 ) NEW_LINE N //= 10 NEW_LINE DEDENT digits . reverse ( ) NEW_LINE D = len ( digits ) NEW_LINE for i in range ( 1 , D + 1 , 1 ) : NEW_LINE INDENT res = getPower ( i ) NEW_LINE if ( i == D ) : NEW_LINE INDENT for p in range ( 1 , D + 1 , 1 ) : NEW_LINE INDENT x = digits [ p - 1 ] NEW_LINE tmp = 0 NEW_LINE if ( p % 2 == 0 ) : NEW_LINE INDENT tmp = ( ( 5 - ( x // 2 + 1 ) ) * getPower ( D - p ) ) NEW_LINE DEDENT else : NEW_LINE INDENT tmp = ( ( 5 - ( x + 1 ) // 2 ) * getPower ( D - p ) ) NEW_LINE DEDENT res -= tmp NEW_LINE if ( p % 2 != x % 2 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT count += res NEW_LINE DEDENT return count NEW_LINE DEDENT def countNumbers ( L , R ) : NEW_LINE INDENT print ( countNumbersUtil ( R ) - countNumbersUtil ( L - 1 ) ) NEW_LINE DEDENT L = 128 NEW_LINE R = 162 NEW_LINE countNumbers ( L , R ) NEW_LINE;"Count numbers from given range having odd digits at odd places and even digits at even places | Function to calculate 5 ^ p ; Stores the result ; Multiply 5 p times ; Return the result ; Function to count anumbers upto N having odd digits at odd places and even digits at even places ; Stores the count ; Stores the digits of N ; Insert the digits of N ; Reverse the vector to arrange the digits from first to last ; Stores count of digits of n ; Stores the count of numbers with i digits ; If the last digit is reached , subtract numbers eceeding range ; Iterate over athe places ; Stores the digit in the pth place ; Stores the count of numbers having a digit greater than x in the p - th position ; Calculate the count of numbers exceeding the range if p is even ; Calculate the count of numbers exceeding the range if p is odd ; Subtract the count of numbers exceeding the range from total count ; If the parity of p and the parity of x are not same ; Add count of numbers having i digits and satisfies the given conditions ; Return the total count of numbers tin ; Function to calculate the count of numbers from given range having odd digits places and even digits at even places ; Count of numbers in range [ L , R ] = Count of numbers tiR - ; Count of numbers ti ( L - 1 ) ; Driver Code"
Python;"def alternatingSumOfFirst_N ( N ) : NEW_LINE INDENT alternateSum = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT alternateSum += - i NEW_LINE DEDENT else : NEW_LINE INDENT alternateSum += i NEW_LINE DEDENT DEDENT return alternateSum NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 6 NEW_LINE print ( alternatingSumOfFirst_N ( N ) ) NEW_LINE DEDENT";"Sum of first N natural numbers with alternate signs | Function to find the sum of First N natural numbers with alternate signs ; Stores sum of alternate sign of First N natural numbers ; If is an even number ; Update alternateSum ; If i is an odd number ; Update alternateSum ; Driver Code"
Python;"def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b ; NEW_LINE DEDENT return gcd ( b % a , a ) ; NEW_LINE DEDENT def findSum ( N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if ( gcd ( i , N ) == 1 ) : NEW_LINE INDENT sum += i ; NEW_LINE DEDENT DEDENT return sum ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 ; NEW_LINE print ( findSum ( N ) ) ; NEW_LINE DEDENT";"Sum of all numbers up to N that are co | Function to return gcd of a and b ; Base Case ; Recursive GCD ; Function to calculate the sum of all numbers till N that are coprime with N ; Stores the resultant sum ; Iterate over [ 1 , N ] ; If gcd is 1 ; Update sum ; Return the final sum ; Driver Code ; Given N ; Function Call"
Python;"def solve ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in arr : NEW_LINE INDENT mp [ i ] = mp . get ( i , 0 ) + 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for x in mp : NEW_LINE INDENT cnt += ( ( mp [ x ] ) * ( mp [ x ] - 1 ) // 2 ) NEW_LINE DEDENT ans = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans [ i ] = cnt - ( mp [ arr [ i ] ] - 1 ) NEW_LINE DEDENT for i in ans : NEW_LINE INDENT print ( i , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 1 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE solve ( arr , N ) NEW_LINE DEDENT";"Count all distinct pairs of repeating elements from the array for every array element | Function to prthe required count of pairs excluding the current element ; Store the frequency ; Find all the count ; Delete the contribution of each element for equal pairs ; Print the answer ; Driver Code ; Given array arr [ ] ; Function call"
Python;"def findMode ( a , n ) : NEW_LINE INDENT mp = { } NEW_LINE max = 0 NEW_LINE mode = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] in mp : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ a [ i ] ] = 1 NEW_LINE DEDENT if ( mp [ a [ i ] ] >= max ) : NEW_LINE INDENT max = mp [ a [ i ] ] NEW_LINE mode = a [ i ] NEW_LINE DEDENT print ( mode , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT arr = [ 2 , 7 , 3 , 2 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE findMode ( arr , n ) NEW_LINE";"Mode in a stream of integers ( running integers ) | Function that prints the Mode values ; Map used to mp integers to its frequency ; To store the maximum frequency ; To store the element with the maximum frequency ; Loop used to read the elements one by one ; Updates the frequency of that element ; Checks for maximum Number of occurrence ; Updates the maximum frequency ; Updates the Mode ; Driver Code ; Function call"
Python;"def modexp ( x , n , m ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return modexp ( ( x * x ) % m , n / 2 , m ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( x * modexp ( ( x * x ) % m , ( n - 1 ) / 2 , m ) % m ) NEW_LINE DEDENT DEDENT DEDENT def modInverse ( x , m ) : NEW_LINE INDENT return modexp ( x , m - 2 , m ) NEW_LINE DEDENT def countNumbers ( N ) : NEW_LINE INDENT m = 1000000007 NEW_LINE factorial = [ 0 for x in range ( 100001 ) ] NEW_LINE factorial [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , 100001 ) : NEW_LINE INDENT factorial [ i ] = ( factorial [ i - 1 ] * i ) % m NEW_LINE DEDENT count = [ 0 for x in range ( 10 ) ] NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE INDENT count [ i ] = 0 NEW_LINE DEDENT length = len ( N ) NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT count [ int ( N [ i ] ) ] += 1 NEW_LINE DEDENT result = factorial [ int ( length ) ] NEW_LINE for i in range ( 0 , 10 ) : NEW_LINE INDENT result = ( result * modInverse ( factorial [ int ( count [ i ] ) ] , m ) ) % m NEW_LINE DEDENT print ( result ) NEW_LINE DEDENT N = ""0223"" ; NEW_LINE countNumbers ( N ) NEW_LINE";"Count of distinct numbers formed by shuffling the digits of a large number N | Recursive function to return the value of ( x ^ n ) % m ; Base Case ; If N is even ; Else N is odd ; Function to find modular inverse of a number x under modulo m ; Using Fermat 's little theorem ; Function to count of numbers formed by shuffling the digits of a large number N ; Modulo value ; Array to store the factorials upto the maximum value of N ; Store factorial of i at index i ; To store count of occurrence of a digit ; Increment the count of digit occured ; Assign the factorial of length of input ; Multiplying result with the modulo multiplicative inverse of factorial of count of i ; Print the result ; Given number as string ; Function call"
Python;"spf = [ 0 for i in range ( 10001 ) ] NEW_LINE def spf_array ( spf ) : NEW_LINE INDENT spf [ 1 ] = 1 NEW_LINE for i in range ( 2 , 1000 , 1 ) : NEW_LINE INDENT spf [ i ] = i NEW_LINE DEDENT for i in range ( 4 , 1000 , 2 ) : NEW_LINE INDENT spf [ i ] = 2 NEW_LINE DEDENT i = 3 NEW_LINE while ( i * i < 1000 ) : NEW_LINE INDENT if ( spf [ i ] == i ) : NEW_LINE INDENT j = i * i NEW_LINE while ( j < 1000 ) : NEW_LINE INDENT if ( spf [ j ] == j ) : NEW_LINE INDENT spf [ j ] = i NEW_LINE DEDENT j += i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT def frequent_prime ( arr , N , K ) : NEW_LINE INDENT spf_array ( spf ) NEW_LINE Hmap = { } NEW_LINE result = [ ] NEW_LINE i = 0 NEW_LINE c = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE while ( x != 1 ) : NEW_LINE INDENT Hmap [ spf [ x ] ] = Hmap . get ( spf [ x ] , 0 ) + 1 NEW_LINE x = x // spf [ x ] NEW_LINE DEDENT DEDENT if ( 1 in Hmap ) : NEW_LINE Hmap . pop ( 1 ) NEW_LINE for key , value in Hmap . items ( ) : NEW_LINE INDENT primeNum = key NEW_LINE frequency = value NEW_LINE if ( frequency % K == 0 ) : NEW_LINE INDENT result . append ( primeNum ) NEW_LINE DEDENT DEDENT result = result [ : : - 1 ] NEW_LINE if ( len ( result ) > 0 ) : NEW_LINE INDENT for it in result : NEW_LINE INDENT print ( it , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( "" { } "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 4 , 6 ] NEW_LINE K = 1 NEW_LINE N = len ( arr ) NEW_LINE frequent_prime ( arr , N , K ) NEW_LINE DEDENT";"Find prime factors of Array elements whose sum of exponents is divisible by K | To store the smallest prime factor till 10 ^ 5 ; Function to compute smallest prime factor array ; Initialize the spf array first element ; Marking smallest prime factor for every number to be itself ; Separately marking smallest prime factor for every even number as 2 ; Checking if i is prime ; Marking SPF for all numbers divisible by i ; Marking spf [ j ] if it is not previously marked ; Function that finds minimum operation ; Create a spf [ ] array ; Map created to store the unique prime numbers ; To store the result ; To store minimum operations ; To store every unique prime number ; Erase 1 as a key because it is not a prime number ; First Prime Number ; Frequency is divisible by K then insert primeNum in the result [ ] ; Print the elements if it exists ; Driver Code ; Given array arr [ ] ; Given K ; Function Call"
Python;"def Kmultiples ( n , k ) : NEW_LINE INDENT a = n NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT print ( "" { } ▁ * ▁ { } ▁ = ▁ { } "" . format ( n , i , a ) ) NEW_LINE j = 0 NEW_LINE while ( n >= ( 1 << j ) ) : NEW_LINE INDENT a += n & ( 1 << j ) NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT N = 16 NEW_LINE K = 7 NEW_LINE Kmultiples ( N , K ) NEW_LINE";"Generate first K multiples of N using Bitwise operators | Function to print the first K multiples of N ; Print the value of N * i ; Iterate each bit of N and add pow ( 2 , pos ) , where pos is the index of each set bit ; Check if current bit at pos j is fixed or not ; For next set bit ; Driver Code"
Python;"def calculateB ( x , y , n ) : NEW_LINE INDENT sx = sum ( x ) NEW_LINE sy = sum ( y ) NEW_LINE sxsy = 0 NEW_LINE sx2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sxsy += x [ i ] * y [ i ] NEW_LINE sx2 += x [ i ] * x [ i ] NEW_LINE DEDENT b = ( n * sxsy - sx * sy ) / ( n * sx2 - sx * sx ) NEW_LINE return b NEW_LINE DEDENT def leastRegLine ( X , Y , n ) : NEW_LINE INDENT b = calculateB ( X , Y , n ) NEW_LINE meanX = int ( sum ( X ) / n ) NEW_LINE meanY = int ( sum ( Y ) / n ) NEW_LINE a = meanY - b * meanX NEW_LINE print ( "" Regression ▁ line : "" ) NEW_LINE print ( "" Y ▁ = ▁ "" , ' % .3f ' % a , "" ▁ + ▁ "" , ' % .3f ' % b , "" * X "" , sep = "" "" ) NEW_LINE DEDENT X = [ 95 , 85 , 80 , 70 , 60 ] NEW_LINE Y = [ 90 , 80 , 70 , 65 , 60 ] NEW_LINE n = len ( X ) NEW_LINE leastRegLine ( X , Y , n ) NEW_LINE";"Least Square Regression Line | Function to calculate b ; sum of array x ; sum of array y ; for sum of product of x and y ; sum of square of x ; Function to find the least regression line ; Finding b ; Calculating a ; Printing regression line ; Statistical data"
Python;def countRepeatingDigits ( N ) : NEW_LINE INDENT res = 0 NEW_LINE cnt = [ 0 ] * 10 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT rem = N % 10 NEW_LINE cnt [ rem ] += 1 NEW_LINE N = N // 10 NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT if ( cnt [ i ] > 1 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT N = 12 NEW_LINE print ( countRepeatingDigits ( N ) ) NEW_LINE;"Count of repeating digits in a given Number | Function that returns the count of repeating digits of the given number ; Initialize a variable to store count of Repeating digits ; Initialize cnt array to store digit count ; Iterate through the digits of N ; Retrieve the last digit of N ; Increase the count of digit ; Remove the last digit of N ; Iterate through the cnt array ; If frequency of digit is greater than 1 ; Increment the count of Repeating digits ; Return count of repeating digit ; Given array arr [ ] ; Function call"
Python;"def findTemperature ( x , y , s ) : NEW_LINE INDENT diff = ( x - y ) * 6 NEW_LINE Day2 = ( diff + s ) // 2 NEW_LINE Day1 = s - Day2 NEW_LINE print ( "" Day1 ▁ : ▁ "" , Day1 ) NEW_LINE print ( "" Day2 ▁ : ▁ "" , Day2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 5 NEW_LINE y = 10 NEW_LINE s = 40 NEW_LINE findTemperature ( x , y , s ) NEW_LINE DEDENT";"Find temperature of missing days using given sum and average | Function for finding the temperature ; Store Day1 - Day2 in diff ; Remaining from s will be Day1 ; Print Day1 and Day2 ; Driver Code ; Functions"
Python;def findAandB ( n , k ) : NEW_LINE INDENT flag = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if str ( i ) . count ( chr ( k + 48 ) ) == 0 and str ( n - i ) . count ( chr ( k + 48 ) ) == 0 : NEW_LINE INDENT print ( i , n - i ) NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 100 NEW_LINE K = 0 NEW_LINE findAandB ( N , K ) NEW_LINE DEDENT;"Find two numbers whose sum is N and does not contain any digit as K | Function to find two numbers whose sum is N and do not contain any digit as k ; Check every number i and ( n - i ) ; Check if i and n - i doesn 't  contain k in them print i and n-i ; check if flag is 0 then print - 1 ; Driver Code ; Given N and K ; Function Call"
Python;def calculate ( p , q ) : NEW_LINE INDENT mod = 998244353 NEW_LINE expo = 0 NEW_LINE expo = mod - 2 NEW_LINE while ( expo ) : NEW_LINE INDENT if ( expo & 1 ) : NEW_LINE INDENT p = ( p * q ) % mod NEW_LINE DEDENT q = ( q * q ) % mod NEW_LINE expo >>= 1 NEW_LINE DEDENT return p NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT p = 1 NEW_LINE q = 4 NEW_LINE print ( calculate ( p , q ) ) NEW_LINE DEDENT;"Find the value of P and modular inverse of Q modulo 998244353 | Function to find the value of P * Q ^ - 1 mod 998244353 ; Loop to find the value until the expo is not zero ; Multiply p with q if expo is odd ; Reduce the value of expo by 2 ; Driver code ; Function call"
Python;"def maxLCMWithGivenSum ( X ) : NEW_LINE INDENT if X % 2 != 0 : NEW_LINE INDENT A = X / 2 NEW_LINE B = X / 2 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( X / 2 ) % 2 == 0 : NEW_LINE INDENT A = X / 2 - 1 NEW_LINE B = X / 2 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT A = X / 2 - 2 NEW_LINE B = X / 2 + 2 NEW_LINE DEDENT DEDENT print ( int ( A ) , int ( B ) , end = "" ▁ "" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 30 NEW_LINE maxLCMWithGivenSum ( X ) NEW_LINE DEDENT";"Find two numbers with given sum and maximum possible LCM | Function that print two numbers with the sum X and maximum possible LCM ; If X is odd ; If X is even ; If floor ( X / 2 ) is even ; If floor ( X / 2 ) is odd ; Print the result ; Driver Code ; Given Number ; Function call"
Python;"def MaxSubarrayLength ( arr , n , k ) : NEW_LINE INDENT left = - 1 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] % k ) != 0 ) : NEW_LINE INDENT if ( left == - 1 ) : NEW_LINE INDENT left = i NEW_LINE DEDENT right = i NEW_LINE DEDENT sum += arr [ i ] NEW_LINE DEDENT if ( ( sum % k ) != 0 ) : NEW_LINE INDENT return n NEW_LINE DEDENT elif ( left == - 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT prefix_length = left + 1 NEW_LINE suffix_length = n - right NEW_LINE return n - min ( prefix_length , suffix_length ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 6 , 3 , 12 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE K = 3 NEW_LINE print ( MaxSubarrayLength ( arr , n , K ) ) NEW_LINE DEDENT";"Length of longest subarray whose sum is not divisible by integer K | Function to find the longest subarray with sum is not divisible by k ; left is the index of the leftmost element that is not divisible by k ; sum of the array ; Find the element that is not multiple of k ; left = - 1 means we are finding the leftmost element that is not divisible by k ; Updating the rightmost element ; Update the sum of the array up to the index i ; Check if the sum of the array is not divisible by k , then return the size of array ; All elements of array are divisible by k , then no such subarray possible so return - 1 ; length of prefix elements that can be removed ; length of suffix elements that can be removed ; Return the length of subarray after removing the elements which have lesser number of elements ; Driver Code"
Python;def solve ( X , Y ) : NEW_LINE INDENT if ( X > Y ) : NEW_LINE INDENT temp = X NEW_LINE X = Y NEW_LINE Y = temp NEW_LINE DEDENT if ( X == Y ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT elif ( Y % X == 0 ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT DEDENT X = 8 NEW_LINE Y = 13 NEW_LINE solve ( X , Y ) NEW_LINE;"Minimum steps to convert X to Y by repeated division and multiplication | Python3 implementation to find minimum steps to convert X to Y by repeated division and multiplication ; Check if X is greater than Y then swap the elements ; Check if X equals Y ; Driver code"
Python;"from collections import defaultdict NEW_LINE def countQuadraples ( N ) : NEW_LINE INDENT cnt = 0 NEW_LINE m = defaultdict ( int ) NEW_LINE for a in range ( 1 , N + 1 ) : NEW_LINE INDENT for b in range ( 1 , N + 1 ) : NEW_LINE INDENT x = a * a + b * b NEW_LINE m [ x ] += 1 NEW_LINE DEDENT DEDENT for c in range ( 1 , N + 1 ) : NEW_LINE INDENT for d in range ( 1 , N + 1 ) : NEW_LINE INDENT x = c * c + d * d NEW_LINE if x in m : NEW_LINE INDENT cnt += m [ x ] NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 2 NEW_LINE print ( countQuadraples ( N ) ) NEW_LINE DEDENT";"Count quadruplets ( A , B , C , D ) till N such that sum of square of A and B is equal to that of C and D | Python3 program for the above approach ; Function to count the quadruples ; Counter variable ; Map to store the sum of pair ( a ^ 2 + b ^ 2 ) ; Iterate till N ; Calculate a ^ 2 + b ^ 2 ; Increment the value in map ; Check if this sum was also in a ^ 2 + b ^ 2 ; Return the count ; Driver Code ; Given N ; Function Call"
Python;from bisect import bisect_left NEW_LINE def numberOfPairs ( a , b , n ) : NEW_LINE INDENT c = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT c [ i ] = a [ i ] - b [ i ] NEW_LINE DEDENT c = sorted ( c ) NEW_LINE answer = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( c [ i ] <= 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT pos = bisect_left ( c , - c [ i ] + 1 ) NEW_LINE answer += ( i - pos ) NEW_LINE DEDENT return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE a = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE b = [ 2 , 5 , 6 , 1 , 9 ] NEW_LINE print ( numberOfPairs ( a , b , n ) ) NEW_LINE DEDENT;"Count of distinct index pair ( i , j ) such that element sum of First Array is greater | Python3 program of the above approach ; Function to find the number of pairs . ; Array c [ ] where c [ i ] = a [ i ] - b [ i ] ; Sort the array c ; Initialise answer as 0 ; Iterate from index 0 to n - 1 ; If c [ i ] <= 0 then in the sorted array c [ i ] + c [ pos ] can never greater than 0 where pos < i ; Find the minimum index such that c [ i ] + c [ j ] > 0 which is equivalent to c [ j ] >= - c [ i ] + 1 ; Add ( i - pos ) to answer ; Return the answer ; Driver code ; Number of elements in a and b ; Array a ; Array b"
Python;def print_h_index ( arr , N ) : NEW_LINE INDENT ms = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT ms . append ( arr [ i ] ) NEW_LINE ms . sort ( ) NEW_LINE if ( ms [ 0 ] < len ( ms ) ) : NEW_LINE INDENT ms . pop ( 0 ) NEW_LINE DEDENT print ( len ( ms ) , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 9 , 10 , 7 , 5 , 0 , 10 , 2 , 0 ] NEW_LINE N = len ( arr ) NEW_LINE print_h_index ( arr , N ) NEW_LINE DEDENT;"Find K for every Array element such that at least K prefixes are â ‰¥ K | Function to find the K - value for every index in the array ; Multiset to store the array in the form of red - black tree ; Iterating over the array ; Inserting the current value in the multiset ; Condition to check if the smallest value in the set is less than it 's size ; Erase the smallest value ; h - index value will be the size of the multiset ; Driver Code ; Array ; Size of the array ; Function call"
Python;"def findPrimes ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while ( p * p <= max_val ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT return prime ; NEW_LINE DEDENT def nonRepeatingPrimes ( arr , n ) : NEW_LINE INDENT prime = findPrimes ( arr , n ) ; NEW_LINE mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT if ( arr [ i ] in mp ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT for entry in mp . keys ( ) : NEW_LINE INDENT if ( mp [ entry ] == 1 ) : NEW_LINE INDENT print ( entry ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 6 , 7 , 9 , 7 , 23 , 21 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE nonRepeatingPrimes ( arr , n ) ; NEW_LINE DEDENT";"Non | Function to find count of prime ; Find maximum value in the array ; Find and store all prime numbers up to max_val using Sieve Create a boolean array "" prime [ 0 . . n ] "" . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; Remaining part of SIEVE ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Function to print Non - repeating primes ; Precompute primes using Sieve ; Create HashMap to store frequency of prime numbers ; Traverse through array elements and Count frequencies of all primes ; Traverse through map and print non repeating primes ; Driver code"
Python;"def prefixProduct ( a , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT a [ i ] = a [ i ] * a [ i - 1 ] ; NEW_LINE DEDENT for j in range ( 0 , n ) : NEW_LINE INDENT print ( a [ j ] , end = "" , ▁ "" ) ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT arr = [ 2 , 4 , 6 , 5 , 10 ] ; NEW_LINE N = len ( arr ) ; NEW_LINE prefixProduct ( arr , N ) ; NEW_LINE";"Prefix Product Array | Function to generate prefix product array ; Update the array with the product of prefixes ; Print the array ; Driver Code"
Python;def countWays ( N ) : NEW_LINE INDENT if ( N < 4 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = ( ( N - 1 ) * ( N - 2 ) ) // 2 NEW_LINE s = 0 NEW_LINE for i in range ( 2 , N - 2 , 1 ) : NEW_LINE INDENT for j in range ( 1 , i , 1 ) : NEW_LINE INDENT if ( N == 2 * i + j ) : NEW_LINE INDENT s += 1 NEW_LINE DEDENT DEDENT DEDENT if ( N % 3 == 0 ) : NEW_LINE INDENT s = 3 * s + 1 NEW_LINE DEDENT else : NEW_LINE INDENT s = 3 * s NEW_LINE DEDENT return ans - s NEW_LINE DEDENT N = 10 NEW_LINE print ( countWays ( N ) ) NEW_LINE;"Count of ways to distribute N items among 3 people with one person receiving maximum | Function to find the number of ways to distribute N items among 3 people ; No distribution possible ; Total number of ways to distribute N items among 3 people ; Store the number of distributions which are not possible ; Count possibilities of two persons receiving the maximum ; If N is divisible by 3 ; Return the final count of ways to distribute ; Driver Code"
Python;"def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 ) or ( n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def isMagnanimous ( N ) : NEW_LINE INDENT s = str ( N ) NEW_LINE l = len ( s ) NEW_LINE if ( l < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( l - 1 ) : NEW_LINE INDENT left = s [ 0 : i + 1 ] NEW_LINE right = s [ i + 1 : ] NEW_LINE x = int ( left ) NEW_LINE y = int ( right ) NEW_LINE if ( not isPrime ( x + y ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT N = 12 NEW_LINE if isMagnanimous ( N ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Magnanimous Numbers | Function to check if n is prime ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function to check if the number is Magnanimous or not ; Converting the number to string ; Finding length of string ; Number should not be of single digit ; Loop to find all left and right part of the string ; Driver code"
Python;"limit = 10000000 NEW_LINE position = [ 0 ] * ( limit + 1 ) NEW_LINE def sieve ( ) : NEW_LINE INDENT position [ 0 ] = - 1 NEW_LINE position [ 1 ] = - 1 NEW_LINE pos = 0 NEW_LINE for i in range ( 2 , limit + 1 ) : NEW_LINE INDENT if ( position [ i ] == 0 ) : NEW_LINE INDENT pos += 1 NEW_LINE position [ i ] = pos NEW_LINE for j in range ( i * 2 , limit + 1 , i ) : NEW_LINE INDENT position [ j ] = - 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def getSum ( n ) : NEW_LINE INDENT Sum = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT Sum = Sum + n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return Sum NEW_LINE DEDENT def isHonakerPrime ( n ) : NEW_LINE INDENT pos = position [ n ] NEW_LINE if ( pos == - 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return bool ( getSum ( n ) == getSum ( pos ) ) NEW_LINE DEDENT sieve ( ) NEW_LINE N = 121 NEW_LINE if ( isHonakerPrime ( N ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Honaker Prime Number | Python3 program for the above approach ; Function to precompute the position of every prime number using Sieve ; 0 and 1 are not prime numbers ; Variable to store the position ; Incrementing the position for every prime number ; Function to get sum of digits ; Function to check whether the given number is Honaker Prime number or not ; Precompute the prime numbers till 10 ^ 6 ; Given Number ; Function Call"
Python;"import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT for i in range ( 2 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def takeSum ( a ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( 0 , 4 ) : NEW_LINE INDENT for j in range ( 0 , 5 ) : NEW_LINE INDENT s += a [ i ] [ j ] NEW_LINE DEDENT DEDENT return s ; NEW_LINE DEDENT a = [ [ 1 , 2 , 3 , 4 , 2 ] , [ 0 , 1 , 2 , 3 , 34 ] , [ 0 , 34 , 21 , 12 , 12 ] , [ 1 , 2 , 3 , 6 , 6 ] ] ; NEW_LINE sum = takeSum ( a ) ; NEW_LINE if ( isPrime ( sum ) ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT";"Check if Matrix sum is prime or not | Python3 implementation to check if the sum of matrix is prime or not ; Function to check whether a number is prime or not ; Corner case ; Check from 2 to n - 1 ; Function for to find the sum of the given matrix ; Driver Code"
Python;def sumOfSumSeries ( N ) : NEW_LINE INDENT _sum = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT _sum = _sum + ( i * ( i + 1 ) ) // 2 NEW_LINE DEDENT return _sum NEW_LINE DEDENT N = 5 NEW_LINE print ( sumOfSumSeries ( N ) ) NEW_LINE;"Sum of sum | Function to find the sum ; Calculate sum - series for every natural number and add them ; Driver code"
Python;def sumOfSumSeries ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) * ( n + 2 ) ) // 6 NEW_LINE DEDENT N = 5 NEW_LINE print ( sumOfSumSeries ( N ) ) NEW_LINE;"Sum of sum | Function to find the sum ; Driver code"
Python;"def isContaindigit ( n ) : NEW_LINE INDENT temp = str ( n ) NEW_LINE for i in temp : NEW_LINE INDENT if i not in [ '0' , '1' , '8' ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def ispalindrome ( n ) : NEW_LINE INDENT temp = str ( n ) NEW_LINE if temp == temp [ : : - 1 ] : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def isTetradic ( n ) : NEW_LINE INDENT if ispalindrome ( n ) : NEW_LINE INDENT if isContaindigit ( n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def printTetradicPrimesLessThanN ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] and isTetradic ( p ) ) : NEW_LINE INDENT print ( p , end = "" ▁ "" ) ; NEW_LINE DEDENT DEDENT DEDENT n = 1000 ; NEW_LINE printTetradicPrimesLessThanN ( n ) ; NEW_LINE";"Tetradic Primes | Function to check if the number N having all digits lies in the set ( 0 , 1 , 8 ) ; Function to check if the number N is palindrome ; Function to check if a number N is Tetradic ; Function to generate all primes and checking whether number is Tetradic or not ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Print all Tetradic prime numbers ; checking whether the given number is prime Tetradic or not ; Driver Code"
Python;def concat ( a , b ) : NEW_LINE INDENT s1 = str ( a ) NEW_LINE s2 = str ( b ) NEW_LINE s = s1 + s2 NEW_LINE c = int ( s ) NEW_LINE return c NEW_LINE DEDENT def isAstonishing ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT sum += j NEW_LINE if ( sum == n ) : NEW_LINE INDENT concatenation = concat ( i , j ) NEW_LINE if ( concatenation == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT n = 429 NEW_LINE if ( isAstonishing ( n ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT;"Astonishing Numbers | Function to concatenate two integers into one ; Convert both the integers to string ; Concatenate both strings ; Convert the concatenated string to integer ; return the formed integer ; Function to check if N is a Astonishing number ; Loop to find sum of all integers from i till the sum becomes >= n ; variable to store sum of all integers from i to j and check if sum and concatenation equals n or not ; finding concatenation of i and j ; condition for Astonishing number ; Given Number ; Function Call"
Python;"def checkSame ( n , b ) : NEW_LINE INDENT m = { } NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % b NEW_LINE n = n // b NEW_LINE if r in m : NEW_LINE INDENT m [ r ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ r ] = 1 NEW_LINE DEDENT DEDENT last = - 1 NEW_LINE for i in m : NEW_LINE INDENT if last != - 1 and m [ i ] != last : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT last = m [ i ] NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 9 NEW_LINE base = 2 NEW_LINE if ( checkSame ( n , base ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT";"Digitally balanced numbers | Function to check if the digits in the number is the same number of digits ; Loop to iterate over the digits of the number N ; Loop to iterate over the map ; Driver code ; Function to check"
Python;"def seriesSum ( n ) : NEW_LINE INDENT sum1 = 0 ; NEW_LINE currProd = 1 ; NEW_LINE currSum = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT currProd *= i ; NEW_LINE currSum += i ; NEW_LINE sum1 += currProd - currSum ; NEW_LINE DEDENT return sum1 ; NEW_LINE DEDENT N = 5 ; NEW_LINE print ( seriesSum ( N ) , end = "" ▁ "" ) ; NEW_LINE";"Sum of series formed by difference between product and sum of N natural numbers | Function to calculate the sum upto Nth term ; Stores the sum of the series ; Stores the product of natural numbers upto the current term ; Stores the sum of natural numbers upto the upto current term ; Generate the remaining terms and calculate sum ; Update the sum ; Return the sum ; Driver Code"
Python;"def count ( a , n ) : NEW_LINE INDENT countElements = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT flag = True NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( a [ i ] % a [ j ] == 0 ) : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == True ) : NEW_LINE INDENT countElements += 1 NEW_LINE DEDENT DEDENT return countElements NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 86 , 45 , 18 , 4 , 8 , 28 , 19 , 33 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( count ( arr , n ) ) NEW_LINE DEDENT";"Count of elements not divisible by any other elements of Array | Function to count the number of elements of array which are not divisible by any other element in the array arr [ ] ; Iterate over the array ; Check if the element is itself or not ; Check for divisibility ; Return the final result ; Driver Code ; Given array ; Function Call"
Python;"import math NEW_LINE def smallestNumber ( N ) : NEW_LINE INDENT return N * math . ceil ( pow ( 10 , ( N - 1 ) ) // N ) ; NEW_LINE DEDENT N = 2 ; NEW_LINE print ( smallestNumber ( N ) ) ; NEW_LINE";"Smallest N digit number divisible by N | Python3 program for the above approach ; Function to find the smallest N - digit number divisible by N ; Return the smallest N - digit number calculated using above formula ; Given N ; Function Call"
Python;def CountPairs ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 or arr [ j ] % 2 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 8 , 2 , 3 , 1 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( CountPairs ( arr , n ) ) NEW_LINE;"Count pairs in an array containing at least one even value | Function to count the pairs in the array such as there is at least one even element in each pair ; Generate all possible pairs and increment then count if the condition is satisfied ; Driver code ; Function call"
Python;def CountPairs ( arr , n ) : NEW_LINE INDENT even = 0 NEW_LINE odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT return ( ( even * ( even - 1 ) ) // 2 + ( even * odd ) ) NEW_LINE DEDENT arr = [ 8 , 2 , 3 , 1 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( CountPairs ( arr , n ) ) NEW_LINE;"Count pairs in an array containing at least one even value | Function to count the pairs in the array such as there is at least one even element in each pair ; Store count of even and odd elements ; Check element is even or odd ; Driver Code"
Python;"import math NEW_LINE def isComposite ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return False NEW_LINE DEDENT def isGiugaNum ( n ) : NEW_LINE INDENT if ( not ( isComposite ( n ) ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT N = n NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT if ( ( int ( N / 2 ) - 1 ) % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = int ( n / 2 ) NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT if ( ( int ( N / i ) - 1 ) % i != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = int ( n / i ) NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT if ( ( int ( N / n ) - 1 ) % n != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT n = 30 NEW_LINE if ( isGiugaNum ( n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Giuga Numbers | Python program for the above approach ; Function to check if n is a composite number ; Corner cases ; This is checked to skip middle 5 numbers ; Function to check if N is a Giuga Number ; N should be composite to be a Giuga Number ; Print the number of 2 s that divide n ; N must be odd at this point . So we can skip one element ; While i divides n , print i and divide n ; This condition is to handle the case when n is a prime number > 2 ; Given Number N ; Function Call"
Python;"import math ; NEW_LINE def isDroll ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT sum_even = 0 ; NEW_LINE sum_odd = 0 ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT sum_even += 2 ; NEW_LINE n = n // 2 ; NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT sum_odd += i ; NEW_LINE n = n // i ; NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT sum_odd += n ; NEW_LINE DEDENT return sum_even == sum_odd ; NEW_LINE DEDENT N = 72 ; NEW_LINE if ( isDroll ( N ) ) : NEW_LINE INDENT print ( "" Yes "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) ; NEW_LINE DEDENT";"Droll Numbers | Python3 program for the above approach ; Function to check droll numbers ; To store sum of even prime factors ; To store sum of odd prime factors ; Add the number of 2 s that divide n in sum_even ; N must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; While i divides n , print i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; Condition to check droll number ; Given Number N ; Function Call"
Python;"import math as m NEW_LINE def CountPairs ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT div1 = i NEW_LINE div2 = n // i NEW_LINE sum = div1 + div2 ; NEW_LINE if ( m . gcd ( sum , n ) == 1 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT n = 24 NEW_LINE print ( CountPairs ( n ) ) NEW_LINE";"Count all pairs of divisors of a number N whose sum is coprime with N | Python3 program to count all pairs of divisors such that their sum is coprime with N ; Function to count all valid pairs ; initialize count ; Check if sum of pair and n are coprime ; Return the result ; Driver code"
Python;"def isPossible ( A , B ) : NEW_LINE INDENT return ( A - B > 1 ) ; NEW_LINE DEDENT A = 10 ; B = 4 ; NEW_LINE if ( isPossible ( A , B ) ) : NEW_LINE INDENT print ( "" Yes "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) ; NEW_LINE DEDENT";"Check if A can be converted to B by reducing with a Prime number | Function to find if it is possible to make A equal to B ; Driver Code ; Function Call"
Python;import math NEW_LINE sub = [ 0 for i in range ( 100005 ) ] NEW_LINE def minDivisorDifference ( n ) : NEW_LINE INDENT num1 = 0 NEW_LINE num2 = 0 NEW_LINE for i in range ( int ( math . sqrt ( n ) ) , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT num1 = i NEW_LINE num2 = n // i NEW_LINE break NEW_LINE DEDENT DEDENT return abs ( num1 - num2 ) NEW_LINE DEDENT def dfs ( g , u , par ) : NEW_LINE INDENT sub [ u ] = minDivisorDifference ( u ) NEW_LINE mx = 0 NEW_LINE for c in g [ u ] : NEW_LINE INDENT if ( c != par ) : NEW_LINE INDENT ans = dfs ( g , c , u ) NEW_LINE mx = max ( mx , ans ) NEW_LINE DEDENT DEDENT sub [ u ] += mx NEW_LINE return sub [ u ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT g = [ [ ] for i in range ( 100005 ) ] NEW_LINE edges = 6 NEW_LINE g [ 18 ] . append ( 7 ) NEW_LINE g [ 7 ] . append ( 18 ) NEW_LINE g [ 18 ] . append ( 15 ) NEW_LINE g [ 15 ] . append ( 18 ) NEW_LINE g [ 15 ] . append ( 2 ) NEW_LINE g [ 2 ] . append ( 15 ) NEW_LINE g [ 7 ] . append ( 4 ) NEW_LINE g [ 4 ] . append ( 7 ) NEW_LINE g [ 7 ] . append ( 12 ) NEW_LINE g [ 12 ] . append ( 7 ) NEW_LINE g [ 12 ] . append ( 9 ) NEW_LINE g [ 9 ] . append ( 12 ) NEW_LINE root = 18 NEW_LINE print ( dfs ( g , root , - 1 ) ) NEW_LINE DEDENT;"Maximize sum of minimum difference of divisors of nodes in N | Python3 program to maximize the sum of minimum difference of divisors of nodes in an n - ary tree ; Array to store the result at each node ; Function to get minimum difference between the divisors of a number ; Iterate from square root of N to N ; Return absolute difference ; DFS function to calculate the maximum sum ; Store the min difference ; Add the maximum of all children to sub [ u ] ; Return maximum sum of node ' u ' to its parent ; Driver code"
Python;"def isCenteredcube ( N ) : NEW_LINE INDENT i = 1 ; NEW_LINE while ( True ) : NEW_LINE INDENT ith_term = ( ( 2 * i + 1 ) * ( i * i + i + 1 ) ) ; NEW_LINE if ( ith_term == N ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( ith_term > N ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT N = 9 ; NEW_LINE if ( isCenteredcube ( N ) ) : NEW_LINE INDENT print ( "" Yes "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) ; NEW_LINE DEDENT";"Program to check if N is a Centered Cubic Number | Function to check if N is a centered cubic number ; Iterating from 1 ; Infinite loop ; Finding ith_term ; Checking if the number N is a centered cube number ; If ith_term > N then N is not a centered cube number ; Incrementing i ; Driver code ; Function call"
Python;"def productOfGP ( a , r , n ) : NEW_LINE INDENT product = 1 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT product = product * a ; NEW_LINE a = a * r ; NEW_LINE DEDENT return product ; NEW_LINE DEDENT a = 1 NEW_LINE r = 2 ; NEW_LINE N = 4 ; NEW_LINE print ( productOfGP ( a , r , N ) ) NEW_LINE";"Product of N terms of a given Geometric series | Function to calculate product of geometric series ; Initialise final product with 1 ; Multiply product with each term stored in a ; Return the final product ; Given first term and common ratio ; Number of terms ; Function Call"
Python;"def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def findlcm ( arr , n ) : NEW_LINE INDENT ans = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = ( ( ( arr [ i ] * ans ) ) // ( gcd ( arr [ i ] , ans ) ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def addReduce ( n , num , den ) : NEW_LINE INDENT final_numerator = 0 NEW_LINE final_denominator = findlcm ( den , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT final_numerator = ( final_numerator + ( num [ i ] ) * ( final_denominator // den [ i ] ) ) NEW_LINE DEDENT GCD = gcd ( final_numerator , final_denominator ) NEW_LINE final_numerator //= GCD NEW_LINE final_denominator //= GCD NEW_LINE print ( final_numerator , "" / "" , final_denominator ) NEW_LINE DEDENT N = 3 NEW_LINE arr1 = [ 1 , 2 , 5 ] NEW_LINE arr2 = [ 2 , 1 , 6 ] NEW_LINE addReduce ( N , arr1 , arr2 ) NEW_LINE";"Sum of given N fractions in reduced form | Function to find GCD of a & b using Euclid Lemma ; Base Case ; Function to find the LCM of all elements in arr [ ] ; Initialize result ; Iterate arr [ ] to find LCM ; Return the final LCM ; Function to find the sum of N fraction in reduced form ; To store the sum of all final numerators ; Find the LCM of all denominator ; Find the sum of all N numerators & denominators ; Add each fraction one by one ; Find GCD of final numerator and denominator ; Convert into reduced form by dividing from GCD ; Print the final fraction ; Given N ; Given Numerator ; Given Denominator ; Function call"
Python;"import sys NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT return gcd ( b , a % b ) ; NEW_LINE DEDENT def minLCM ( arr , n ) : NEW_LINE INDENT ans = 1000000000 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT g = gcd ( arr [ i ] , arr [ j ] ) ; NEW_LINE lcm = arr [ i ] / g * arr [ j ] ; NEW_LINE ans = min ( ans , lcm ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT arr = [ 2 , 4 , 3 , 6 , 5 ] ; NEW_LINE print ( minLCM ( arr , 5 ) ) NEW_LINE";"Minimum LCM of all pairs in a given array | Python3 program to find minimum possible lcm from any pair ; Function to compute GCD of two numbers ; Function that return minimum possible lcm from any pair ; Fix the ith element and iterate over all the array to find minimum LCM ; Driver code"
Python;"from math import pow , ceil NEW_LINE def solve ( n ) : NEW_LINE INDENT upper_limit = ceil ( pow ( n , 1.0 / 4 ) ) ; NEW_LINE for x in range ( upper_limit + 1 ) : NEW_LINE INDENT for y in range ( upper_limit + 1 ) : NEW_LINE INDENT num1 = x * x * x * x ; NEW_LINE num2 = y * y * y * y ; NEW_LINE if ( num1 - num2 == n ) : NEW_LINE INDENT print ( "" x ▁ = "" , x , "" , ▁ y ▁ = "" , y ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT print ( - 1 ) ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 15 ; NEW_LINE solve ( n ) ; NEW_LINE DEDENT";"Find two numbers whose difference of fourth power is equal to N | Python3 implementation to find the values of x and y for the given equation with integer N ; Function which find required x & y ; Upper limit of x & y , if such x & y exists ; num1 stores x ^ 4 ; num2 stores y ^ 4 ; If condition is satisfied the print and return ; If no such pair exists ; Driver code"
Python;"import math NEW_LINE def divisorsSame ( n ) : NEW_LINE INDENT even_div = 0 ; odd_div = 0 ; NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n // i == i ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT even_div += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT odd_div += 1 ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT even_div += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT odd_div += 1 ; NEW_LINE DEDENT if ( n // ( i % 2 ) == 0 ) : NEW_LINE INDENT even_div += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT odd_div += 1 ; NEW_LINE DEDENT DEDENT DEDENT DEDENT return ( even_div == odd_div ) ; NEW_LINE DEDENT N = 6 ; NEW_LINE if ( divisorsSame ( N ) == 0 ) : NEW_LINE INDENT print ( "" Yes "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) ; NEW_LINE DEDENT";"Check if count of even divisors of N is equal to count of odd divisors | Python3 program for the above approach ; Function to check if count of even and odd divisors are equal ; To store the count of even factors and odd factors ; Loop till [ 1 , sqrt ( N ) ] ; If divisors are equal add only one ; Check for even divisor ; Odd divisor ; Check for both divisor i . e . , i and N / i ; Check if i is odd or even ; Check if N / i is odd or even ; Return true if count of even_div and odd_div are equals ; Given Number ; Function Call"
Python;"def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def isBalancedPrime ( n ) : NEW_LINE INDENT if not isPrime ( n ) or n == 2 : NEW_LINE INDENT return False NEW_LINE DEDENT previous_prime = n - 1 NEW_LINE next_prime = n + 1 NEW_LINE while not isPrime ( next_prime ) : NEW_LINE INDENT next_prime += 1 NEW_LINE DEDENT while not isPrime ( previous_prime ) : NEW_LINE INDENT previous_prime -= 1 NEW_LINE DEDENT mean = ( previous_prime + next_prime ) / 2 NEW_LINE if n == mean : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 53 NEW_LINE if isBalancedPrime ( n ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Check if N is a Balanced Prime number or not | Utility function to check if a number is prime or not ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function that returns true if n is a Balanced prime ; If n is not a prime number or n is the first prime then return false ; Initialize previous_prime to n - 1 and next_prime to n + 1 ; Find next prime number ; Find previous prime number ; Arithmetic mean ; If n is a weak prime ; Driver code"
Python;"import math NEW_LINE N = 100001 NEW_LINE adj = [ [ ] for i in range ( N ) ] NEW_LINE a = [ 0 for i in range ( N ) ] NEW_LINE ans = [ 0 for i in range ( N ) ] NEW_LINE def hasOddNumberOfDivisors ( n ) : NEW_LINE INDENT if ( math . sqrt ( n ) == int ( math . sqrt ( n ) ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def dfs ( node , parent ) : NEW_LINE INDENT count = 0 NEW_LINE for i in adj [ node ] : NEW_LINE INDENT if ( i != parent ) : NEW_LINE INDENT count += dfs ( i , node ) NEW_LINE DEDENT DEDENT if ( hasOddNumberOfDivisors ( a [ node ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT ans [ node ] = count NEW_LINE return count NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 5 NEW_LINE i = 0 NEW_LINE q = [ 4 , 1 , 5 , 3 ] NEW_LINE adj [ 1 ] . append ( 2 ) NEW_LINE adj [ 2 ] . append ( 1 ) NEW_LINE adj [ 2 ] . append ( 3 ) NEW_LINE adj [ 3 ] . append ( 2 ) NEW_LINE adj [ 3 ] . append ( 4 ) NEW_LINE adj [ 4 ] . append ( 3 ) NEW_LINE adj [ 1 ] . append ( 5 ) NEW_LINE adj [ 5 ] . append ( 1 ) NEW_LINE a [ 1 ] = 4 NEW_LINE a [ 2 ] = 9 NEW_LINE a [ 3 ] = 14 NEW_LINE a [ 4 ] = 100 NEW_LINE a [ 5 ] = 5 NEW_LINE dfs ( 1 , - 1 ) NEW_LINE for i in range ( len ( q ) ) : NEW_LINE INDENT print ( ans [ q [ i ] ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT";"Count of nodes having odd divisors in the given subtree for Q queries | Python3 implementation to count the number of nodes having odd number of divisors for each query ; Adjacency list for tree . ; Array for values and answer at ith node . ; Function to check whether N has odd divisors or not ; DFS function to pre - compute the answers ; Initialize the count ; Repeat for every child ; Increase the count if current node has odd number of divisors ; Driver Code ; Adjacency List ; Function call"
Python;"def lowerBound ( array , length , value ) : NEW_LINE INDENT low = 0 NEW_LINE high = length NEW_LINE while ( low < high ) : NEW_LINE INDENT mid = ( low + high ) // 2 NEW_LINE if ( value <= array [ mid ] ) : NEW_LINE INDENT high = mid NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT def costCalculation ( current , arr , n , pref , a , r , minimum ) : NEW_LINE INDENT index = lowerBound ( arr , len ( arr ) , current ) NEW_LINE left = index * current - pref [ index ] NEW_LINE right = ( pref [ n ] - pref [ index ] - ( n - index ) * current ) NEW_LINE res = min ( left , right ) NEW_LINE left -= res NEW_LINE right -= res NEW_LINE total = res * minimum NEW_LINE total += left * a NEW_LINE total += right * r NEW_LINE return total NEW_LINE DEDENT def solve ( arr , n , a , r , m ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE minimum = min ( a + r , m ) NEW_LINE pref = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT pref [ i + 1 ] = pref [ i ] + arr [ i ] NEW_LINE DEDENT ans = 10000 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = min ( ans , costCalculation ( arr [ i ] , arr , n , pref , a , r , minimum ) ) NEW_LINE DEDENT ans = min ( ans , costCalculation ( pref [ n ] // n , arr , n , pref , a , r , minimum ) ) NEW_LINE ans = min ( ans , costCalculation ( pref [ n ] // n + 1 , arr , n , pref , a , r , minimum ) ) NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 5 , 5 , 3 , 6 , 5 ] NEW_LINE A = 1 NEW_LINE R = 2 NEW_LINE M = 4 NEW_LINE size = len ( arr ) NEW_LINE solve ( arr , size , A , R , M ) NEW_LINE DEDENT";"Minimum Cost to make all array elements equal using given operations | Python3 implementation to find the minimum cost to make all array elements equal ; Checks if the value is less than middle element of the array ; Function that returns the cost of making all elements equal to current element ; Compute the lower bound of current element ; Calculate the requirement of add operation ; Calculate the requirement of subtract operation ; Compute minimum of left and right ; Computing the total cost of add and subtract operations ; Function that prints minimum cost of making all elements equal ; Sort the given array ; Calculate minimum from a + r and m ; Compute prefix sum and store in pref array ; Find the minimum cost from the given elements ; Finding the minimum cost from the other cases where minimum cost can occur ; Printing the minimum cost of making all elements equal ; Driver Code ; Function call"
Python;from math import * NEW_LINE def countBinaries ( N ) : NEW_LINE INDENT ctr = 1 NEW_LINE ans = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N % 10 == 1 ) : NEW_LINE INDENT ans += pow ( 2 , ctr - 1 ) NEW_LINE DEDENT elif ( N % 10 > 1 ) : NEW_LINE INDENT ans = pow ( 2 , ctr ) - 1 NEW_LINE DEDENT ctr += 1 NEW_LINE N //= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 20 NEW_LINE print ( int ( countBinaries ( N ) ) ) NEW_LINE DEDENT;"Count of integers up to N which represent a Binary number | Python3 program to count the number of integers upto N which are of the form of binary representations ; Function to return the count ; If the current last digit is 1 ; Add 2 ^ ( ctr - 1 ) possible integers to the answer ; If the current digit exceeds 1 ; Set answer as 2 ^ ctr - 1 as all possible binary integers with ctr number of digits can be obtained ; Driver Code"
Python;def countBinaries ( N ) : NEW_LINE INDENT powersOfTwo = [ 0 ] * 11 NEW_LINE powersOfTwo [ 0 ] = 1 NEW_LINE for i in range ( 1 , 11 ) : NEW_LINE INDENT powersOfTwo [ i ] = powersOfTwo [ i - 1 ] * 2 NEW_LINE DEDENT ctr = 1 NEW_LINE ans = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N % 10 == 1 ) : NEW_LINE INDENT ans += powersOfTwo [ ctr - 1 ] NEW_LINE DEDENT elif ( N % 10 > 1 ) : NEW_LINE INDENT ans = powersOfTwo [ ctr ] - 1 NEW_LINE DEDENT ctr += 1 NEW_LINE N = N // 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT N = 20 NEW_LINE print ( countBinaries ( N ) ) NEW_LINE;"Count of integers up to N which represent a Binary number | Function to return the count ; PreCompute and store the powers of 2 ; If the current last digit is 1 ; Add 2 ^ ( ctr - 1 ) possible integers to the answer ; If the current digit exceeds 1 ; Set answer as 2 ^ ctr - 1 as all possible binary integers with ctr number of digits can be obtained ; Driver code"
Python;def Centered_Hexadecagonal_num ( n ) : NEW_LINE INDENT return ( 8 * n * n - 8 * n + 1 ) NEW_LINE DEDENT def sum_Centered_Hexadecagonal_num ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ += Centered_Hexadecagonal_num ( i ) NEW_LINE DEDENT return summ NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( sum_Centered_Hexadecagonal_num ( n ) ) NEW_LINE DEDENT;"Find the sum of the first Nth Centered Hexadecagonal Number | Centered_Hexadecagonal number function ; Formula to calculate nth Centered_Hexadecagonal number & return it into main function . ; Function to find the sum of the first N Centered Hexadecagonal number ; Variable to store the sum ; Loop to iterate through the first N numbers ; Find the sum ; Driver Code ; display first Nth Centered_Hexadecagonal number"
Python;def center_heptagonal_num ( n ) : NEW_LINE INDENT return ( 7 * n * n - 7 * n + 2 ) // 2 NEW_LINE DEDENT def sum_center_heptagonal_num ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ += center_heptagonal_num ( i ) NEW_LINE DEDENT return summ NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( sum_center_heptagonal_num ( n ) ) NEW_LINE DEDENT;"Find the sum of the first N Centered heptagonal number | Function to find N - th centered heptagonal number ; Formula to calculate nth centered heptagonal number ; Function to find the sum of the first N centered heptagonal numbers ; Variable to store the sum ; Iterate through the range 1 to N ; Driver code"
Python;def Centered_Dodecagonal_num ( n ) : NEW_LINE INDENT return 6 * n * ( n - 1 ) + 1 NEW_LINE DEDENT def sum_Centered_Dodecagonal_num ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ += Centered_Dodecagonal_num ( i ) NEW_LINE DEDENT return summ NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( sum_Centered_Dodecagonal_num ( n ) ) NEW_LINE DEDENT;"Find the sum of the first N Centered Dodecagonal Number | Function to find the N - th Centered Dodecagonal number ; Formula to calculate nth Centered_Dodecagonal number ; Function to find the sum of the first N Centered_Dodecagonal number ; Variable to store the sum ; Iterating from 1 to N ; Finding the sum ; Driver code"
Python;def center_Octagonal_num ( n ) : NEW_LINE INDENT return ( 4 * n * n - 4 * n + 1 ) NEW_LINE DEDENT def sum_center_Octagonal_num ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ += center_Octagonal_num ( i ) NEW_LINE DEDENT return summ NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( sum_center_Octagonal_num ( n ) ) NEW_LINE DEDENT;"Find the sum of the first N Centered Octagonal Number | Function to find N - th Centered Octagonal number ; Formula to calculate nth centered Octagonal number ; Function to find the sum of the first N Centered Octagonal numbers ; Variable to store the sum ; Iterating through the first N numbers ; Driver code"
Python;def Centered_decagonal_num ( n ) : NEW_LINE INDENT return ( 5 * n * n - 5 * n + 1 ) NEW_LINE DEDENT def sum_Centered_decagonal_num ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ += Centered_decagonal_num ( i ) NEW_LINE DEDENT return summ NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( sum_Centered_decagonal_num ( n ) ) NEW_LINE DEDENT;"Find the sum of the first N Centered Decagonal Numbers | Function to find the N - th centred decagonal number ; Formula to calculate nth Centered_decagonal number & return it into main function . ; Function to find the sum of the first N Centered decagonal numbers ; Variable to store the sum ; Iterating through the range ; Driver code ; display first Nth Centered_decagonal number"
Python;def center_octadecagon_num ( n ) : NEW_LINE INDENT return ( 9 * n * n - 9 * n + 1 ) NEW_LINE DEDENT def sum_center_octadecagon_num ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ += center_octadecagon_num ( i ) NEW_LINE DEDENT return summ NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( sum_center_octadecagon_num ( n ) ) NEW_LINE DEDENT;"Find the sum of the first N Centered Octadecagonal Numbers | Function to find the N - th Centered octadecagonal number ; Formula to calculate nth centered octadecagonal number ; Function to find the sum of the first N Centered octadecagonal numbers ; Variable to store the sum ; Iterating through the range 1 to N ; Driver code"
Python;def Centered_Pentadecagonal_num ( n ) : NEW_LINE INDENT return ( 15 * n * n - 15 * n + 2 ) // 2 NEW_LINE DEDENT def sum_Centered_Pentadecagonal_num ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ += Centered_Pentadecagonal_num ( i ) NEW_LINE DEDENT return summ NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( sum_Centered_Pentadecagonal_num ( n ) ) NEW_LINE DEDENT;"Find the sum of the first Nth Centered Pentadecagonal Number | Function to find the Centered_Pentadecagonal number ; Formula to calculate N - th Centered_Pentadecagonal number ; Function to find the sum of the first N Centered_Pentadecagonal numbers ; Variable to store the sum ; Driver code"
Python;"from math import sqrt NEW_LINE def isoctagonal ( N ) : NEW_LINE INDENT n = ( 2 + sqrt ( 12 * N + 4 ) ) / 6 ; NEW_LINE return ( n - int ( n ) ) == 0 ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 8 ; NEW_LINE if ( isoctagonal ( N ) ) : NEW_LINE INDENT print ( "" Yes "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) ; NEW_LINE DEDENT DEDENT";"Program to check if N is a Octagonal Number | Python3 program for the above approach ; Function to check if N is a octagonal number ; Condition to check if the number is a octagonal number ; Driver Code ; Given number ; Function call"
Python;"from math import sqrt NEW_LINE def isPentadecagon ( N ) : NEW_LINE INDENT n = ( 11 + sqrt ( 104 * N + 121 ) ) / 26 ; NEW_LINE return ( n - int ( n ) == 0 ) ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 15 ; NEW_LINE if ( isPentadecagon ( N ) ) : NEW_LINE INDENT print ( "" Yes "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) ; NEW_LINE DEDENT DEDENT";"Program to check if N is a Pentadecagonal Number | Python3 program for the above approach ; Function to check if N is a pentadecagon number ; Condition to check if the number is a pentadecagon number ; Driver Code ; Given number ; Function call"
Python;"import math NEW_LINE def istetradecagonal ( N ) : NEW_LINE INDENT n = ( 10 + math . sqrt ( 96 * N + 100 ) ) / 24 NEW_LINE if ( n - int ( n ) ) == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT N = 11 NEW_LINE if ( istetradecagonal ( N ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Program to check if N is a Tetradecagonal Number | Python3 program for the above approach ; Function to check if N is a Tetradecagonal Number ; Condition to check if the number is a tetradecagonal number ; Given Number ; Function call"
Python;def Icosagonal_num ( n ) : NEW_LINE INDENT return ( 18 * n * n - 16 * n ) // 2 NEW_LINE DEDENT def sum_Icosagonal_num ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ += Icosagonal_num ( i ) NEW_LINE DEDENT return summ NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( sum_Icosagonal_num ( n ) ) NEW_LINE DEDENT;"Find the sum of the first Nth Icosagonal Numbers | Function to calculate the N - th Icosagonal number ; Formula to calculate nth Icosagonal number & return it ; Function to find the sum of the first N Icosagonal numbers ; Variable to store the sum ; Loop to iterate through the first N values and find the sum of first N Icosagonal numbers ; function to get the Icosagonal_num ; Driver Code ; Display the sum of first N Icosagonal number"
Python;def Centered_Pentagonal_num ( n ) : NEW_LINE INDENT return ( 5 * n * n - 5 * n + 2 ) // 2 NEW_LINE DEDENT def sum_Centered_Pentagonal_num ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ += Centered_Pentagonal_num ( i ) NEW_LINE DEDENT return summ NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( sum_Centered_Pentagonal_num ( n ) ) NEW_LINE DEDENT;"Find the sum of the first N Centered Pentagonal Number | Function to find the Centered_Pentagonal number ; Formula to calculate nth Centered_Pentagonal number & return it into main function . ; Function to find the sum of the first N Centered_Pentagonal numbers ; To get the sum ; Function to get the Centered_Pentagonal_num ; Driver Code ; display first Nth Centered_Pentagonal number"
Python;def Centered_tridecagonal_num ( n ) : NEW_LINE INDENT return ( 13 * n * ( n - 1 ) + 2 ) // 2 NEW_LINE DEDENT def sum_Centered_tridecagonal_num ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT summ += Centered_tridecagonal_num ( i ) NEW_LINE DEDENT return summ NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( sum_Centered_tridecagonal_num ( n ) ) NEW_LINE DEDENT;"Find the sum of the first Nth Centered Tridecagonal Numbers | Function to calculate the N - th Centered tridecagonal number ; Formula to calculate Nth Centered tridecagonal number & return it ; Function to find the sum of the first N Centered tridecagonal numbers ; Variable to store the sum ; Loop to iterate and find the sum of first N Centered tridecagonal numbers ; Driver Code"
Python;"import math NEW_LINE def isConcentrichexagonal ( N ) : NEW_LINE INDENT n = math . sqrt ( ( 2 * N ) / 3 ) NEW_LINE return ( n - int ( n ) ) == 0 NEW_LINE DEDENT N = 6 NEW_LINE if isConcentrichexagonal ( N ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Program to check if N is a Concentric Hexagonal Number | Python3 program to check if N is a concentric hexagonal number ; Function to check if the number is a concentric hexagonal number ; Condition to check if the number is a concentric hexagonal number ; Driver code ; Function call"
Python;"def computePrime ( N ) : NEW_LINE INDENT Prime = [ True ] * ( N + 1 ) NEW_LINE Prime [ 0 ] = False NEW_LINE Prime [ 1 ] = False NEW_LINE i = 2 NEW_LINE while i * i <= N : NEW_LINE INDENT if ( Prime [ i ] ) : NEW_LINE INDENT for j in range ( i * i , N , i ) : NEW_LINE INDENT Prime [ j ] = False NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return Prime NEW_LINE DEDENT def countSexyPairs ( arr , n ) : NEW_LINE INDENT maxE = max ( arr ) NEW_LINE Prime = computePrime ( maxE ) NEW_LINE count = 0 NEW_LINE freq = [ 0 ] * ( maxE + 6 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT arr . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( Prime [ arr [ i ] ] ) : NEW_LINE INDENT if ( ( arr [ i ] + 6 ) <= ( maxE ) and freq [ arr [ i ] + 6 ] > 0 and Prime [ arr [ i ] + 6 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 6 , 7 , 5 , 11 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countSexyPairs ( arr , n ) ) NEW_LINE DEDENT";"Count Sexy Prime Pairs in the given array | A utility function that find the Prime Numbers till N ; Resize the Prime Number ; Loop till sqrt ( N ) to find prime numbers and make their multiple false in the bool array Prime ; Function that returns the count of SPP ( Sexy Prime Pair ) Pairs ; Find the maximum element in the given array arr [ ] ; Function to calculate the prime numbers till N ; To store the count of pairs ; To store the frequency of element in the array arr [ ] ; Sort before traversing the array ; Traverse the array and find the pairs with SPP ( Sexy Prime Pair ) s ; If current element is Prime , then check for ( current element + 6 ) ; Return the count of pairs ; Driver code ; Function call to find SPP ( Sexy Prime Pair ) s pair"
Python;"def countWays ( N ) : NEW_LINE INDENT if ( N <= 2 ) : NEW_LINE INDENT print ( "" - 1"" ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( N - 1 ) * ( N - 2 ) / 2 NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE countWays ( N ) NEW_LINE DEDENT";"Count of ways to write N as a sum of three numbers | Function to find the number of ways ; Check if number is less than 2 ; Calculate the sum ; Driver code"
Python;"import math NEW_LINE def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( math . ceil ( math . log ( n ) // math . log ( 2 ) ) == math . floor ( math . log ( n ) // math . log ( 2 ) ) ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE if isPowerOfTwo ( N ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT DEDENT";"Logarithm tricks for Competitive Programming | Python3 implementation to check that a integer is a power of two ; Function to check if the number is a power of two ; Driver code"
Python;"def count_pairs ( x ) : NEW_LINE INDENT ans = 1 ; NEW_LINE while ( x > 0 ) : NEW_LINE INDENT if ( x % 2 == 1 ) : NEW_LINE INDENT ans = ans * 3 ; NEW_LINE DEDENT x = x // 2 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 6 ; NEW_LINE print ( count_pairs ( X ) ) ; NEW_LINE DEDENT";"Count of pairs having bit size at most X and Bitwise OR equal to X | Function to count the pairs ; Initializing answer with 1 ; Iterating through bits of x ; Check if bit is 1 ; Multiplying ans by 3 if bit is 1 ; Driver code"
Python;import sys NEW_LINE def kthNonDivisible ( N , K ) : NEW_LINE INDENT L = 1 NEW_LINE H = sys . maxsize NEW_LINE ans = 0 NEW_LINE while ( L <= H ) : NEW_LINE INDENT mid = ( L + H ) // 2 NEW_LINE sol = mid - mid // N NEW_LINE if ( sol > K ) : NEW_LINE INDENT H = mid - 1 NEW_LINE DEDENT elif ( sol < K ) : NEW_LINE L = mid + 1 NEW_LINE else : NEW_LINE INDENT ans = mid NEW_LINE H = mid - 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT N = 3 NEW_LINE K = 7 NEW_LINE kthNonDivisible ( N , K ) NEW_LINE;"Find the Kth number which is not divisible by N | Python3 implementation for above approach ; Function to find the Kth not divisible by N ; Lowest possible value ; Highest possible value ; To store the Kth non divisible number of N ; Using binary search ; Calculating mid value ; Sol would have the value by subtracting all multiples of n till mid ; Check if sol is greater than k ; H should be reduced to find minimum possible value ; Check if sol is less than k then L will be mid + 1 ; Check if sol is equal to k ; ans will be mid ; H would be reduced to find any more possible value ; Print the answer ; Driver Code ; Function call"
Python;"def printPair ( n ) : NEW_LINE INDENT print ( ""1"" , end = "" ▁ "" ) NEW_LINE print ( n - 1 ) NEW_LINE DEDENT n = 14 NEW_LINE printPair ( n ) NEW_LINE";"Print any pair of integers with sum of GCD and LCM equals to N | Function to print the required pair ; Print the pair ; Driver code"
Python;"def isAutoBiographyNum ( number ) : NEW_LINE INDENT count = 0 ; NEW_LINE NUM = str ( number ) ; NEW_LINE size = len ( NUM ) ; NEW_LINE for i in range ( size ) : NEW_LINE INDENT position = ord ( NUM [ i ] ) - ord ( '0' ) ; NEW_LINE count = 0 ; NEW_LINE for j in range ( size ) : NEW_LINE INDENT digit = ord ( NUM [ j ] ) - ord ( '0' ) ; NEW_LINE if ( digit == i ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT if ( position != count ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def checkArray ( arr , n ) : NEW_LINE INDENT current_length = 0 ; NEW_LINE max_length = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isAutoBiographyNum ( arr [ i ] ) ) : NEW_LINE INDENT current_length += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT current_length = 0 ; NEW_LINE DEDENT max_length = max ( max_length , current_length ) ; NEW_LINE DEDENT return max_length ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 21200 , 1 , 1303 , 1210 , 2020 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( checkArray ( arr , n ) ) ; NEW_LINE DEDENT";"Find the length of largest subarray in which all elements are Autobiographical Numbers | Function to check number is autobiographical ; Convert integer to string ; Iterate for every digit to check for their total count ; Check occurrence of every number and count them ; Check if any position mismatches with total count them return with false else continue with loop ; Function to return the length of the largest subarray whose every element is a autobiographical number ; Utility function which checks every element of array for autobiographical number ; Check if element arr [ i ] is an autobiographical number ; Increment the current length ; Update max_length value ; Return the final result ; Driver code"
Python;"MAX = 100000 NEW_LINE graph = [ [ ] for i in range ( MAX + 1 ) ] NEW_LINE Prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE height = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT Prime [ 0 ] = Prime [ 1 ] = False NEW_LINE i = 2 NEW_LINE while i * i <= MAX : NEW_LINE INDENT if ( Prime [ i ] ) : NEW_LINE INDENT for j in range ( 2 * i , MAX , i ) : NEW_LINE INDENT Prime [ j ] = False NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT def dfs ( node , parent , h ) : NEW_LINE INDENT height [ node ] = h NEW_LINE for to in graph [ node ] : NEW_LINE INDENT if ( to == parent ) : NEW_LINE INDENT continue NEW_LINE DEDENT dfs ( to , node , h + 1 ) NEW_LINE DEDENT DEDENT def primeHeightNode ( N ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( Prime [ height [ i ] ] ) : NEW_LINE INDENT print ( i , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 5 NEW_LINE graph [ 1 ] . append ( 2 ) NEW_LINE graph [ 1 ] . append ( 3 ) NEW_LINE graph [ 2 ] . append ( 4 ) NEW_LINE graph [ 2 ] . append ( 5 ) NEW_LINE dfs ( 1 , 1 , 0 ) NEW_LINE primeHeightNode ( N ) NEW_LINE DEDENT";"Print the nodes of the Binary Tree whose height is a Prime number | Python3 implementation of nodes at prime height in the given tree ; To store Prime Numbers ; To store height of each node ; Function to find the prime numbers till 10 ^ 5 ; Traverse all multiple of i and make it false ; Function to perform dfs ; Store the height of node ; Function to find the nodes at prime height ; To precompute prime number till 10 ^ 5 ; Check if height [ node ] is prime ; Driver code ; Number of nodes ; Edges of the tree"
Python;"def reverse ( a ) : NEW_LINE INDENT rev = 0 ; NEW_LINE while ( a != 0 ) : NEW_LINE INDENT r = a % 10 ; NEW_LINE rev = rev * 10 + r ; NEW_LINE a = a // 10 ; NEW_LINE DEDENT return ( rev ) ; NEW_LINE DEDENT def prime ( a ) : NEW_LINE INDENT k = 0 ; NEW_LINE for i in range ( 2 , a ) : NEW_LINE INDENT if ( a % i == 0 ) : NEW_LINE INDENT k = 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( k == 1 ) : NEW_LINE INDENT return ( 0 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( 1 ) ; NEW_LINE DEDENT DEDENT def adam ( a ) : NEW_LINE INDENT r1 = reverse ( a ) ; NEW_LINE s1 = a * a ; NEW_LINE s2 = r1 * r1 ; NEW_LINE r2 = reverse ( s2 ) ; NEW_LINE if ( s1 == r2 ) : NEW_LINE INDENT return ( 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( 0 ) ; NEW_LINE DEDENT DEDENT def find ( m , n ) : NEW_LINE INDENT if ( m > n ) : NEW_LINE INDENT print ( "" INVALID INPUT "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT c = 0 ; NEW_LINE DEDENT for i in range ( m , n ) : NEW_LINE INDENT l = prime ( i ) ; NEW_LINE k = adam ( i ) ; NEW_LINE if ( ( l == 1 ) and ( k == 1 ) ) : NEW_LINE INDENT print ( i , "" TABSYMBOL "" , end = "" ▁ "" ) ; NEW_LINE DEDENT DEDENT DEDENT L = 5 ; R = 100 ; NEW_LINE find ( L , R ) ; NEW_LINE";"Find Prime Adam integers in the given range [ L , R ] | Python3 program to find all prime adam numbers in the given range ; Reversing a number by taking remainder at a time ; Function to check if a number is a prime or not ; Iterating till the number ; Checking for factors ; Returning 1 if the there are no factors of the number other than 1 or itself ; Function to check whether a number is an adam number or not ; Reversing given number ; Squaring given number ; Squaring reversed number ; Reversing the square of the reversed number ; Checking if the square of the number and the square of its reverse are equal or not ; Function to find all the prime adam numbers in the given range ; If the first number is greater than the second number , print invalid ; Iterating through all the numbers in the given range ; Checking for prime number ; Checking for Adam number ; Driver code"
Python;"def sumDig ( n ) : NEW_LINE INDENT s = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT s = s + int ( n % 10 ) NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return s NEW_LINE DEDENT def Pec ( n ) : NEW_LINE INDENT dup = n NEW_LINE dig = sumDig ( n ) NEW_LINE if ( dig * 3 == dup ) : NEW_LINE INDENT return "" Yes "" NEW_LINE DEDENT else : NEW_LINE INDENT return "" No "" NEW_LINE DEDENT DEDENT n = 36 NEW_LINE if Pec ( n ) == True : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Determine whether the given integer N is a Peculiar Number or not | Function to get sum of digits of a number ; Function to check if the number is peculiar ; Store a duplicate of n ; Driver code"
Python;"def digit_sum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT m = n % 10 ; NEW_LINE sum = sum + m ; NEW_LINE n = n // 10 NEW_LINE DEDENT return ( sum ) NEW_LINE DEDENT def reverse ( n ) : NEW_LINE INDENT r = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = r * 10 NEW_LINE r = r + n % 10 NEW_LINE n = n // 10 NEW_LINE DEDENT return ( r ) NEW_LINE DEDENT def operation ( n ) : NEW_LINE INDENT i = 1 NEW_LINE count = 0 NEW_LINE while ( count < n ) : NEW_LINE INDENT a = digit_sum ( i ) NEW_LINE r = reverse ( i ) NEW_LINE if ( i % a == 0 and r % a == 0 ) : NEW_LINE INDENT print ( i , end = "" ▁ "" ) NEW_LINE count += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE operation ( n ) NEW_LINE DEDENT";"Find N numbers such that a number and its reverse are divisible by sum of its digits | Function to calculate the sum of digits ; Loop to iterate through every digit of the number ; Returning the sum of digits ; Function to calculate the reverse of a number ; Loop to calculate the reverse of the number ; Return the reverse of the number ; Function to print the first N numbers such that every number and the reverse of the number is divisible by its sum of digits ; Loop to continuously check and generate number until there are n outputs ; Variable to hold the sum of the digit of the number ; Computing the reverse of the number ; Checking if the condition satisfies . Increment the count and print the number if it satisfies . ; Driver code"
Python;"def createSets ( N ) : NEW_LINE INDENT if ( N <= 2 ) : NEW_LINE INDENT print ( "" - 1"" ) ; NEW_LINE return ; NEW_LINE DEDENT for i in range ( 2 , N + 1 , 2 ) : NEW_LINE INDENT print ( i , end = "" ▁ "" ) ; NEW_LINE DEDENT print ( "" "" ) ; NEW_LINE for i in range ( 1 , N + 1 , 2 ) : NEW_LINE INDENT print ( i , end = "" ▁ "" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 ; NEW_LINE createSets ( N ) ; NEW_LINE DEDENT";"Split N natural numbers into two sets having GCD of their sums greater than 1 | Function to create and print the two sets ; No such split possible for N <= 2 ; Print the first set consisting of even elements ; Print the second set consisting of odd ones ; Driver Code"
Python;"graph = [ [ ] for i in range ( 100 ) ] NEW_LINE weight = [ 0 ] * 100 NEW_LINE ans = 0 NEW_LINE def isPowerful ( n ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT power = 0 ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n /= 2 ; NEW_LINE power += 1 ; NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT factor = 3 NEW_LINE while ( factor * factor <= n ) : NEW_LINE INDENT power = 0 ; NEW_LINE while ( n % factor == 0 ) : NEW_LINE INDENT n = n / factor ; NEW_LINE power += 1 ; NEW_LINE DEDENT if ( power == 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT factor += 2 ; NEW_LINE DEDENT return ( n == 1 ) ; NEW_LINE DEDENT def dfs ( Node , parent ) : NEW_LINE INDENT global ans ; NEW_LINE if ( isPowerful ( weight [ Node ] ) ) : NEW_LINE INDENT ans += 1 ; NEW_LINE DEDENT for to in graph [ Node ] : NEW_LINE INDENT if ( to == parent ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT dfs ( to , Node ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT weight [ 1 ] = 5 ; NEW_LINE weight [ 2 ] = 10 ; NEW_LINE weight [ 3 ] = 11 ; NEW_LINE weight [ 4 ] = 8 ; NEW_LINE weight [ 5 ] = 6 ; NEW_LINE graph [ 1 ] . append ( 2 ) ; NEW_LINE graph [ 2 ] . append ( 3 ) ; NEW_LINE graph [ 2 ] . append ( 4 ) ; NEW_LINE graph [ 1 ] . append ( 5 ) ; NEW_LINE dfs ( 1 , 1 ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT";"Count the nodes in the given tree whose weight is a powerful number | Python3 implementation to Count the Nodes in the given tree whose weight is a powerful number ; Function to check if the number is powerful ; First divide the number repeatedly by 2 ; Check if only 2 ^ 1 divides n , then return False ; Check if n is not a power of 2 then this loop will execute ; Find highest power of "" factor "" that divides n ; Check if only factor ^ 1 divides n , then return False ; n must be 1 now if it is not a prime number . Since prime numbers are not powerful , we return False if n is not 1. ; Function to perform dfs ; Check if weight of the current Node is a powerful number ; Driver code ; Weights of the Node ; Edges of the tree"
Python;"def CountWays ( N , M ) : NEW_LINE INDENT count = 1 NEW_LINE count = pow ( 3 , M + N ) NEW_LINE count *= pow ( 2 , M * N ) ; NEW_LINE return count NEW_LINE DEDENT N = 3 NEW_LINE M = 2 NEW_LINE print ( CountWays ( N , M ) ) NEW_LINE";"Number of ways to color boundary of each block of M * N table | Function to compute all way to fill the boundary of all sides of the unit square ; Count possible ways to fill all upper and left side of the rectangle M * N ; Count possible ways to fill all side of the all squares unit size ; Number of rows ; Number of columns"
Python;def findNthNumber ( N ) : NEW_LINE INDENT arr = [ 0 for i in range ( N + 1 ) ] NEW_LINE q = [ ] NEW_LINE for i in range ( 1 , 10 , 1 ) : NEW_LINE INDENT q . append ( i ) NEW_LINE DEDENT for i in range ( 1 , N + 1 , 1 ) : NEW_LINE INDENT arr [ i ] = q [ 0 ] NEW_LINE q . remove ( q [ 0 ] ) NEW_LINE if ( arr [ i ] % 10 != 0 ) : NEW_LINE INDENT q . append ( arr [ i ] * 10 + arr [ i ] % 10 - 1 ) NEW_LINE DEDENT q . append ( arr [ i ] * 10 + arr [ i ] % 10 ) NEW_LINE if ( arr [ i ] % 10 != 9 ) : NEW_LINE INDENT q . append ( arr [ i ] * 10 + arr [ i ] % 10 + 1 ) NEW_LINE DEDENT DEDENT print ( arr [ N ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 21 NEW_LINE findNthNumber ( N ) NEW_LINE DEDENT;"Nth positive number whose absolute difference of adjacent digits is at most 1 | Return Nth number with absolute difference between all adjacent digits at most 1. ; To store all such numbers ; Enqueue all integers from 1 to 9 in increasing order . ; Perform the operation N times so that we can get all such N numbers . ; Store the front element of queue , in array and pop it from queue . ; If the last digit of dequeued integer is not 0 , then enqueue the next such number . ; Enqueue the next such number ; If the last digit of dequeued integer is not 9 , then enqueue the next such number . ; Driver Code"
Python;def findUniqueElements ( arr , N , K ) : NEW_LINE INDENT s = set ( ) NEW_LINE for x in arr : NEW_LINE INDENT s . add ( x ) NEW_LINE DEDENT arr_sum = sum ( arr ) NEW_LINE set_sum = 0 NEW_LINE for x in s : NEW_LINE INDENT set_sum += x NEW_LINE DEDENT print ( ( K * set_sum - arr_sum ) // ( K - 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 ] NEW_LINE N = len ( arr ) NEW_LINE K = 3 NEW_LINE findUniqueElements ( arr , N , K ) NEW_LINE DEDENT;"Unique element in an array where all elements occur K times except one | Set 2 | Function that find the unique element in the array arr [ ] ; Store all unique element in set ; Sum of all element of the array ; Sum of element in the set ; Print the unique element using formula ; Driver Code ; Function call"
Python;"def findEquation ( a , b , c ) : NEW_LINE INDENT X = ( a + b + c ) ; NEW_LINE Y = ( a * b ) + ( b * c ) + ( c * a ) ; NEW_LINE Z = ( a * b * c ) ; NEW_LINE print ( "" x ^ 3 ▁ - ▁ "" , X , "" x ^ 2 ▁ + ▁ "" , Y , "" x ▁ - ▁ "" , Z , "" ▁ = ▁ 0"" ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 5 ; NEW_LINE b = 2 ; NEW_LINE c = 3 ; NEW_LINE findEquation ( a , b , c ) ; NEW_LINE DEDENT";"Form the Cubic equation from the given roots | Function to find the cubic equation whose roots are a , b and c ; Find the value of coefficient ; Print the equation as per the above coefficients ; Driver Code ; Function Call"
Python;"from math import sqrt NEW_LINE def dydx ( x , y ) : NEW_LINE INDENT return ( x - y ) / 2 NEW_LINE DEDENT def Gill ( x0 , y0 , x , h ) : NEW_LINE INDENT n = ( ( x - x0 ) / h ) NEW_LINE y = y0 NEW_LINE for i in range ( 1 , int ( n + 1 ) , 1 ) : NEW_LINE INDENT k1 = h * dydx ( x0 , y ) NEW_LINE k2 = h * dydx ( x0 + 0.5 * h , y + 0.5 * k1 ) NEW_LINE k3 = h * dydx ( x0 + 0.5 * h , y + 0.5 * ( - 1 + sqrt ( 2 ) ) * k1 + k2 * ( 1 - 0.5 * sqrt ( 2 ) ) ) NEW_LINE k4 = h * dydx ( x0 + h , y - ( 0.5 * sqrt ( 2 ) ) * k2 + k3 * ( 1 + 0.5 * sqrt ( 2 ) ) ) NEW_LINE y = y + ( 1 / 6 ) * ( k1 + ( 2 - sqrt ( 2 ) ) * k2 + ( 2 + sqrt ( 2 ) ) * k3 + k4 ) NEW_LINE x0 = x0 + h NEW_LINE DEDENT return y NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x0 = 0 NEW_LINE y = 3.0 NEW_LINE x = 5.0 NEW_LINE h = 0.2 NEW_LINE print ( "" y ( x ) ▁ = "" , round ( Gill ( x0 , y , x , h ) , 6 ) ) NEW_LINE DEDENT";"Gill 's 4th Order Method to solve Differential Equations | Python3 program to implement Gill 's method ; A sample differential equation "" dy / dx ▁ = ▁ ( x ▁ - ▁ y ) /2"" ; Finds value of y for a given x using step size h and initial value y0 at x0 ; Count number of iterations using step size or height h ; Initial value of y ( 0 ) ; Iterate for number of iteration ; Value of K1 ; Value of K2 ; Value of K3 ; Value of K4 ; Find the next value of y ( n + 1 ) using y ( n ) and values of K in the above steps ; Update next value of x ; Return the final value of dy / dx ; Driver Code"
Python;"def PrintReverseOrder ( N ) : NEW_LINE INDENT for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT print ( i , end = "" ▁ "" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 ; NEW_LINE PrintReverseOrder ( N ) ; NEW_LINE DEDENT";"Program to print numbers from N to 1 in reverse order | Recursive function to print from N to 1 ; Driver code"
Python;"def findAns ( a , b , n ) : NEW_LINE INDENT lcm = ( a * b ) // __gcd ( a , b ) ; NEW_LINE multiples = ( n // lcm ) + 1 ; NEW_LINE answer = max ( a , b ) * multiples ; NEW_LINE lastvalue = lcm * ( n // lcm ) + max ( a , b ) ; NEW_LINE if ( lastvalue > n ) : NEW_LINE INDENT answer = answer - ( lastvalue - n - 1 ) ; NEW_LINE DEDENT return answer ; NEW_LINE DEDENT def __gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT else : NEW_LINE INDENT return __gcd ( b , a % b ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 1 ; NEW_LINE b = 13 ; NEW_LINE n = 500 ; NEW_LINE print ( findAns ( a , b , n ) ) ; NEW_LINE DEDENT";"Find count of numbers from 0 to n which satisfies the given equation for a value K | Function to find the values ; Calculate the LCM ; Calculate the multiples of lcm ; Find the values which satisfies the given condition ; Subtract the extra values ; Return the final result ; Driver code"
Python;"from math import sqrt NEW_LINE def ArithmeticMean ( A , B ) : NEW_LINE INDENT return ( A + B ) / 2 NEW_LINE DEDENT def HarmonicMean ( A , B ) : NEW_LINE INDENT return ( 2 * A * B ) / ( A + B ) NEW_LINE DEDENT def CheckArithmeticHarmonic ( arr , A , B , N ) : NEW_LINE INDENT AM = ArithmeticMean ( A , B ) NEW_LINE HM = HarmonicMean ( A , B ) NEW_LINE Hash = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT Hash . add ( arr [ i ] ) NEW_LINE DEDENT if ( A in Hash and B in Hash ) : NEW_LINE INDENT if ( AM in Hash and HM in Hash ) : NEW_LINE INDENT print ( "" GM ▁ = "" , round ( sqrt ( AM * HM ) , 2 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" AM ▁ and ▁ HM ▁ not ▁ found "" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( "" Numbers ▁ not ▁ found "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1.0 , 2.0 , 2.5 , 3.0 , 4.0 , 4.5 , 5.0 , 6.0 ] NEW_LINE N = len ( arr ) NEW_LINE A = 3.0 NEW_LINE B = 6.0 NEW_LINE CheckArithmeticHarmonic ( arr , A , B , N ) NEW_LINE DEDENT";"Program to find if two numbers and their AM and HM are present in an array using STL | Python3 program to check if two numbers are present in an array then their AM and HM are also present . Finally , find the GM of the numbers ; Function to find the arithmetic mean of 2 numbers ; Function to find the harmonic mean of 2 numbers ; Following function checks and computes the desired results based on the means ; Calculate means ; Hash container ( set ) to store elements ; Insertion of array elements in the set ; Conditionals to check if numbers are present in array by Hashing ; Conditionals to check if the AM and HM of the numbers are present in array ; If all conditions are satisfied , the Geometric Mean is calculated ; If numbers are found but the respective AM and HM are not found in the array ; If none of the conditions are satisfied ; Driver Code"
Python;def movesRequired ( a , b ) : NEW_LINE INDENT total_moves = a % b NEW_LINE print ( total_moves ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 10 NEW_LINE B = 3 NEW_LINE movesRequired ( A , B ) NEW_LINE DEDENT;"Minimum decrements to make integer A divisible by integer B | Function that print number of moves required ; Calculate modulo ; Print the required answer ; Driver Code ; Initialise A and B"
Python;"def PythagoreanTriplet ( n ) : NEW_LINE INDENT flag = 0 NEW_LINE for a in range ( 1 , n , 1 ) : NEW_LINE INDENT b = ( n * n - 2 * n * a ) // ( 2 * n - 2 * a ) NEW_LINE c = n - a - b NEW_LINE if ( a * a + b * b == c * c and b > 0 and c > 0 ) : NEW_LINE INDENT print ( a , b , c ) NEW_LINE flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 0 ) : NEW_LINE INDENT print ( "" - 1"" ) NEW_LINE DEDENT return NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 12 NEW_LINE PythagoreanTriplet ( N ) NEW_LINE DEDENT";"Pythagorean Triplet with given sum using single loop | Function to calculate the Pythagorean triplet in O ( n ) ; Iterate a from 1 to N - 1. ; Calculate value of b ; The value of c = n - a - b ; Driver code ; Function call"
Python;"from math import sqrt NEW_LINE def check ( X , K ) : NEW_LINE INDENT prime = 0 NEW_LINE temp = X NEW_LINE sqr = int ( sqrt ( X ) ) NEW_LINE for i in range ( 2 , sqr + 1 , 1 ) : NEW_LINE INDENT while ( temp % i == 0 ) : NEW_LINE INDENT temp = temp // i NEW_LINE prime += 1 NEW_LINE DEDENT DEDENT if ( temp > 2 ) : NEW_LINE INDENT prime += 1 NEW_LINE DEDENT if ( X == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( prime == 1 and K == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( prime >= K ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 4 NEW_LINE K = 2 NEW_LINE if ( check ( X , K ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT";"Check if there exists a number with X factors out of which exactly K are prime | Python3 program to check if there exists a number with X factors out of which exactly K are prime ; Function to check if such number exists ; To store the sum of powers of prime factors of X which determines the maximum count of numbers whose product can form X ; Determining the prime factors of X ; To check if the number is prime ; If X is 1 , then we cannot form a number with 1 factor and K prime factor ( as K is atleast 1 ) ; If X itself is prime then it can be represented as a power of only 1 prime factor w0hich is X itself so we return true ; If sum of the powers of prime factors of X is greater than or equal to K , which means X can be represented as a product of K numbers , we return true ; In any other case , we return false as we cannot form a number with X factors and K prime factors ; Driver code"
Python;"class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( key ) : NEW_LINE INDENT temp = Node ( key ) NEW_LINE return temp NEW_LINE DEDENT N = 1000000 NEW_LINE prime = [ ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT check = [ True for i in range ( N + 1 ) ] NEW_LINE p = 2 NEW_LINE while ( p * p <= N ) : NEW_LINE INDENT if ( check [ p ] ) : NEW_LINE INDENT prime . append ( p ) NEW_LINE for i in range ( p * p , N + 1 , p ) : NEW_LINE INDENT check [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def isPathCo_Prime ( path ) : NEW_LINE INDENT max = 0 NEW_LINE for x in path : NEW_LINE INDENT if ( max < x ) : NEW_LINE INDENT max = x NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while ( i * prime [ i ] <= max // 2 ) : NEW_LINE INDENT ct = 0 NEW_LINE for x in path : NEW_LINE INDENT if ( x % prime [ i ] == 0 ) : NEW_LINE INDENT ct += 1 NEW_LINE DEDENT DEDENT if ( ct > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def printCo_PrimePaths ( path ) : NEW_LINE INDENT for x in path : NEW_LINE INDENT print ( x , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def findCo_PrimePaths ( root , path ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return path NEW_LINE DEDENT path . append ( root . key ) NEW_LINE path = findCo_PrimePaths ( root . left , path ) NEW_LINE path = findCo_PrimePaths ( root . right , path ) NEW_LINE if ( root . left == None and root . right == None ) : NEW_LINE INDENT if ( isPathCo_Prime ( path ) ) : NEW_LINE INDENT printCo_PrimePaths ( path ) NEW_LINE DEDENT DEDENT path . pop ( ) NEW_LINE return path NEW_LINE DEDENT def printCo_PrimePath ( node ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE path = [ ] NEW_LINE path = findCo_PrimePaths ( node , path ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT root = newNode ( 10 ) NEW_LINE root . left = newNode ( 48 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . right . left = newNode ( 11 ) NEW_LINE root . right . right = newNode ( 37 ) NEW_LINE root . right . left . left = newNode ( 7 ) NEW_LINE root . right . left . right = newNode ( 29 ) NEW_LINE root . right . right . left = newNode ( 42 ) NEW_LINE root . right . right . right = newNode ( 19 ) NEW_LINE root . right . right . right . left = newNode ( 7 ) NEW_LINE printCo_PrimePath ( root ) NEW_LINE DEDENT";"Print all Coprime path of a Binary Tree | A Tree node ; Utility function to create a new node ; Vector to store all the prime numbers ; Function to store all the prime numbers in an array ; Create a boolean array "" prime [ 0 . . N ] "" and initialize all the entries in it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p greater than or equal to the square of it numbers which are multiples of p and are less than p ^ 2 are already marked . ; Function to check whether Path is Co - prime or not ; Iterating through the array to find the maximum element in the array ; Incrementing the variable if any of the value has a factor ; If not co - prime ; Function to print a Co - Prime path ; Function to find co - prime paths of binary tree ; Base case ; Store the value in path vector ; Recursively call for left sub tree ; Recursively call for right sub tree ; Condition to check , if leaf node ; Condition to check , if path co - prime or not ; Print co - prime path ; Remove the last element from the path vector ; Function to find Co - Prime paths In a given binary tree ; To save all prime numbers ; Function call ; Driver code ; Create Binary Tree as shown ; Print Co - Prime Paths"
Python;"mod = 1000000007 ; NEW_LINE def countSubsets ( a , n ) : NEW_LINE INDENT answer = 0 ; NEW_LINE for i in range ( 1 << n ) : NEW_LINE INDENT bitwiseAND = - 1 ; NEW_LINE bitwiseOR = 0 ; NEW_LINE bitwiseXOR = 0 ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT if ( bitwiseAND == - 1 ) : NEW_LINE INDENT bitwiseAND = a [ j ] ; NEW_LINE DEDENT else : NEW_LINE INDENT bitwiseAND &= a [ j ] ; NEW_LINE DEDENT bitwiseOR |= a [ j ] ; NEW_LINE bitwiseXOR ^= a [ j ] ; NEW_LINE DEDENT DEDENT if ( bitwiseAND == bitwiseOR and bitwiseOR == bitwiseXOR ) : NEW_LINE INDENT answer = ( answer + 1 ) % mod ; NEW_LINE DEDENT DEDENT return answer ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 6 ; NEW_LINE A = [ 1 , 3 , 2 , 1 , 2 , 1 ] ; NEW_LINE print ( countSubsets ( A , N ) ) ; NEW_LINE DEDENT";"Number of subsets with same AND , OR and XOR values in an Array | Python3 implementation to find the number of subsets with equal bitwise AND , OR and XOR values ; Function to find the number of subsets with equal bitwise AND , OR and XOR values ; Traverse through all the subsets ; Finding the subsets with the bits of ' i ' which are set ; Computing the bitwise AND ; Computing the bitwise OR ; Computing the bitwise XOR ; Comparing all the three values ; Driver code"
Python;def count ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == K ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( count * ( count + 1 ) ) // 2 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT ans = ans + ( count * ( count + 1 ) ) // 2 NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 , 0 , 1 , 1 , 0 , 0 ] NEW_LINE N = len ( arr ) NEW_LINE K = 0 NEW_LINE print ( count ( arr , N , K ) ) NEW_LINE DEDENT;"Count of Subsets containing only the given value K | Function to find the number of subsets formed by the given value K ; Count is used to maintain the number of continuous K 's ; Iterating through the array ; If the element in the array is equal to K ; count * ( count + 1 ) / 2 is the total number of subsets with only K as their element ; Change count to 0 because other element apart from K has been found ; To handle the last set of K 's ; Driver code"
Python;"def convertToTernary ( N ) : NEW_LINE INDENT if ( N == 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT x = N % 3 ; NEW_LINE N //= 3 ; NEW_LINE if ( x < 0 ) : NEW_LINE INDENT N += 1 ; NEW_LINE DEDENT convertToTernary ( N ) ; NEW_LINE if ( x < 0 ) : NEW_LINE INDENT print ( x + ( 3 * - 1 ) , end = "" "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( x , end = "" "" ) ; NEW_LINE DEDENT DEDENT def convert ( Decimal ) : NEW_LINE INDENT print ( "" Ternary ▁ number ▁ of ▁ "" , Decimal , "" ▁ is : ▁ "" , end = "" "" ) ; NEW_LINE if ( Decimal != 0 ) : NEW_LINE INDENT convertToTernary ( Decimal ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ""0"" , end = "" "" ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Decimal = 2747 ; NEW_LINE convert ( Decimal ) ; NEW_LINE DEDENT";"Ternary number system or Base 3 numbers | Function to convert a decimal number to a ternary number ; Base case ; Finding the remainder when N is divided by 3 ; Recursive function to call the function for the integer division of the value N / 3 ; Handling the negative cases ; Function to convert the decimal to ternary ; If the number is greater than 0 , compute the ternary representation of the number ; Driver Code"
Python;def get ( x , y , z ) : NEW_LINE INDENT if ( x > z ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT val = z - x NEW_LINE div = ( z - x ) // y NEW_LINE ans = div * y + x NEW_LINE return ans NEW_LINE DEDENT x = 1 NEW_LINE y = 5 NEW_LINE z = 8 NEW_LINE print ( get ( x , y , z ) ) NEW_LINE;"Largest number less than or equal to Z that leaves a remainder X when divided by Y | Function to get the number ; remainder can ' t ▁ be ▁ larger ▁ ▁ than ▁ the ▁ largest ▁ number , ▁ ▁ if ▁ so ▁ then ▁ answer ▁ doesn ' t exist . ; reduce number by x ; finding the possible number that is divisible by y ; this number is always <= x as we calculated over z - x ; initialise the three integers"
Python;"def countOfGreaterElements ( arr , n ) : NEW_LINE INDENT mp = { i : 0 for i in range ( 1000 ) } NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT x = 0 NEW_LINE p = [ ] NEW_LINE q = [ ] NEW_LINE m = [ ] NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT m . append ( [ key , value ] ) NEW_LINE DEDENT m = m [ : : - 1 ] NEW_LINE for p in m : NEW_LINE INDENT temp = p [ 1 ] NEW_LINE mp [ p [ 0 ] ] = x NEW_LINE x += temp NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( mp [ arr [ i ] ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 7 , 9 , 5 , 2 , 1 , 3 , 4 , 8 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE countOfGreaterElements ( arr , n ) NEW_LINE DEDENT";"Count of greater elements for each element in the Array | Python 3 implementation of the above approach ; Store the frequency of the array elements ; Store the sum of frequency of elements greater than the current element ; Driver code"
Python;"import math NEW_LINE def minOperations ( A , B ) : NEW_LINE INDENT if ( A > B ) : NEW_LINE INDENT swap ( A , B ) NEW_LINE DEDENT B = B // math . gcd ( A , B ) ; NEW_LINE return B - 1 NEW_LINE DEDENT A = 7 NEW_LINE B = 15 NEW_LINE print ( minOperations ( A , B ) ) NEW_LINE";"Minimum operations required to make two numbers equal | Python program to find minimum operations required to make two numbers equal ; Function to return the minimum operations required ; Keeping B always greater ; Reduce B such that gcd ( A , B ) becomes 1. ; Driver code"
Python;"def quadrant ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE DEDENT ' NEW_LINE INDENT if ( ' + ' in s ) : NEW_LINE INDENT i = s . index ( ' + ' ) NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT else : NEW_LINE INDENT i = s . index ( ' - ' ) NEW_LINE DEDENT real = s [ 0 : i ] NEW_LINE imaginary = s [ i + 1 : l - 1 ] NEW_LINE x = int ( real ) NEW_LINE y = int ( imaginary ) NEW_LINE if ( x > 0 and y > 0 ) : NEW_LINE INDENT print ( "" Quadrant ▁ 1"" ) NEW_LINE DEDENT elif ( x < 0 and y > 0 ) : NEW_LINE INDENT print ( "" Quadrant ▁ 2"" ) NEW_LINE DEDENT elif ( x < 0 and y < 0 ) : NEW_LINE INDENT print ( "" Quadrant ▁ 3"" ) NEW_LINE DEDENT elif ( x > 0 and y < 0 ) : NEW_LINE INDENT print ( "" Quadrant ▁ 4"" ) NEW_LINE DEDENT elif ( x == 0 and y > 0 ) : NEW_LINE INDENT print ( "" Lies ▁ on ▁ positive "" , "" Imaginary ▁ axis "" ) NEW_LINE DEDENT elif ( x == 0 and y < 0 ) : NEW_LINE INDENT print ( "" Lies ▁ on ▁ negative "" , "" Imaginary ▁ axis "" ) NEW_LINE DEDENT elif ( y == 0 and x < 0 ) : NEW_LINE INDENT print ( "" Lies ▁ on ▁ negative "" , "" X - axis "" ) NEW_LINE DEDENT elif ( y == 0 and x > 0 ) : NEW_LINE INDENT print ( "" Lies ▁ on ▁ positive "" , "" X - axis "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Lies ▁ on ▁ the ▁ Origin "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = ""5 + 3i "" NEW_LINE quadrant ( s ) NEW_LINE DEDENT";"Program to determine the Quadrant of a Complex number | Function to determine the quadrant of a complex number ; Storing the index of '+ ; Storing the index of '- ; Finding the real part of the complex number ; Finding the imaginary part of the complex number ; Driver code"
Python;"import sys NEW_LINE class Node ( ) : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def largestElement ( head_ref ) : NEW_LINE INDENT max = - sys . maxsize NEW_LINE head = head_ref NEW_LINE while ( head != None ) : NEW_LINE INDENT if ( max < head . data ) : NEW_LINE INDENT max = head . data NEW_LINE DEDENT head = head . next NEW_LINE DEDENT return max NEW_LINE DEDENT def createHash ( hash , maxElement ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE hash . add ( prev ) NEW_LINE hash . add ( curr ) NEW_LINE while ( curr <= maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT return hash NEW_LINE DEDENT def sumAndProduct ( head_ref ) : NEW_LINE INDENT maxEle = largestElement ( head_ref ) NEW_LINE hash = set ( ) NEW_LINE hash = createHash ( hash , maxEle ) NEW_LINE prod = 1 NEW_LINE sum = 0 NEW_LINE ptr = head_ref NEW_LINE while ( ptr != None ) : NEW_LINE INDENT if ptr . data in hash : NEW_LINE INDENT prod *= ptr . data NEW_LINE sum += ptr . data NEW_LINE DEDENT ptr = ptr . next NEW_LINE DEDENT print ( "" Sum ▁ = "" , sum ) NEW_LINE print ( "" Product ▁ = "" , prod ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT head = None ; NEW_LINE head = push ( head , 13 ) NEW_LINE head = push ( head , 6 ) NEW_LINE head = push ( head , 8 ) NEW_LINE head = push ( head , 16 ) NEW_LINE head = push ( head , 15 ) NEW_LINE sumAndProduct ( head ) NEW_LINE DEDENT";"Sum and Product of all Fibonacci Nodes of a Singly Linked List | Python3 implementation to find the sum and product of all of the Fibonacci nodes in a singly linked list ; Node of the singly linked list ; Function to insert a node at the beginning of the singly Linked List ; Allocate new node ; Link the old list to the new node ; Move the head to point the new node ; Function that returns the largest element from the linked list . ; Declare a max variable and initialize with INT_MIN ; Check loop while head not equal to NULL ; If max is less then head -> data then assign value of head -> data to max otherwise node points to next node . ; Function to create a hash table to check Fibonacci numbers ; Inserting the first two numbers in the hash ; Loop to add Fibonacci numbers upto the maximum element present in the linked list ; Function to find the required sum and product ; Find the largest node value in Singly Linked List ; Creating a set containing all the fibonacci numbers upto the maximum data value in the Singly Linked List ; Traverse the linked list ; If current node is fibonacci ; Find the sum and the product ; Driver code ; Create the linked list 15 -> 16 -> 8 -> 6 -> 13"
Python;"def product_subarrays ( arr , n ) : NEW_LINE INDENT product = 1 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( i , j + 1 ) : NEW_LINE INDENT product *= arr [ k ] ; NEW_LINE DEDENT DEDENT DEDENT print ( product ,   "" "" ) ; NEW_LINE DEDENT arr = [ 10 , 3 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE product_subarrays ( arr , n ) ; NEW_LINE";"Product of all Subarrays of an Array | Function to find product of all subarrays ; Variable to store the product ; Compute the product while traversing for subarrays ; Printing product of all subarray ; Driver code ; Function call"
Python;"def val ( c ) : NEW_LINE INDENT if ( ord ( c ) >= ord ( '0' ) and ord ( c ) <= ord ( '9' ) ) : NEW_LINE INDENT return ord ( c ) - ord ( '0' ) NEW_LINE DEDENT else : NEW_LINE INDENT return ord ( c ) - ord ( ' A ' ) + 10 NEW_LINE DEDENT DEDENT def toDeci ( str , base ) : NEW_LINE INDENT Len = len ( str ) NEW_LINE power = 1 NEW_LINE num = 0 NEW_LINE for i in range ( Len - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( val ( str [ i ] ) >= base ) : NEW_LINE INDENT print ( "" Invalid ▁ Number "" ) NEW_LINE return - 1 NEW_LINE DEDENT num += val ( str [ i ] ) * power NEW_LINE power = power * base NEW_LINE DEDENT return num NEW_LINE DEDENT def isEven ( num , N ) : NEW_LINE INDENT deci = toDeci ( num , N ) NEW_LINE return ( deci % 2 == 0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = ""11A "" NEW_LINE N = 16 NEW_LINE if ( isEven ( num , N ) ) : NEW_LINE INDENT print ( "" Even "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Odd "" ) NEW_LINE DEDENT DEDENT";"Check if a N base number is Even or Odd | To return value of a char . ; Function to convert a number from N base to decimal ; power of base ; Decimal equivaLent is str [ Len - 1 ] * 1 + str [ Len - 1 ] * base + str [ Len - 1 ] * ( base ^ 2 ) + ... ; A digit in input number must be less than number 's base ; Returns true if n is even , else odd ; Driver code"
Python;fact = [ 0 ] * 21 NEW_LINE def preCompute ( ) : NEW_LINE INDENT fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , 18 ) : NEW_LINE INDENT fact [ i ] = ( fact [ i - 1 ] * i ) NEW_LINE DEDENT DEDENT def nextFactorial ( N ) : NEW_LINE INDENT for i in range ( 21 ) : NEW_LINE INDENT if N < fact [ i ] : NEW_LINE INDENT print ( fact [ i ] ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT preCompute ( ) NEW_LINE N = 120 NEW_LINE nextFactorial ( N ) NEW_LINE;"Find the next Factorial greater than N | Array that stores the factorial till 20 ; Function to pre - compute the factorial till 20 ; Precomputing factorials ; Function to return the next factorial number greater than N ; Traverse the factorial array ; Find the next just greater factorial than N ; Function to precalculate the factorial till 20 ; Function call"
Python;"def findDistinctOddsumm ( n , k ) : NEW_LINE INDENT if ( ( k * k ) <= n and ( n + k ) % 2 == 0 ) : NEW_LINE INDENT val = 1 NEW_LINE summ = 0 NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT print ( val , end = "" ▁ "" ) NEW_LINE summ += val NEW_LINE val += 2 NEW_LINE DEDENT print ( n - summ ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT DEDENT n = 100 NEW_LINE k = 4 NEW_LINE findDistinctOddsumm ( n , k ) NEW_LINE";"Find K distinct positive odd integers with sum N | Function to find K odd positive integers such that their summ is N ; Condition to check if there are enough values to check ; Driver Code"
Python;"def checkArray ( a , b , n ) : NEW_LINE INDENT operations = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( a [ i ] - b [ i ] == 0 ) : NEW_LINE INDENT i += 1 ; NEW_LINE continue ; NEW_LINE DEDENT diff = a [ i ] - b [ i ] ; NEW_LINE i += 1 ; NEW_LINE while ( i < n and a [ i ] - b [ i ] == diff ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT operations += 1 ; NEW_LINE DEDENT print ( operations ) ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = [ 3 , 7 , 1 , 4 , 1 , 2 ] ; NEW_LINE b = [ 3 , 7 , 3 , 6 , 3 , 2 ] ; NEW_LINE size = len ( a ) ; NEW_LINE checkArray ( a , b , size ) ; NEW_LINE DEDENT";"Minimum number of operations to convert array A to array B by adding an integer into a subarray | Function to find the minimum number of operations in which array A can be converted to array B ; Loop to iterate over the array ; if both elements are equal then move to next element ; Calculate the difference between two elements ; loop while the next pair of elements have same difference ; Increase the number of operations by 1 ; Print the number of operations required ; Driver Code"
Python;"import math NEW_LINE def insertPF ( primeFact , fact ) : NEW_LINE INDENT if ( fact in primeFact ) : NEW_LINE INDENT primeFact [ fact ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT primeFact [ fact ] = 1 NEW_LINE DEDENT return primeFact NEW_LINE DEDENT def primeFactors ( n ) : NEW_LINE INDENT primeFact = { } NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT primeFact = insertPF ( primeFact , 2 ) NEW_LINE n = n // 2 NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT primeFact = insertPF ( primeFact , i ) NEW_LINE n = n // i NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT primeFact = insertPF ( primeFact , n ) NEW_LINE DEDENT return primeFact NEW_LINE DEDENT def perfectCube ( n ) : NEW_LINE INDENT primeFact = { } NEW_LINE primeFact = primeFactors ( n ) NEW_LINE for x in primeFact : NEW_LINE INDENT if ( primeFact [ x ] % 3 != 0 ) : NEW_LINE INDENT return "" No "" NEW_LINE DEDENT DEDENT return "" Yes "" NEW_LINE DEDENT N = 216 NEW_LINE print ( perfectCube ( N ) ) NEW_LINE";"Perfect Cube | Python3 program to check if a number is a perfect cube using prime factors ; Inserts the prime factor in HashMap if not present if present updates it 's frequency ; A utility function to find all prime factors of a given number N ; Insert the number of 2 s that divide n ; n must be odd at this point So we can skip one element ; while i divides n , insert i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; Function to check if a number is perfect cube ; Iteration in Map ; Driver Code ; Function to check if N is perfect cube or not"
Python;"import math NEW_LINE def ways ( n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return 0 NEW_LINE DEDENT c2 = 0 NEW_LINE c1 = n - 3 NEW_LINE l = c1 + 1 NEW_LINE s = 0 NEW_LINE exp_c2 = c1 / 2 NEW_LINE while exp_c2 >= c2 : NEW_LINE INDENT f1 = math . factorial ( l ) NEW_LINE f2 = math . factorial ( c1 ) NEW_LINE f3 = math . factorial ( c2 ) NEW_LINE s += f1 // ( f2 * f3 ) NEW_LINE c2 += 1 NEW_LINE c1 -= 2 NEW_LINE l -= 1 NEW_LINE DEDENT return s NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 7 NEW_LINE print ( ways ( N ) ) NEW_LINE DEDENT";"Count ways to reach the Nth stair using multiple 1 or 2 steps and a single step 3 | Python3 implementation to find the number the number of ways to reach Nth stair by taking 1 or 2 steps at a time and 3 rd Step exactly once ; Function to find the number of ways ; Base Case ; Count of 2 - steps ; Count of 1 - steps ; Initial length of sequence ; expected count of 2 - steps ; Loop to find the ways for every possible sequence ; Driver Code"
Python;"m = { } ; NEW_LINE def precompute ( ) : NEW_LINE INDENT fact = 1 ; NEW_LINE for i in range ( 1 , 19 ) : NEW_LINE INDENT fact = fact * i ; NEW_LINE m [ fact ] = i ; NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT precompute ( ) ; NEW_LINE K = 120 ; NEW_LINE print ( m [ K ] ) ; NEW_LINE K = 6 ; NEW_LINE print ( m [ K ] ) ; NEW_LINE DEDENT";"Find N from the value of N ! | Map to precompute and store the factorials of the numbers ; Function to precompute factorial ; Calculating the factorial for each i and storing in a map ; Driver code ; Precomputing the factorials"
Python;"def calNum ( year ) : NEW_LINE INDENT return ( year // 4 ) - ( year // 100 ) + ( year // 400 ) ; NEW_LINE DEDENT def leapNum ( l , r ) : NEW_LINE INDENT l -= 1 ; NEW_LINE num1 = calNum ( r ) ; NEW_LINE num2 = calNum ( l ) ; NEW_LINE print ( num1 - num2 ) ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT l1 = 1 ; r1 = 400 ; NEW_LINE leapNum ( l1 , r1 ) ; NEW_LINE l2 = 400 ; r2 = 2000 ; NEW_LINE leapNum ( l2 , r2 ) ; NEW_LINE DEDENT";"Count of Leap Years in a given year range | Function to calculate the number of leap years in range of ( 1 , year ) ; Function to calculate the number of leap years in given range ; Driver Code"
Python;N = 100005 NEW_LINE mod = ( 10 ** 9 + 7 ) NEW_LINE factorial = [ 0 ] * N NEW_LINE modinverse = [ 0 ] * N NEW_LINE def factorialfun ( ) : NEW_LINE INDENT factorial [ 0 ] = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT factorial [ i ] = ( factorial [ i - 1 ] * i ) % mod NEW_LINE DEDENT DEDENT def modinversefun ( ) : NEW_LINE INDENT modinverse [ N - 1 ] = pow ( factorial [ N - 1 ] , mod - 2 , mod ) % mod NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT modinverse [ i ] = ( modinverse [ i + 1 ] * ( i + 1 ) ) % mod NEW_LINE DEDENT DEDENT def binomial ( n , r ) : NEW_LINE INDENT if ( r > n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT a = ( factorial [ n ] * modinverse [ n - r ] ) % mod NEW_LINE a = ( a * modinverse [ r ] ) % mod NEW_LINE return a NEW_LINE DEDENT def max_min ( a , n , k ) : NEW_LINE INDENT a = sorted ( a ) NEW_LINE factorialfun ( ) NEW_LINE modinversefun ( ) NEW_LINE ans = 0 NEW_LINE k -= 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = n - i - 1 NEW_LINE if ( x >= k ) : NEW_LINE INDENT ans -= ( binomial ( x , k ) * a [ i ] ) % mod NEW_LINE DEDENT y = i NEW_LINE if ( y >= k ) : NEW_LINE INDENT ans += ( binomial ( y , k ) * a [ i ] ) % mod NEW_LINE DEDENT ans = ( ans + mod ) % mod NEW_LINE DEDENT return ans NEW_LINE DEDENT a = [ 1 , 1 , 3 , 4 ] NEW_LINE k = 2 NEW_LINE n = len ( a ) NEW_LINE print ( max_min ( a , n , k ) ) NEW_LINE;"Find sum of f ( s ) for all the chosen sets from the given array | Python3 implementation of the approach ; To store the factorial and the factorial mod inverse of a number ; Function to find factorial of all the numbers ; Function to find the factorial mod inverse of all the numbers ; Function to return nCr ; Function to find sum of f ( s ) for all the chosen sets from the given array ; Sort the given array ; Calculate the factorial and modinverse of all elements ; For all the possible sets Calculate max ( S ) and min ( S ) ; Driver code"
Python;"def countNumber ( N , S ) : NEW_LINE INDENT countElements = 0 ; NEW_LINE currSum = 0 ; NEW_LINE while ( currSum <= S ) : NEW_LINE INDENT currSum += N ; NEW_LINE N = N - 1 ; NEW_LINE countElements = countElements + 1 ; NEW_LINE DEDENT return countElements ; NEW_LINE DEDENT N = 5 ; NEW_LINE S = 11 ; NEW_LINE count = countNumber ( N , S ) ; NEW_LINE print ( count ) ; NEW_LINE";"Length of Smallest subarray in range 1 to N with sum greater than a given value | Function to return the count of minimum elements such that the sum of those elements is > S . ; Initialize currentSum = 0 ; Loop from N to 1 to add the numbers and check the condition . ; Driver code"
Python;"import sys NEW_LINE INT_MAX = sys . maxsize ; NEW_LINE def countDistinct ( n ) : NEW_LINE INDENT arr = [ 0 ] * 10 ; NEW_LINE count = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = int ( n % 10 ) ; NEW_LINE arr [ r ] = 1 ; NEW_LINE n //= 10 ; NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT if ( arr [ i ] != 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT def countDigit ( n ) : NEW_LINE INDENT c = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT r = n % 10 ; NEW_LINE c += 1 ; NEW_LINE n //= 10 ; NEW_LINE DEDENT return c ; NEW_LINE DEDENT def nextNumberDistinctDigit ( n ) : NEW_LINE INDENT while ( n < INT_MAX ) : NEW_LINE INDENT distinct_digits = countDistinct ( n + 1 ) ; NEW_LINE total_digits = countDigit ( n + 1 ) ; NEW_LINE if ( distinct_digits == total_digits ) : NEW_LINE INDENT return n + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT n += 1 ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2019 ; NEW_LINE print ( nextNumberDistinctDigit ( n ) ) ; NEW_LINE DEDENT";"Next Number with distinct digits | Python3 program to find next consecutive Number with all distinct digits ; Function to count distinct digits in a number ; To count the occurrence of digits in number from 0 to 9 ; Iterate over the digits of the number Flag those digits as found in the array ; Traverse the array arr and count the distinct digits in the array ; Function to return the total number of digits in the number ; Iterate over the digits of the number ; Function to return the next number with distinct digits ; Count the distinct digits in N + 1 ; Count the total number of digits in N + 1 ; Return the next consecutive number ; Increment Number by 1 ; Driver code"
Python;mod = 10 ** 9 + 7 NEW_LINE N = 1000005 NEW_LINE lpf = [ 0 for i in range ( N ) ] NEW_LINE def least_prime_factor ( ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT lpf [ i ] = i NEW_LINE DEDENT for i in range ( 2 , N ) : NEW_LINE INDENT if ( lpf [ i ] == i ) : NEW_LINE INDENT for j in range ( i * 2 , N , i ) : NEW_LINE INDENT if ( lpf [ j ] == j ) : NEW_LINE INDENT lpf [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT def sum_of_elements ( a , n ) : NEW_LINE INDENT least_prime_factor ( ) NEW_LINE prime_factor = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp = a [ i ] NEW_LINE single_number = dict ( ) NEW_LINE while ( temp > 1 ) : NEW_LINE INDENT x = lpf [ temp ] NEW_LINE single_number [ x ] = single_number . get ( x , 0 ) + 1 NEW_LINE temp //= x NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT prime_factor = single_number NEW_LINE DEDENT else : NEW_LINE INDENT for x in single_number : NEW_LINE INDENT if x in prime_factor : NEW_LINE INDENT prime_factor [ x ] = max ( prime_factor [ x ] , single_number [ x ] ) NEW_LINE DEDENT else : NEW_LINE INDENT prime_factor [ x ] = single_number [ x ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans , lcm = 0 , 1 NEW_LINE for x in prime_factor : NEW_LINE INDENT lcm = ( lcm * pow ( x , prime_factor [ x ] , mod ) ) % mod NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT ans = ( ans + ( lcm * pow ( a [ i ] , mod - 2 , mod ) ) % mod ) % mod NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 2 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( sum_of_elements ( a , n ) ) NEW_LINE DEDENT;"Minimum possible sum of array B such that AiBi = AjBj for all 1 â ‰¤ i < j â ‰¤ N | Python3 implementation of the approach ; To store least prime factors of all the numbers ; Function to find the least prime factor of all the numbers ; Function to return the sum of elements of array B ; Find the prime factors of all the numbers ; To store each prime count in lcm ; Current number ; Map to store the prime count of a single number ; Basic way to calculate all prime factors ; If it is the first number in the array ; Take the maximum count of prime in a number ; Calculate lcm of given array ; Calculate sum of elements of array B ; Driver code"
Python;"def findNumberOfEvenCells ( n , q , size ) : NEW_LINE INDENT row = [ 0 ] * n ; NEW_LINE col = [ 0 ] * n NEW_LINE for i in range ( size ) : NEW_LINE INDENT x = q [ i ] [ 0 ] ; NEW_LINE y = q [ i ] [ 1 ] ; NEW_LINE row [ x - 1 ] += 1 ; NEW_LINE col [ y - 1 ] += 1 ; NEW_LINE DEDENT r1 = 0 ; NEW_LINE r2 = 0 ; NEW_LINE c1 = 0 ; NEW_LINE c2 = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( row [ i ] % 2 == 0 ) : NEW_LINE INDENT r1 += 1 ; NEW_LINE DEDENT if ( row [ i ] % 2 == 1 ) : NEW_LINE INDENT r2 += 1 ; NEW_LINE DEDENT if ( col [ i ] % 2 == 0 ) : NEW_LINE INDENT c1 += 1 ; NEW_LINE DEDENT if ( col [ i ] % 2 == 1 ) : NEW_LINE INDENT c2 += 1 ; NEW_LINE DEDENT DEDENT count = r1 * c1 + r2 * c2 ; NEW_LINE return count ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 2 ; NEW_LINE q = [ [ 1 , 1 ] , [ 1 , 2 ] , [ 2 , 1 ] ] ; NEW_LINE size = len ( q ) ; NEW_LINE print ( findNumberOfEvenCells ( n , q , size ) ) ; NEW_LINE DEDENT";"Find Number of Even cells in a Zero Matrix after Q queries | Function to find the number of even cell in a 2D matrix ; Maintain two arrays , one for rows operation and one for column operation ; Increment operation on row [ i ] ; Increment operation on col [ i ] ; Count odd and even values in both arrays and multiply them ; Count of rows having even numbers ; Count of rows having odd numbers ; Count of columns having even numbers ; Count of columns having odd numbers ; Driver code"
Python;def maxHeight ( h1 , h2 ) : NEW_LINE INDENT return ( ( h1 * h2 ) - h1 - h2 ) NEW_LINE DEDENT h1 = 7 NEW_LINE h2 = 5 NEW_LINE print ( max ( 0 , maxHeight ( h1 , h2 ) ) ) NEW_LINE;"Find maximum unreachable height using two ladders | Function to return the maximum height which can 't be reached ; Driver code"
Python;from math import ceil , sqrt NEW_LINE def FermatFactors ( n ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return [ n ] NEW_LINE DEDENT if ( n & 1 ) == 0 : NEW_LINE INDENT return [ n / 2 , 2 ] NEW_LINE DEDENT a = ceil ( sqrt ( n ) ) NEW_LINE if ( a * a == n ) : NEW_LINE INDENT return [ a , a ] NEW_LINE DEDENT while ( True ) : NEW_LINE INDENT b1 = a * a - n NEW_LINE b = int ( sqrt ( b1 ) ) NEW_LINE if ( b * b == b1 ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT a += 1 NEW_LINE DEDENT DEDENT return [ a - b , a + b ] NEW_LINE DEDENT print ( FermatFactors ( 6557 ) ) NEW_LINE;"Fermat 's Factorization Method | Python 3 implementation of fermat 's factorization ; This function finds the value of a and b and returns a + b and a - b ; since fermat 's factorization applicable  for odd positive integers only ; check if n is a even number ; if n is a perfect root , then both its square roots are its factors ; Driver Code"
Python;"def findNums ( arr , n ) : NEW_LINE INDENT S = 0 ; X = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT S += arr [ i ] ; NEW_LINE X ^= arr [ i ] ; NEW_LINE DEDENT print ( X , X + S ) ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 7 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findNums ( arr , n ) ; NEW_LINE DEDENT";"Append two elements to make the array satisfy the given condition | Function to find the required numbers ; Find the sum and xor ; Print the required elements ; Driver code"
Python;def solve ( A , B ) : NEW_LINE INDENT p = B / 2 NEW_LINE M = int ( 4 * p ) NEW_LINE N = 1 NEW_LINE O = - 2 * A NEW_LINE Q = int ( A * A + 4 * p * p ) NEW_LINE return [ M , N , O , Q ] NEW_LINE DEDENT a = 1 NEW_LINE b = 1 NEW_LINE print ( * solve ( a , b ) ) NEW_LINE;"Satisfy the parabola when point ( A , B ) and the equation is given | Function to find the required values ; Driver code"
Python;from math import gcd as __gcd NEW_LINE def findLargest ( arr , n ) : NEW_LINE INDENT gcd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT gcd = __gcd ( arr [ i ] , gcd ) NEW_LINE DEDENT return gcd NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 6 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findLargest ( arr , n ) ) NEW_LINE DEDENT;"Largest number dividing maximum number of elements in the array | Python3 implementation of the approach ; Function to return the largest number that divides the maximum elements from the given array ; Finding gcd of all the numbers in the array ; Driver code"
Python;"def digitSum ( n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT sum += ( n % 10 ) ; NEW_LINE n //= 10 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def isPalindrome ( n ) : NEW_LINE INDENT divisor = 1 ; NEW_LINE while ( n // divisor >= 10 ) : NEW_LINE INDENT divisor *= 10 ; NEW_LINE DEDENT while ( n != 0 ) : NEW_LINE INDENT leading = n // divisor ; NEW_LINE trailing = n % 10 ; NEW_LINE if ( leading != trailing ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT n = ( n % divisor ) // 10 ; NEW_LINE divisor = divisor // 100 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def isDigitSumPalindrome ( n ) : NEW_LINE INDENT sum = digitSum ( n ) ; NEW_LINE if ( isPalindrome ( sum ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 56 ; NEW_LINE if ( isDigitSumPalindrome ( n ) ) : NEW_LINE INDENT print ( "" Yes "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) ; NEW_LINE DEDENT DEDENT";"Check if the sum of digits of N is palindrome | Function to return the sum of digits of n ; Function that returns true if n is palindrome ; Find the appropriate divisor to extract the leading digit ; If first and last digit not same return false ; Removing the leading and trailing digit from number ; Reducing divisor by a factor of 2 as 2 digits are dropped ; Function that returns true if the digit sum of n is palindrome ; Sum of the digits of n ; If the digit sum is palindrome ; Driver code"
Python;def xorK ( n , k ) : NEW_LINE INDENT if ( k % 2 == 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return 0 NEW_LINE DEDENT n = 123 NEW_LINE k = 3 NEW_LINE print ( xorK ( n , k ) ) NEW_LINE;"Find the value of N XOR 'ed to itself K times | Function to return n ^ n ^ ... k times ; If k is odd the answer is the number itself ; Else the answer is 0 ; Driver code"
Python;"N = 100005 NEW_LINE mod = ( int ) ( 1e9 + 7 ) NEW_LINE factorial = [ 0 ] * N ; NEW_LINE modinverse = [ 0 ] * N ; NEW_LINE def power ( a , m1 ) : NEW_LINE INDENT if ( m1 == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT elif ( m1 == 1 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT elif ( m1 == 2 ) : NEW_LINE INDENT return ( a * a ) % mod ; NEW_LINE DEDENT elif ( m1 & 1 ) : NEW_LINE INDENT return ( a * power ( power ( a , m1 // 2 ) , 2 ) ) % mod ; NEW_LINE DEDENT else : NEW_LINE INDENT return power ( power ( a , m1 // 2 ) , 2 ) % mod ; NEW_LINE DEDENT DEDENT def factorialfun ( ) : NEW_LINE INDENT factorial [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT factorial [ i ] = ( factorial [ i - 1 ] * i ) % mod ; NEW_LINE DEDENT DEDENT def modinversefun ( ) : NEW_LINE INDENT modinverse [ N - 1 ] = power ( factorial [ N - 1 ] , mod - 2 ) % mod ; NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT modinverse [ i ] = ( modinverse [ i + 1 ] * ( i + 1 ) ) % mod ; NEW_LINE DEDENT DEDENT def binomial ( n , r ) : NEW_LINE INDENT if ( r > n ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT a = ( factorial [ n ] * modinverse [ n - r ] ) % mod ; NEW_LINE a = ( a * modinverse [ r ] ) % mod ; NEW_LINE return a ; NEW_LINE DEDENT def arrange ( n , m , k ) : NEW_LINE INDENT factorialfun ( ) ; NEW_LINE modinversefun ( ) ; NEW_LINE ans = 0 ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans += ( i * ( n - i ) * m * m ) % mod ; NEW_LINE DEDENT for i in range ( 1 , m ) : NEW_LINE INDENT ans += ( i * ( m - i ) * n * n ) % mod ; NEW_LINE DEDENT ans = ( ans * binomial ( n * m - 2 , k - 2 ) ) % mod ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 2 ; m = 2 ; k = 2 ; NEW_LINE print ( arrange ( n , m , k ) ) ; NEW_LINE DEDENT";"Find the sum of the costs of all possible arrangements of the cells | Python3 implementation of the approach ; To store the factorials and factorial mod inverse of the numbers ; Function to return ( a ^ m1 ) % mod ; Function to find the factorials of all the numbers ; Function to find factorial mod inverse of all the numbers ; Function to return nCr ; Function to return the sum of the costs of all the possible arrangements of the cells ; For all possible X 's ; For all possible Y 's ; Driver code"
Python;"def findNthDigit ( p , q , N ) : NEW_LINE INDENT while ( N > 0 ) : NEW_LINE INDENT N -= 1 ; NEW_LINE p *= 10 ; NEW_LINE res = p // q ; NEW_LINE p %= q ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT p = 1 ; q = 2 ; N = 1 ; NEW_LINE print ( findNthDigit ( p , q , N ) ) ; NEW_LINE DEDENT";"Find the Nth digit in the proper fraction of two numbers | Function to print the Nth digit in the fraction ( p / q ) ; While N > 0 compute the Nth digit by dividing p and q and store the result into variable res and go to next digit ; Driver code"
Python;"def sumArr ( arr , n ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def sumModArr ( arr , n ) : NEW_LINE INDENT subSum = arr [ n - 1 ] ; NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT curr = arr [ i ] ; NEW_LINE arr [ i ] -= subSum ; NEW_LINE subSum += curr ; NEW_LINE DEDENT return sumArr ( arr , n ) ; NEW_LINE DEDENT arr = [ 40 , 25 , 12 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( sumModArr ( arr , n ) ) ; NEW_LINE";"Sum of the updated array after performing the given operation | Utility function to return the sum of the array ; Function to return the sum of the modified array ; Subtract the subarray sum ; Sum of subarray arr [ i ... n - 1 ] ; Return the sum of the modified array ; Driver code"
Python;"NumUnsignBits = 64 ; NEW_LINE def findNum ( x ) : NEW_LINE INDENT for i in range ( NumUnsignBits - 1 ) : NEW_LINE INDENT if ( ( ( x >> i ) & 1 ) != ( ( x >> ( i + 1 ) ) & 1 ) ) : NEW_LINE INDENT x ^= ( 1 << i ) | ( 1 << ( i + 1 ) ) ; NEW_LINE return x ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 92 ; NEW_LINE print ( findNum ( n ) ) ; NEW_LINE DEDENT";"Find closest integer with the same weight | Python3 implementation of the approach ; Function to return the number closest to x which has equal number of set bits as x ; Loop for each bit in x and compare with the next bit ; Driver code"
Python;def cntCakes ( n , m ) : NEW_LINE INDENT sum = ( n * ( n + 1 ) ) // 2 NEW_LINE quo , rem = m // sum , m % sum NEW_LINE ans = m - quo * sum NEW_LINE x = int ( ( - 1 + ( 8 * rem + 1 ) ** 0.5 ) / 2 ) NEW_LINE ans = ans - x * ( x + 1 ) // 2 NEW_LINE return ans NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT n = 4 NEW_LINE m = 11 NEW_LINE ans = cntCakes ( n , m ) NEW_LINE print ( ans ) NEW_LINE DEDENT main ( ) NEW_LINE;"Cake Distribution Problem | Function to return the remaining count of cakes ; Sum for 1 cycle ; no . of full cycle and remainder ; Driver code"
Python;"def cntSquares ( n ) : NEW_LINE INDENT return int ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT print ( cntSquares ( 4 ) ) ; NEW_LINE DEDENT";"Find the number of squares inside the given square grid | Function to return the number of squares inside an n * n grid ; Driver code"
Python;"def reverse ( num ) : NEW_LINE INDENT rev = 0 ; NEW_LINE while ( num > 0 ) : NEW_LINE INDENT rev = rev * 10 + num % 10 ; NEW_LINE num = num // 10 ; NEW_LINE DEDENT return rev ; NEW_LINE DEDENT def isPalindrome ( num ) : NEW_LINE INDENT if ( num == reverse ( num ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT def printPalindromes ( d ) : NEW_LINE INDENT if ( d <= 0 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT smallest = pow ( 10 , d - 1 ) ; NEW_LINE largest = pow ( 10 , d ) - 1 ; NEW_LINE for i in range ( smallest , largest + 1 ) : NEW_LINE INDENT if ( isPalindrome ( i ) ) : NEW_LINE INDENT print ( i , end = "" ▁ "" ) ; NEW_LINE DEDENT DEDENT DEDENT d = 2 ; NEW_LINE printPalindromes ( d ) ; NEW_LINE";"Find all palindrome numbers of given digits | Function to return the reverse of num ; Function that returns true if num is palindrome ; If the number is equal to the reverse of it then it is a palindrome ; Function to prall the d - digit palindrome numbers ; Smallest and the largest d - digit numbers ; Starting from the smallest d - digit number till the largest ; If the current number is palindrome ; Driver code"
Python;"import sys NEW_LINE from math import sqrt NEW_LINE def min_moves ( n ) : NEW_LINE INDENT ans = sys . maxsize ; NEW_LINE for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT ans = min ( ans , i + n // i - 2 ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 10 ; NEW_LINE print ( min_moves ( n ) ) ; NEW_LINE DEDENT";"Minimum number of moves to reach N starting from ( 1 , 1 ) | Python3 implementation of the approach ; Function to return the minimum number of moves required to reach the cell containing N starting from ( 1 , 1 ) ; To store the required answer ; For all possible values of divisors ; If i is a divisor of n ; Get the moves to reach n ; Return the required answer ; Driver code"
Python;"MOD = 2019 ; NEW_LINE def min_modulo ( l , r ) : NEW_LINE INDENT if ( r - l >= MOD ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = MOD - 1 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( i + 1 , r + 1 ) : NEW_LINE INDENT ans = min ( ans , ( i * j ) % MOD ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT l = 2020 ; r = 2040 ; NEW_LINE print ( min_modulo ( l , r ) ) ; NEW_LINE DEDENT";"Minimum possible value of ( i * j ) % 2019 | Python3 implementation of the approach ; Function to return the minimum possible value of ( i * j ) % 2019 ; If we can get a number divisible by 2019 ; Find the minimum value by running nested loops ; Driver code"
Python;"def find_numbers ( N ) : NEW_LINE INDENT if ( N == 1 ) : NEW_LINE INDENT print ( - 1 , end = "" "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( N , N + 1 , N * ( N + 1 ) ) ; NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 5 ; NEW_LINE find_numbers ( N ) ; NEW_LINE DEDENT";"Represent ( 2 / N ) as the sum of three distinct positive integers of the form ( 1 / m ) | Function to find the required fractions ; Base condition ; For N > 1 ; Driver code"
Python;def countPairs ( arr , n ) : NEW_LINE INDENT map = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT map [ arr [ i ] - i ] = map . get ( arr [ i ] - i , 0 ) + 1 NEW_LINE DEDENT res = 0 NEW_LINE for x in map : NEW_LINE INDENT cnt = map [ x ] NEW_LINE res += ( ( cnt * ( cnt - 1 ) ) // 2 ) NEW_LINE DEDENT return res NEW_LINE DEDENT arr = [ 1 , 5 , 6 , 7 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE;"Count the pairs in an array such that the difference between them and their indices is equal | Function to return the count of all valid pairs ; To store the frequencies of ( arr [ i ] - i ) ; To store the required count ; If cnt is the number of elements whose difference with their index is same then ( ( cnt * ( cnt - 1 ) ) / 2 ) such pairs are possible ; Driver code"
Python;"def minInt ( str1 ) : NEW_LINE INDENT for i in range ( len ( str1 ) ) : NEW_LINE INDENT if ( str1 [ i ] >= 5 ) : NEW_LINE INDENT str1 [ i ] = ( 9 - str1 [ i ] ) NEW_LINE DEDENT DEDENT if ( str1 [ 0 ] == 0 ) : NEW_LINE INDENT str1 [ 0 ] = 9 NEW_LINE DEDENT temp = "" "" NEW_LINE for i in str1 : NEW_LINE INDENT temp += str ( i ) NEW_LINE DEDENT return temp NEW_LINE DEDENT str1 = ""589"" NEW_LINE str1 = [ int ( i ) for i in str1 ] NEW_LINE print ( minInt ( str1 ) ) NEW_LINE";"Minimum possible number with the given operation | Function to return the minimum possible integer that can be obtained from the given integer after performing the given operations ; For every digit ; Digits less than 5 need not to be changed as changing them will lead to a larger number ; The resulting integer cannot have leading zero ; Driver code"
Python;def minOperations ( n ) : NEW_LINE INDENT count = 0 NEW_LINE d = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT while ( n > 9 ) : NEW_LINE INDENT d = max ( n % 10 , d ) NEW_LINE n //= 10 NEW_LINE count += 10 NEW_LINE DEDENT d = max ( d , n - 1 ) NEW_LINE count += abs ( d ) NEW_LINE return count - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 240 NEW_LINE print ( minOperations ( n ) ) NEW_LINE DEDENT;"Reduce N to 1 with minimum number of given operations | Function to return the minimum number of given operations required to reduce n to 1 ; To store the count of operations ; To store the digit ; If n is already then no operation is required ; Extract all the digits except the first digit ; Store the maximum of that digits ; for each digit ; First digit ; Add the value to count ; Driver code"
Python;"def findMaximumNum ( st , n , k ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( k < 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( st [ i ] != '9' ) : NEW_LINE INDENT st = st [ 0 : i ] + '9' + st [ i + 1 : ] NEW_LINE k -= 1 NEW_LINE DEDENT DEDENT return st NEW_LINE DEDENT st = ""569431"" NEW_LINE n = len ( st ) NEW_LINE k = 3 NEW_LINE print ( findMaximumNum ( st , n , k ) ) NEW_LINE";"Find the largest number that can be formed by changing at most K digits | Function to return the maximum number that can be formed by changing at most k digits in str ; For every digit of the number ; If no more digits can be replaced ; If current digit is not already 9 ; Replace it with 9 ; One digit has been used ; Driver code"
Python;"def areAnagrams ( a , b ) : NEW_LINE INDENT a = str ( a ) NEW_LINE b = str ( b ) NEW_LINE if ( sorted ( a ) == sorted ( b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT a = 240 NEW_LINE b = 204 NEW_LINE if ( areAnagrams ( a , b ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Check if two Integer are anagrams of each other | Function that returns true if a and b are anagarams of each other ; Converting numbers to strings ; Checking if the sorting values of two strings are equal ; Driver code"
Python;def solve ( ang , n ) : NEW_LINE INDENT if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif ( ( ang * n ) % 180 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT ans = 1 NEW_LINE freq = ( ang * n ) // 180 NEW_LINE ans = ans * ( n - 1 - freq ) NEW_LINE ans = ans * n NEW_LINE return ans NEW_LINE DEDENT ang = 90 NEW_LINE n = 4 NEW_LINE print ( solve ( ang , n ) ) NEW_LINE;"Number of occurrences of a given angle formed using 3 vertices of a n | Function that calculates occurrences of given angle that can be created using any 3 sides ; Maximum angle in a regular n - gon is equal to the interior angle If the given angle is greater than the interior angle then the given angle cannot be created ; The given angle times n should be divisible by 180 else it cannot be created ; Initialise answer ; Calculate the frequency of given angle for each vertex ; Multiply answer by frequency . ; Multiply answer by the number of vertices . ; Driver code"
Python;def prime ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i * i > n + 1 : NEW_LINE INDENT break NEW_LINE DEDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def thirdNumber ( a , b ) : NEW_LINE INDENT summ = 0 NEW_LINE temp = 0 NEW_LINE summ = a + b NEW_LINE temp = 1 NEW_LINE if ( summ & 1 ) : NEW_LINE INDENT temp = 2 NEW_LINE DEDENT while ( prime ( summ + temp ) == False ) : NEW_LINE INDENT temp += 2 NEW_LINE DEDENT print ( temp ) NEW_LINE DEDENT a = 3 NEW_LINE b = 5 NEW_LINE thirdNumber ( a , b ) NEW_LINE;"Find third number such that sum of all three number becomes prime | Function that will check whether number is prime or not ; Function to print the 3 rd number ; If the summ is odd ; If summ is not prime ; Driver code"
Python;"def nCr ( n , r ) : NEW_LINE INDENT ans = 1 ; NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT ans *= ( n - r + i ) ; NEW_LINE ans //= i ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT def total_ways ( N , X ) : NEW_LINE INDENT return ( nCr ( N - 1 , X - 1 ) + nCr ( N - 1 , X ) ) ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 5 ; X = 3 ; NEW_LINE print ( total_ways ( N , X ) ) ; NEW_LINE DEDENT";"Total ways of selecting a group of X men from N men with or without including a particular man | Function to return the value of nCr ; Initialize the answer ; Divide simultaneously by i to avoid overflow ; Function to return the count of ways ; Driver code"
Python;"def calculate ( n , k , m , power ) : NEW_LINE INDENT if n > m : NEW_LINE INDENT if power == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return power - 1 NEW_LINE DEDENT DEDENT elif n == m : NEW_LINE INDENT return power NEW_LINE DEDENT else : NEW_LINE INDENT return calculate ( n * k , k , m , power + 1 ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 1 NEW_LINE K = 2 NEW_LINE M = 5 NEW_LINE print ( calculate ( N , K , M , 0 ) ) NEW_LINE DEDENT";"Compute the maximum power with a given condition | Function to return the largest power ; If n is greater than given M ; If n == m ; Checking for the next power ; Driver 's code"
Python;"def printNumber ( holes ) : NEW_LINE INDENT if ( holes == 0 ) : NEW_LINE INDENT print ( ""1"" ) NEW_LINE DEDENT elif ( holes == 1 ) : NEW_LINE INDENT print ( ""0"" , end = "" "" ) NEW_LINE DEDENT else : NEW_LINE INDENT rem = 0 NEW_LINE quo = 0 NEW_LINE rem = holes % 2 NEW_LINE quo = holes // 2 NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT print ( ""4"" , end = "" "" ) NEW_LINE DEDENT for i in range ( quo ) : NEW_LINE INDENT print ( ""8"" , end = "" "" ) NEW_LINE DEDENT DEDENT DEDENT holes = 3 NEW_LINE printNumber ( holes ) NEW_LINE";"Program to find the number from given holes | Function that will find out the number ; If number of holes equal 0 then return 1 ; If number of holes equal 0 then return 0 ; If number of holes is more than 0 or 1. ; If number of holes is odd ; Driver code ; Calling Function"
Python;def minCost ( arr , n ) : NEW_LINE INDENT count_even = 0 NEW_LINE count_odd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT count_even += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count_odd += 1 NEW_LINE DEDENT DEDENT return min ( count_even , count_odd ) NEW_LINE DEDENT arr = [ 2 , 4 , 3 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minCost ( arr , n ) ) NEW_LINE;"Minimum cost to make all array elements equal | Function to return the minimum cost to make each array element equal ; To store the count of even numbers present in the array ; To store the count of odd numbers present in the array ; Iterate through the array and find the count of even numbers and odd numbers ; Driver code"
Python;"def negProdSubArr ( arr , n ) : NEW_LINE INDENT positive = 1 NEW_LINE negative = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] > 0 ) : NEW_LINE INDENT arr [ i ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = - 1 NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT arr [ i ] *= arr [ i - 1 ] NEW_LINE DEDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT else : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * negative ) NEW_LINE DEDENT def posProdSubArr ( arr , n ) : NEW_LINE INDENT total = ( n * ( n + 1 ) ) / 2 ; NEW_LINE cntNeg = negProdSubArr ( arr , n ) ; NEW_LINE return ( total - cntNeg ) ; NEW_LINE DEDENT arr = [ 5 , - 4 , - 3 , 2 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( posProdSubArr ( arr , n ) ) NEW_LINE";"Number of Subarrays with positive product | Function to return the count of subarrays with negative product ; Replace current element with 1 if it is positive else replace it with - 1 instead ; Take product with previous element to form the prefix product ; Count positive and negative elements in the prefix product array ; Return the required count of subarrays ; Function to return the count of subarrays with positive product ; Total subarrays possible ; Count to subarrays with negative product ; Return the count of subarrays with positive product ; Driver code"
Python;MAX = 10000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , MAX + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( 2 * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def xorFirstNPrime ( n ) : NEW_LINE INDENT count = 0 NEW_LINE num = 1 NEW_LINE xorVal = 0 NEW_LINE while ( count < n ) : NEW_LINE INDENT if ( prime [ num ] ) : NEW_LINE INDENT xorVal ^= num NEW_LINE count += 1 NEW_LINE DEDENT num += 1 NEW_LINE DEDENT return xorVal NEW_LINE DEDENT SieveOfEratosthenes ( ) NEW_LINE n = 4 NEW_LINE print ( xorFirstNPrime ( n ) ) NEW_LINE;"Find the XOR of first N Prime Numbers | Python3 implementation of the approach ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all entries it as true . A value in prime [ i ] will finally be false + if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Set all multiples of p to non - prime ; Function to return the xor of 1 st N prime numbers ; Count of prime numbers ; XOR of prime numbers ; If the number is prime xor it ; Increment the count ; Get to the next number ; Create the sieve ; Find the xor of 1 st n prime numbers"
Python;"mod = 1000000007 NEW_LINE inv2 = 500000004 ; NEW_LINE def modulo ( num ) : NEW_LINE INDENT res = 0 ; NEW_LINE DEDENT ' NEW_LINE INDENT for i in range ( len ( num ) ) : NEW_LINE INDENT res = ( res * 10 + int ( num [ i ] ) - 0 ) % mod ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def findSum ( L , R ) : NEW_LINE INDENT a = modulo ( L ) ; NEW_LINE b = modulo ( R ) ; NEW_LINE l = ( ( a * ( a - 1 ) ) % mod * inv2 ) % mod ; NEW_LINE r = ( ( b * ( b + 1 ) ) % mod * inv2 ) % mod ; NEW_LINE ret = ( r % mod - l % mod ) ; NEW_LINE if ( ret < 0 ) : NEW_LINE INDENT ret = ret + mod ; NEW_LINE DEDENT else : NEW_LINE INDENT ret = ret % mod ; NEW_LINE DEDENT return ret ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT L = ""88949273204"" ; NEW_LINE R = ""98429729474298592"" ; NEW_LINE print ( findSum ( L , R ) ) ; NEW_LINE DEDENT";"Sum of all natural numbers from L to R ( for large values of L and R ) | Python3 implementation of the approach ; Value of inverse modulo 2 with 10 ^ 9 + 7 ; Function to return num % 1000000007 where num is a large number ; Initialize result ; One by one process all the digits of string 'num ; Function to return the sum of the integers from the given range modulo 1000000007 ; a stores the value of L modulo 10 ^ 9 + 7 ; b stores the value of R modulo 10 ^ 9 + 7 ; l stores the sum of natural numbers from 1 to ( a - 1 ) ; r stores the sum of natural numbers from 1 to b ; If the result is negative ; Driver code"
Python;"import sys NEW_LINE def maxSubArraySum ( a , n , k , i ) : NEW_LINE INDENT max_so_far = - sys . maxsize ; NEW_LINE max_ending_here = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] ; NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here ; NEW_LINE DEDENT if ( max_ending_here < 0 ) : NEW_LINE INDENT max_ending_here = 0 ; NEW_LINE DEDENT i += k ; NEW_LINE DEDENT return max_so_far ; NEW_LINE DEDENT def find ( arr , n , k ) : NEW_LINE INDENT maxSum = 0 ; NEW_LINE for i in range ( 0 , min ( n , k ) + 1 ) : NEW_LINE INDENT sum = 0 ; NEW_LINE maxSum = max ( maxSum , maxSubArraySum ( arr , n , k , i ) ) ; NEW_LINE DEDENT return maxSum ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , - 3 , - 1 , - 1 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE print ( find ( arr , n , k ) ) ; NEW_LINE DEDENT";"Maximum subsequence sum such that all elements are K distance apart | Function to return the maximum subarray sum for the array { a [ i ] , a [ i + k ] , a [ i + 2 k ] , ... } ; Function to return the sum of the maximum required subsequence ; To store the result ; Run a loop from 0 to k ; Find the maximum subarray sum for the array { a [ i ] , a [ i + k ] , a [ i + 2 k ] , ... } ; Return the maximum value ; Driver code"
Python;"from math import sqrt NEW_LINE MAX = 1000000 NEW_LINE prime = [ True ] * ( MAX + 1 ) ; NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False ; NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def solve ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE i = 3 ; NEW_LINE while count < n : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT print ( i , end = "" ▁ "" ) ; NEW_LINE count += 1 ; NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT SieveOfEratosthenes ( ) ; NEW_LINE n = 6 ; NEW_LINE solve ( n ) ; NEW_LINE DEDENT";"Generate N integers satisfying the given conditions | Python3 implementation of the approach ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Set all multiples of p to non - prime ; Function to find the first n odd prime numbers ; To store the current count of prime numbers ; Starting with 3 as 2 is an even prime number ; If i is prime ; Print i and increment count ; Driver code ; Create the sieve"
Python;"def solve ( n ) : NEW_LINE INDENT n_2 = n // 2 ; NEW_LINE den = ""1"" ; NEW_LINE while ( n_2 ) : NEW_LINE INDENT den += '0' ; NEW_LINE n_2 -= 1 NEW_LINE DEDENT print ( str ( 1 ) + "" / "" + str ( den ) ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 5 ; NEW_LINE solve ( N ) ; NEW_LINE DEDENT";"Probability that a N digit number is palindrome | Find the probability that a n digit number is palindrome ; Denominator ; Assign 10 ^ ( floor ( n / 2 ) ) to denominator ; Display the answer ; Driver code"
Python;MOD = 1000000007 NEW_LINE def countWays ( n ) : NEW_LINE INDENT return ( ( ( 2 ** n ) - 1 ) % MOD ) NEW_LINE DEDENT n = 3 NEW_LINE print ( countWays ( n ) ) NEW_LINE;"Ways to choose balls such that at least one ball is chosen | Python3 implementation of the approach ; Function to return the count of ways to choose the balls ; Return ( ( 2 ^ n ) - 1 ) % MOD ; Driver code"
Python;def findMin ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum = sum + arr [ i ] NEW_LINE DEDENT arr . sort ( ) NEW_LINE min = arr [ 0 ] NEW_LINE max = 0 NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT num = arr [ i ] NEW_LINE total = num + min NEW_LINE for j in range ( 2 , num + 1 ) : NEW_LINE INDENT if ( num % j == 0 ) : NEW_LINE INDENT d = j NEW_LINE now = ( num // d ) + ( min * d ) NEW_LINE reduce = total - now NEW_LINE if ( reduce > max ) : NEW_LINE INDENT max = reduce NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( sum - max ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE findMin ( arr , n ) NEW_LINE;"Minimize the sum of the array according the given condition | Function to return the minimum sum ; sort the array to find the minimum element ; finding the number to divide ; Checking to what instance the sum has decreased ; getting the max difference ; Driver Code"
Python;"def convert_To_Len_th_base ( n , arr , Len , L ) : NEW_LINE INDENT for i in range ( L ) : NEW_LINE INDENT print ( arr [ n % Len ] , end = "" "" ) NEW_LINE n //= Len NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def printf ( arr , Len , L ) : NEW_LINE INDENT for i in range ( pow ( Len , L ) ) : NEW_LINE INDENT convert_To_Len_th_base ( i , arr , Len , L ) NEW_LINE DEDENT DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE Len = len ( arr ) NEW_LINE L = 2 NEW_LINE printf ( arr , Len , L ) NEW_LINE";"Print all the permutation of length L using the elements of an array | Iterative | Convert the number to Lth base and print the sequence ; Sequence is of Length L ; Print the ith element of sequence ; Print all the permuataions ; There can be ( Len ) ^ l permutations ; Convert i to Len th base ; Driver code ; function call"
Python;def totalways ( arr , n ) : NEW_LINE INDENT cnt = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ arr [ i ] ] = cnt . get ( arr [ i ] , 0 ) + 1 NEW_LINE DEDENT if ( n % 2 == 1 ) : NEW_LINE INDENT start , endd = 0 , n - 1 NEW_LINE for i in range ( start , endd + 1 , 2 ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT if ( cnt [ i ] != 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( cnt [ i ] != 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT ways = 1 NEW_LINE start = 2 NEW_LINE endd = n - 1 NEW_LINE for i in range ( start , endd + 1 , 2 ) : NEW_LINE INDENT ways = ways * 2 NEW_LINE DEDENT return ways NEW_LINE DEDENT elif ( n % 2 == 0 ) : NEW_LINE INDENT start = 1 NEW_LINE endd = n - 1 NEW_LINE for i in range ( 1 , endd + 1 , 2 ) : NEW_LINE INDENT if ( cnt [ i ] != 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT ways = 1 NEW_LINE for i in range ( start , endd + 1 , 2 ) : NEW_LINE INDENT ways = ways * 2 NEW_LINE DEDENT return ways NEW_LINE DEDENT DEDENT N = 5 NEW_LINE arr = [ 2 , 4 , 4 , 0 , 2 ] NEW_LINE print ( totalways ( arr , N ) ) NEW_LINE;"Number of possible permutations when absolute difference between number of elements to the right and left are given | Function to find the number of permutations possible of the original array to satisfy the given absolute differences ; To store the count of each a [ i ] in a map ; if n is odd ; check the count of each whether it satisfy the given criteria or not ; there is only 1 way for middle element . ; for others there are 2 ways . ; now find total ways ; When n is even . ; there will be no middle element so for each a [ i ] there will be 2 ways ; Driver Code"
Python;def proizvolov ( a , b , n ) : NEW_LINE INDENT return n * n NEW_LINE DEDENT a = [ 1 , 5 , 6 , 8 , 10 ] NEW_LINE b = [ 9 , 7 , 4 , 3 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( proizvolov ( a , b , n , ) ) NEW_LINE;"Proizvolov 's Identity | Function to implement proizvolov 's identity ; According to proizvolov 's identity ; Driver code ; Function call"
Python;"from math import pow NEW_LINE def calculateLnx ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE num = ( n - 1 ) / ( n + 1 ) NEW_LINE for i in range ( 1 , 1001 , 1 ) : NEW_LINE INDENT mul = ( 2 * i ) - 1 NEW_LINE cal = pow ( num , mul ) NEW_LINE cal = cal / mul NEW_LINE sum = sum + cal NEW_LINE DEDENT sum = 2 * sum NEW_LINE return sum NEW_LINE DEDENT def calculateLogx ( lnx ) : NEW_LINE INDENT return ( lnx / 2.303 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE lnx = calculateLnx ( n ) NEW_LINE logx = calculateLogx ( lnx ) NEW_LINE print ( "" ln "" , "" { 0 : . 3f } "" . format ( n ) , "" = "" , "" { 0 : . 3f } "" . format ( lnx ) ) NEW_LINE print ( "" log10"" , "" { 0 : . 3f } "" . format ( n ) , "" = "" , "" { 0 : . 3f } "" . format ( logx ) ) NEW_LINE DEDENT";"Find the ln ( X ) and log10X with the help of expansion | Function to calculate ln x using expansion ; terminating value of the loop can be increased to improve the precision ; Function to calculate log10 x ; Driver Code ; setprecision ( 3 ) is used to display the output up to 3 decimal places"
Python;def Sum ( A , B , R ) : NEW_LINE INDENT ssum = 0 NEW_LINE for i in range ( 1 , R + 1 ) : NEW_LINE INDENT ssum = ssum + ( i * A ) NEW_LINE A = A + B NEW_LINE DEDENT return ssum NEW_LINE DEDENT A , B , R = 5 , 3 , 3 NEW_LINE print ( Sum ( A , B , R ) ) NEW_LINE;"Find the sum of elements of the Matrix generated by the given rules | Function to return the required ssum ; To store the ssum ; For every row ; Update the ssum as A appears i number of times in the current row ; Update A for the next row ; Return the ssum ; Driver code"
Python;def smallestPrimeFactor ( n ) : NEW_LINE INDENT i = 2 NEW_LINE while ( i * i ) <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return n NEW_LINE DEDENT def solve ( n ) : NEW_LINE INDENT product = 1 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT num = smallestPrimeFactor ( product + 1 ) NEW_LINE print ( num , end = ' ▁ ' ) NEW_LINE product = product * num NEW_LINE i += 1 NEW_LINE DEDENT DEDENT b = 14 NEW_LINE solve ( b ) NEW_LINE;"Euclidâ €“ Mullin Sequence | Function to return the smallest prime factor of n ; Initialize i = 2 ; While i <= sqrt ( n ) ; If n is divisible by i ; Increment i ; Function to print the first n terms of the required sequence ; To store the product of the previous terms ; Traverse the prime numbers ; Current term will be smallest prime factor of ( 1 + product of all previous terms ) ; Print the current term ; Update the product ; Find the first 14 terms of the sequence"
Python;"def countSetBits ( n ) : NEW_LINE INDENT n += 1 ; NEW_LINE powerOf2 = 2 ; NEW_LINE cnt = n // 2 ; NEW_LINE while ( powerOf2 <= n ) : NEW_LINE INDENT totalPairs = n // powerOf2 ; NEW_LINE cnt += ( totalPairs // 2 ) * powerOf2 ; NEW_LINE if ( totalPairs & 1 ) : NEW_LINE INDENT cnt += ( n % powerOf2 ) NEW_LINE DEDENT else : NEW_LINE INDENT cnt += 0 NEW_LINE DEDENT powerOf2 <<= 1 ; NEW_LINE DEDENT return cnt ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 14 ; NEW_LINE print ( countSetBits ( n ) ) ; NEW_LINE DEDENT";"Count total set bits in all numbers from 1 to n | Set 2 | Function to return the sum of the count of set bits in the integers from 1 to n ; Ignore 0 as all the bits are unset ; To store the powers of 2 ; To store the result , it is initialized with n / 2 because the count of set least significant bits in the integers from 1 to n is n / 2 ; Loop for every bit required to represent n ; Total count of pairs of 0 s and 1 s ; totalPairs / 2 gives the complete count of the pairs of 1 s Multiplying it with the current power of 2 will give the count of 1 s in the current bit ; If the count of pairs was odd then add the remaining 1 s which could not be groupped together ; Next power of 2 ; Return the result ; Driver code"
Python;def getHeight ( X ) : NEW_LINE INDENT return ( 2 * X ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = 35 NEW_LINE print ( getHeight ( X ) ) NEW_LINE DEDENT;"Find the height of a right | Function to return the height of the right - angled triangle whose area is X times its base ; Driver code"
Python;"def SumofInverseDivisors ( N , Sum ) : NEW_LINE INDENT ans = float ( Sum ) * 1.0 / float ( N ) ; NEW_LINE return round ( ans , 2 ) ; NEW_LINE DEDENT N = 9 ; NEW_LINE Sum = 13 ; NEW_LINE print SumofInverseDivisors ( N , Sum ) ; NEW_LINE";"Find sum of inverse of the divisors when sum of divisors and the number is given | Function to return the sum of inverse of divisors ; Calculating the answer ; Return the answer ; Driver code ; Function call"
Python;"def NoofTriplets ( N , K ) : NEW_LINE INDENT cnt = [ 0 ] * K ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT cnt [ i % K ] += 1 ; NEW_LINE DEDENT if ( K & 1 ) : NEW_LINE INDENT rslt = cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] ; NEW_LINE return rslt NEW_LINE DEDENT else : NEW_LINE INDENT rslt = ( cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] + cnt [ K // 2 ] * cnt [ K // 2 ] * cnt [ K // 2 ] ) ; NEW_LINE return rslt NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 3 ; K = 2 ; NEW_LINE print ( NoofTriplets ( N , K ) ) ; NEW_LINE DEDENT";"Number of triplets such that each value is less than N and each pair sum is a multiple of K | Function to return the number of triplets ; Initializing the count array ; Storing the frequency of each modulo class ; If K is odd ; If K is even ; Driver Code ; Function Call"
Python;"def findNumber ( n ) : NEW_LINE INDENT num = n - 1 ; NEW_LINE num = 2 * ( 4 ** num ) ; NEW_LINE num = num // 3 ; NEW_LINE return num ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 5 ; NEW_LINE print ( findNumber ( n ) ) ; NEW_LINE DEDENT";"Find a number containing N | Function to compute number using our deduced formula ; Initialize num to n - 1 ; Driver code"
Python;"from operator import xor NEW_LINE def findXOR ( n ) : NEW_LINE INDENT mod = n % 4 ; NEW_LINE if ( mod == 0 ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT elif ( mod == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT elif ( mod == 2 ) : NEW_LINE INDENT return n + 1 ; NEW_LINE DEDENT elif ( mod == 3 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT def findXORFun ( l , r ) : NEW_LINE INDENT return ( xor ( findXOR ( l - 1 ) , findXOR ( r ) ) ) ; NEW_LINE DEDENT l = 4 ; r = 8 ; NEW_LINE print ( findXORFun ( l , r ) ) ; NEW_LINE";"Find XOR of numbers from the range [ L , R ] | Python3 implementation of the approach ; Function to return the XOR of elements from the range [ 1 , n ] ; If n is a multiple of 4 ; If n % 4 gives remainder 1 ; If n % 4 gives remainder 2 ; If n % 4 gives remainder 3 ; Function to return the XOR of elements from the range [ l , r ] ; Driver code"
Python;"def GCD ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT return GCD ( b , a % b ) ; NEW_LINE DEDENT def findReachable ( arr , D , A , B , n ) : NEW_LINE INDENT gcd_AB = GCD ( A , B ) ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( ( arr [ i ] - D ) % gcd_AB == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT arr = [ 4 , 5 , 6 , 7 , 8 , 9 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE D = 4 ; A = 4 ; B = 6 ; NEW_LINE print ( findReachable ( arr , D , A , B , n ) ) ; NEW_LINE";"Number of elements from the array which are reachable after performing given operations on D | Function to return the GCD of a and b ; Function to return the count of reachable integers from the given array ; GCD of A and B ; To store the count of reachable integers ; If current element can be reached ; Return the count ; Driver code"
Python;"def power ( x , y ) : NEW_LINE INDENT res = 1 ; NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y % 2 == 1 ) : NEW_LINE INDENT res = ( res * x ) ; NEW_LINE DEDENT y = int ( y ) >> 1 ; NEW_LINE x = ( x * x ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def solve ( L ) : NEW_LINE INDENT n = L / 2 + 1 ; NEW_LINE ans = power ( n , n - 2 ) ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT L = 6 ; NEW_LINE print ( solve ( L ) ) ; NEW_LINE";"Number of trees whose sum of degrees of all the vertices is L | Iterative Function to calculate ( x ^ y ) in O ( log y ) ; Initialize result ; If y is odd , multiply x with result ; y must be even now y = y / 2 ; Function to return the count of required trees ; number of nodes ; Return the result ; Driver code"
Python;"def makeAP ( arr , n ) : NEW_LINE INDENT initial_term , common_difference = 0 , 0 NEW_LINE if ( n == 3 ) : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT elif ( ( arr [ 1 ] - arr [ 0 ] ) == arr [ 2 ] - arr [ 1 ] ) : NEW_LINE INDENT initial_term = arr [ 0 ] NEW_LINE common_difference = arr [ 1 ] - arr [ 0 ] NEW_LINE DEDENT elif ( ( arr [ 2 ] - arr [ 1 ] ) == ( arr [ 3 ] - arr [ 2 ] ) ) : NEW_LINE INDENT common_difference = arr [ 2 ] - arr [ 1 ] NEW_LINE initial_term = arr [ 1 ] - common_difference NEW_LINE DEDENT else : NEW_LINE INDENT common_difference = ( arr [ 3 ] - arr [ 0 ] ) / 3 NEW_LINE initial_term = arr [ 0 ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( int ( initial_term + ( i * common_difference ) ) , end = "" ▁ "" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 1 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE makeAP ( arr , n ) NEW_LINE";"Change one element in the given array to make it an Arithmetic Progression | Python program to change one element of an array such that the resulting array is in arithmetic progression . ; Finds the initial term and common difference and prints the resulting array . ; Check if the first three elements are in arithmetic progression ; Check if the first element is not in arithmetic progression ; The first and fourth element are in arithmetic progression ; Print the arithmetic progression ; Driver code"
Python;"def getfactor ( n , p ) : NEW_LINE INDENT pw = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT n //= p ; NEW_LINE pw += n ; NEW_LINE DEDENT return pw ; NEW_LINE DEDENT def isDivisible ( n , r , p ) : NEW_LINE INDENT x1 = getfactor ( n , p ) ; NEW_LINE x2 = getfactor ( r , p ) ; NEW_LINE x3 = getfactor ( n - r , p ) ; NEW_LINE if ( x1 > x2 + x3 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 7 ; r = 2 ; p = 7 ; NEW_LINE if ( isDivisible ( n , r , p ) ) : NEW_LINE INDENT print ( "" Yes "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) ; NEW_LINE DEDENT DEDENT";"Find if nCr is divisible by the given prime | Function to return the highest power of p that divides n ! implementing Legendre Formula ; Return the highest power of p which divides n ! ; Function that returns true if nCr is divisible by p ; Find the highest powers of p that divide n ! , r ! and ( n - r ) ! ; If nCr is divisible by p ; Driver code"
Python;"def isEven ( arr , n , r ) : NEW_LINE INDENT if ( r % 2 == 0 ) : NEW_LINE INDENT if ( arr [ n - 1 ] % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT oddCount = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 != 0 ) : NEW_LINE INDENT oddCount += 1 NEW_LINE DEDENT DEDENT if ( oddCount % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE r = 2 NEW_LINE if ( isEven ( arr , n , r ) ) : NEW_LINE INDENT print ( "" Even "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Odd "" ) NEW_LINE DEDENT DEDENT";"Check if the number is even or odd whose digits and base ( radix ) is given | Function that returns true if the number represented by arr [ ] is even in base r ; If the base is even , then the last digit is checked ; If base is odd , then the number of odd digits are checked ; To store the count of odd digits ; Number is odd ; Driver code"
Python;"import sys NEW_LINE def closetAND ( arr , n , k ) : NEW_LINE INDENT ans = sys . maxsize ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT X = arr [ i ] ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT X &= arr [ j ] ; NEW_LINE ans = min ( ans , abs ( k - X ) ) ; NEW_LINE if ( X <= k ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT arr = [ 4 , 7 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE print ( closetAND ( arr , n , k ) ) ; NEW_LINE";"Bitwise AND of sub | Python implementation of the approach ; Function to return the minimum possible value of | K - X | where X is the bitwise AND of the elements of some sub - array ; Check all possible sub - arrays ; Find the overall minimum ; No need to perform more AND operations as | k - X | will increase ; Driver code"
Python;"def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT return gcd ( b , a % b ) ; NEW_LINE DEDENT def countQuadruplets ( l , r , k ) : NEW_LINE INDENT frequency = [ 0 ] * ( r + 1 ) ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( l , r + 1 ) : NEW_LINE INDENT frequency [ gcd ( i , j ) ] += 1 ; NEW_LINE DEDENT DEDENT answer = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT for j in range ( l , r + 1 ) : NEW_LINE INDENT if ( gcd ( i , j ) == k ) : NEW_LINE INDENT answer += ( frequency [ i ] * frequency [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT return answer ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l , r , k = 1 , 10 , 2 ; NEW_LINE print ( countQuadruplets ( l , r , k ) ) ; NEW_LINE DEDENT";"Count of quadruplets from range [ L , R ] having GCD equal to K | Function to return the gcd of a and b ; Function to return the count of quadruplets having gcd = k ; Count the frequency of every possible gcd value in the range ; To store the required count ; Calculate the answer using frequency values ; Return the required count ; Driver code"
Python;"def solve ( a , n ) : NEW_LINE INDENT ones , twos = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT else : NEW_LINE INDENT twos += 1 NEW_LINE DEDENT DEDENT ind = 0 NEW_LINE if ( twos ) : NEW_LINE INDENT a [ ind ] = 2 NEW_LINE ind += 1 NEW_LINE DEDENT if ones % 2 == 0 : NEW_LINE INDENT evenOnes = True NEW_LINE DEDENT else : NEW_LINE INDENT evenOnes = False NEW_LINE DEDENT if ( evenOnes ) : NEW_LINE INDENT ones -= 1 NEW_LINE DEDENT for i in range ( ones ) : NEW_LINE INDENT a [ ind ] = 1 NEW_LINE ind += 1 NEW_LINE DEDENT for i in range ( twos - 1 ) : NEW_LINE INDENT a [ ind ] = 2 NEW_LINE ind += 1 NEW_LINE DEDENT if ( evenOnes ) : NEW_LINE INDENT a [ ind ] = 1 NEW_LINE ind += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( a [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT a = [ 1 , 2 , 1 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE solve ( a , n ) NEW_LINE";"Rearrange the array to maximize the number of primes in prefix sum of the array | Function to print the re - arranged array ; Count the number of ones and twos in a [ ] ; If the array element is 1 ; Array element is 2 ; If it has at least one 2 Fill up first 2 ; Decrease the cnt of ones if even ; Fill up with odd count of ones ; Fill up with remaining twos ; If even ones , then fill last position ; Print the rearranged array ; Driver code"
Python;"def CreateArray ( N , even , odd ) : NEW_LINE INDENT temp = - 1 NEW_LINE for i in range ( N + 2 ) : NEW_LINE INDENT if ( i * ( ( N + 1 ) - i ) == odd ) : NEW_LINE INDENT temp = 0 NEW_LINE OddPreSums = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( temp == - 1 ) : NEW_LINE INDENT print ( temp ) NEW_LINE DEDENT else : NEW_LINE INDENT EvenPreSums = ( N + 1 ) - OddPreSums NEW_LINE e = 1 NEW_LINE o = 0 NEW_LINE CurrSum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( CurrSum % 2 == 0 ) : NEW_LINE INDENT if ( e < EvenPreSums ) : NEW_LINE INDENT e += 1 NEW_LINE print ( ""0 ▁ "" , end = "" "" ) NEW_LINE DEDENT else : NEW_LINE INDENT o += 1 NEW_LINE print ( ""1 ▁ "" , end = "" "" ) NEW_LINE CurrSum += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( e < EvenPreSums ) : NEW_LINE INDENT e += 1 NEW_LINE print ( ""1 ▁ "" ) NEW_LINE CurrSum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT o += 1 NEW_LINE print ( ""0 ▁ "" , end = "" "" ) NEW_LINE DEDENT DEDENT DEDENT print ( "" "" , ▁ end ▁ = ▁ "" "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 15 NEW_LINE even = 60 NEW_LINE odd = 60 NEW_LINE CreateArray ( N , even , odd ) NEW_LINE DEDENT";"Generate an Array in which count of even and odd sum sub | Function to generate and print the required array ; Find the number of odd prefix sums ; If no odd prefix sum found ; Calculating the number of even prefix sums ; Stores the current prefix sum ; If current prefix sum is even ; Print 0 until e = EvenPreSums - 1 ; Print 1 when e = EvenPreSums ; Print 0 for rest of the values ; Driver code"
Python;import math NEW_LINE import sys NEW_LINE def changeTheArray ( arr , n ) : NEW_LINE INDENT minEle = min ( arr ) NEW_LINE maxEle = max ( arr ) NEW_LINE minOperations = sys . maxsize NEW_LINE for num in range ( minEle , maxEle + 1 ) : NEW_LINE INDENT operations = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] != num : NEW_LINE INDENT operations += ( abs ( num - arr [ i ] ) - 1 ) NEW_LINE DEDENT DEDENT minOperations = min ( minOperations , operations ) NEW_LINE DEDENT return minOperations NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 1 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( changeTheArray ( arr , n ) ) NEW_LINE DEDENT;"Minimum operations required to change the array such that | arr [ i ] | Python3 implementation of the approach ; Function to return the minimum number of operations required ; Minimum and maximum elements from the array ; To store the minimum number of operations required ; To store the number of operations required to change every element to either ( num - 1 ) , num or ( num + 1 ) ; If current element is not already num ; Add the count of operations required to change arr [ i ] ; Update the minimum operations so far ; Driver code"
Python;"def findX ( A , B ) : NEW_LINE INDENT j = 0 NEW_LINE x = 0 NEW_LINE while ( A or B ) : NEW_LINE INDENT if ( ( A & 1 ) and ( B & 1 ) ) : NEW_LINE INDENT x += ( 1 << j ) NEW_LINE DEDENT A >>= 1 NEW_LINE B >>= 1 NEW_LINE j += 1 NEW_LINE DEDENT return x NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 2 NEW_LINE B = 3 NEW_LINE X = findX ( A , B ) NEW_LINE print ( "" X ▁ = "" , X , "" , ▁ Sum ▁ = "" , ( A ^ X ) + ( B ^ X ) ) NEW_LINE DEDENT";"Choose X such that ( A xor X ) + ( B xor X ) is minimized | Function to return the integer X such that ( A xor X ) + ( B ^ X ) is minimized ; While either A or B is non - zero ; Position at which both A and B have a set bit ; Inserting a set bit in x ; Right shifting both numbers to traverse all the bits ; Driver code"
Python;"def findX ( A , B ) : NEW_LINE INDENT return A & B NEW_LINE DEDENT def findSum ( A , B ) : NEW_LINE INDENT return A ^ B NEW_LINE DEDENT A , B = 2 , 3 NEW_LINE print ( "" X ▁ = "" , findX ( A , B ) , "" , ▁ Sum ▁ = "" , findSum ( A , B ) ) NEW_LINE";"Choose X such that ( A xor X ) + ( B xor X ) is minimized | finding X ; finding Sum ; Driver code"
Python;"def isSumEqual ( ar , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT sum += ar [ i ] NEW_LINE DEDENT if ( sum == ar [ n - 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isSumEqual ( arr , n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT";"Compare sum of first N | Function that returns true if sum of first n - 1 elements of the array is equal to the last element ; Find the sum of first n - 1 elements of the array ; If sum equals to the last element ; Driver code"
Python;"from math import sqrt , ceil , floor ; NEW_LINE def perfectSquares ( a , b ) : NEW_LINE INDENT return ( floor ( sqrt ( b ) ) - ceil ( sqrt ( a ) ) + 1 ) ; NEW_LINE DEDENT def countOnes ( arr , n ) : NEW_LINE INDENT return perfectSquares ( 1 , n ) ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 10 ; NEW_LINE arr = [ 0 ] * 10 ; NEW_LINE print ( countOnes ( arr , N ) ) ; NEW_LINE DEDENT";"Count number of 1 s in the array after N moves | Python3 implementation of the above approach ; Function to count number of perfect squares ; Counting number of perfect squares between a and b ; Function to count number of 1 s in array after N moves ; Driver Code ; Initialize array size ; Initialize all elements to 0"
Python;"import bisect NEW_LINE def printPosition ( A , B , sizeOfA , sizeOfB ) : NEW_LINE INDENT for i in range ( 1 , sizeOfA ) : NEW_LINE INDENT A [ i ] += A [ i - 1 ] NEW_LINE DEDENT for i in range ( sizeOfB ) : NEW_LINE INDENT row = bisect . bisect_left ( A , B [ i ] ) NEW_LINE if row >= 1 : NEW_LINE INDENT boxNumber = B [ i ] - A [ row - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT boxNumber = B [ i ] NEW_LINE DEDENT print ( row + 1 , "" , "" , boxNumber ) NEW_LINE DEDENT DEDENT A = [ 2 , 2 , 2 , 2 ] NEW_LINE B = [ 1 , 2 , 3 , 4 ] NEW_LINE sizeOfA = len ( A ) NEW_LINE sizeOfB = len ( B ) NEW_LINE printPosition ( A , B , sizeOfA , sizeOfB ) NEW_LINE";"Find the position of box which occupies the given ball | Python3 implementation of the approach ; Function to print the position of each boxes where a ball has to be placed ; Find the cumulative sum of array A [ ] ; Find the position of box for each ball ; Row number ; Column ( position of box in particular row ) ; Row + 1 denotes row if indexing of array start from 1 ; Driver code"
Python;import math NEW_LINE def primeFactors ( n , freq ) : NEW_LINE INDENT cnt = 0 NEW_LINE while n % 2 == 0 : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE n = int ( n // 2 ) NEW_LINE DEDENT freq [ 2 ] = cnt NEW_LINE i = 3 NEW_LINE while i <= math . sqrt ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT cnt = cnt + 1 NEW_LINE n = int ( n // i ) NEW_LINE DEDENT freq [ int ( i ) ] = cnt NEW_LINE i = i + 2 NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT freq [ int ( n ) ] = 1 NEW_LINE DEDENT DEDENT def getMaximumPower ( n , m ) : NEW_LINE INDENT freq1 = [ 0 ] * ( n + 1 ) NEW_LINE freq2 = [ 0 ] * ( m + 1 ) NEW_LINE primeFactors ( n , freq1 ) NEW_LINE primeFactors ( m , freq2 ) NEW_LINE maxi = 0 NEW_LINE i = 2 NEW_LINE while i <= m : NEW_LINE INDENT if ( freq1 [ i ] == 0 and freq2 [ i ] == 0 ) : NEW_LINE INDENT i = i + 1 NEW_LINE continue NEW_LINE DEDENT if ( freq2 [ i ] > freq1 [ i ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( freq2 [ i ] ) : NEW_LINE INDENT maxi = max ( maxi , int ( freq1 [ i ] // freq2 [ i ] ) ) NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return maxi NEW_LINE DEDENT n = 48 NEW_LINE m = 4 NEW_LINE print ( getMaximumPower ( n , m ) ) NEW_LINE;"Highest power of a number that divides other number | Python program to implement the above approach ; Function to get the prime factors and its count of times it divides ; Count the number of 2 s that divide n ; n must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; While i divides n , count i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; Function to return the highest power ; Initialize two arrays ; Get the prime factors of n and m ; Iterate and find the maximum power ; If i not a prime factor of n and m ; If i is a prime factor of n and m If count of i dividing m is more than i dividing n , then power will be 0 ; If i is a prime factor of M ; get the maximum power ; Drivers code"
Python;"def findDivisors ( n ) : NEW_LINE INDENT div = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if j * i <= n : NEW_LINE INDENT div [ i * j ] += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( div [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 10 NEW_LINE findDivisors ( n ) NEW_LINE DEDENT";"Find the number of divisors of all numbers in the range [ 1 , n ] | Function to find the number of divisors of all numbers in the range [ 1 , n ] ; List to store the count of divisors ; For every number from 1 to n ; Increase divisors count for every number divisible by i ; Print the divisors ; Driver Code"
Python;"def decideWinner ( a , n ) : NEW_LINE INDENT count0 = 0 NEW_LINE count1 = 0 NEW_LINE count2 = 0 NEW_LINE count3 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 4 == 0 ) : NEW_LINE INDENT count0 += 1 NEW_LINE DEDENT elif ( a [ i ] % 4 == 1 ) : NEW_LINE INDENT count1 += 1 NEW_LINE DEDENT elif ( a [ i ] % 4 == 2 ) : NEW_LINE INDENT count2 += 1 NEW_LINE DEDENT elif ( a [ i ] % 4 == 3 ) : NEW_LINE INDENT count3 += 1 NEW_LINE DEDENT DEDENT if ( count0 % 2 == 0 and count1 % 2 == 0 and count2 % 2 == 0 and count3 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT a = [ 4 , 8 , 5 , 9 ] NEW_LINE n = len ( a ) NEW_LINE if ( decideWinner ( a , n ) == 1 ) : NEW_LINE INDENT print ( "" X ▁ wins "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Y ▁ wins "" ) NEW_LINE DEDENT";"Predict the winner of the game on the basis of absolute difference of sum by selecting numbers | Function to decide the winner ; Iterate for all numbers in the array ; If mod gives 0 ; If mod gives 1 ; If mod gives 2 ; If mod gives 3 ; Check the winning condition for X ; Driver code"
Python;def CntDivbyX ( arr , n , x ) : NEW_LINE INDENT number = 0 NEW_LINE count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT number = ( number * 2 + arr [ i ] ) % x NEW_LINE if number == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT arr = [ 1 , 0 , 1 , 0 , 1 , 1 , 0 ] NEW_LINE n = 7 NEW_LINE x = 2 NEW_LINE print ( CntDivbyX ( arr , n , x ) ) NEW_LINE;"Count all prefixes of the given binary array which are divisible by x | Function to return the count of total binary prefix which are divisible by x ; Initialize with zero ; Instead of converting all prefixes to decimal , take reminder with x ; If number is divisible by x then reminder = 0 ; Driver code"
Python;def numLen ( K ) : NEW_LINE INDENT if ( K % 2 == 0 or K % 5 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT number = 0 NEW_LINE len = 1 NEW_LINE for len in range ( 1 , K + 1 ) : NEW_LINE INDENT number = ( number * 10 + 1 ) % K NEW_LINE if number == 0 : NEW_LINE INDENT return len NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT K = 7 NEW_LINE print ( numLen ( K ) ) NEW_LINE;"Length of the smallest number which is divisible by K and formed by using 1 's only | Function to return length of the resultant number ; If K is a multiple of 2 or 5 ; Instead of generating all possible numbers 1 , 11 , 111 , 111 , ... , K 1 's  Take remainder with K ; If number is divisible by k then remainder will be 0 ; Driver code"
Python;"max_Element = 100005 NEW_LINE sum1 = [ 0 for i in range ( max_Element ) ] NEW_LINE sum2 = [ 0 for i in range ( max_Element ) ] NEW_LINE sum3 = [ 0 for i in range ( max_Element ) ] NEW_LINE def precomputation ( arr , n ) : NEW_LINE INDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT for j in range ( i , max_Element , i ) : NEW_LINE INDENT sum1 [ j ] += i NEW_LINE DEDENT DEDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT for j in range ( i , max_Element , i ) : NEW_LINE INDENT sum2 [ j ] += ( sum1 [ j ] - i ) * i NEW_LINE DEDENT DEDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT sum2 [ i ] = int ( sum2 [ i ] / 2 ) NEW_LINE DEDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT for j in range ( i , max_Element , i ) : NEW_LINE INDENT sum3 [ j ] += i * ( sum2 [ j ] - i * ( sum1 [ j ] - i ) ) NEW_LINE DEDENT DEDENT for i in range ( 1 , max_Element , 1 ) : NEW_LINE INDENT sum3 [ i ] = int ( sum3 [ i ] / 3 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( sum3 [ arr [ i ] ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 9 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE precomputation ( arr , n ) NEW_LINE DEDENT";"Sum of multiplication of triplet of divisors of a number | Global array declaration global max_Element ; Function to find the sum of multiplication of every triplet in the divisors of a number ; global max_Element sum1 [ x ] represents the sum of all the divisors of x ; Adding i to sum1 [ j ] because i is a divisor of j ; sum2 [ x ] represents the sum of all the divisors of x ; Here i is divisor of j and sum1 [ j ] - i represents sum of all divisors of j which do not include i so we add i * ( sum1 [ j ] - i ) to sum2 [ j ] ; In the above implementation we have considered every pair two times so we have to divide every sum2 array element by 2 ; Here i is the divisor of j and we are trying to add the sum of multiplication of all triplets of divisors of j such that one of the divisors is i ; In the above implementation we have considered every triplet three times so we have to divide every sum3 array element by 3 ; Print the results ; Driver code ; Precomputing"
Python;"import math NEW_LINE def fib ( n ) : NEW_LINE INDENT phi = ( 1 + math . sqrt ( 5 ) ) / 2 ; NEW_LINE return int ( round ( pow ( phi , n ) / math . sqrt ( 5 ) ) ) ; NEW_LINE DEDENT def calculateSum ( l , r ) : NEW_LINE INDENT sum = fib ( r + 2 ) - fib ( l + 1 ) ; NEW_LINE return sum ; NEW_LINE DEDENT l = 4 ; NEW_LINE r = 8 ; NEW_LINE print ( calculateSum ( l , r ) ) ; NEW_LINE";"Sum of Fibonacci Numbers in a range | Python3 implementation of the approach ; Function to return the nth Fibonacci number ; Function to return the required sum ; Using our deduced result ; Driver code"
Python;"def printBalancedExpression ( a , b , c , d ) : NEW_LINE INDENT if ( ( a == d and a ) or ( a == 0 and c == 0 and d == 0 ) ) : NEW_LINE INDENT for i in range ( 1 , a + 1 ) : NEW_LINE INDENT print ( "" ( ( "" , end = "" "" ) NEW_LINE DEDENT for i in range ( 1 , c + 1 ) : NEW_LINE INDENT print ( "" ) ( "" , end = "" "" ) NEW_LINE DEDENT for i in range ( 1 , d + 1 ) : NEW_LINE INDENT print ( "" ) ) "" , end = "" "" ) NEW_LINE DEDENT for i in range ( 1 , b + 1 ) : NEW_LINE INDENT print ( "" ( ) "" , end = "" "" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( "" - 1"" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a , b , c , d = 3 , 1 , 4 , 3 NEW_LINE printBalancedExpression ( a , b , c , d ) NEW_LINE DEDENT";"Print the balanced bracket expression using given brackets | Function to print balanced bracket expression if it is possible ; If the condition is met ; Print brackets of type - 1 ; Print brackets of type - 3 ; Print brackets of type - 4 ; Print brackets of type - 2 ; If the condition is not met ; Driver code"
Python;"def factorial ( f ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 2 , f + 1 ) : NEW_LINE INDENT fact *= i NEW_LINE DEDENT return fact NEW_LINE DEDENT def findPermuatation ( N , M ) : NEW_LINE INDENT permutation = ( factorial ( N + M - 1 ) // ( factorial ( N ) * factorial ( M - 1 ) ) ) NEW_LINE return permutation NEW_LINE DEDENT N = 3 ; M = 3 NEW_LINE print ( findPermuatation ( N , M ) ) NEW_LINE";"Count numbers having N 0 ' s ▁ and ▁ and ▁ M ▁ 1' s with no leading zeros | Function to return the factorial of a number ; Function to return the count of distinct ( N + M ) digit numbers having N 0 ' s ▁ and ▁ and ▁ M ▁ 1' s with no leading zeros ; Driver code"
Python;def maxValue ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( ( n * n // 2 ) - 1 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( maxValue ( n ) ) NEW_LINE;"Maximum value of | arr [ 0 ] | Function to return the maximum required value ; Driver code"
Python;"import math NEW_LINE def findCount ( n ) : NEW_LINE INDENT a , b , c = 1 , 0 , 0 ; NEW_LINE x = ( int ) ( n / 60 ) ; NEW_LINE a = int ( math . pow ( 32 , x ) ) ; NEW_LINE x = 60 * x ; NEW_LINE for i in range ( x + 1 , n + 1 ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT b += a ; NEW_LINE a = 0 ; NEW_LINE DEDENT if ( i % 5 == 0 ) : NEW_LINE INDENT c += b ; NEW_LINE b = 0 ; NEW_LINE DEDENT if ( i % 12 == 0 ) : NEW_LINE INDENT a += ( 2 * c ) ; NEW_LINE c = 0 ; NEW_LINE DEDENT DEDENT print ( "" a ▁ = "" , a , end = "" , ▁ "" ) ; NEW_LINE print ( "" b ▁ = "" , b , end = "" , ▁ "" ) ; NEW_LINE print ( "" c ▁ = "" , c ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 72 ; NEW_LINE findCount ( n ) ; NEW_LINE DEDENT";"Count of a , b & c after n seconds for given reproduction rate | Function to print the count of a , b and c after n seconds ; Number of multiples of 60 below n ; Multiple of 60 nearest to n ; Change all a to b ; Change all b to c ; Change each c to two a ; Print the updated values of a , b and c ; Driver code"
Python;def factorial ( n ) : NEW_LINE INDENT if n == 1 or n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return factorial ( n - 1 ) * n NEW_LINE DEDENT DEDENT def gcdOfFactorial ( arr , n ) : NEW_LINE INDENT minm = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if minm > arr [ i ] : NEW_LINE INDENT minm = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = minm NEW_LINE DEDENT DEDENT return factorial ( minm ) NEW_LINE DEDENT arr = [ 9 , 12 , 122 , 34 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( gcdOfFactorial ( arr , n ) ) NEW_LINE;"Find GCD of factorial of elements of given array | Implementation of factorial function ; Function to find GCD of factorial of elements from array ; find the minimum element of array ; return the factorial of minimum element ; Driver Code"
Python;def sum ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return pow ( n , n ) + sum ( n - 1 ) NEW_LINE DEDENT DEDENT n = 2 NEW_LINE print ( sum ( n ) ) NEW_LINE;"Sum of the series 1 ^ 1 + 2 ^ 2 + 3 ^ 3 + ... . . + n ^ n using recursion | Recursive function to return the sum of the given series ; 1 ^ 1 = 1 ; Recursive call ; Driver code"
Python;"mod = 1000000007 NEW_LINE def power ( a , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( a , int ( n / 2 ) ) % mod ; NEW_LINE p = ( p * p ) % mod NEW_LINE if ( n & 1 ) : NEW_LINE INDENT p = ( p * a ) % mod NEW_LINE DEDENT return p NEW_LINE DEDENT def countPermutations ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( power ( 2 , n - 1 ) - 2 ) % mod NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( countPermutations ( n ) ) NEW_LINE DEDENT";"Count permutations that are first decreasing then increasing . | Python3 implementation of the above approach ; Function to compute a ^ n % mod ; Function to count permutations that are first decreasing and then increasing ; For n = 1 return 0 ; Calculate and return result ; Driver code"
Python;def numbers ( n ) : NEW_LINE INDENT return pow ( 2 , n + 1 ) - 2 NEW_LINE DEDENT n = 2 NEW_LINE print ( numbers ( n ) ) NEW_LINE;"Find the count of numbers that can be formed using digits 3 , 4 only and having length at max N . | Function to find the count of numbers that can be formed using digits 3 , 4 only and having length at max N . ; Driver code"
Python;def NumbersofWays ( n ) : NEW_LINE INDENT x = ( n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) // ( 4 * 3 * 2 * 1 ) NEW_LINE y = n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) NEW_LINE return x * y NEW_LINE DEDENT n = 4 NEW_LINE print ( NumbersofWays ( n ) ) NEW_LINE;"Ways to place 4 items in n ^ 2 positions such that no row / column contains more than one | Function to return the number of ways to place 4 items in n ^ 2 positions ; Driver code"
Python;def nthTerm ( N ) : NEW_LINE INDENT nth = 0 NEW_LINE nth = ( N * N * ( N + 1 ) ) // 2 NEW_LINE return nth NEW_LINE DEDENT N = 5 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE;"Find Nth term of the series 1 , 6 , 18 , 40 , 75 , ... . | Function to generate a fixed number ; ( N ^ 2 * ( N + 1 ) ) / 2 ; Driver code"
Python;"def findNumber ( n ) : NEW_LINE INDENT i = 1 NEW_LINE while i <= n : NEW_LINE INDENT print ( ( 2 * i ) - 1 , end = "" ▁ "" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT n = 3 NEW_LINE findNumber ( n ) NEW_LINE";"Print n numbers such that their sum is a perfect square | Function to print n numbers such that their sum is a perfect square ; Print ith odd number ; Driver code"
Python;"import sys NEW_LINE def findMissingNums ( even , sizeEven , odd , sizeOdd ) : NEW_LINE INDENT minEven = sys . maxsize ; NEW_LINE maxEven = - ( sys . maxsize - 1 ) ; NEW_LINE minOdd = sys . maxsize ; NEW_LINE maxOdd = - ( sys . maxsize - 1 ) ; NEW_LINE sumEvenArr = 0 ; NEW_LINE sumOddArr = 0 ; NEW_LINE for i in range ( sizeEven ) : NEW_LINE INDENT minEven = min ( minEven , even [ i ] ) ; NEW_LINE maxEven = max ( maxEven , even [ i ] ) ; NEW_LINE sumEvenArr += even [ i ] ; NEW_LINE DEDENT for i in range ( sizeOdd ) : NEW_LINE INDENT minOdd = min ( minOdd , odd [ i ] ) ; NEW_LINE maxOdd = max ( maxOdd , odd [ i ] ) ; NEW_LINE sumOddArr += odd [ i ] ; NEW_LINE DEDENT totalTerms = 0 ; NEW_LINE reqSum = 0 ; NEW_LINE totalTerms = minEven // 2 ; NEW_LINE evenSumMin = ( totalTerms * ( totalTerms + 1 ) ) ; NEW_LINE totalTerms = maxEven // 2 ; NEW_LINE evenSumMax = ( totalTerms * ( totalTerms + 1 ) ) ; NEW_LINE reqSum = ( evenSumMax - evenSumMin + minEven ) ; NEW_LINE print ( "" Even ▁ = "" , reqSum - sumEvenArr ) ; NEW_LINE totalTerms = ( minOdd // 2 ) + 1 ; NEW_LINE oddSumMin = totalTerms * totalTerms ; NEW_LINE totalTerms = ( maxOdd // 2 ) + 1 ; NEW_LINE oddSumMax = totalTerms * totalTerms ; NEW_LINE reqSum = ( oddSumMax - oddSumMin + minOdd ) ; NEW_LINE print ( "" Odd ▁ = "" , reqSum - sumOddArr ) ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT even = [ 6 , 4 , 8 , 14 , 10 ] ; NEW_LINE sizeEven = len ( even ) NEW_LINE odd = [ 7 , 5 , 3 , 11 , 13 ] ; NEW_LINE sizeOdd = len ( odd ) ; NEW_LINE findMissingNums ( even , sizeEven , odd , sizeOdd ) ; NEW_LINE DEDENT";"Missing even and odd elements from the given arrays | Python3 implementation of the approach ; Function to find the missing numbers ; To store the minimum and the maximum odd and even elements from the arrays ; To store the sum of the array elements ; Get the minimum and the maximum even elements from the array ; Get the minimum and the maximum odd elements from the array ; To store the total terms in the series and the required sum of the array ; Total terms from 2 to minEven ; Sum of all even numbers from 2 to minEven ; Total terms from 2 to maxEven ; Sum of all even numbers from 2 to maxEven ; Required sum for the even array ; Missing even number ; Total terms from 1 to minOdd ; Sum of all odd numbers from 1 to minOdd ; Total terms from 1 to maxOdd ; Sum of all odd numbers from 1 to maxOdd ; Required sum for the odd array ; Missing odd number ; Driver code"
Python;def findMinimum ( x , y ) : NEW_LINE INDENT low = 0 NEW_LINE high = y NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if ( ( mid * 2 + ( y - mid ) ) >= x ) : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return low NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 6 NEW_LINE y = 5 NEW_LINE print ( findMinimum ( x , y ) ) NEW_LINE DEDENT;"Minimum matches the team needs to win to qualify | Function to return the minimum number of matches to win to qualify for next round ; Do a binary search to find ; Find mid element ; Check for condition to qualify for next round ; Driver Code"
Python;"def getResult ( n ) : NEW_LINE INDENT proOdd = 1 NEW_LINE proEven = 1 NEW_LINE num = str ( n ) NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT proOdd = proOdd * int ( num [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT proEven = proEven * int ( num [ i ] ) NEW_LINE DEDENT DEDENT if ( proOdd == proEven ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 4324 NEW_LINE getResult ( n ) NEW_LINE DEDENT";"Check if product of digits of a number at even and odd places is equal | Python3 implementation of the approach ; To store the respective product ; Converting integer to string ; Traversing the string ; Driver code"
Python;"def sumOfDigits ( x ) : NEW_LINE INDENT sum = 0 NEW_LINE while x != 0 : NEW_LINE INDENT sum += x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def countNumbers ( l , r ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if i % 2 == 0 and sumOfDigits ( i ) % 3 == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT l = 1000 ; r = 6000 NEW_LINE print ( countNumbers ( l , r ) ) NEW_LINE";"Count of all even numbers in the range [ L , R ] whose sum of digits is divisible by 3 | Function to return the sum of digits of x ; Function to return the count of required numbers ; If i is divisible by 2 and sum of digits of i is divisible by 3 ; Return the required count ; Driver code"
Python;def findMinSum ( arr , n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += arr [ i ] * ( n - i ) NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 3 , 5 , 7 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinSum ( arr , n ) ) NEW_LINE;"Sum of minimum element of all subarrays of a sorted array | Function to find the sum of minimum of all subarrays ; Driver code"
Python;"def maxLenSubArr ( a , n ) : NEW_LINE INDENT cm , Max = 1 , 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] > Max : NEW_LINE INDENT Max = a [ i ] NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while i < n - 1 : NEW_LINE INDENT count = 1 NEW_LINE if a [ i ] == a [ i + 1 ] and a [ i ] == Max : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if a [ j ] == Max : NEW_LINE INDENT count += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if count > cm : NEW_LINE INDENT cm = count NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return cm NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 6 , 1 , 6 , 6 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxLenSubArr ( arr , n ) ) NEW_LINE DEDENT";"Longest Sub | Function to return the max length of the sub - array that have the maximum average ( average value of the elements ) ; Finding the maximum value ; If consecutive maximum found ; Find the max length of consecutive max ; Driver code"
Python;"def minSum ( arr , n , x ) : NEW_LINE INDENT Sum = 0 NEW_LINE largestDivisible , minimum = - 1 , arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE if ( arr [ i ] % x == 0 and largestDivisible < arr [ i ] ) : NEW_LINE INDENT largestDivisible = arr [ i ] NEW_LINE DEDENT if arr [ i ] < minimum : NEW_LINE INDENT minimum = arr [ i ] NEW_LINE DEDENT DEDENT if largestDivisible == - 1 : NEW_LINE INDENT return Sum NEW_LINE DEDENT sumAfterOperation = ( Sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible // x ) ) NEW_LINE return min ( Sum , sumAfterOperation ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 5 , 5 , 5 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE x = 3 NEW_LINE print ( minSum ( arr , n , x ) ) NEW_LINE DEDENT";"Minimum possible sum of array elements after performing the given operation | Function to return the minimized sum ; To store the largest element from the array which is divisible by x ; Sum of array elements before performing any operation ; If current element is divisible by x and it is maximum so far ; Update the minimum element ; If no element can be reduced then there 's  no point in performing the operation as  we will end up increasing the sum when an  element is multiplied by x ; Subtract the chosen elements from the sum and then add their updated values ; Return the minimized sum ; Driver code"
Python;"def maxAND ( L , R ) : NEW_LINE INDENT if ( L == R ) : NEW_LINE INDENT return L ; NEW_LINE DEDENT elif ( ( R - L ) == 1 ) : NEW_LINE INDENT return ( R & L ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) : NEW_LINE INDENT return ( ( R - 1 ) & R ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( R - 2 ) & ( R - 1 ) ) ; NEW_LINE DEDENT DEDENT DEDENT L = 1 ; NEW_LINE R = 632 ; NEW_LINE print ( maxAND ( L , R ) ) ; NEW_LINE";"Maximum Bitwise AND pair from given range | Function to return the maximum bitwise AND possible among all the possible pairs ; If there is only a single value in the range [ L , R ] ; If there are only two values in the range [ L , R ] ; Driver code"
Python;def checkSpecialPrime ( sieve , num ) : NEW_LINE INDENT while ( num ) : NEW_LINE INDENT if ( sieve [ num ] == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT num = int ( num / 10 ) NEW_LINE DEDENT return True NEW_LINE DEDENT def findSpecialPrime ( N ) : NEW_LINE INDENT sieve = [ True for i in range ( N * 10 + 1 ) ] NEW_LINE sieve [ 0 ] = False NEW_LINE sieve [ 1 ] = False NEW_LINE for i in range ( 2 , N * 10 + 1 ) : NEW_LINE INDENT if ( sieve [ i ] ) : NEW_LINE INDENT for j in range ( i * i , N * 10 + 1 , i ) : NEW_LINE INDENT sieve [ j ] = False NEW_LINE DEDENT DEDENT DEDENT while ( True ) : NEW_LINE INDENT if ( checkSpecialPrime ( sieve , N ) ) : NEW_LINE INDENT print ( N ) NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT N += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 379 NEW_LINE findSpecialPrime ( N ) NEW_LINE N = 100 NEW_LINE findSpecialPrime ( N ) NEW_LINE DEDENT;"Smallest Special Prime which is greater than or equal to a given number | Function to check whether the number is a special prime or not ; While number is not equal to zero ; If the number is not prime return false . ; Else remove the last digit by dividing the number by 10. ; If the number has become zero then the number is special prime , hence return true ; Function to find the Smallest Special Prime which is greater than or equal to a given number ; sieve for finding the Primes ; There is always an answer possible ; Checking if the number is a special prime or not ; If yes print the number and break the loop . ; Else increment the number . ; Driver code"
Python;"import sys NEW_LINE def minMoves ( n ) : NEW_LINE INDENT s = str ( n ) ; NEW_LINE ans = sys . maxsize ; NEW_LINE len1 = len ( s ) ; NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT for j in range ( len1 ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT t = s ; NEW_LINE cur = 0 ; NEW_LINE list1 = list ( t ) ; NEW_LINE for k in range ( i , len1 - 1 ) : NEW_LINE INDENT e = list1 [ k ] ; NEW_LINE list1 [ k ] = list1 [ k + 1 ] ; NEW_LINE list1 [ k + 1 ] = e ; NEW_LINE cur += 1 ; NEW_LINE DEDENT t = ' ' . join ( list1 ) ; NEW_LINE list1 = list ( t ) ; NEW_LINE for k in range ( j - ( j > i ) , len1 - 2 ) : NEW_LINE INDENT e = list1 [ k ] ; NEW_LINE list1 [ k ] = list1 [ k + 1 ] ; NEW_LINE list1 [ k + 1 ] = e ; NEW_LINE cur += 1 ; NEW_LINE DEDENT t = ' ' . join ( list1 ) ; NEW_LINE pos = - 1 ; NEW_LINE for k in range ( len1 ) : NEW_LINE INDENT if ( t [ k ] != '0' ) : NEW_LINE INDENT pos = k ; NEW_LINE break ; NEW_LINE DEDENT DEDENT for k in range ( pos , 0 , - 1 ) : NEW_LINE INDENT e = list1 [ k ] ; NEW_LINE list1 [ k ] = list1 [ k + 1 ] ; NEW_LINE list1 [ k + 1 ] = e ; NEW_LINE cur += 1 ; NEW_LINE DEDENT t = ' ' . join ( list1 ) ; NEW_LINE nn = int ( t ) ; NEW_LINE if ( nn % 25 == 0 ) : NEW_LINE INDENT ans = min ( ans , cur ) ; NEW_LINE DEDENT DEDENT DEDENT if ( ans == sys . maxsize ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT n = 509201 ; NEW_LINE print ( minMoves ( n ) ) ; NEW_LINE";"Minimum number of given moves required to make N divisible by 25 | Python3 implementation of the approach ; Function to return the minimum number of moves required to make n divisible by 25 ; Convert number into string ; To store required answer ; Length of the string ; To check all possible pairs ; Make a duplicate string ; Number of swaps required to place ith digit in last position ; Number of swaps required to place jth digit in 2 nd last position ; Find first non zero digit ; Place first non zero digit in the first position ; Convert string to number ; If this number is divisible by 25 then cur is one of the possible answer ; If not possible ; Driver code"
Python;def getMaxNum ( a , b , c ) : NEW_LINE INDENT if ( b % c == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT x = ( ( b // c ) * c ) NEW_LINE if ( x >= a and x <= b ) : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT a , b , c = 2 , 10 , 3 NEW_LINE print ( getMaxNum ( a , b , c ) ) NEW_LINE;"Maximum positive integer divisible by C and is in the range [ A , B ] | Function to return the required number ; If b % c = 0 then b is the required number ; Else get the maximum multiple of c smaller than b ; Driver code"
Python;def getPairs ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE count = ( n * ( n - 1 ) ) // 2 NEW_LINE return count NEW_LINE DEDENT a = [ 2 , 4 , 3 , 1 ] NEW_LINE print ( getPairs ( a ) ) NEW_LINE;"Count of pairs ( x , y ) in an array such that x < y | Function to return the number of pairs ( x , y ) such that x < y ; Length of the array ; Calculate the number of valid pairs ; Return the count of valid pairs ; Driver code"
Python;def countSquares ( row , column ) : NEW_LINE INDENT topLeft = min ( row , column ) - 1 NEW_LINE bottomRight = 8 - max ( row , column ) NEW_LINE topRight = min ( row , 9 - column ) - 1 NEW_LINE bottomLeft = 8 - max ( row , 9 - column ) NEW_LINE return ( topLeft + topRight + bottomRight + bottomLeft ) NEW_LINE DEDENT row = 4 NEW_LINE column = 4 NEW_LINE print ( countSquares ( row , column ) ) NEW_LINE;"Count the total number of squares that can be visited by Bishop in one move | Function to return the count of total positions the Bishop can visit in a single move ; Count top left squares ; Count bottom right squares ; Count top right squares ; Count bottom left squares ; Return total count ; Bishop 's Position"
Python;"def canTakeDown ( bishopX , bishopY , pawnX , pawnY ) : NEW_LINE INDENT if ( pawnX - bishopX == pawnY - bishopY ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( - pawnX + bishopX == pawnY - bishopY ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT bishopX = 5 NEW_LINE bishopY = 5 NEW_LINE pawnX = 1 NEW_LINE pawnY = 1 NEW_LINE if ( canTakeDown ( bishopX , bishopY , pawnX , pawnY ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Check whether Bishop can take down Pawn or not | Function that return true if the Bishop can take down the pawn ; If pawn is at angle 45 or 225 degree from bishop 's Position ; If pawn is at angle 135 or 315 degree from bishop 's Position ; Bishop 's Position ; Pawn 's Position"
Python;"N = 1000005 NEW_LINE primeFactors = [ 0 ] * N ; NEW_LINE def findPrimeFactors ( ) : NEW_LINE INDENT for i in range ( 2 , N ) : NEW_LINE INDENT if ( primeFactors [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT primeFactors [ j ] = primeFactors [ j // i ] + 1 ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT primeFactors [ i ] += primeFactors [ i - 1 ] ; NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT findPrimeFactors ( ) ; NEW_LINE a = 6 ; b = 3 ; NEW_LINE print ( primeFactors [ a ] - primeFactors [ b ] ) ; NEW_LINE DEDENT";"Find maximum operations to reduce N to 1 | Python3 program to find maximum number moves possible ; To store number of prime factors of each number ; Function to find number of prime factors of each number ; if i is a prime number ; increase value by one from it 's preveious multiple ; make prefix sum this will be helpful for multiple test cases ; Driver Code ; Generate primeFactors array ; required answer"
Python;"from math import floor , pow NEW_LINE import sys NEW_LINE def digitSum ( n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT ans += n % 10 ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT return ans NEW_LINE DEDENT def findInt ( n , m ) : NEW_LINE INDENT minDigit = floor ( m / 9 ) NEW_LINE start = ( int ( pow ( 10 , minDigit ) ) - int ( pow ( 10 , minDigit ) ) % n ) NEW_LINE while ( start < sys . maxsize ) : NEW_LINE INDENT if ( digitSum ( start ) == m ) : NEW_LINE INDENT return start NEW_LINE DEDENT else : NEW_LINE INDENT start += n NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 13 NEW_LINE m = 32 NEW_LINE print ( findInt ( n , m ) ) NEW_LINE DEDENT";"Smallest integer with digit sum M and multiple of N | Python 3 implementation of the above approach ; Function to return digit sum ; Function to find out the smallest integer ; Start of the iterator ( Smallest multiple of n ) ; Driver code"
Python;from math import sqrt NEW_LINE def smallestDivisor ( n ) : NEW_LINE INDENT mx = int ( sqrt ( n ) ) NEW_LINE for i in range ( 2 , mx + 1 , 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT def maxSum ( n ) : NEW_LINE INDENT res = n NEW_LINE while ( n > 1 ) : NEW_LINE INDENT divi = smallestDivisor ( n ) NEW_LINE n = int ( n / divi ) NEW_LINE res += n NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 34 NEW_LINE print ( maxSum ( n ) ) NEW_LINE DEDENT;"Maximum sum after repeatedly dividing N by a divisor | Python 3 implementation of the above approach ; Function to find the smallest divisor ; Function to find the maximum sum ; Driver Code"
Python;"def isPossible ( n , k , arr ) : NEW_LINE INDENT sum = arr [ 0 ] NEW_LINE maxVal = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE maxVal = max ( maxVal , arr [ i ] ) NEW_LINE DEDENT if ( int ( maxVal ) > int ( ( sum + k ) / n ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 8 NEW_LINE arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE if ( isPossible ( n , k , arr ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT";"Make all elements of an array equal with the given operation | Function that returns true if all the elements of the array can be made equal with the given operation ; To store the sum of the array elements and the maximum element from the array ; Driver code"
Python;"from math import * NEW_LINE def maxResult ( n , a , b , c ) : NEW_LINE INDENT maxVal = 0 NEW_LINE for i in range ( 0 , n + 1 , a ) : NEW_LINE INDENT for j in range ( 0 , n - i + 1 , b ) : NEW_LINE INDENT z = ( n - ( i + j ) ) / c NEW_LINE if ( floor ( z ) == ceil ( z ) ) : NEW_LINE INDENT x = i // a NEW_LINE y = j // b NEW_LINE maxVal = max ( maxVal , x + y + int ( z ) ) NEW_LINE DEDENT DEDENT DEDENT return maxVal NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 10 NEW_LINE a = 5 NEW_LINE b = 3 NEW_LINE c = 4 NEW_LINE print ( maxResult ( n , a , b , c ) ) NEW_LINE DEDENT";"Maximize the value of x + y + z such that ax + by + cz = n | Python3 implementation of the approach ; Function to return the maximum value of ( x + y + z ) such that ( ax + by + cz = n ) ; i represents possible values of a * x ; j represents possible values of b * y ; If z is an integer ; Driver code ; Function Call"
Python;"def EqualNumbers ( a , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT while a [ i ] % 2 == 0 : NEW_LINE INDENT a [ i ] //= 2 NEW_LINE DEDENT while a [ i ] % 3 == 0 : NEW_LINE INDENT a [ i ] //= 3 NEW_LINE DEDENT if a [ i ] != a [ 0 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = [ 50 , 75 , 150 ] NEW_LINE n = len ( a ) NEW_LINE if EqualNumbers ( a , n ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT";"Make all numbers of an array equal | Function that returns true if all the array elements can be made equal with the given operation ; Divide number by 2 ; Divide number by 3 ; Driver code"
Python;"import math NEW_LINE def max_gcd ( n , p ) : NEW_LINE INDENT count = 0 ; NEW_LINE gcd = 1 ; NEW_LINE while ( p % 2 == 0 ) : NEW_LINE INDENT p >>= 1 ; NEW_LINE count = count + 1 ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT gcd = gcd * pow ( 2 , count // n ) ; NEW_LINE DEDENT for i in range ( 3 , ( int ) ( math . sqrt ( p ) ) , 2 ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( p % i == 0 ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE p = p // i ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT gcd = gcd * pow ( i , count // n ) ; NEW_LINE DEDENT DEDENT if ( p > 2 ) : NEW_LINE INDENT gcd = gcd * pow ( p , 1 // n ) ; NEW_LINE DEDENT return gcd ; NEW_LINE DEDENT n = 3 ; NEW_LINE p = 80 ; NEW_LINE print ( max_gcd ( n , p ) ) ; NEW_LINE";"Maximum GCD from Given Product of Unknowns | Python3 implementation of the approach ; Function to return the required gcd ; Count the number of times 2 divides p ; Equivalent to p = p / 2 ; ; If 2 divides p ; Check all the possible numbers that can divide p ; If n in the end is a prime number ; Return the required gcd ; Driver code"
Python;def getMinNum ( a , b , c ) : NEW_LINE INDENT if ( c < a or c > b ) : NEW_LINE INDENT return c NEW_LINE DEDENT x = ( ( b // c ) * c ) + c NEW_LINE return x NEW_LINE DEDENT a , b , c = 2 , 4 , 4 NEW_LINE print ( getMinNum ( a , b , c ) ) NEW_LINE;"Minimum positive integer divisible by C and is not in range [ A , B ] | Function to return the required number ; If doesn 't belong to the range  then c is the required number ; Else get the next multiple of c starting from b + 1 ; Driver code"
Python;"def countPairs ( n ) : NEW_LINE INDENT if ( n == 2 ) : NEW_LINE INDENT return 4 NEW_LINE DEDENT num = ( ( n // 2 ) + 1 ) ; NEW_LINE max = n % num ; NEW_LINE count = n - max ; NEW_LINE return count NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 5 ; NEW_LINE DEDENT print ( countPairs ( n ) ) ; NEW_LINE";"Count of pairs of ( i , j ) such that ( ( n % i ) % j ) % n is maximized | Function to return the count of required pairs ; Special case ; Number which will give the max value for ( ( n % i ) % j ) % n ; To store the maximum possible value of ( ( n % i ) % j ) % n ; Count of possible pairs ; Driver code"
Python;"import math as mt NEW_LINE def checkSub ( sub , s ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( sub [ j ] == s [ i ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT if j == int ( len ( sub ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def getMultiple ( s ) : NEW_LINE INDENT for i in range ( 0 , 10 ** 3 , 8 ) : NEW_LINE INDENT if ( checkSub ( str ( i ) , s ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT s = ""3454"" NEW_LINE print ( getMultiple ( s ) ) NEW_LINE";"Remove characters from a numeric string such that string becomes divisible by 8 | Python3 program to remove digits from a numeric string such that the number becomes divisible by 8 ; Function that return true if sub is a sub - sequence in s ; Function to return a multiple of 8 formed after removing 0 or more characters from the given string ; Iterate over all multiples of 8 ; If current multiple exists as a subsequence in the given string ; Driver Code"
Python;def getResult ( n ) : NEW_LINE INDENT st = str ( n ) NEW_LINE for i in st : NEW_LINE INDENT if ( n % int ( i ) == 0 ) : NEW_LINE INDENT return ' Yes ' NEW_LINE DEDENT DEDENT return ' No ' NEW_LINE DEDENT n = 9876543 NEW_LINE print ( getResult ( n ) ) NEW_LINE;"Program to check if a number is divisible by any of its digits | Python implementation of above approach ; Converting integer to string ; Traversing the string ; If the number is divisible by digits then return yes ; If no digits are dividing the number then return no ; Driver Code ; passing this number to get result function"
Python;def sum ( n ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 / n + ( sum ( n - 1 ) ) NEW_LINE DEDENT DEDENT print ( sum ( 8 ) ) NEW_LINE print ( sum ( 10 ) ) NEW_LINE;"Program to find sum of harmonic series | Python program to find sum of harmonic series using recursion ; Base condition ; Driven Code"
Python;import math as mt NEW_LINE def findingValues ( m , n , mth , nth ) : NEW_LINE INDENT d = ( ( abs ( mth - nth ) ) / abs ( ( m - 1 ) - ( n - 1 ) ) ) NEW_LINE a = mth - ( ( m - 1 ) * d ) NEW_LINE return a , d NEW_LINE DEDENT def findSum ( m , n , mth , nth , p ) : NEW_LINE INDENT a , d = findingValues ( m , n , mth , nth ) NEW_LINE Sum = ( p * ( 2 * a + ( p - 1 ) * d ) ) / 2 NEW_LINE return Sum NEW_LINE DEDENT m = 6 NEW_LINE n = 10 NEW_LINE mTerm = 12 NEW_LINE nTerm = 20 NEW_LINE p = 5 NEW_LINE print ( findSum ( m , n , mTerm , nTerm , p ) ) NEW_LINE;"Sum of P terms of an AP if Mth and Nth terms are given | Python3 implementation of the above approach ; Function to calculate the value of the ; Calculate value of d using formula ; Calculate value of a using formula ; Return pair ; Function to calculate value sum of first p numbers of the series ; First calculate value of a and d ; Calculate the sum by using formula ; Return the Sum ; Driver Code"
Python;"def powerfulIntegers ( x , y , bound ) : NEW_LINE INDENT s = set ( ) NEW_LINE powersOfY = [ ] NEW_LINE powersOfY . append ( 1 ) NEW_LINE i = y NEW_LINE while i < bound and y != 1 : NEW_LINE INDENT powersOfY . append ( i ) NEW_LINE i *= y NEW_LINE DEDENT i = 0 NEW_LINE while ( True ) : NEW_LINE INDENT xPowI = pow ( x , i ) NEW_LINE for j in powersOfY : NEW_LINE INDENT num = xPowI + j NEW_LINE if ( num <= bound ) : NEW_LINE INDENT s . add ( num ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( xPowI >= bound or x == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT for itr in s : NEW_LINE INDENT print ( itr , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT x = 2 NEW_LINE y = 3 NEW_LINE bound = 10 NEW_LINE powerfulIntegers ( x , y , bound ) NEW_LINE DEDENT";"Print all integers that are sum of powers of two given numbers | Function to print powerful integers ; Set is used to store distinct numbers in sorted order ; Store all the powers of y < bound in a vector to avoid calculating them again and again ; x ^ i ; If num is within limits insert it into the set ; Break out of the inner loop ; Adding any number to it will be out of bounds ; Increment i ; Print the contents of the set ; Driver code ; Print powerful integers"
Python;"import math as mt NEW_LINE def candies ( n , k ) : NEW_LINE INDENT count = 0 NEW_LINE ind = 1 NEW_LINE arr = [ 0 for i in range ( k ) ] NEW_LINE while n > 0 : NEW_LINE INDENT f1 = ( ind - 1 ) * k NEW_LINE f2 = ind * k NEW_LINE sum1 = ( f1 * ( f1 + 1 ) ) // 2 NEW_LINE sum2 = ( f2 * ( f2 + 1 ) ) // 2 NEW_LINE res = sum2 - sum1 NEW_LINE if ( res <= n ) : NEW_LINE INDENT count += 1 NEW_LINE n -= res NEW_LINE ind += 1 NEW_LINE i = 0 NEW_LINE term = ( ( ind - 1 ) * k ) + 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( term <= n ) : NEW_LINE INDENT arr [ i ] = term NEW_LINE i += 1 NEW_LINE n -= term NEW_LINE term += 1 NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = n NEW_LINE i += 1 NEW_LINE n = 0 NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( k ) : NEW_LINE INDENT arr [ i ] += ( ( count * ( i + 1 ) ) + ( k * ( count * ( count - 1 ) ) // 2 ) ) NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT n , k = 10 , 3 NEW_LINE candies ( n , k ) NEW_LINE";"Distribute N candies among K people | Python3 code for better approach to distribute candies ; Function to find out the number of candies every person received ; Count number of complete turns ; Get the last term ; Stores the number of candies ; Last term of last and current series ; Sum of current and last series ; Sum of current series only ; If sum of current is less than N ; else : Individually distribute ; First term ; Distribute candies till there ; Candies available ; Not available ; Count the total candies ; Print the total candies ; Driver Code"
Python;"def candies ( n , k ) : NEW_LINE INDENT count = 0 ; NEW_LINE ind = 1 ; NEW_LINE arr = [ 0 ] * k ; NEW_LINE low = 0 ; NEW_LINE high = n ; NEW_LINE while ( low <= high ) : NEW_LINE INDENT mid = ( low + high ) >> 1 ; NEW_LINE sum = ( mid * ( mid + 1 ) ) >> 1 ; NEW_LINE if ( sum <= n ) : NEW_LINE INDENT count = int ( mid / k ) ; NEW_LINE low = mid + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 ; NEW_LINE DEDENT DEDENT last = ( count * k ) ; NEW_LINE n -= int ( ( last * ( last + 1 ) ) / 2 ) ; NEW_LINE i = 0 ; NEW_LINE term = ( count * k ) + 1 ; NEW_LINE while ( n ) : NEW_LINE INDENT if ( term <= n ) : NEW_LINE INDENT arr [ i ] = term ; NEW_LINE i += 1 ; NEW_LINE n -= term ; NEW_LINE term += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] += n ; NEW_LINE n = 0 ; NEW_LINE DEDENT DEDENT for i in range ( k ) : NEW_LINE INDENT arr [ i ] += ( ( count * ( i + 1 ) ) + int ( k * ( count * ( count - 1 ) ) / 2 ) ) ; NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) ; NEW_LINE DEDENT DEDENT n = 7 ; NEW_LINE k = 4 ; NEW_LINE candies ( n , k ) ; NEW_LINE";"Distribute N candies among K people | Function to find out the number of candies every person received ; Count number of complete turns ; Get the last term ; Stores the number of candies ; Do a binary search to find the number whose sum is less than N . ; Get mide ; If sum is below N ; Find number of complete turns ; Right halve ; Left halve ; Last term of last complete series ; Subtract the sum till ; First term of incomplete series ; Count the total candies ; Print the total candies ; Driver Code"
Python;def printSmallest ( a , n ) : NEW_LINE INDENT sum0 , sum1 = 0 , 0 NEW_LINE a = sorted ( a ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 3 == 0 ) : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT num = ( a [ i ] * 10 ) + a [ j ] NEW_LINE if ( num % 3 == 0 ) : NEW_LINE INDENT return num NEW_LINE DEDENT DEDENT DEDENT return a [ 0 ] * 100 + a [ 0 ] * 10 + a [ 0 ] NEW_LINE DEDENT arr = [ 7 , 7 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( printSmallest ( arr , n ) ) NEW_LINE;"Smallest multiple of 3 which consists of three given non | Function to return the minimum number divisible by 3 formed by the given digits ; Sort the given array in ascending ; Check if any single digit is divisible by 3 ; Check if any two digit number formed by the given digits is divisible by 3 starting from the minimum ; Generate the two digit number ; If none of the above is true , we can form three digit number by taking a [ 0 ] three times . ; Driver code"
Python;"def updateMatrix ( n , q , mat ) : NEW_LINE INDENT for i in range ( 0 , len ( q ) ) : NEW_LINE INDENT X1 = q [ i ] [ 0 ] ; NEW_LINE Y1 = q [ i ] [ 1 ] ; NEW_LINE X2 = q [ i ] [ 2 ] ; NEW_LINE Y2 = q [ i ] [ 3 ] ; NEW_LINE mat [ X1 ] [ Y1 ] = mat [ X1 ] [ Y1 ] + 1 ; NEW_LINE if ( Y2 + 1 < n ) : NEW_LINE INDENT mat [ X2 ] [ Y2 + 1 ] = mat [ X2 ] [ Y2 + 1 ] - 1 ; NEW_LINE DEDENT elif ( X2 + 1 < n ) : NEW_LINE INDENT mat [ X2 + 1 ] [ 0 ] = mat [ X2 + 1 ] [ 0 ] - 1 ; NEW_LINE DEDENT DEDENT sum = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT sum = sum + mat [ i ] [ j ] ; NEW_LINE print ( sum , end = ' ▁ ' ) ; NEW_LINE DEDENT print ( "" ▁ "" ) ; NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE mat = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] ; NEW_LINE q = [ [ 0 , 0 , 1 , 2 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 4 , 3 , 4 ] ] ; NEW_LINE updateMatrix ( n , q , mat ) ; NEW_LINE";"Print matrix after applying increment operations in M ranges | Function to update and print the matrix after performing queries ; Add 1 to the first element of the sub - matrix ; If there is an element after the last element of the sub - matrix then decrement it by 1 ; Calculate the running sum ; Print the updated element ; Next line ; Size of the matrix ; Queries"
Python;"def printArr ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT def replaceMax ( arr , n ) : NEW_LINE INDENT max_element = max ( arr ) NEW_LINE min_element = min ( arr ) NEW_LINE ranges = max_element - min_element NEW_LINE coeffOfRange = ranges / ( max_element + min_element ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == max_element ) : NEW_LINE INDENT arr [ i ] = coeffOfRange NEW_LINE break NEW_LINE DEDENT DEDENT printArr ( arr , n ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 15 , 16 , 10 , 9 , 6 , 7 , 17 ] NEW_LINE n = len ( arr ) NEW_LINE replaceMax ( arr , n ) NEW_LINE DEDENT";"Replace the maximum element in the array by coefficient of range | Utility function to print the contents of the array ; Function to replace the maximum element from the array with the coefficient of range of the array ; Maximum element from the array ; Minimum element from the array ; Calculate the coefficient of range for the array ; Assuming all the array elements are distinct . Replace the maximum element with the coefficient of range of the array ; Print the updated array ; Driver code"
Python;"def divide ( a , b ) : NEW_LINE INDENT for i in range ( 2 , min ( a , b ) + 1 ) : NEW_LINE INDENT while ( a % i == 0 and b % i == 0 ) : NEW_LINE INDENT a = a // i NEW_LINE b = b // i NEW_LINE DEDENT DEDENT print ( "" A ▁ = "" , a , "" , ▁ B ▁ = "" , b ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A , B = 10 , 15 NEW_LINE divide ( A , B ) NEW_LINE DEDENT";"Divide the two given numbers by their common divisors | print the numbers after dividing them by their common factors ; iterate from 1 to minimum of a and b ; if i is the common factor of both the numbers ; Driver code ; divide A and B by their common factors"
Python;"def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def commDiv ( a , b ) : NEW_LINE INDENT n = gcd ( a , b ) NEW_LINE a = a // n NEW_LINE b = b // n NEW_LINE print ( "" A ▁ = "" , a , "" , ▁ B ▁ = "" , b ) NEW_LINE DEDENT a , b = 10 , 15 NEW_LINE commDiv ( a , b ) NEW_LINE";"Divide the two given numbers by their common divisors | Function to calculate gcd of two numbers ; Function to calculate all common divisors of two given numbers a , b -- > input eger numbers ; find gcd of a , b ; Driver code"
Python;"import math NEW_LINE def minAbsDiff ( n ) : NEW_LINE INDENT left = 1 << ( int ) ( math . floor ( math . log2 ( n ) ) ) NEW_LINE right = left * 2 NEW_LINE return min ( ( n - left ) , ( right - n ) ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 15 NEW_LINE print ( minAbsDiff ( n ) ) NEW_LINE DEDENT";"Minimum absolute difference between N and a power of 2 | Python3 implementation of the above approach ; Function to return the minimum difference between N and a power of 2 ; Power of 2 closest to n on its left ; Power of 2 closest to n on its right ; Return the minimum abs difference ; Driver code"
Python;"def find_probability ( p , q , r , s ) : NEW_LINE INDENT t = ( 1 - p / q ) * ( 1 - r / s ) NEW_LINE ans = ( p / q ) / ( 1 - t ) ; NEW_LINE return round ( ans , 9 ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT p , q , r , s = 1 , 2 , 1 , 2 NEW_LINE print ( find_probability ( p , q , r , s ) ) NEW_LINE DEDENT";"Find probability that a player wins when probabilities of hitting the target are given | Function to return the probability of the winner ; Driver Code ; Will print 9 digits after the decimal point"
Python;"def FindAllElements ( n , k ) : NEW_LINE INDENT sum = k NEW_LINE A = [ 1 for i in range ( k ) ] NEW_LINE i = k - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT while ( sum + A [ i ] <= n ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE A [ i ] *= 2 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT if ( sum != n ) : NEW_LINE INDENT print ( "" Impossible "" ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 0 , k , 1 ) : NEW_LINE INDENT print ( A [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE k = 6 NEW_LINE FindAllElements ( n , k ) NEW_LINE DEDENT";"Represent n as the sum of exactly k powers of two | Set 2 | Function to print k numbers which are powers of two and whose sum is equal to n ; Initialising the sum with k ; Initialising an array A with k elements and filling all elements with 1 ; Iterating A [ ] from k - 1 to 0 ; Update sum and A [ i ] till sum + A [ i ] is less than equal to n ; Impossible to find the combination ; Possible solution is stored in A [ ] ; Driver code"
Python;"def removeZero ( n ) : NEW_LINE INDENT res = 0 NEW_LINE d = 1 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 != 0 ) : NEW_LINE INDENT res += ( n % 10 ) * d NEW_LINE d *= 10 NEW_LINE DEDENT n //= 10 NEW_LINE DEDENT return res NEW_LINE DEDENT def isEqual ( a , b ) : NEW_LINE INDENT if ( removeZero ( a ) + removeZero ( b ) == removeZero ( a + b ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT a = 105 NEW_LINE b = 106 NEW_LINE if ( isEqual ( a , b ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Check whether a + b = c or not after removing all zeroes from a , b and c | Function to remove zeroes ; Initialize result to zero holds the Result after removing zeroes from no ; Initialize variable d to 1 that holds digits of no ; Loop while n is greater then zero ; Check if n mod 10 is not equal to zero ; store the result by removing zeroes And increment d by 10 ; Go to the next digit ; Return the result ; Function to check if sum is true after Removing all zeroes . ; Call removeZero ( ) for both sides and check whether they are equal After removing zeroes . ; Driver code"
Python;"def sumArray ( arr , n ) : NEW_LINE INDENT leftSum = [ 0 for i in range ( n ) ] NEW_LINE rightSum = [ 0 for i in range ( n ) ] NEW_LINE Sum = [ 0 for i in range ( n ) ] NEW_LINE i , j = 0 , 0 NEW_LINE leftSum [ 0 ] = 0 NEW_LINE rightSum [ n - 1 ] = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT leftSum [ i ] = arr [ i - 1 ] + leftSum [ i - 1 ] NEW_LINE DEDENT for j in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT rightSum [ j ] = arr [ j + 1 ] + rightSum [ j + 1 ] NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT Sum [ i ] = leftSum [ i ] + rightSum [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( Sum [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT arr = [ 3 , 6 , 4 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE sumArray ( arr , n ) NEW_LINE";"A Sum Array Puzzle | Python3 implementation of above approach ; Allocate memory for temporary arrays leftSum [ ] , rightSum [ ] and Sum [ ] ; Left most element of left array is always 0 ; Rightmost most element of right array is always 0 ; Construct the left array ; Construct the right array ; Construct the sum array using left [ ] and right [ ] ; print the constructed prod array ; Driver Code"
Python;"import sys NEW_LINE def minimumX ( n , k ) : NEW_LINE INDENT mini = sys . maxsize NEW_LINE i = 1 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT fir = i NEW_LINE sec = n // i NEW_LINE num1 = fir * k + sec NEW_LINE res = ( num1 // k ) * ( num1 % k ) NEW_LINE if ( res == n ) : NEW_LINE INDENT mini = min ( num1 , mini ) NEW_LINE DEDENT num2 = sec * k + fir NEW_LINE res = ( num2 // k ) * ( num2 % k ) NEW_LINE if ( res == n ) : NEW_LINE INDENT mini = min ( num2 , mini ) NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return mini NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 4 NEW_LINE k = 6 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE n = 5 NEW_LINE k = 5 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE DEDENT";"Find minimum x such that ( x % k ) * ( x / k ) == n | Set | Python3 program to find the minimum positive X such that the given equation holds true ; This function gives the required answer ; Iterate for all the factors ; Check if i is a factor ; Consider i to be A and n / i to be B ; Consider i to be B and n / i to be A ; Driver Code"
Python;def minimumX ( n , k ) : NEW_LINE INDENT ans = 10 ** 18 NEW_LINE for i in range ( k - 1 , 0 , - 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT ans = min ( ans , i + ( n / i ) * k ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n , k = 4 , 6 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE n , k = 5 , 5 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE;"Find minimum x such that ( x % k ) * ( x / k ) == n | This function gives the required answer ; Iterate over all possible remainders ; it must divide n ; Driver Code"
Python;"def getHermiteNumber ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ) NEW_LINE DEDENT DEDENT n = 6 NEW_LINE print ( getHermiteNumber ( n ) ) ; NEW_LINE";"Find nth Hermite number | Function to return nth Hermite number ; Base conditions ; Driver Code ; Print nth Hermite number"
Python;"def find ( n ) : NEW_LINE INDENT b = n NEW_LINE a = b * ( n - 1 ) NEW_LINE if a * b > n and a // b < n : NEW_LINE INDENT print ( "" a ▁ = ▁ { } , ▁ b ▁ = ▁ { } "" . format ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 10 NEW_LINE find ( n ) NEW_LINE DEDENT";"Find numbers a and b that satisfy the given conditions | Function to print the required numbers ; Suppose b = n and we want a % b = 0 and also ( a / b ) < n so a = b * ( n - 1 ) ; Special case if n = 1 we get a = 0 so ( a * b ) < n ; If no pair satisfies the conditions ; Driver Code"
Python;"from math import sqrt , floor NEW_LINE def isPerfect ( N ) : NEW_LINE INDENT if ( sqrt ( N ) - floor ( sqrt ( N ) ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def getClosestPerfectSquare ( N ) : NEW_LINE INDENT if ( isPerfect ( N ) ) : NEW_LINE INDENT print ( N , ""0"" ) NEW_LINE return NEW_LINE DEDENT aboveN = - 1 NEW_LINE belowN = - 1 NEW_LINE n1 = 0 NEW_LINE n1 = N + 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( isPerfect ( n1 ) ) : NEW_LINE INDENT aboveN = n1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT n1 += 1 NEW_LINE DEDENT DEDENT n1 = N - 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( isPerfect ( n1 ) ) : NEW_LINE INDENT belowN = n1 NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT n1 -= 1 NEW_LINE DEDENT DEDENT diff1 = aboveN - N NEW_LINE diff2 = N - belowN NEW_LINE if ( diff1 > diff2 ) : NEW_LINE INDENT print ( belowN , diff2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( aboveN , diff1 ) NEW_LINE DEDENT DEDENT N = 1500 NEW_LINE getClosestPerfectSquare ( N ) NEW_LINE";"Closest perfect square and its distance | Function to check if a number is perfect square or not ; Function to find the closest perfect square taking minimum steps to reach from a number ; Variables to store first perfect square number above and below N ; Finding first perfect square number greater than N ; Finding first perfect square number less than N ; Variables to store the differences ; Driver code"
Python;"def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def lowest ( den3 , num3 ) : NEW_LINE INDENT common_factor = gcd ( num3 , den3 ) NEW_LINE den3 = int ( den3 / common_factor ) NEW_LINE num3 = int ( num3 / common_factor ) NEW_LINE print ( num3 , "" / "" , den3 ) NEW_LINE DEDENT def addFraction ( num1 , den1 , num2 , den2 ) : NEW_LINE INDENT den3 = gcd ( den1 , den2 ) NEW_LINE den3 = ( den1 * den2 ) / den3 NEW_LINE num3 = ( ( num1 ) * ( den3 / den1 ) + ( num2 ) * ( den3 / den2 ) ) NEW_LINE lowest ( den3 , num3 ) NEW_LINE DEDENT num1 = 1 ; den1 = 500 NEW_LINE num2 = 2 ; den2 = 1500 NEW_LINE print ( num1 , "" / "" , den1 , "" ▁ + ▁ "" , num2 , "" / "" , den2 , "" ▁ is ▁ equal ▁ to ▁ "" , end = "" "" ) NEW_LINE addFraction ( num1 , den1 , num2 , den2 ) NEW_LINE";"Fraction | Function to return gcd of a and b ; Function to convert the obtained fraction into it 's simplest form ; Finding gcd of both terms ; Converting both terms into simpler terms by dividing them by common factor ; Function to add two fractions ; Finding gcd of den1 and den2 ; Denominator of final fraction obtained finding LCM of den1 and den2 LCM * GCD = a * b ; Changing the fractions to have same denominator Numerator of the final fraction obtained ; Calling function to convert final fraction into it 's  simplest form ; Driver Code"
Python;"import math NEW_LINE def findLargestDivisor ( n ) : NEW_LINE INDENT for i in range ( 2 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT while ( n % ( i * i ) == 0 ) : NEW_LINE INDENT n = n // i NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 12 NEW_LINE print ( findLargestDivisor ( n ) ) NEW_LINE n = 97 NEW_LINE print ( findLargestDivisor ( n ) ) NEW_LINE DEDENT";"Largest Divisor of a Number not divisible by a perfect square | Efficient Python3 Program to find the largest divisor not divisible by any perfect square greater than 1 ; Function to find the largest divisor not divisible by any perfect square greater than 1 ; If the number is divisible by i * i , then remove one i ; Now all squares are removed from n ; Driver Code"
Python;"def checkIsAP ( arr , n ) : NEW_LINE INDENT if ( n == 1 ) : return True NEW_LINE arr . sort ( ) NEW_LINE d = arr [ 1 ] - arr [ 0 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] != d ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 20 , 15 , 5 , 0 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( "" Yes "" ) if ( checkIsAP ( arr , n ) ) else print ( "" No "" ) NEW_LINE";"Arithmetic Progression | Returns true if a permutation of arr [ 0. . n - 1 ] can form arithmetic progression ; Sort array ; After sorting , difference between consecutive elements must be same . ; Driver code"
Python;"def isTriPerfect ( n ) : NEW_LINE INDENT sum = 1 + n NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n / i == i : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i + n / i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ( True if sum == 3 * n and n != 1 else False ) NEW_LINE DEDENT n = 120 NEW_LINE if isTriPerfect ( n ) : NEW_LINE INDENT print ( n , "" is ▁ a ▁ Triperfect ▁ number "" ) NEW_LINE DEDENT";"Check if a number is Triperfect Number | Returns true if n is Triperfect ; To store sum of divisors . Adding 1 and n since they are divisors of n . ; Find all divisors and add them ; If sum of divisors is equal to 3 * n , then n is a Triperfect number ; Driver program"
Python;from math import ceil , floor NEW_LINE def sum ( N , X , Y ) : NEW_LINE INDENT S1 = floor ( floor ( N / X ) * floor ( 2 * X + floor ( N / X - 1 ) * X ) / 2 ) NEW_LINE S2 = floor ( floor ( N / Y ) ) * floor ( 2 * Y + floor ( N / Y - 1 ) * Y ) / 2 NEW_LINE S3 = floor ( floor ( N / ( X * Y ) ) ) * floor ( 2 * ( X * Y ) + floor ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 NEW_LINE return S1 + S2 - S3 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 14 NEW_LINE X = 3 NEW_LINE Y = 5 NEW_LINE print ( int ( sum ( N , X , Y ) ) ) NEW_LINE DEDENT;"Sum of first N natural numbers which are divisible by X or Y | Python 3 program to find sum of numbers from 1 to N which are divisible by X or Y ; Function to calculate the sum of numbers divisible by X or Y ; Driver code"
Python;"def findTwoThreePrime ( l , r ) : NEW_LINE INDENT if ( l == 1 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT num = i NEW_LINE while ( num % 2 == 0 ) : NEW_LINE INDENT num //= 2 ; NEW_LINE DEDENT while ( num % 3 == 0 ) : NEW_LINE INDENT num //= 3 NEW_LINE DEDENT if ( num == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT l = 1 NEW_LINE r = 10 NEW_LINE print ( findTwoThreePrime ( l , r ) ) NEW_LINE DEDENT";"Count numbers from range whose prime factors are only 2 and 3 | Function to count the number within a range whose prime factors are only 2 and 3 ; Start with 2 so that 1 doesn 't get counted ; While num is divisible by 2 , divide it by 2 ; While num is divisible by 3 , divide it by 3 ; If num got reduced to 1 then it has only 2 and 3 as prime factors ; Driver code"
Python;"def getNumber ( s ) : NEW_LINE INDENT number_of_digits = len ( s ) ; NEW_LINE freq = [ 0 ] * 10 ; NEW_LINE for i in range ( number_of_digits ) : NEW_LINE INDENT if ( s [ i ] == '1' or s [ i ] == '2' or s [ i ] == '3' or s [ i ] == '5' or s [ i ] == '7' ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - 48 ] += 1 ; NEW_LINE DEDENT if ( s [ i ] == '4' ) : NEW_LINE INDENT freq [ 2 ] += 2 ; NEW_LINE freq [ 3 ] += 1 ; NEW_LINE DEDENT if ( s [ i ] == '6' ) : NEW_LINE INDENT freq [ 5 ] += 1 ; NEW_LINE freq [ 3 ] += 1 ; NEW_LINE DEDENT if ( s [ i ] == '8' ) : NEW_LINE INDENT freq [ 7 ] += 1 ; NEW_LINE freq [ 2 ] += 3 ; NEW_LINE DEDENT if ( s [ i ] == '9' ) : NEW_LINE INDENT freq [ 7 ] += 1 ; NEW_LINE freq [ 3 ] += 2 ; NEW_LINE freq [ 2 ] += 1 ; NEW_LINE DEDENT DEDENT t = "" "" ; NEW_LINE if ( freq [ 1 ] == number_of_digits or freq [ 0 ] == number_of_digits or ( freq [ 0 ] + freq [ 1 ] ) == number_of_digits ) : NEW_LINE INDENT return s ; NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 9 , 1 , - 1 ) : NEW_LINE INDENT ctr = freq [ i ] ; NEW_LINE while ( ctr > 0 ) : NEW_LINE INDENT t += chr ( i + 48 ) ; NEW_LINE ctr -= 1 ; NEW_LINE DEDENT DEDENT return t ; NEW_LINE DEDENT DEDENT s = ""1280"" ; NEW_LINE print ( getNumber ( s ) ) ; NEW_LINE";"Maximum number with same digit factorial product | Function to return the required number ; Count the frequency of each digit ; 4 ! can be expressed as 2 ! * 2 ! * 3 ! ; 6 ! can be expressed as 5 ! * 3 ! ; 8 ! can be expressed as 7 ! * 2 ! * 2 ! * 2 ! ; 9 ! can be expressed as 7 ! * 3 ! * 3 ! * 2 ! ; To store the required number ; If number has only either 1 and 0 as its digits ; Generate the greatest number possible ; Driver code"
Python;"def reversedigit ( num ) : NEW_LINE INDENT rev_num = 0 NEW_LINE while num > 0 : NEW_LINE INDENT rev_num = rev_num * 10 + num % 10 NEW_LINE num = num // 10 NEW_LINE DEDENT return rev_num NEW_LINE DEDENT def icanobifNumbers ( N ) : NEW_LINE INDENT first = 0 NEW_LINE second = 1 NEW_LINE if N == 1 : NEW_LINE INDENT print ( first ) NEW_LINE DEDENT elif N == 2 : NEW_LINE INDENT print ( first , second ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( first , second , end = "" ▁ "" ) NEW_LINE for i in range ( 3 , N + 1 ) : NEW_LINE INDENT x = reversedigit ( first ) NEW_LINE y = reversedigit ( second ) NEW_LINE print ( x + y , end = "" ▁ "" ) NEW_LINE temp = second NEW_LINE second = x + y NEW_LINE first = temp NEW_LINE DEDENT DEDENT DEDENT N = 12 NEW_LINE icanobifNumbers ( N ) NEW_LINE";"Program to find first N Iccanobif Numbers | Iterative function to reverse digits of num ; Function to print first N Icanobif Numbers ; Initialize first , second numbers ; Print first two numbers ; Reversing digit of previous two terms and adding them ; Driver code"
Python;"def addNDigits ( a , b , n ) : NEW_LINE INDENT num = a NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT tmp = a * 10 + i NEW_LINE if ( tmp % b == 0 ) : NEW_LINE INDENT a = tmp NEW_LINE break NEW_LINE DEDENT DEDENT if ( num == a ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for j in range ( n - 1 ) : NEW_LINE INDENT a *= 10 NEW_LINE DEDENT return a NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = 5 NEW_LINE b = 3 NEW_LINE n = 3 NEW_LINE print ( addNDigits ( a , b , n ) ) NEW_LINE DEDENT";"Add N digits to A such that it is divisible by B after each addition | Python3 implementation of the approach ; Try all digits from ( 0 to 9 ) ; Fails in the first move itself ; Add ( n - 1 ) 0 's ; Driver Code"
Python;"import math NEW_LINE def Triplets ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT x = i * i + j * j NEW_LINE y = int ( math . sqrt ( x ) ) NEW_LINE if ( y * y == x and y <= n ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 10 NEW_LINE print ( Triplets ( n ) ) NEW_LINE DEDENT";"Count number of triplets ( a , b , c ) such that a ^ 2 + b ^ 2 = c ^ 2 and 1 <= a <= b <= c <= n | Python3 program to Find number of Triplets 1 <= a <= b <= c <= n , Such that a ^ 2 + b ^ 2 = c ^ 2 ; function to ind number of Triplets 1 <= a <= b <= c <= n , Such that a ^ 2 + b ^ 2 = c ^ 2 ; to store required answer ; run nested loops for first two numbers . ; third number ; check if third number is perfect square and less than n ; Driver code ; function call"
Python;from math import floor NEW_LINE def solve ( n , base ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT remainder = n % base NEW_LINE sum = sum + remainder NEW_LINE n = int ( n / base ) NEW_LINE DEDENT return sum NEW_LINE DEDENT def SumsOfDigits ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE N = floor ( n / 2 ) NEW_LINE for base in range ( 2 , N + 1 , 1 ) : NEW_LINE INDENT sum = sum + solve ( n , base ) NEW_LINE DEDENT print ( sum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8 NEW_LINE SumsOfDigits ( n ) NEW_LINE DEDENT;"Sum of the digits of a number N written in all bases from 2 to N / 2 | Python 3 implementation of the approach ; Function to calculate the sum of the digits of n in the given base ; Sum of digits ; Digit of n in the given base ; Add the digit ; Function to calculate the sum of digits of n in bases from 2 to n / 2 ; to store digit sum in all base ; function call for multiple bases ; Driver program"
Python;import math NEW_LINE def checkPerfectcube ( n ) : NEW_LINE INDENT cube_root = n ** ( 1. / 3. ) NEW_LINE if round ( cube_root ) ** 3 == n : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def largestNonPerfectcubeNumber ( a , n ) : NEW_LINE INDENT maxi = - 1 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( checkPerfectcube ( a [ i ] ) == False ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 16 , 64 , 25 , 2 , 3 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestNonPerfectcubeNumber ( a , n ) ) NEW_LINE DEDENT;"Largest number in an array that is not a perfect cube | Python 3 program to find the largest non - perfect cube number among n numbers ; Function to check if a number is perfect cube number or not ; takes the sqrt of the number ; checks if it is a perfect cube number ; Function to find the largest non perfect cube number in the array ; stores the maximum of all perfect cube numbers ; Traverse all elements in the array ; store the maximum if current element is a non perfect cube ; Driver Code"
Python;"def checkIfPossibleRec ( x , a , b , isPossible , n ) : NEW_LINE INDENT if x > n : NEW_LINE INDENT return NEW_LINE DEDENT if isPossible [ x ] : NEW_LINE INDENT return NEW_LINE DEDENT isPossible [ x ] = True NEW_LINE checkIfPossibleRec ( x + a , a , b , isPossible , n ) NEW_LINE checkIfPossibleRec ( x + b , a , b , isPossible , n ) NEW_LINE DEDENT def checkPossible ( n , a , b ) : NEW_LINE INDENT isPossible = [ False ] * ( n + 1 ) NEW_LINE checkIfPossibleRec ( 0 , a , b , isPossible , n ) NEW_LINE return isPossible [ n ] NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a , b , n = 3 , 7 , 8 NEW_LINE if checkPossible ( a , b , n ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT";"Check if N can be represented as sum of integers chosen from set { A , B } | Function to find if number N can be represented as sum of a ' s ▁ and ▁ b ' s ; base condition ; If x is already visited ; Set x as possible ; Recursive call ; Driver Code"
Python;"def sumOdd ( n ) : NEW_LINE INDENT terms = ( n + 1 ) // 2 NEW_LINE sum1 = terms * terms NEW_LINE return sum1 NEW_LINE DEDENT def suminRange ( l , r ) : NEW_LINE INDENT return sumOdd ( r ) - sumOdd ( l - 1 ) NEW_LINE DEDENT l = 2 ; r = 5 NEW_LINE print ( "" Sum ▁ of ▁ odd ▁ natural ▁ number "" , "" from ▁ L ▁ to ▁ R ▁ is "" , suminRange ( l , r ) ) NEW_LINE";"Sum of all odd natural numbers in range L and R | Function to return the sum of all odd natural numbers ; Function to return the sum of all odd numbers in range L and R ; Driver code"
Python;"from math import gcd , sqrt NEW_LINE def sumcommDiv ( a , b ) : NEW_LINE INDENT n = gcd ( a , b ) NEW_LINE sum = 0 NEW_LINE N = int ( sqrt ( n ) ) + 1 NEW_LINE for i in range ( 1 , N , 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT sum += i NEW_LINE DEDENT else : NEW_LINE INDENT sum += ( n / i ) + i NEW_LINE DEDENT DEDENT DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 10 NEW_LINE b = 15 NEW_LINE print ( "" Sum ▁ = "" , int ( sumcommDiv ( a , b ) ) ) NEW_LINE DEDENT";"Sum of common divisors of two numbers A and B | Python 3 implementation of above approach ; Function to calculate all common divisors of two given numbers a , b -- > input integer numbers ; find gcd of a , b ; Find the sum of divisors of n . ; if ' i ' is factor of n ; check if divisors are equal ; Driver program to run the case"
Python;"def checkNumber ( N ) : NEW_LINE INDENT temp = N NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT if ( temp % 1000 == 144 ) : NEW_LINE INDENT temp /= 1000 NEW_LINE DEDENT elif ( temp % 100 == 14 ) : NEW_LINE INDENT temp /= 100 NEW_LINE DEDENT elif ( temp % 10 == 1 ) : NEW_LINE INDENT temp /= 10 NEW_LINE DEDENT else : NEW_LINE INDENT return "" YES "" NEW_LINE DEDENT DEDENT return "" NO "" NEW_LINE DEDENT N = 1414 ; NEW_LINE print ( checkNumber ( N ) ) ; NEW_LINE";"Check if a number is formed by Concatenation of 1 , 14 or 144 only | Function to check if a number is formed by Concatenation of 1 , 14 or 144 only ; check for each possible digit if given number consist other then 1 , 14 , 144 print NO else print YES ; Driver Code"
Python;def getResult ( n ) : NEW_LINE INDENT if n & 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT n = 3 NEW_LINE print ( getResult ( n ) ) NEW_LINE;"Fibonacci problem ( Value of Fib ( N ) * Fib ( N ) | Python 3 implementation of the approach ; Driver code"
Python;"from math import sqrt NEW_LINE def findAandB ( N ) : NEW_LINE INDENT val = N * N - 4.0 * N NEW_LINE if ( val < 0 ) : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE return NEW_LINE DEDENT a = ( N + sqrt ( val ) ) / 2.0 NEW_LINE b = ( N - sqrt ( val ) ) / 2.0 NEW_LINE print ( "" a ▁ = "" , ' { 0 : . 6 } ' . format ( a ) ) NEW_LINE print ( "" b ▁ = "" , ' { 0 : . 6 } ' . format ( b ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 69.0 NEW_LINE findAandB ( N ) NEW_LINE DEDENT";"Find two numbers with sum and product both same as N | Python 3 program to find a and b such that a * b = N and a + b = N ; Function to return the smallest string ; Not possible ; find a and b ; Driver Code"
Python;"def minOperations ( A , n ) : NEW_LINE INDENT if n & 1 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT zeros , consZeros , ones = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if A [ i ] : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT if ( i + 1 < n ) : NEW_LINE INDENT if A [ i ] == 0 and A [ i + 1 ] == 0 : NEW_LINE INDENT consZeros += 1 NEW_LINE DEDENT DEDENT DEDENT if A [ 0 ] == A [ n - 1 ] and A [ 0 ] == 0 : NEW_LINE INDENT consZeros += 1 NEW_LINE DEDENT if zeros == ones : NEW_LINE INDENT return consZeros NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A = [ 1 , 1 , 0 , 0 ] NEW_LINE n = len ( A ) NEW_LINE print ( minOperations ( A , n ) ) NEW_LINE DEDENT";"Find minimum operations needed to make an Array beautiful | Function to find minimum operations required to make array beautiful ; counting consecutive zeros . ; check that start and end are same ; check is zero and one are equal ; Driver code"
Python;def countdig ( m ) : NEW_LINE INDENT if ( m == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + countdig ( m // 10 ) NEW_LINE DEDENT DEDENT def countSteps ( x ) : NEW_LINE INDENT c = 0 NEW_LINE last = x NEW_LINE while ( last ) : NEW_LINE INDENT digits = countdig ( last ) NEW_LINE digits -= 1 NEW_LINE divisor = pow ( 10 , digits ) NEW_LINE first = last // divisor NEW_LINE lastnumber = first * divisor NEW_LINE skipped = ( last - lastnumber ) // first NEW_LINE skipped += 1 NEW_LINE c += skipped NEW_LINE last = last - ( first * skipped ) NEW_LINE DEDENT return c NEW_LINE DEDENT n = 14 NEW_LINE print ( countSteps ( n ) ) NEW_LINE;"Steps to reduce N to zero by subtracting its most significant digit at every step | Function to count the number of digits in a number m ; Function to count the number of steps to reach 0 ; count the total number of stesp ; iterate till we reach 0 ; count the digits in last ; decrease it by 1 ; find the number on whose division , we get the first digit ; first digit in last ; find the first number less than last where the first digit changes ; find the number of numbers with same first digit that are jumped ; count the steps ; the next number with a different first digit ; Driver code"
Python;"def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def powerGCD ( a , b , n ) : NEW_LINE INDENT e = power ( a , n , b ) NEW_LINE return gcd ( e , b ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = 5 NEW_LINE b = 4 NEW_LINE n = 2 NEW_LINE print ( powerGCD ( a , b , n ) ) NEW_LINE DEDENT";"GCD of a number raised to some power and another number | Calculates modular exponentiation , i . e . , ( x ^ y ) % p in O ( log y ) ; x = x % p Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 y = y / 2 ; Returns GCD of a ^ n and b ; Driver code"
Python;def allOddDigits ( n ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT if ( ( n % 10 ) % 2 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE DEDENT return True NEW_LINE DEDENT def largestNumber ( n ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT n -= 1 NEW_LINE DEDENT i = n NEW_LINE while ( 1 ) : NEW_LINE INDENT if ( allOddDigits ( i ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 2 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 23 NEW_LINE print ( largestNumber ( N ) ) NEW_LINE DEDENT;"Largest number not greater than N all the digits of which are odd | Function to check if all digits of a number are odd ; iterate for all digits ; if digit is even ; all digits are odd ; function to return the largest number with all digits odd ; iterate till we find a number with all digits odd ; Driver Code"
Python;"def largestNumber ( n ) : NEW_LINE INDENT s = "" "" NEW_LINE duplicate = n NEW_LINE while ( n ) : NEW_LINE INDENT s = chr ( n % 10 + 48 ) + s NEW_LINE n //= 10 NEW_LINE DEDENT index = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ( ( ord ( s [ i ] ) - ord ( '0' ) ) % 2 & 1 ) == 0 ) : NEW_LINE INDENT index = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( index == - 1 ) : NEW_LINE INDENT return duplicate NEW_LINE DEDENT num = 0 NEW_LINE for i in range ( index ) : NEW_LINE INDENT num = num * 10 + ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT num = num * 10 + ( ord ( s [ index ] ) - ord ( '0' ) - 1 ) NEW_LINE for i in range ( index + 1 , len ( s ) ) : NEW_LINE INDENT num = num * 10 + 9 NEW_LINE DEDENT return num NEW_LINE DEDENT N = 24578 NEW_LINE print ( largestNumber ( N ) ) NEW_LINE";"Largest number not greater than N all the digits of which are odd | function to return the largest number with all digits odd ; convert the number to a string for easy operations ; find first even digit ; if no even digit , then N is the answer ; till first even digit , add all odd numbers ; decrease 1 from the even digit ; add 9 in the rest of the digits ; Driver Code"
Python;"import math NEW_LINE def countNumbers ( N ) : NEW_LINE INDENT return int ( math . sqrt ( N ) ) - 1 NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 36 NEW_LINE print ( countNumbers ( N ) ) NEW_LINE DEDENT";"Count number less than N which are product of perfect squares | Python 3 program to count number less than N which are product of any two perfect squares ; Function to count number less than N which are product of any two perfect squares ; Driver Code"
Python;from math import sqrt NEW_LINE def countOrderedPairs ( N ) : NEW_LINE INDENT count_pairs = 0 NEW_LINE p = int ( sqrt ( N - 1 ) ) + 1 NEW_LINE q = int ( sqrt ( N ) ) + 2 NEW_LINE for i in range ( 1 , p , 1 ) : NEW_LINE INDENT for j in range ( i , q , 1 ) : NEW_LINE INDENT count_pairs += 1 NEW_LINE DEDENT DEDENT count_pairs *= 2 NEW_LINE count_pairs -= int ( sqrt ( N - 1 ) ) NEW_LINE return count_pairs NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE print ( countOrderedPairs ( N ) ) NEW_LINE DEDENT;"Count ordered pairs with product less than N | Python3 implementation of above approach ; Function to return count of Ordered pairs whose product are less than N ; Initialize count to 0 ; count total pairs ; multiply by 2 to get ordered_pairs ; subtract redundant pairs ( a , b ) where a == b . ; return answer ; Driver code ; function call to print required answer"
Python;"def pairwiseDifference ( arr , n ) : NEW_LINE INDENT for i in range ( n - 1 ) : NEW_LINE INDENT diff = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE print ( diff , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 4 , 10 , 15 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE pairwiseDifference ( arr , n ) NEW_LINE DEDENT";"Absolute Difference of all pairwise consecutive elements in an array | Function to print pairwise absolute difference of consecutive elements ; absolute difference between consecutive numbers ; Driver Code"
Python;"def sumAP ( n , d ) : NEW_LINE INDENT n = int ( n / d ) ; NEW_LINE return ( n ) * ( 1 + n ) * ( d / 2 ) ; NEW_LINE DEDENT def sumMultiples ( n ) : NEW_LINE INDENT n -= 1 ; NEW_LINE return ( int ( sumAP ( n , 2 ) + sumAP ( n , 5 ) - sumAP ( n , 10 ) ) ) ; NEW_LINE DEDENT n = 20 ; NEW_LINE print ( sumMultiples ( n ) ) ; NEW_LINE";"Find the sum of all multiples of 2 and 5 below N | Function to find sum of AP series ; Number of terms ; Function to find the sum of all multiples of 2 and 5 below N ; Since , we need the sum of multiples less than N ; Driver code"
Python;def markingScheme ( N , answerKey , studentAnswer ) : NEW_LINE INDENT positive = 0 NEW_LINE negative = 0 NEW_LINE notattempt = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( studentAnswer [ i ] == 0 ) : NEW_LINE INDENT notattempt += 1 NEW_LINE DEDENT elif ( answerKey [ i ] == studentAnswer [ i ] ) : NEW_LINE INDENT positive += 1 NEW_LINE DEDENT elif ( answerKey [ i ] != studentAnswer [ i ] ) : NEW_LINE INDENT negative += 1 NEW_LINE DEDENT DEDENT return ( positive * 3 ) + ( negative * - 1 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT answerKey = [ 1 , 2 , 3 , 4 , 1 ] NEW_LINE studentAnswer = [ 1 , 2 , 3 , 4 , 0 ] NEW_LINE N = 5 NEW_LINE print ( markingScheme ( N , answerKey , studentAnswer ) ) NEW_LINE DEDENT;"Find the total marks obtained according to given marking scheme | Function that calculates marks . ; for not attempt score + 0 ; for each correct answer score + 3 ; for each wrong answer score - 1 ; calculate total marks ; Driver code"
Python;import math as mt NEW_LINE MAX = 10000 NEW_LINE prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE def SieveOfErastosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE for p in range ( 2 , mt . ceil ( mt . sqrt ( MAX ) ) ) : NEW_LINE INDENT if prime [ p ] : NEW_LINE INDENT for i in range ( 2 * p , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def solve ( n ) : NEW_LINE INDENT count , num = 0 , 1 NEW_LINE prod = 1 NEW_LINE while count < n : NEW_LINE INDENT if prime [ num ] : NEW_LINE INDENT prod *= num NEW_LINE count += 1 NEW_LINE DEDENT num += 1 NEW_LINE DEDENT return prod NEW_LINE DEDENT SieveOfErastosthenes ( ) NEW_LINE n = 5 NEW_LINE print ( solve ( n ) ) NEW_LINE;"Find the Product of first N Prime Numbers | python3 implementation of above solution ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; if prime [ p ] is not changes , then it is a prime ; set all multiples of p to non - prime ; find the product of 1 st N prime numbers ; count of prime numbers ; product of prime numbers ; if the number is prime add it ; increase the count ; get to next number ; create the sieve ; find the value of 1 st n prime numbers"
Python;"def divisor ( a ) : NEW_LINE INDENT div = 1 ; NEW_LINE count = 0 ; NEW_LINE for i in range ( 2 , int ( pow ( a , 1 / 2 ) ) + 1 ) : NEW_LINE INDENT while ( a % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE a = a / i ; NEW_LINE DEDENT div = div * ( count + 1 ) ; NEW_LINE count = 0 ; NEW_LINE DEDENT if ( a > 1 ) : NEW_LINE INDENT div = div * ( 2 ) ; NEW_LINE DEDENT return div ; NEW_LINE DEDENT def OddDivCount ( a , b ) : NEW_LINE INDENT res = 0 ; NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT divCount = divisor ( i ) ; NEW_LINE if ( divCount % 2 ) : NEW_LINE INDENT res += 1 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a , b = 1 , 10 ; NEW_LINE print ( OddDivCount ( a , b ) ) ; NEW_LINE DEDENT";"Program to find count of numbers having odd number of divisors in given range | Function to return the count of divisors of a number ; Count the powers of the current prime i which divides a ; Update the count of divisors ; Reset the count ; If the remaining a is prime then a ^ 1 will be one of its prime factors ; Function to count numbers having odd number of divisors in range [ A , B ] ; To store the count of elements having odd number of divisors ; Iterate from a to b and find the count of their divisors ; To store the count of divisors of i ; If the divisor count of i is odd ; Driver code"
Python;"def Check_is_possible ( l , r , k ) : NEW_LINE INDENT div_count = ( r // k ) - ( l // k ) NEW_LINE if l % k == 0 : NEW_LINE INDENT div_count += 1 NEW_LINE DEDENT return div_count > 1 NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT l , r , k = 30 , 70 , 10 NEW_LINE if Check_is_possible ( l , r , k ) == True : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT DEDENT";"Check if there is any pair in a given range with GCD is divisible by k | Returns count of numbers in [ l r ] that are divisible by k . ; Add 1 explicitly as l is divisible by k ; l is not divisible by k ; Driver Code"
Python;def nth_group ( n ) : NEW_LINE INDENT return n * ( 2 * pow ( n , 2 ) + 1 ) NEW_LINE DEDENT N = 5 NEW_LINE print ( nth_group ( N ) ) NEW_LINE;"Find sum of N | calculate sum of Nth group ; Driver code"
Python;"def printPossible ( a , b , c ) : NEW_LINE INDENT if ( ( a + b + c ) % 2 != 0 or a + b < c ) : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = 2 NEW_LINE b = 4 NEW_LINE c = 2 NEW_LINE printPossible ( a , b , c ) NEW_LINE DEDENT";"Find if a molecule can be formed from 3 atoms using their valence numbers | Function to check if it is possible ; Driver code"
Python;"from math import sqrt , pow NEW_LINE def isPerfectPower ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT for x in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT y = 2 NEW_LINE p = pow ( x , y ) NEW_LINE while p <= n and p > 0 : NEW_LINE INDENT if p == n : NEW_LINE INDENT return True NEW_LINE DEDENT y += 1 NEW_LINE p = pow ( x , y ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def isStrongNumber ( n ) : NEW_LINE INDENT count = { i : 0 for i in range ( n ) } NEW_LINE while n % 2 == 0 : NEW_LINE INDENT n = n // 2 NEW_LINE count [ 2 ] += 1 NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while n % i == 0 : NEW_LINE INDENT n = n // i NEW_LINE count [ i ] += 1 NEW_LINE DEDENT DEDENT if n > 2 : NEW_LINE INDENT count [ n ] += 1 NEW_LINE DEDENT flag = 0 NEW_LINE for key , value in count . items ( ) : NEW_LINE INDENT if value == 1 : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 1 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def isTrojan ( n ) : NEW_LINE INDENT return isPerfectPower ( n ) == False and isStrongNumber ( n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 108 NEW_LINE if ( isTrojan ( n ) ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT DEDENT";"Check if a number is a Trojan Number | Python 3 program to check if a number is Trojan Number or not ; Function to check if a number can be expressed as x ^ y ; Try all numbers from 2 to sqrt ( n ) as base ; Keep increasing y while power ' p ' is smaller than n . ; Function to check if a number is Strong ; count the number for each prime factor ; minimum number of prime divisors should be 2 ; Function to check if a number is Trojan Number ; Driver Code"
Python;def Sum_upto_nth_Term ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( 2 * n + 7 ) // 3 NEW_LINE DEDENT N = 5 NEW_LINE print ( Sum_upto_nth_Term ( N ) ) NEW_LINE;"Find the sum of first N terms of the series 2 Ã — 3 + 4 Ã — 4 + 6 Ã — 5 + 8 Ã — 6 + ... | calculate sum upto N term of series ; Driver code"
Python;import sys NEW_LINE def CalculateDifference ( arr , n ) : NEW_LINE INDENT max_val = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] > max_val ) : NEW_LINE INDENT max_val = arr [ i ] NEW_LINE DEDENT DEDENT prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while ( p * p <= max_val ) : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT S1 = 0 NEW_LINE S2 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT S1 += arr [ i ] NEW_LINE DEDENT elif arr [ i ] != 1 : NEW_LINE INDENT S2 += arr [ i ] NEW_LINE DEDENT DEDENT return abs ( S2 - S1 ) NEW_LINE DEDENT arr = [ 1 , 3 , 5 , 10 , 15 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( CalculateDifference ( arr , n ) ) NEW_LINE;"Absolute Difference between the Sum of Non | Python3 program to find the Absolute Difference between the Sum of Non - Prime numbers and Prime numbers of an Array ; Function to find the difference between the sum of non - primes and the sum of primes of an array . ; Find maximum value in the array ; USE SIEVE TO FIND ALL PRIME NUMBERS LESS THAN OR EQUAL TO max_val Create a boolean array "" prime [ 0 . . n ] "" . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; Remaining part of SIEVE ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Store the sum of primes in S1 and the sum of non primes in S2 ; the number is prime ; the number is non - prime ; Return the absolute difference ; Get the array ; Find the absolute difference"
Python;"def sum ( x , n ) : NEW_LINE INDENT total = 1.0 ; NEW_LINE previous = 1.0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT previous = ( previous * x ) / ( i + 1 ) ; NEW_LINE total = total + previous ; NEW_LINE DEDENT return total ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 5 ; NEW_LINE n = 4 ; NEW_LINE print ( "" Sum ▁ is : ▁ "" , sum ( x , n ) ) ; NEW_LINE DEDENT";"Program to find sum of 1 + x / 2 ! + x ^ 2 / 3 ! + ... + x ^ n / ( n + 1 ) ! | Function to compute the series sum ; To store the value of S [ i - 1 ] ; Iterate over n to store sum in total ; Update previous with S [ i ] ; Driver code ; Get x and n ; Find and prthe sum"
Python;"def numberOfDivisors ( num ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( 1 , num + 1 ) : NEW_LINE INDENT if ( num % i == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT def countNumbers ( n ) : NEW_LINE INDENT c = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( numberOfDivisors ( i ) == 9 ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 1000 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE DEDENT";"Count number of integers less than or equal to N which has exactly 9 divisors | Function to count factors in O ( N ) ; iterate and check if factor or not ; Function to count numbers having exactly 9 divisors ; check for all numbers <= N ; check if exactly 9 factors or not ; Driver Code"
Python;"import math NEW_LINE def numberOfDistinct ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE if ( ( n // i ) != i ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 3 NEW_LINE print ( numberOfDistinct ( n ) ) NEW_LINE DEDENT";"Number of distinct integers obtained by lcm ( X , N ) / X | Python 3 program to find distinct integers ontained by lcm ( x , num ) / x ; Function to count the number of distinct integers ontained by lcm ( x , num ) / x ; iterate to count the number of factors ; Driver Code"
Python;"MAX = 1000 NEW_LINE arr = [ ] NEW_LINE def ulam ( ) : NEW_LINE INDENT arr . append ( 1 ) ; NEW_LINE arr . append ( 2 ) ; NEW_LINE for i in range ( 3 , MAX ) : NEW_LINE INDENT count = 0 ; NEW_LINE for j in range ( len ( arr ) - 1 ) : NEW_LINE INDENT for k in range ( j + 1 , len ( arr ) ) : NEW_LINE INDENT if ( arr [ j ] + arr [ k ] == i ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( count > 1 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( count > 1 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( count == 1 ) : NEW_LINE INDENT arr . append ( i ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ulam ( ) ; NEW_LINE n = 9 ; NEW_LINE print ( arr [ n - 1 ] ) NEW_LINE DEDENT";"Ulam Number Sequence | Python3 code to print nth Ulam number ; Array to store Ulam Number ; function to compute ulam Number ; push First 2 two term of the sequence in the array for further calculation ; loop to generate Ulam number ; traverse the array and check if i can be represented as sum of two distinct element of the array ; If count is 1 that means i can be represented as sum of two distinct terms of the sequence ; i is ulam number ; Driver code ; Pre compute Ulam Number sequence ; Print nth Ulam number"
Python;"def NumberOfRectangles ( n , m ) : NEW_LINE INDENT if ( n % 2 == 0 ) : NEW_LINE INDENT return ( n / 2 ) * m NEW_LINE DEDENT elif ( m % 2 == 0 ) : NEW_LINE INDENT return ( m // 2 ) * n NEW_LINE DEDENT return ( n * m - 1 ) // 2 NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 3 NEW_LINE m = 3 NEW_LINE print ( NumberOfRectangles ( n , m ) ) NEW_LINE DEDENT";"Find the number of rectangles of size 2 * 1 which can be placed inside a rectangle of size n * m | function to Find the number of rectangles of size 2 * 1 can be placed inside a rectangle of size n * m ; if n is even ; if m is even ; if both are odd ; Driver code ; function call"
Python;def findNumUtil ( res , a , aCount , b , bCount , n ) : NEW_LINE INDENT if ( res > 1e11 ) : NEW_LINE INDENT return 1e11 NEW_LINE DEDENT if ( aCount == bCount and res >= n ) : NEW_LINE INDENT return res NEW_LINE DEDENT return min ( findNumUtil ( res * 10 + a , a , aCount + 1 , b , bCount , n ) , findNumUtil ( res * 10 + b , a , aCount , b , bCount + 1 , n ) ) NEW_LINE DEDENT def findNum ( n , a , b ) : NEW_LINE INDENT result = 0 NEW_LINE aCount = 0 NEW_LINE bCount = 0 NEW_LINE return findNumUtil ( result , a , aCount , b , bCount , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4500 NEW_LINE A = 4 NEW_LINE B = 7 NEW_LINE print ( findNum ( N , A , B ) ) NEW_LINE DEDENT;"Next greater Number than N with the same quantity of digits A and B | Recursive function to find the required number ; If the resulting number is >= n and count of a = count of b , return the number ; select minimum of two and call the function again ; Function to find the number next greater Number than N with the same quantity of digits A and B ; Driver code"
Python;n , k = 7 , 3 NEW_LINE if ( n % k == 0 ) : NEW_LINE INDENT print ( n // k , n // k ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( n - n % k ) // k , ( n - n % k ) // k + 1 ) NEW_LINE DEDENT;Minimum and maximum number of N chocolates after distribution among K students | Driver code
Python;import math as ma NEW_LINE m , n , x , h = 50 , 5 , 67 , 2927 NEW_LINE z = int ( ma . ceil ( h / 60 ) ) NEW_LINE if ( z <= n ) : NEW_LINE INDENT print ( z * m ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n * m + ( z - n ) * x ) NEW_LINE DEDENT;"Total money to be paid after traveling the given number of hours | Python3 implementation of the above approach ; calculating hours travelled"
Python;def sumProductDifference ( a , b , c , d , e ) : NEW_LINE INDENT rootSum = ( - 1 * b ) / a NEW_LINE rootProduct = e / a NEW_LINE return abs ( rootSum - rootProduct ) NEW_LINE DEDENT print ( sumProductDifference ( 8 , 4 , 6 , 4 , 1 ) ) NEW_LINE;"Absolute difference between sum and product of roots of a quartic equation | Function taking coefficient of each term of equation as input ; Finding sum of roots ; Finding product of roots ; Absolute difference ; Driver Code"
Python;"def numberOfSolutions ( n ) : NEW_LINE INDENT c = 0 NEW_LINE for x in range ( n + 1 ) : NEW_LINE INDENT if ( n == ( x + ( n ^ x ) ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT return c NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 3 NEW_LINE print ( numberOfSolutions ( n ) ) NEW_LINE DEDENT";"Number of solutions of n = x + n âŠ • x | Function to find the number of solutions of n = n xor x ; Counter to store the number of solutions found ; Driver code"
Python;import math NEW_LINE def minimumLecture ( m , n ) : NEW_LINE INDENT ans = 0 NEW_LINE if ( n < math . ceil ( 0.75 * m ) ) : NEW_LINE INDENT ans = math . ceil ( ( ( 0.75 * m ) - n ) / 0.25 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 0 NEW_LINE DEDENT return ans NEW_LINE DEDENT M = 9 NEW_LINE N = 1 NEW_LINE print ( minimumLecture ( M , N ) ) NEW_LINE;"Program to find minimum number of lectures to attend to maintain 75 % | Python Program to find minimum number of lectures to attend to maintain 75 % attendance ; Function to compute minimum lecture ; Formula to compute ; Driver Code"
Python;"def countNumbers ( N ) : NEW_LINE INDENT return ( pow ( 10 , N ) - pow ( 8 , N ) ) // 2 NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 5 NEW_LINE print ( countNumbers ( n ) ) NEW_LINE DEDENT";"Count Numbers with N digits which consists of odd number of 0 's | Function to count Numbers with N digits which consists of odd number of 0 's ; Driver code"
Python;from math import sqrt NEW_LINE MAX = 10000 NEW_LINE prefix = [ 0 for i in range ( MAX + 1 ) ] NEW_LINE def buildPrefix ( ) : NEW_LINE INDENT prime = [ True for i in range ( MAX + 1 ) ] NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT prefix [ 0 ] = 0 NEW_LINE prefix [ 1 ] = 0 NEW_LINE for p in range ( 2 , MAX + 1 , 1 ) : NEW_LINE INDENT prefix [ p ] = prefix [ p - 1 ] NEW_LINE if ( prime [ p ] ) : NEW_LINE INDENT prefix [ p ] += p NEW_LINE DEDENT DEDENT DEDENT def sumPrimeRange ( L , R ) : NEW_LINE INDENT buildPrefix ( ) NEW_LINE return prefix [ R ] - prefix [ L - 1 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L = 10 NEW_LINE R = 20 NEW_LINE print ( sumPrimeRange ( L , R ) ) NEW_LINE DEDENT;"Sum of all Primes in a given range using Sieve of Eratosthenes | Python 3 program to find sum of primes in range L to R ; prefix [ i ] is going to store sum of primes till i ( including i ) . ; Function to build the prefix sum array ; Create a boolean array "" prime [ 0 . . n ] "" . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Build prefix array ; Function to return sum of prime in range ; Driver code"
Python;"def calculateSum ( n ) : NEW_LINE INDENT return ( 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) // 6 ) + n * ( n + 1 ) // 2 + 2 * ( n ) ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 3 NEW_LINE print ( "" Sum ▁ = "" , calculateSum ( n ) ) NEW_LINE DEDENT";"Sum of the first N terms of the series 5 , 12 , 23 , 38. ... | Function to calculate the sum ; Driver code ; number of terms to be included in sum ; find the Sn"
Python;"def checkSolution ( a , b , c ) : NEW_LINE INDENT if ( ( b * b ) - ( 4 * a * c ) ) > 0 : NEW_LINE INDENT print ( ""2 ▁ solutions "" ) NEW_LINE DEDENT elif ( ( b * b ) - ( 4 * a * c ) ) == 0 : NEW_LINE INDENT print ( ""1 ▁ solution "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No ▁ solutions "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a , b , c = 2 , 5 , 2 NEW_LINE checkSolution ( a , b , c ) NEW_LINE DEDENT";"Program to find number of solutions in Quadratic Equation | function to check for solutions of equations ; If the expression is greater than 0 , then 2 solutions ; If the expression is equal 0 , then 1 solutions ; Else no solutions ; Driver code"
Python;"def Bits ( kilobytes ) : NEW_LINE INDENT Bits = kilobytes * 8192 NEW_LINE return Bits NEW_LINE DEDENT def Bytes ( kilobytes ) : NEW_LINE INDENT Bytes = kilobytes * 1024 NEW_LINE return Bytes NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT kilobytes = 1 NEW_LINE print ( kilobytes , "" Kilobytes ▁ = "" , Bytes ( kilobytes ) , "" Bytes ▁ and "" , Bits ( kilobytes ) , "" Bits "" ) NEW_LINE DEDENT";"Program to convert KiloBytes to Bytes and Bits | Function to calculates the bits ; calculates Bits 1 kilobytes ( s ) = 8192 bits ; Function to calculates the bytes ; calculates Bytes 1 KB = 1024 bytes ; Driver code"
Python;"if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 3 NEW_LINE a = [ 1 , 2 , 3 ] NEW_LINE i = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT x = sum // n NEW_LINE if ( x * n == sum ) : NEW_LINE INDENT print ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" - 1"" ) NEW_LINE DEDENT DEDENT";"Program to find the Hidden Number | Driver Code ; Getting the size of array ; Getting the array of size n ; Solution ; Finding sum of the . array elements ; Dividing sum by size n ; Print x , if found"
Python;import math NEW_LINE def findSum ( n ) : NEW_LINE INDENT return math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT;"Find sum of the series ? 3 + ? 12 + ... ... ... upto N terms | Function to find the sum ; Apply AP formula ; number of terms"
Python;def sum ( x , y , n ) : NEW_LINE INDENT sum1 = ( ( x ** 2 ) * ( x ** ( 2 * n ) - 1 ) ) // ( x ** 2 - 1 ) NEW_LINE sum2 = ( x * y * ( x ** n * y ** n - 1 ) ) // ( x * y - 1 ) NEW_LINE return ( sum1 + sum2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 2 NEW_LINE y = 2 NEW_LINE n = 2 NEW_LINE print ( sum ( x , y , n ) ) NEW_LINE DEDENT;"Find the sum of the series x ( x + y ) + x ^ 2 ( x ^ 2 + y ^ 2 ) + x ^ 3 ( x ^ 3 + y ^ 3 ) + ... + x ^ n ( x ^ n + y ^ n ) | Function to return required sum ; sum of first series ; sum of second series ; Driver Code ; function call to print sum"
Python;"def printPair ( g , l ) : NEW_LINE INDENT print ( g , l ) NEW_LINE DEDENT g = 3 ; l = 12 ; NEW_LINE printPair ( g , l ) ; NEW_LINE";"Find any pair with given GCD and LCM | Function to print the pairs ; Driver Code"
Python;"def calculateSum ( n ) : NEW_LINE INDENT a1 = 1 ; NEW_LINE a2 = 2 ; NEW_LINE r = 2 ; NEW_LINE d = 1 ; NEW_LINE return ( ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( pow ( r , n ) - 1 ) / ( r - 1 ) ) ; NEW_LINE DEDENT n = 5 ; NEW_LINE print ( "" Sum ▁ = "" , int ( calculateSum ( n ) ) ) NEW_LINE";"Sum of first n terms of a given series 3 , 6 , 11 , ... . . | Function to calculate the sum ; starting number ; common ratio of GP ; common difference Of AP ; no . of the terms for the sum ; Find the Sn"
Python;"def repeatedSum ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 9 if ( n % 9 == 0 ) else ( n % 9 ) NEW_LINE DEDENT def repeatedProduct ( n ) : NEW_LINE INDENT prod = 1 NEW_LINE while ( n > 0 or prod > 9 ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT n = prod NEW_LINE prod = 1 NEW_LINE DEDENT prod *= n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return prod NEW_LINE DEDENT def maxSumProduct ( N ) : NEW_LINE INDENT if ( N < 10 ) : NEW_LINE INDENT return N NEW_LINE DEDENT return max ( repeatedSum ( N ) , repeatedProduct ( N ) ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 631 NEW_LINE print ( maxSumProduct ( n ) ) NEW_LINE DEDENT";"Maximum of sum and product of digits until number is reduced to a single digit | Function to sum the digits until it becomes a single digit ; Function to product the digits until it becomes a single digit ; Loop to do sum while sum is not less than or equal to 9 ; Function to find the maximum among repeated sum and repeated product ; Driver code"
Python;"digits = [ ] NEW_LINE vis = [ False for i in range ( 170 ) ] NEW_LINE dp = [ [ [ [ 0 for l in range ( 170 ) ] for k in range ( 2 ) ] for j in range ( 19 ) ] for i in range ( 19 ) ] NEW_LINE def ConvertIntoDigit ( n ) : NEW_LINE INDENT while ( n > 0 ) : NEW_LINE INDENT dig = n % 10 ; NEW_LINE digits . append ( dig ) ; NEW_LINE n //= 10 ; NEW_LINE DEDENT digits . reverse ( ) NEW_LINE DEDENT def solve ( idx , k , tight , sum ) : NEW_LINE INDENT if ( idx == len ( digits ) and k == 0 and sum % 2 == 1 ) : NEW_LINE INDENT if ( not vis [ sum ] ) : NEW_LINE INDENT vis [ sum ] = True ; NEW_LINE return 1 ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT if ( idx > len ( digits ) ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( dp [ idx ] [ k ] [ tight ] [ sum ] ) : NEW_LINE INDENT return dp [ idx ] [ k ] [ tight ] [ sum ] ; NEW_LINE DEDENT j = 0 ; NEW_LINE if ( idx < len ( digits ) and tight == 0 ) : NEW_LINE INDENT j = digits [ idx ] ; NEW_LINE DEDENT else : NEW_LINE INDENT j = 9 ; NEW_LINE DEDENT cnt = 0 ; NEW_LINE for i in range ( 0 if k else 1 , j + 1 ) : NEW_LINE INDENT newtight = tight ; NEW_LINE if ( i < j ) : NEW_LINE INDENT newtight = 1 ; NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT cnt += solve ( idx + 1 , k - 1 , newtight , sum ) ; NEW_LINE DEDENT else : NEW_LINE INDENT cnt += solve ( idx + 1 , k , newtight , sum + i ) ; NEW_LINE DEDENT DEDENT dp [ idx ] [ k ] [ tight ] [ sum ] = cnt NEW_LINE return cnt ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 169 NEW_LINE k = 2 ; NEW_LINE ConvertIntoDigit ( N ) ; NEW_LINE k = len ( digits ) - k ; NEW_LINE print ( solve ( 0 , k , 0 , 0 ) ) NEW_LINE DEDENT";"Count numbers with exactly K non | To store digits of N ; visited map ; DP Table ; Push all the digits of N into digits vector ; Function returns the count ; If desired number is formed whose sum is odd ; If it is not present in map , mark it as true and return 1 ; Sum is present in map already ; Desired result not found ; If that state is already calculated just return that state value ; Upper limit ; To store the count of desired numbers ; If k is non - zero , i ranges from 0 to j else [ 1 , j ] ; If current digit is 0 , decrement k and recurse sum is not changed as we are just adding 0 that makes no difference ; If i is non zero , then k remains unchanged and value is added to sum ; Memoize and return ; Driver code ; K is the number of exact non - zero elements to have in number ; break N into its digits ; We keep record of 0 s we need to place in the number"
Python;def countSubsets ( N ) : NEW_LINE INDENT if ( N <= 2 ) : NEW_LINE INDENT return N NEW_LINE DEDENT if ( N == 3 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT DP = [ 0 ] * ( N + 1 ) NEW_LINE DP [ 0 ] = 0 NEW_LINE DP [ 1 ] = 1 NEW_LINE DP [ 2 ] = 2 NEW_LINE DP [ 3 ] = 2 NEW_LINE for i in range ( 4 , N + 1 ) : NEW_LINE INDENT DP [ i ] = DP [ i - 2 ] + DP [ i - 3 ] NEW_LINE DEDENT return DP [ N ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 20 NEW_LINE print ( countSubsets ( N ) ) NEW_LINE DEDENT;"Count of subsets of integers from 1 to N having no adjacent elements | Function to count subsets ; Driver Code"
Python;"dp = [ [ - 1 for j in range ( 500 ) ] for i in range ( 500 ) ] NEW_LINE def CountSets ( x , pos ) : NEW_LINE INDENT if ( x <= 0 ) : NEW_LINE INDENT if ( pos == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if ( pos == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ x ] [ pos ] != - 1 ) : NEW_LINE INDENT return dp [ x ] [ pos ] NEW_LINE DEDENT answer = ( CountSets ( x - 1 , pos ) + CountSets ( x - 2 , pos - 1 ) ) NEW_LINE dp [ x ] [ pos ] = answer NEW_LINE return answer NEW_LINE DEDENT def CountOrderedSets ( n ) : NEW_LINE INDENT factorial = [ 0 for i in range ( 10000 ) ] NEW_LINE factorial [ 0 ] = 1 NEW_LINE for i in range ( 1 , 10000 ) : NEW_LINE INDENT factorial [ i ] = factorial [ i - 1 ] * i NEW_LINE DEDENT answer = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sets = CountSets ( n , i ) * factorial [ i ] NEW_LINE answer = answer + sets NEW_LINE DEDENT return answer NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 3 NEW_LINE print ( CountOrderedSets ( N ) ) NEW_LINE DEDENT";"Count the number of ordered sets not containing consecutive numbers | DP table ; Function to calculate the count of ordered set for a given size ; Base cases ; If subproblem has been soved before ; Store and return answer to this subproblem ; Function returns the count of all ordered sets ; Prestore the factorial value ; Iterate all ordered set sizes and find the count for each one maximum ordered set size will be smaller than N as all elements are distinct and non consecutive . ; Multiply ny size ! for all the arrangements because sets are ordered . ; Add to total answer ; Driver code"
Python;def numberOfArithmeticSequences ( L , N ) : NEW_LINE INDENT if ( N <= 2 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT count = 0 NEW_LINE res = 0 NEW_LINE for i in range ( 2 , N ) : NEW_LINE INDENT if ( ( L [ i ] - L [ i - 1 ] ) == ( L [ i - 1 ] - L [ i - 2 ] ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE DEDENT res += count NEW_LINE DEDENT return res NEW_LINE DEDENT L = [ 1 , 3 , 5 , 6 , 7 , 8 ] NEW_LINE N = len ( L ) NEW_LINE print ( numberOfArithmeticSequences ( L , N ) ) NEW_LINE;"Count the Arithmetic sequences in the Array of size at least 3 | Function to find all arithmetic sequences of size atleast 3 ; If array size is less than 3 ; Finding arithmetic subarray length ; To store all arithmetic subarray of length at least 3 ; Check if current element makes arithmetic sequence with previous two elements ; Begin with a new element for new arithmetic sequences ; Accumulate result in till i . ; Return final count ; Driver code ; Function to find arithmetic sequences"
Python;def CountOfTriplets ( a , n ) : NEW_LINE INDENT answer = 0 NEW_LINE x = 0 NEW_LINE count = [ 0 for i in range ( 100005 ) ] NEW_LINE ways = [ 0 for i in range ( 100005 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x ^= a [ i ] NEW_LINE answer += count [ x ] * i - ways [ x ] NEW_LINE count [ x ] += 1 NEW_LINE ways [ x ] += ( i + 1 ) NEW_LINE DEDENT return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Arr = [ 3 , 6 , 12 , 8 , 6 , 2 , 1 , 5 ] NEW_LINE N = len ( Arr ) NEW_LINE print ( CountOfTriplets ( Arr , N ) ) NEW_LINE DEDENT;"Count triplet of indices ( i , j , k ) such that XOR of elements between [ i , j ) equals [ j , k ] | Function return the count of triplets having subarray XOR equal ; XOR value till i ; Count and ways array as defined above ; Using the formula stated ; Increase the frequency of x ; Add i + 1 to ways [ x ] for upcoming indices ; Driver code"
Python;"def getmask ( val ) : NEW_LINE INDENT mask = 0 NEW_LINE if val == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT while ( val ) : NEW_LINE INDENT d = val % 10 ; NEW_LINE mask |= ( 1 << d ) NEW_LINE val = val // 10 NEW_LINE DEDENT return mask NEW_LINE DEDENT def countWays ( pos , mask , a , n ) : NEW_LINE INDENT if pos == n : NEW_LINE INDENT if mask > 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT if dp [ pos ] [ mask ] != - 1 : NEW_LINE INDENT return dp [ pos ] [ mask ] NEW_LINE DEDENT count = 0 NEW_LINE count = ( count + countWays ( pos + 1 , mask , a , n ) ) NEW_LINE if ( getmask ( a [ pos ] ) & mask ) == 0 : NEW_LINE INDENT new_mask = ( mask | ( getmask ( a [ pos ] ) ) ) NEW_LINE count = ( count + countWays ( pos + 1 , new_mask , a , n ) ) NEW_LINE DEDENT dp [ pos ] [ mask ] = count NEW_LINE return count NEW_LINE DEDENT def numberOfSubarrays ( a , n ) : NEW_LINE INDENT return countWays ( 0 , 0 , a , n ) NEW_LINE DEDENT dp = [ [ - 1 for i in range ( cols ) ] for j in range ( rows ) ] NEW_LINE print ( numberOfSubarrays ( A , N ) ) NEW_LINE N = 4 NEW_LINE A = [ 1 , 12 , 23 , 34 ] NEW_LINE rows = 5000 NEW_LINE cols = 1100 NEW_LINE";"Count of subarrays of an Array having all unique digits | Function to obtain the mask for any integer ; Function to count the number of ways ; Subarray must not be empty ; If subproblem has been solved ; Excluding this element in the subarray ; If there are no common digits then only this element can be included ; Calculate the new mask if this element is included ; Store and return the answer ; Function to find the count of subarray with all digits unique ; Initializing dp ; Driver Code"
Python;fib = [ ] NEW_LINE class node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( data ) : NEW_LINE INDENT temp = node ( data ) NEW_LINE return temp NEW_LINE DEDENT def height ( root ) : NEW_LINE INDENT ht = 0 NEW_LINE if ( root == None ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( max ( height ( root . left ) , height ( root . right ) ) + 1 ) NEW_LINE DEDENT def FibonacciSeries ( n ) : NEW_LINE INDENT fib . append ( 0 ) NEW_LINE fib . append ( 1 ) NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT fib . append ( fib [ i - 1 ] + fib [ i - 2 ] ) NEW_LINE DEDENT DEDENT def CountPathUtil ( root , i , count ) : NEW_LINE INDENT if ( root == None or not ( fib [ i ] == root . data ) ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( not root . left and not root . right ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT count = CountPathUtil ( root . left , i + 1 , count ) NEW_LINE return CountPathUtil ( root . right , i + 1 , count ) NEW_LINE DEDENT def CountPath ( root ) : NEW_LINE INDENT ht = height ( root ) NEW_LINE FibonacciSeries ( ht ) NEW_LINE print ( CountPathUtil ( root , 0 , 0 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 0 ) NEW_LINE root . left = newNode ( 1 ) NEW_LINE root . right = newNode ( 1 ) NEW_LINE root . left . left = newNode ( 1 ) NEW_LINE root . left . right = newNode ( 4 ) NEW_LINE root . right . right = newNode ( 1 ) NEW_LINE root . right . right . left = newNode ( 2 ) NEW_LINE CountPath ( root ) NEW_LINE DEDENT;"Count of Fibonacci paths in a Binary tree | Vector to store the fibonacci series ; Binary Tree Node ; Function to create a new tree node ; Function to find the height of the given tree ; Function to make fibonacci series upto n terms ; Preorder Utility function to count exponent path in a given Binary tree ; Base Condition , when node pointer becomes null or node value is not a number of pow ( x , y ) ; Increment count when encounter leaf node ; Left recursive call save the value of count ; Right recursive call and return value of count ; Function to find whether fibonacci path exists or not ; To find the height ; Making fibonacci series upto ht terms ; Driver code ; Create binary tree ; Function Call"
Python;M = 18 NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE dp = [ [ [ [ - 1 for i in range ( 2 ) ] for j in range ( 90 ) ] for k in range ( 90 ) ] for l in range ( M ) ] NEW_LINE fib = set ( ) NEW_LINE def fibonacci ( ) : NEW_LINE INDENT prev = 0 NEW_LINE curr = 1 NEW_LINE fib . add ( prev ) NEW_LINE fib . add ( curr ) NEW_LINE while ( curr <= 100 ) : NEW_LINE INDENT temp = curr + prev NEW_LINE fib . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def count ( pos , even , odd , tight , num ) : NEW_LINE INDENT if ( pos == len ( num ) ) : NEW_LINE INDENT if ( ( len ( num ) & 1 ) ) : NEW_LINE INDENT val = odd NEW_LINE odd = even NEW_LINE even = val NEW_LINE DEDENT d = even - odd NEW_LINE if ( d in fib ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ pos ] [ even ] [ odd ] [ tight ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ even ] [ odd ] [ tight ] NEW_LINE DEDENT ans = 0 NEW_LINE if ( tight == 1 ) : NEW_LINE INDENT limit = 9 NEW_LINE DEDENT else : NEW_LINE INDENT limit = num [ pos ] NEW_LINE DEDENT for d in range ( limit ) : NEW_LINE INDENT currF = tight NEW_LINE currEven = even NEW_LINE currOdd = odd NEW_LINE if ( d < num [ pos ] ) : NEW_LINE INDENT currF = 1 NEW_LINE DEDENT if ( pos & 1 ) : NEW_LINE INDENT currOdd += d NEW_LINE DEDENT else : NEW_LINE INDENT currEven += d NEW_LINE DEDENT ans += count ( pos + 1 , currEven , currOdd , currF , num ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def solve ( x ) : NEW_LINE INDENT num = [ ] NEW_LINE while ( x > 0 ) : NEW_LINE INDENT num . append ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT num = num [ : : - 1 ] NEW_LINE return count ( 0 , 0 , 0 , 0 , num ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT fibonacci ( ) NEW_LINE L = 1 NEW_LINE R = 50 NEW_LINE print ( solve ( R ) - solve ( L - 1 ) + 1 ) NEW_LINE L = 50 NEW_LINE R = 100 NEW_LINE print ( solve ( R ) - solve ( L - 1 ) + 2 ) NEW_LINE DEDENT;"Numbers with a Fibonacci difference between Sum of digits at even and odd positions in a given range | Python3 program to count the numbers in the range having the difference between the sum of digits at even and odd positions as a Fibonacci Number ; To store all the Fibonacci numbers ; Function to generate Fibonacci numbers upto 100 ; Adding the first two Fibonacci numbers in the set ; Computing the remaining Fibonacci numbers using the first two Fibonacci numbers ; Function to return the count of required numbers from 0 to num ; Base Case ; Check if the difference is equal to any fibonacci number ; If this result is already computed simply return it ; Maximum limit upto which we can place digit . If tight is 1 , means number has already become smaller so we can place any digit , otherwise num [ pos ] ; If the current position is odd add it to currOdd , otherwise to currEven ; Function to convert x into its digit vector and uses count ( ) function to return the required count ; Driver Code ; Generate fibonacci numbers"
Python;"import sys NEW_LINE def maximumOccurrence ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE freq = [ 0 ] * ( 26 ) NEW_LINE dp = [ [ 0 for i in range ( 26 ) ] for j in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT c = ( ord ( s [ i ] ) - ord ( ' a ' ) ) NEW_LINE for j in range ( 26 ) : NEW_LINE INDENT dp [ j ] += freq [ j ] NEW_LINE DEDENT freq += 1 NEW_LINE DEDENT answer = - sys . maxsize NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT answer = max ( answer , freq [ i ] ) NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT for j in range ( 26 ) : NEW_LINE INDENT answer = max ( answer , dp [ i ] [ j ] ) NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = "" xxxyy "" NEW_LINE print ( maximumOccurrence ( s ) ) NEW_LINE DEDENT";"Count maximum occurrence of subsequence in string such that indices in subsequence is in A . P . | Python3 implementation to find the maximum occurrence of the subsequence such that the indices of characters are in arithmetic progression ; Function to find the maximum occurrence of the subsequence such that the indices of characters are in arithmetic progression ; Frequency for characters ; Loop to count the occurrence of ith character before jth character in the given String ; Increase the frequency of s [ i ] or c of String ; Maximum occurrence of subsequence of length 1 in given String ; Maximum occurrence of subsequence of length 2 in given String ; Driver Code"
Python;mod = 1000000007 NEW_LINE dp = [ [ [ - 1 for i in range ( 2 ) ] for i in range ( 105 ) ] for i in range ( 1005 ) ] NEW_LINE powers = [ 0 ] * 1005 NEW_LINE powersModk = [ 0 ] * 1005 NEW_LINE def calculate ( pos , rem , z , k , n ) : NEW_LINE INDENT if ( rem == 0 and z ) : NEW_LINE INDENT if ( pos != n ) : NEW_LINE INDENT return ( powers [ n - pos - 1 ] * 9 ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if ( pos == n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ pos ] [ rem ] [ z ] != - 1 ) : NEW_LINE INDENT return dp [ pos ] [ rem ] [ z ] NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT count = ( count + ( calculate ( pos + 1 , ( rem + ( i * powersModk [ pos ] ) % k ) % k , z , k , n ) ) ) % mod NEW_LINE DEDENT else : NEW_LINE INDENT count = ( count + ( calculate ( pos + 1 , ( rem + ( i * powersModk [ pos ] ) % k ) % k , 1 , k , n ) ) ) % mod NEW_LINE DEDENT DEDENT dp [ pos ] [ rem ] [ z ] = count NEW_LINE return count NEW_LINE DEDENT def countNumbers ( n , k ) : NEW_LINE INDENT st = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT powers [ i ] = st NEW_LINE st *= 10 NEW_LINE st %= mod NEW_LINE DEDENT st = 1 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT powersModk [ i ] = st NEW_LINE st *= 10 NEW_LINE st %= mod NEW_LINE DEDENT return calculate ( 0 , 0 , 0 , k , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 2 NEW_LINE K = 2 NEW_LINE print ( countNumbers ( N , K ) ) NEW_LINE DEDENT;"Count the numbers with N digits and whose suffix is divisible by K | Python3 implementation to Count the numbers with N digits and whose suffix is divisible by K ; Suffix of length pos with remainder rem and Z representing whether the suffix has a non zero digit until now ; Base case ; If count of digits is less than n ; Placing all possible digits in remaining positions ; If remainder non zero and suffix has n digits ; If the subproblem is already solved ; Placing all digits at MSB of suffix and increasing it 's length by 1 ; Non zero digit is placed ; Store and return the solution to this subproblem ; Function to Count the numbers with N digits and whose suffix is divisible by K ; Since we need powers of 10 for counting , it 's better to  pre store them along with their  modulo with 1e9 + 7 for counting ; Since at each recursive step we increase the suffix length by 1 by placing digits at its leftmost position , we need powers of 10 modded with k , in order to fpos the new remainder efficiently ; Initialising dp table values - 1 represents subproblem hasn 't  been solved yet  memset(dp, -1, sizeof(dp)) ; Driver Code"
Python;inf = 100000000 NEW_LINE def smPath ( s , d , ed , n , k ) : NEW_LINE INDENT dis = [ inf ] * ( n + 1 ) NEW_LINE dis [ s ] = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT dis1 = [ inf ] * ( n + 1 ) NEW_LINE for it in ed : NEW_LINE INDENT dis1 [ it [ 1 ] ] = min ( dis1 [ it [ 1 ] ] , dis [ it [ 0 ] ] + it [ 2 ] ) NEW_LINE DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT dis [ i ] = dis1 [ i ] NEW_LINE DEDENT DEDENT if ( dis [ d ] == inf ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return dis [ d ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE ed = [ [ 0 , 1 , 10 ] , [ 0 , 2 , 3 ] , [ 0 , 3 , 2 ] , [ 1 , 3 , 7 ] , [ 2 , 3 , 7 ] ] NEW_LINE s = 0 NEW_LINE d = 3 NEW_LINE k = 2 NEW_LINE print ( smPath ( s , d , ed , n , k ) ) NEW_LINE DEDENT;"Shortest path with exactly k edges in a directed and weighted graph | Set 2 | Python3 implementation of the above approach ; Function to find the smallest path with exactly K edges ; Array to store dp ; Loop to solve DP ; Initialising next state ; Recurrence relation ; Returning final answer ; Driver code ; Input edges ; Source and Destination ; Number of edges in path ; Calling the function"
Python;"import sys NEW_LINE inf = sys . maxsize ; NEW_LINE def bellman ( s , d , ed , n ) : NEW_LINE INDENT if ( s == d ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT dis = [ 0 ] * ( n + 1 ) ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT dis [ i ] = inf ; NEW_LINE DEDENT dis [ s ] = 1 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for it in ed : NEW_LINE INDENT dis [ it [ 1 ] ] = min ( dis [ it [ 1 ] ] , dis [ it [ 0 ] ] * ed [ it ] ) ; NEW_LINE DEDENT DEDENT for it in ed : NEW_LINE INDENT if ( dis [ it [ 1 ] ] > dis [ it [ 0 ] ] * ed [ it ] ) : NEW_LINE INDENT return - 2 ; NEW_LINE DEDENT DEDENT if ( dis [ d ] == inf ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return dis [ d ] ; NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 3 ; NEW_LINE ed = { ( 1 , 2 ) : 0.5 , ( 1 , 3 ) : 1.9 , ( 2 , 3 ) : 3 } ; NEW_LINE s = 1 ; d = 3 ; NEW_LINE get = bellman ( s , d , ed , n ) ; NEW_LINE if ( get == - 2 ) : NEW_LINE INDENT print ( "" Cycle ▁ Detected "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( get ) ; NEW_LINE DEDENT DEDENT";"Path with smallest product of edges with weight > 0 | Python3 implementation of the approach . ; Function to return the smallest product of edges ; If the source is equal to the destination ; Array to store distances ; Initialising the array ; Bellman ford algorithm ; Loop to detect cycle ; Returning final answer ; Driver code ; Input edges ; Source and Destination ; Bellman ford"
Python;"import numpy as np NEW_LINE def maxLengthSquare ( row , column , arr , k ) : NEW_LINE INDENT sum = np . zeros ( ( row + 1 , column + 1 ) ) ; NEW_LINE cur_max = 1 ; NEW_LINE max = 0 ; NEW_LINE for i in range ( 1 , row + 1 ) : NEW_LINE INDENT for j in range ( 1 , column + 1 ) : NEW_LINE INDENT sum [ i ] [ j ] = sum [ i - 1 ] [ j ] + sum [ i ] [ j - 1 ] + arr [ i - 1 ] [ j - 1 ] - sum [ i - 1 ] [ j - 1 ] ; NEW_LINE if ( i >= cur_max and j >= cur_max and sum [ i ] [ j ] - sum [ i - cur_max ] [ j ] - sum [ i ] [ j - cur_max ] + sum [ i - cur_max ] [ j - cur_max ] <= k ) : NEW_LINE INDENT max = cur_max ; NEW_LINE cur_max += 1 ; NEW_LINE DEDENT DEDENT DEDENT return max ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT row = 4 ; NEW_LINE column = 4 ; NEW_LINE matrix = [ [ 1 , 1 , 1 , 1 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] ] ; NEW_LINE k = 6 ; NEW_LINE ans = maxLengthSquare ( row , column , matrix , k ) ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT";"Find Maximum Length Of A Square Submatrix Having Sum Of Elements At | Python3 implementation of the above approach ; Function to return maximum length of square submatrix having sum of elements at - most K ; Matrix to store prefix sum ; Current maximum length ; Variable for storing maximum length of square ; Calculating prefix sum ; Checking whether there exits square with length cur_max + 1 or not ; Returning the maximum length ; Driver code"
Python;"import numpy as np NEW_LINE N = 101 ; NEW_LINE mod = int ( 1e9 ) + 7 ; NEW_LINE exactsum = np . zeros ( ( N , N , N ) ) ; NEW_LINE exactnum = np . zeros ( ( N , N , N ) ) ; NEW_LINE def getSum ( x , y , z ) : NEW_LINE INDENT ans = 0 ; NEW_LINE exactnum [ 0 ] [ 0 ] [ 0 ] = 1 ; NEW_LINE for i in range ( x + 1 ) : NEW_LINE INDENT for j in range ( y + 1 ) : NEW_LINE INDENT for k in range ( z + 1 ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i - 1 ] [ j ] [ k ] * 10 + 4 * exactnum [ i - 1 ] [ j ] [ k ] ) % mod ; NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i - 1 ] [ j ] [ k ] % mod ; NEW_LINE DEDENT if ( j > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j - 1 ] [ k ] * 10 + 5 * exactnum [ i ] [ j - 1 ] [ k ] ) % mod ; NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j - 1 ] [ k ] % mod ; NEW_LINE DEDENT if ( k > 0 ) : NEW_LINE INDENT exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j ] [ k - 1 ] * 10 + 6 * exactnum [ i ] [ j ] [ k - 1 ] ) % mod ; NEW_LINE exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j ] [ k - 1 ] % mod ; NEW_LINE DEDENT ans += exactsum [ i ] [ j ] [ k ] % mod ; NEW_LINE ans %= mod ; NEW_LINE DEDENT DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT x = 1 ; y = 1 ; z = 1 ; NEW_LINE print ( ( getSum ( x , y , z ) % mod ) ) ; NEW_LINE DEDENT";"Sum of all numbers formed having 4 atmost X times , 5 atmost Y times and 6 atmost Z times | Python3 program to find sum of all numbers formed having 4 atmost X times , 5 atmost Y times and 6 atmost Z times ; exactsum [ i ] [ j ] [ k ] stores the sum of all the numbers having exact i 4 ' s , ▁ j ▁ 5' s and k 6 's ; exactnum [ i ] [ j ] [ k ] stores numbers of numbers having exact i 4 ' s , ▁ j ▁ 5' s and k 6 's ; Utility function to calculate the sum for x 4 ' s , ▁ y ▁ 5' s and z 6 's ; Computing exactsum [ i ] [ j ] [ k ] as explained above ; Driver code"
Python;"import numpy as np NEW_LINE def findMax ( a , n ) : NEW_LINE INDENT dp = np . zeros ( ( n , 2 ) ) ; NEW_LINE dp [ 0 ] [ 0 ] = a [ 0 ] + a [ 1 ] ; NEW_LINE dp [ 0 ] [ 1 ] = a [ 0 ] * a [ 1 ] ; NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i + 1 ] ; NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] - a [ i ] + a [ i ] * a [ i + 1 ] ; NEW_LINE DEDENT print ( max ( dp [ n - 2 ] [ 0 ] , dp [ n - 2 ] [ 1 ] ) , end = "" "" ) ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 5 , - 1 , - 5 , - 3 , 2 , 9 , - 4 ] ; NEW_LINE findMax ( arr , 7 ) ; NEW_LINE DEDENT";"Maximum value obtained by performing given operations in an Array | Python3 implementation of the above approach ; A function to calculate the maximum value ; basecases ; Loop to iterate and add the max value in the dp array ; Driver Code"
Python;"import numpy as np NEW_LINE def Sum ( arr , l , r ) : NEW_LINE INDENT s = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT s += arr [ i ] ; NEW_LINE DEDENT return s ; NEW_LINE DEDENT dp = np . zeros ( ( 101 , 101 , 101 ) ) ; NEW_LINE def solve ( arr , l , r , k ) : NEW_LINE INDENT if ( r - l + 1 <= k ) : NEW_LINE INDENT return Sum ( arr , l , r ) ; NEW_LINE DEDENT if ( dp [ l ] [ r ] [ k ] ) : NEW_LINE INDENT return dp [ l ] [ r ] [ k ] ; NEW_LINE DEDENT sum_ = Sum ( arr , l , r ) ; NEW_LINE len_r = ( r - l + 1 ) - k ; NEW_LINE length = ( r - l + 1 ) ; NEW_LINE ans = 0 ; NEW_LINE for i in range ( length - len_r + 1 ) : NEW_LINE INDENT sum_sub = Sum ( arr , i + l , i + l + len_r - 1 ) ; NEW_LINE ans = max ( ans , ( sum_ - sum_sub ) + ( sum_sub - solve ( arr , i + l , i + l + len_r - 1 , k ) ) ) ; NEW_LINE DEDENT dp [ l ] [ r ] [ k ] = ans ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 10 , 15 , 20 , 9 , 2 , 5 ] ; k = 2 ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( solve ( arr , 0 , n - 1 , k ) ) ; NEW_LINE DEDENT";"Optimal strategy for a Game with modifications | Python3 implementation of the above approach ; Function to return sum of subarray from l to r ; calculate sum by a loop from l to r ; dp to store the values of sub problems ; if length of the array is less than k return the sum ; if the value is previously calculated ; else calculate the value ; select all the sub array of length len_r ; get the sum of that sub array ; check if it is the maximum or not ; store it in the table ; Driver code"
Python;"import numpy as np NEW_LINE import sys NEW_LINE MAXI = 50 NEW_LINE INT_MAX = sys . maxsize NEW_LINE dp = np . ones ( ( MAXI , MAXI , MAXI * MAXI ) ) ; NEW_LINE dp *= - 1 NEW_LINE def minDifference ( x , y , k , b , c ) : NEW_LINE INDENT if ( x >= n or y >= m ) : NEW_LINE INDENT return INT_MAX ; NEW_LINE DEDENT if ( x == n - 1 and y == m - 1 ) : NEW_LINE INDENT diff = b [ x ] [ y ] - c [ x ] [ y ] ; NEW_LINE return min ( abs ( k - diff ) , abs ( k + diff ) ) ; NEW_LINE DEDENT ans = dp [ x ] [ y ] [ k ] ; NEW_LINE if ( ans != - 1 ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT ans = INT_MAX ; NEW_LINE diff = b [ x ] [ y ] - c [ x ] [ y ] ; NEW_LINE ans = min ( ans , minDifference ( x + 1 , y , abs ( k + diff ) , b , c ) ) ; NEW_LINE ans = min ( ans , minDifference ( x , y + 1 , abs ( k + diff ) , b , c ) ) ; NEW_LINE ans = min ( ans , minDifference ( x + 1 , y , abs ( k - diff ) , b , c ) ) ; NEW_LINE ans = min ( ans , minDifference ( x , y + 1 , abs ( k - diff ) , b , c ) ) ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 2 ; m = 2 ; b = [ [ 1 , 4 ] , [ 2 , 4 ] ] ; NEW_LINE c = [ [ 3 , 2 ] , [ 3 , 1 ] ] ; NEW_LINE print ( minDifference ( 0 , 0 , 0 , b , c ) ) ; NEW_LINE DEDENT";"Find the minimum difference path from ( 0 , 0 ) to ( N | Python3 implementation of the approach ; Function to return the minimum difference path from ( 0 , 0 ) to ( N - 1 , M - 1 ) ; Terminating case ; Base case ; If it is already visited ; Recursive calls ; Return the value ; Driver code ; Function call"
Python;"def longest_subseq ( n , k , s ) : NEW_LINE INDENT dp = [ 0 ] * n NEW_LINE max_length = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT curr = ord ( s [ i ] ) - ord ( ' a ' ) NEW_LINE lower = max ( 0 , curr - k ) NEW_LINE upper = min ( 25 , curr + k ) NEW_LINE for j in range ( lower , upper + 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , max_length [ j ] + 1 ) NEW_LINE DEDENT max_length [ curr ] = max ( dp [ i ] , max_length [ curr ] ) NEW_LINE DEDENT return max ( dp ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT s = "" geeksforgeeks "" NEW_LINE n = len ( s ) NEW_LINE k = 3 NEW_LINE print ( longest_subseq ( n , k , s ) ) NEW_LINE DEDENT main ( ) NEW_LINE";"Longest subsequence having difference atmost K | Function to find the longest Special Sequence ; Creating a list with all 0 's of size  equal to the length of string ; Supporting list with all 0 's of size 26 since  the given string consists  of only lower case alphabets ; Converting the ascii value to list indices ; Determining the lower bound ; Determining the upper bound ; Filling the dp array with values ; Filling the max_length array with max length of subsequence till now ; return the max length of subsequence ; driver code"
Python;"def max_sum ( a , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 0 ; dp [ 0 ] [ 1 ] = - 999999 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] + a [ i ] , dp [ i ] [ 1 ] - a [ i ] ) ; NEW_LINE dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] - a [ i ] , dp [ i ] [ 1 ] + a [ i ] ) ; NEW_LINE DEDENT return dp [ n ] [ 0 ] ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ - 10 , 5 , - 4 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( max_sum ( a , n ) ) ; NEW_LINE DEDENT";"Maximum possible array sum after performing the given operation | Function to return the maximum possible sum after performing the given operation ; Dp vector to store the answer ; Base value ; Return the maximum sum ; Driver code"
Python;"MOD = 1000000007 ; NEW_LINE def number_of_ways ( arr , n , k ) : NEW_LINE INDENT if ( k == 1 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT dp = [ - 1 ] * ( k + 1 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ arr [ i ] ] = 0 ; NEW_LINE DEDENT dp [ 0 ] = 1 ; NEW_LINE dp [ 1 ] = 1 if ( dp [ 1 ] == - 1 ) else dp [ 1 ] ; NEW_LINE for i in range ( 2 , k + 1 ) : NEW_LINE INDENT if ( dp [ i ] == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; NEW_LINE dp [ i ] %= MOD ; NEW_LINE DEDENT return dp [ k ] ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 6 ; NEW_LINE print ( number_of_ways ( arr , n , k ) ) ; NEW_LINE DEDENT";"Find the number of ways to reach Kth step in stair case | Python3 implementation of the approach ; Function to return the number of ways to reach the kth step ; Create the dp array ; Broken steps ; Calculate the number of ways for the rest of the positions ; If it is a blocked position ; Number of ways to get to the ith step ; Return the required answer ; Driver code"
Python;import math NEW_LINE def findCount ( n ) : NEW_LINE INDENT return int ( math . log ( n , 2 ) ) + 1 NEW_LINE DEDENT N = 10 NEW_LINE print ( findCount ( N ) ) NEW_LINE;"Minimum number of coins that can generate all the values in the given range | Python3 program to find minimum number of coins ; Function to find minimum number of coins ; Driver code"
Python;"def count ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT count += n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return count NEW_LINE DEDENT def findSetBits ( n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT print ( count ( i ) , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE findSetBits ( n ) NEW_LINE DEDENT";"Calculate the number of set bits for every number from 0 to N | Python 3 implementation of the approach ; Function to find the count of set bits in all the integers from 0 to n ; Driver code"
Python;from itertools import permutations NEW_LINE def countWays ( n ) : NEW_LINE INDENT a = [ ] NEW_LINE i = 1 NEW_LINE while ( i <= n ) : NEW_LINE INDENT a . append ( i ) NEW_LINE i += 1 NEW_LINE DEDENT ways = 0 NEW_LINE INDENT flag = 1 if ( per [ 0 ] == 1 ) else 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( abs ( per [ i ] - per [ i - 1 ] ) > 2 ) : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT ways += 1 NEW_LINE DEDENT DEDENT return ways NEW_LINE for per in list ( permutations ( a ) ) : NEW_LINE DEDENT n = 6 NEW_LINE print ( countWays ( n ) ) NEW_LINE;"Count number of ways to arrange first N numbers | Python3 implementation of the approach ; Function to return the count of required arrangements ; Create a vector ; Store numbers from 1 to n ; To store the count of ways ; Initialize flag to true if first element is 1 else false ; Checking if the current permutation satisfies the given conditions ; If the current permutation is invalid then set the flag to false ; If valid arrangement ; Generate the all permutation ; Driver code"
Python;def countWays ( n ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 0 NEW_LINE dp [ 1 ] = 1 NEW_LINE dp [ 2 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 NEW_LINE DEDENT return dp [ n ] NEW_LINE DEDENT n = 6 NEW_LINE print ( countWays ( n ) ) NEW_LINE;"Count number of ways to arrange first N numbers | Function to return the count of required arrangements ; Create the dp array ; Initialize the base cases as explained above ; ( 12 ) as the only possibility ; Generate answer for greater values ; dp [ n ] contains the desired answer ; Driver code"
Python;"def NumberOfShortestPaths ( n , m ) : NEW_LINE INDENT a = [ [ 0 for i in range ( m ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT a [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( j == 0 or i == n - 1 ) : NEW_LINE INDENT a [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT a [ i ] [ j ] = a [ i ] [ j - 1 ] + a [ i + 1 ] [ j ] NEW_LINE DEDENT DEDENT i -= 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT print ( a [ i ] [ j ] , end = "" ▁ "" ) NEW_LINE DEDENT print ( "" "" , ▁ end ▁ = ▁ "" "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE m = 2 NEW_LINE NumberOfShortestPaths ( n , m ) NEW_LINE DEDENT";"Number of shortest paths to reach every cell from bottom | Function to find number of shortest paths ; Compute the grid starting from the bottom - left corner ; Print the grid ; Driver code ; Function call"
Python;def Max_Sum ( arr1 , arr2 , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = arr1 [ i ] NEW_LINE dp [ i ] [ 1 ] = arr2 [ i ] NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ 0 ] = max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] + arr1 [ i ] ) NEW_LINE dp [ i ] [ 1 ] = max ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] + arr2 [ i ] ) NEW_LINE DEDENT DEDENT return max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr1 = [ 9 , 3 , 5 , 7 , 3 ] NEW_LINE arr2 = [ 5 , 8 , 1 , 4 , 5 ] NEW_LINE n = len ( arr1 ) NEW_LINE print ( Max_Sum ( arr1 , arr2 , n ) ) NEW_LINE DEDENT;"Maximum sum combination from two arrays | Function to maximum sum combination from two arrays ; To store dp value ; For loop to calculate the value of dp ; Return the required answer ; Driver code ; Function call"
Python;' NEW_LINE def checkpossible ( mask , arr , prefix , n , k ) : NEW_LINE ' NEW_LINE INDENT dp = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT for l in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( dp [ l ] [ j - 1 ] and ( ( ( prefix [ i ] - prefix [ l ] ) & mask ) == mask ) ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT def Partition ( arr , n , k ) : NEW_LINE INDENT prefix = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + arr [ i ] NEW_LINE DEDENT LOGS = 20 NEW_LINE ans = 0 NEW_LINE for i in range ( LOGS , - 1 , - 1 ) : NEW_LINE INDENT if ( checkpossible ( ans | ( 1 << i ) , arr , prefix , n , k ) ) : NEW_LINE INDENT ans = ans | ( 1 << i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 0 , 1 , 2 , 7 , 10 , 23 , 21 , 6 , 8 , 7 , 3 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) - 1 NEW_LINE print ( Partition ( arr , n , k ) ) NEW_LINE;"Partition the array in K segments such that bitwise AND of individual segment sum is maximized | Function to check whether a k segment partition is possible such that bitwise AND is 'mask ; dp [ i ] [ j ] stores whether it is possible to partition first i elements into j segments such that all j segments are 'good ; Initialising dp ; Filling dp in bottom - up manner ; Finding a cut such that first l elements can be partitioned into j - 1 ' good ' segments and arr [ l + 1 ] + ... + arr [ i ] is a ' good ' segment ; Function to find maximum possible AND ; Array to store prefix sums ; Maximum no of bits in the possible answer ; This will store the final answer ; Constructing answer greedily selecting from the higher most bit ; Checking if array can be partitioned such that the bitwise AND is ans | ( 1 << i ) ; if possible , update the answer ; Return the final answer ; Driver code ; n = 11 , first element is zero to make array 1 based indexing . So , number of elements are 10 ; Function call"
Python;"import numpy as np NEW_LINE import sys NEW_LINE RODS = 3 NEW_LINE N = 3 NEW_LINE dp = np . zeros ( ( N + 1 , RODS + 1 , RODS + 1 ) ) ; NEW_LINE def initialize ( ) : NEW_LINE INDENT for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( 1 , RODS + 1 ) : NEW_LINE INDENT for k in range ( 1 , RODS + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = sys . maxsize ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def mincost ( idx , src , dest , costs ) : NEW_LINE INDENT if ( idx > N ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( dp [ idx ] [ src ] [ dest ] != sys . maxsize ) : NEW_LINE INDENT return dp [ idx ] [ src ] [ dest ] ; NEW_LINE DEDENT rem = 6 - ( src + dest ) ; NEW_LINE ans = sys . maxsize ; NEW_LINE case1 = costs [ src - 1 ] [ dest - 1 ] + mincost ( idx + 1 , src , rem , costs ) + mincost ( idx + 1 , rem , dest , costs ) ; NEW_LINE case2 = ( costs [ src - 1 ] [ rem - 1 ] + mincost ( idx + 1 , src , dest , costs ) + mincost ( idx + 1 , dest , src , costs ) + costs [ rem - 1 ] [ dest - 1 ] + mincost ( idx + 1 , src , dest , costs ) ) ; NEW_LINE ans = min ( case1 , case2 ) ; NEW_LINE dp [ idx ] [ src ] [ dest ] = ans ; NEW_LINE return ans ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT costs = [ [ 0 , 1 , 2 ] , [ 2 , 0 , 1 ] , [ 3 , 2 , 0 ] ] ; NEW_LINE initialize ( ) ; NEW_LINE print ( mincost ( 1 , 1 , 3 , costs ) ) ; NEW_LINE DEDENT";"Cost Based Tower of Hanoi | Python3 implementation of the approach ; Function to initialize the dp table ; Initialize with maximum value ; Function to return the minimum cost ; Base case ; If problem is already solved , return the pre - calculated answer ; Number of the auxiliary disk ; Initialize the minimum cost as Infinity ; Calculationg the cost for first case ; Calculating the cost for second case ; Minimum of both the above cases ; Store it in the dp table ; Return the minimum cost ; Driver code"
Python;C = 5 NEW_LINE R = 3 NEW_LINE INT_MAX = 10000000 NEW_LINE table = [ [ 0 for i in range ( C ) ] for j in range ( R ) ] NEW_LINE visited = [ [ 0 for i in range ( C ) ] for j in range ( R ) ] NEW_LINE def min ( p , q , r , s ) : NEW_LINE INDENT if ( p < q ) : NEW_LINE INDENT temp1 = p NEW_LINE DEDENT else : NEW_LINE INDENT temp1 = q NEW_LINE DEDENT if ( r < s ) : NEW_LINE INDENT temp2 = r NEW_LINE DEDENT else : NEW_LINE INDENT temp2 = s NEW_LINE DEDENT if ( temp1 < temp2 ) : NEW_LINE INDENT return temp1 NEW_LINE DEDENT return temp2 NEW_LINE DEDENT def Distance ( arr , i , j ) : NEW_LINE INDENT if ( i >= R or j >= C or i < 0 or j < 0 ) : NEW_LINE INDENT return INT_MAX NEW_LINE DEDENT elif ( arr [ i ] [ j ] == 0 ) : NEW_LINE INDENT table [ i ] [ j ] = INT_MAX NEW_LINE return INT_MAX NEW_LINE DEDENT elif ( arr [ i ] [ j ] == 2 ) : NEW_LINE INDENT table [ i ] [ j ] = 0 NEW_LINE return 0 NEW_LINE DEDENT elif ( visited [ i ] [ j ] ) : NEW_LINE INDENT return INT_MAX NEW_LINE DEDENT else : NEW_LINE INDENT visited [ i ] [ j ] = 1 NEW_LINE temp1 = Distance ( arr , i + 1 , j ) NEW_LINE temp2 = Distance ( arr , i - 1 , j ) NEW_LINE temp3 = Distance ( arr , i , j + 1 ) NEW_LINE temp4 = Distance ( arr , i , j - 1 ) NEW_LINE min_value = 1 + min ( temp1 , temp2 , temp3 , temp4 ) NEW_LINE if table [ i ] [ j ] > 0 and table [ i ] [ j ] < INT_MAX : NEW_LINE INDENT if min_value < table [ i ] [ j ] : NEW_LINE INDENT table [ i ] [ j ] = min_value NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT table [ i ] [ j ] = min_value NEW_LINE DEDENT visited [ i ] [ j ] = 0 NEW_LINE DEDENT return table [ i ] [ j ] NEW_LINE DEDENT def minTime ( arr ) : NEW_LINE INDENT max = 0 NEW_LINE for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == 1 ) : NEW_LINE INDENT Distance ( arr , i , j ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( R ) : NEW_LINE INDENT for j in range ( C ) : NEW_LINE INDENT if ( arr [ i ] [ j ] == 1 and table [ i ] [ j ] > max ) : NEW_LINE INDENT max = table [ i ] [ j ] NEW_LINE DEDENT DEDENT DEDENT if ( max < INT_MAX ) : NEW_LINE INDENT return max NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 2 , 1 , 0 , 2 , 1 ] , [ 0 , 0 , 1 , 2 , 1 ] , [ 1 , 0 , 0 , 2 , 1 ] ] NEW_LINE print ( minTime ( arr ) ) NEW_LINE DEDENT;"Minimum time required to rot all oranges | Dynamic Programming | Python 3 implementation of the approach ; DP table to memoize the values ; Visited array to keep track of visited nodes in order to avoid infinite loops ; Function to return the minimum of four numbers ; Function to return the minimum distance to any rotten orange from [ i , j ] ; If i , j lie outside the array ; If 0 then it can 't lead to  any path so return INT_MAX ; If 2 then we have reached our rotten oranges so return from here ; If this node is already visited then return to avoid infinite loops ; Mark the current node as visited ; Check in all four possible directions ; Take the minimum of all ; If result already exists in the table check if min_value is less than existing value ; Function to return the minimum time required to rot all the oranges ; Calculate the minimum distances to any rotten orange from all the fresh oranges ; Pick the maximum distance of fresh orange to some rotten orange ; If all oranges can be rotten ; Driver Code"
Python;"maxLen = 10 NEW_LINE dp = [ 0 ] * maxLen ; NEW_LINE visit = [ 0 ] * maxLen ; NEW_LINE def maxSum ( arr , i , n , k ) : NEW_LINE INDENT if ( i >= n ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( visit [ i ] ) : NEW_LINE INDENT return dp [ i ] ; NEW_LINE DEDENT visit [ i ] = 1 ; NEW_LINE tot = 0 ; NEW_LINE dp [ i ] = maxSum ( arr , i + 1 , n , k ) ; NEW_LINE j = i NEW_LINE while ( j < i + k and j < n ) : NEW_LINE INDENT tot += arr [ j ] ; NEW_LINE dp [ i ] = max ( dp [ i ] , tot + maxSum ( arr , j + 2 , n , k ) ) ; NEW_LINE j += 1 NEW_LINE DEDENT return dp [ i ] ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ - 1 , 2 , - 3 , 4 , 5 ] ; NEW_LINE k = 2 ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxSum ( arr , 0 , n , k ) ) ; NEW_LINE DEDENT";"Maximum sum of non | Python3 program to implement above approach ; Variable to store states of dp ; Variable to check if a given state has been solved ; Function to find the maximum sum subsequence such that no two elements are adjacent ; Base case ; To check if a state has been solved ; Variable to store prefix sum for sub - array { i , j } ; Required recurrence relation ; Returning the value ; Driver code ; Input array"
Python;"dp = [ 0 ] * 1024 ; NEW_LINE def get_binary ( u ) : NEW_LINE INDENT ans = 0 ; NEW_LINE while ( u ) : NEW_LINE INDENT rem = u % 10 ; NEW_LINE ans |= ( 1 << rem ) ; NEW_LINE u //= 10 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT def recur ( u , array , n ) : NEW_LINE INDENT if ( u == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( dp [ u ] != - 1 ) : NEW_LINE INDENT return dp [ u ] ; NEW_LINE DEDENT temp = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT mask = get_binary ( array [ i ] ) ; NEW_LINE if ( ( mask u ) == u ) : NEW_LINE INDENT dp [ u ] = max ( max ( 0 , dp [ u ^ mask ] ) + array [ i ] , dp [ u ] ) ; NEW_LINE DEDENT DEDENT return dp [ u ] ; NEW_LINE DEDENT def solve ( array , n ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < ( 1 << 10 ) ) : NEW_LINE INDENT dp [ i ] = - 1 ; NEW_LINE i += 1 NEW_LINE DEDENT ans = 0 ; NEW_LINE i = 0 NEW_LINE while ( i < ( 1 << 10 ) ) : NEW_LINE INDENT ans = max ( ans , recur ( i , array , n ) ) ; NEW_LINE i += 1 NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT array = [ 22 , 132 , 4 , 45 , 12 , 223 ] ; NEW_LINE n = len ( array ) ; NEW_LINE print ( solve ( array , n ) ) ; NEW_LINE DEDENT";"Maximum subset sum such that no two elements in set have same digit in them | Python3 implementation of above approach ; Function to create mask for every number ; Recursion for Filling DP array ; Base Condition ; Recurrence Relation ; Function to find Maximum Subset Sum ; Initialize DP array ; Iterate over all possible masks of 10 bit number ; Driver Code"
Python;"import numpy as np NEW_LINE SIZE = 3 ; NEW_LINE N = 3 ; NEW_LINE def minSum ( A , B , C , i , n , curr , dp ) : NEW_LINE INDENT if ( n <= 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( dp [ n ] [ curr ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ curr ] ; NEW_LINE DEDENT if ( curr == 0 ) : NEW_LINE INDENT dp [ n ] [ curr ] = min ( B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; NEW_LINE return dp [ n ] [ curr ] NEW_LINE DEDENT if ( curr == 1 ) : NEW_LINE INDENT dp [ n ] [ curr ] = min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; NEW_LINE return dp [ n ] [ curr ] NEW_LINE DEDENT dp [ n ] [ curr ] = min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) ) ; NEW_LINE return dp [ n ] [ curr ] NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A = [ 1 , 50 , 1 ] ; NEW_LINE B = [ 50 , 50 , 50 ] ; NEW_LINE C = [ 50 , 50 , 50 ] ; NEW_LINE dp = np . zeros ( ( SIZE , N ) ) ; NEW_LINE for i in range ( SIZE ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 ; NEW_LINE DEDENT DEDENT print ( min ( A [ 0 ] + minSum ( A , B , C , 1 , SIZE - 1 , 0 , dp ) , min ( B [ 0 ] + minSum ( A , B , C , 1 , SIZE - 1 , 1 , dp ) , C [ 0 ] + minSum ( A , B , C , 1 , SIZE - 1 , 2 , dp ) ) ) ) ; NEW_LINE DEDENT";"Minimize the sum after choosing elements from the given three arrays | Python3 implementation of the above approach ; Function to return the minimized sum ; If all the indices have been used ; If this value is pre - calculated then return its value from dp array instead of re - computing it ; If A [ i - 1 ] was chosen previously then only B [ i ] or C [ i ] can chosen now choose the one which leads to the minimum sum ; If B [ i - 1 ] was chosen previously then only A [ i ] or C [ i ] can chosen now choose the one which leads to the minimum sum ; If C [ i - 1 ] was chosen previously then only A [ i ] or B [ i ] can chosen now choose the one which leads to the minimum sum ; Driver code ; Initialize the dp [ ] [ ] array ; min ( start with A [ 0 ] , start with B [ 0 ] , start with C [ 0 ] )"
Python;"import numpy as np NEW_LINE n = 3 NEW_LINE dp = np . zeros ( ( n , n , 2 ) ) ; NEW_LINE v = np . zeros ( ( n , n , 2 ) ) ; NEW_LINE def max_three ( a , b , c ) : NEW_LINE INDENT m = a ; NEW_LINE if ( m < b ) : NEW_LINE INDENT m = b ; NEW_LINE DEDENT if ( m < c ) : NEW_LINE INDENT m = c ; NEW_LINE DEDENT return m ; NEW_LINE DEDENT def maxScore ( arr , i , j , s ) : NEW_LINE INDENT if ( i > n - 1 or i < 0 or j > n - 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( i == 0 and j == n - 1 ) : NEW_LINE INDENT return arr [ i ] [ j ] ; NEW_LINE DEDENT if ( v [ i ] [ j ] [ s ] ) : NEW_LINE INDENT return dp [ i ] [ j ] [ s ] ; NEW_LINE DEDENT v [ i ] [ j ] [ s ] = 1 ; NEW_LINE if ( not bool ( s ) ) : NEW_LINE INDENT dp [ i ] [ j ] [ s ] = arr [ i ] [ j ] + max_three ( maxScore ( arr , i + 1 , j , s ) , maxScore ( arr , i , j + 1 , s ) , maxScore ( arr , i - 1 , j , not bool ( s ) ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] [ s ] = arr [ i ] [ j ] + max ( maxScore ( arr , i - 1 , j , s ) , maxScore ( arr , i , j + 1 , s ) ) ; NEW_LINE DEDENT return dp [ i ] [ j ] [ s ] ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ [ 1 , 1 , 1 ] , [ 1 , 5 , 1 ] , [ 1 , 1 , 1 ] , ] ; NEW_LINE print ( maxScore ( arr , 0 , 0 , 0 ) ) ; NEW_LINE DEDENT";"Maximise matrix sum by following the given Path | Python3 implementation of the approach ; To store the states of the DP ; Function to return the maximum of the three integers ; Function to return the maximum score ; Base cases ; If the state has already been solved then return it ; Marking the state as solved ; Growing phase ; Shrinking phase ; Returning the solved state ; Driver code"
Python;"import numpy as np NEW_LINE def MaximumMarks ( marksarr , timearr , h , n , p ) : NEW_LINE INDENT no_of_topics = n + 1 ; NEW_LINE total_time = h + 1 ; NEW_LINE T = np . zeros ( ( no_of_topics , total_time ) ) ; NEW_LINE for i in range ( no_of_topics ) : NEW_LINE INDENT T [ i ] [ 0 ] = 0 ; NEW_LINE DEDENT for j in range ( total_time ) : NEW_LINE INDENT T [ 0 ] [ j ] = 0 ; NEW_LINE DEDENT for i in range ( 1 , no_of_topics ) : NEW_LINE INDENT for j in range ( 1 , total_time ) : NEW_LINE INDENT if ( j < timearr [ i ] ) : NEW_LINE INDENT T [ i ] [ j ] = T [ i - 1 ] [ j ] ; NEW_LINE DEDENT else : NEW_LINE INDENT T [ i ] [ j ] = max ( marksarr [ i ] + T [ i - 1 ] [ j - timearr [ i ] ] , T [ i - 1 ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT i = no_of_topics - 1 ; j = total_time - 1 ; NEW_LINE sum = 0 ; NEW_LINE while ( i > 0 and j > 0 ) : NEW_LINE INDENT if ( T [ i ] [ j ] == T [ i - 1 ] [ j ] ) : NEW_LINE INDENT i -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT sum += timearr [ i ] ; NEW_LINE j -= timearr [ i ] ; NEW_LINE i -= 1 ; NEW_LINE DEDENT DEDENT marks = T [ no_of_topics - 1 ] [ total_time - 1 ] ; NEW_LINE if ( marks < p ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 4 ; h = 10 ; p = 10 ; NEW_LINE marksarr = [ 0 , 6 , 4 , 2 , 8 ] ; NEW_LINE timearr = [ 0 , 4 , 6 , 2 , 7 ] ; NEW_LINE print ( MaximumMarks ( marksarr , timearr , h , n , p ) ) ; NEW_LINE DEDENT";"Find maximum topics to prepare in order to pass the exam | Python3 implementation of the approach ; Function to return the maximum marks by considering topics which can be completed in the given time duration ; If we are given 0 time then nothing can be done So all values are 0 ; If we are given 0 topics then the time required will be 0 for sure ; Calculating the maximum marks that can be achieved under the given time constraints ; If time taken to read that topic is more than the time left now at position j then do no read that topic ; Two cases arise : 1 ) Considering current topic 2 ) Ignoring current topic We are finding maximum of ( current topic weightage + topics which can be done in leftover time - current topic time ) and ignoring current topic weightage sum ; Moving upwards in table from bottom right to calculate the total time taken to read the topics which can be done in given time and have highest weightage sum ; It means we have not considered reading this topic for max weightage sum ; Adding the topic time ; Evaluating the left over time after considering this current topic ; One topic completed ; It contains the maximum weightage sum formed by considering the topics ; Condition when exam cannot be passed ; Return the marks that can be obtained after passing the exam ; Driver code ; Number of topics , hours left and the passing marks ; n + 1 is taken for simplicity in loops Array will be indexed starting from 1"
Python;maxLen = 10 NEW_LINE maskLen = 130 NEW_LINE dp = [ [ 0 for i in range ( maskLen ) ] for i in range ( maxLen ) ] NEW_LINE v = [ [ False for i in range ( maskLen ) ] for i in range ( maxLen ) ] NEW_LINE def minSteps ( arr , i , mask , n ) : NEW_LINE INDENT if ( i == n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i > n - 1 or i < 0 ) : NEW_LINE INDENT return 9999999 NEW_LINE DEDENT if ( ( mask >> i ) & 1 ) : NEW_LINE INDENT return 9999999 NEW_LINE DEDENT if ( v [ i ] [ mask ] == True ) : NEW_LINE INDENT return dp [ i ] [ mask ] NEW_LINE DEDENT v [ i ] [ mask ] = True NEW_LINE dp [ i ] [ mask ] = 1 + min ( minSteps ( arr , i - arr [ i ] , ( mask | ( 1 << i ) ) , n ) , minSteps ( arr , i + arr [ i ] , ( mask | ( 1 << i ) ) , n ) ) NEW_LINE return dp [ i ] [ mask ] NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 2 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE ans = minSteps ( arr , 0 , 0 , n ) NEW_LINE if ( ans >= 9999999 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT;"Minimize the number of steps required to reach the end of the array | Python3 implementation of the above approach ; variable to store states of dp ; variable to check if a given state has been solved ; Function to find the minimum number of steps required to reach the end of the array ; base case ; to check if a state has been solved ; required recurrence relation ; returning the value ; Driver code"
Python;def oSRec ( arr , i , j , Sum ) : NEW_LINE INDENT if ( j == i + 1 ) : NEW_LINE INDENT return max ( arr [ i ] , arr [ j ] ) NEW_LINE DEDENT return max ( ( Sum - oSRec ( arr , i + 1 , j , Sum - arr [ i ] ) ) , ( Sum - oSRec ( arr , i , j - 1 , Sum - arr [ j ] ) ) ) NEW_LINE DEDENT def optimalStrategyOfGame ( arr , n ) : NEW_LINE INDENT Sum = 0 NEW_LINE Sum = sum ( arr ) NEW_LINE return oSRec ( arr , 0 , n - 1 , Sum ) NEW_LINE DEDENT arr1 = [ 8 , 15 , 3 , 7 ] NEW_LINE n = len ( arr1 ) NEW_LINE print ( optimalStrategyOfGame ( arr1 , n ) ) NEW_LINE arr2 = [ 2 , 2 , 2 , 2 ] NEW_LINE n = len ( arr2 ) NEW_LINE print ( optimalStrategyOfGame ( arr2 , n ) ) NEW_LINE arr3 = [ 20 , 30 , 2 , 2 , 2 , 10 ] NEW_LINE n = len ( arr3 ) NEW_LINE print ( optimalStrategyOfGame ( arr3 , n ) ) NEW_LINE;"Optimal Strategy for a Game | Set 2 | python3 program to find out maximum value from a given sequence of coins ; For both of your choices , the opponent gives you total Sum minus maximum of his value ; Returns optimal value possible that a player can collect from an array of coins of size n . Note than n must be even ; Driver code"
Python;"def ispower ( n ) : NEW_LINE INDENT if ( n < 125 ) : NEW_LINE INDENT return ( n == 1 or n == 5 or n == 25 ) NEW_LINE DEDENT if ( n % 125 != 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ispower ( n // 125 ) NEW_LINE DEDENT DEDENT def number ( s , i , j ) : NEW_LINE INDENT ans = 0 NEW_LINE for x in range ( i , j ) : NEW_LINE INDENT ans = ans * 2 + ( ord ( s [ x ] ) - ord ( '0' ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def minCuts ( s , n ) : NEW_LINE INDENT dp = [ n + 1 for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( s [ i - 1 ] == '0' ) : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( i ) : NEW_LINE INDENT if ( s [ j ] == '0' ) : NEW_LINE INDENT continue NEW_LINE DEDENT num = number ( s , j , i ) NEW_LINE if ( not ispower ( num ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT dp [ i ] = min ( dp [ i ] , dp [ j ] + 1 ) NEW_LINE DEDENT DEDENT if dp [ n ] < n + 1 : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s = ""101101101"" NEW_LINE n = len ( s ) NEW_LINE print ( minCuts ( s , n ) ) NEW_LINE DEDENT";"Minimum number of sub | Function that returns true if n is a power of 5 ; Function to return the decimal value of binary equivalent ; Function to return the minimum cuts required ; Allocating memory for dp [ ] array ; From length 1 to n ; If previous character is '0' then ignore to avoid number with leading 0 s . ; Ignore s [ j ] = '0' starting numbers ; Number formed from s [ j ... . i ] ; Check for power of 5 ; Assigning min value to get min cut possible ; ( n + 1 ) to check if all the strings are traversed and no divisible by 5 is obtained like 000000 ; Driver code"
Python;"def MinOfCubed ( k ) : NEW_LINE INDENT if ( k < 8 ) : NEW_LINE INDENT return k ; NEW_LINE DEDENT res = k ; NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT if ( ( i * i * i ) > k ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT res = min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT num = 15 ; NEW_LINE print ( MinOfCubed ( num ) ) ; NEW_LINE";"Minimum number of cubes whose sum equals to given number N | Function to return the minimum number of cubes whose sum is k ; If k is less than the 2 ^ 3 ; Initialize with the maximum number of cubes required ; Driver code"
Python;"import sys NEW_LINE def MinOfCubedDP ( k ) : NEW_LINE INDENT DP = [ 0 ] * ( k + 1 ) ; NEW_LINE j = 1 ; NEW_LINE t = 1 ; NEW_LINE DP [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT DP [ i ] = sys . maxsize ; NEW_LINE while ( j <= i ) : NEW_LINE INDENT if ( j == i ) : NEW_LINE INDENT DP [ i ] = 1 ; NEW_LINE DEDENT elif ( DP [ i ] > DP [ i - j ] ) : NEW_LINE INDENT DP [ i ] = DP [ i - j ] + 1 ; NEW_LINE DEDENT t += 1 ; NEW_LINE j = t * t * t ; NEW_LINE DEDENT t = j = 1 ; NEW_LINE DEDENT return DP [ k ] ; NEW_LINE DEDENT num = 15 ; NEW_LINE print ( MinOfCubedDP ( num ) ) ; NEW_LINE";"Minimum number of cubes whose sum equals to given number N | Python implementation of the approach ; Function to return the minimum number of cubes whose sum is k ; While current perfect cube is less than current element ; If i is a perfect cube ; i = ( i - 1 ) + 1 ^ 3 ; Next perfect cube ; Re - initialization for next element ; Driver code"
Python;"def maxSum ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE arr = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT arr [ i ] = a [ i - 1 ] NEW_LINE DEDENT dp = [ [ 0 for i in range ( 3 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = max ( arr [ i ] , dp [ i - 1 ] [ 0 ] + arr [ i ] ) NEW_LINE dp [ i ] [ 1 ] = max ( 0 , dp [ i - 1 ] [ 0 ] ) - arr [ i ] NEW_LINE if i >= 2 : NEW_LINE INDENT dp [ i ] [ 1 ] = max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + arr [ i ] ) NEW_LINE DEDENT if i >= 2 : NEW_LINE INDENT dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - arr [ i ] NEW_LINE DEDENT if i >= 3 : NEW_LINE INDENT dp [ i ] [ 2 ] = max ( dp [ i ] [ 2 ] , dp [ i - 1 ] [ 2 ] + arr [ i ] ) NEW_LINE DEDENT ans = max ( ans , dp [ i ] [ 0 ] ) NEW_LINE ans = max ( ans , dp [ i ] [ 1 ] ) NEW_LINE ans = max ( ans , dp [ i ] [ 2 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ - 5 , 3 , 2 , 7 , - 8 , 3 , 7 , - 9 , 10 , 12 , - 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxSum ( arr , n ) ) NEW_LINE DEDENT";"Maximum Subarray Sum after inverting at most two elements | Function to return the maximum required sub - array sum ; Creating one based indexing ; 2d array to contain solution for each step ; Case 1 : Choosing current or ( current + previous ) whichever is smaller ; Case 2 : ( a ) Altering sign and add to previous case 1 or value 0 ; Case 2 : ( b ) Adding current element with previous case 2 and updating the maximum ; Case 3 : ( a ) Altering sign and add to previous case 2 ; Case 3 : ( b ) Adding current element with previous case 3 ; Updating the maximum value of variable ans ; Return the final solution ; Driver code"
Python;"def maxSum ( arr , k , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT return arr [ 0 ] ; NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT return max ( arr [ 0 ] , arr [ 1 ] ) ; NEW_LINE DEDENT dp = [ 0 ] * n ; NEW_LINE dp [ 0 ] = arr [ 0 ] ; NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT dp [ i ] = max ( arr [ i ] , dp [ i - 1 ] ) ; NEW_LINE DEDENT for i in range ( k + 1 , n ) : NEW_LINE INDENT dp [ i ] = max ( arr [ i ] , dp [ i - ( k + 1 ) ] + arr [ i ] ) ; NEW_LINE DEDENT max_element = max ( dp ) ; NEW_LINE return max_element ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 6 , 7 , 1 , 3 , 8 , 2 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE k = 2 ; NEW_LINE print ( maxSum ( arr , k , n ) ) ; NEW_LINE DEDENT";"Maximum sum possible for a sub | Function to return the maximum sum possible ; dp [ i ] represent the maximum sum so far after reaching current position i ; Initialize dp [ 0 ] ; Initialize the dp values till k since any two elements included in the sub - sequence must be atleast k indices apart , and thus first element and second element will be k indices apart ; Fill remaining positions ; Return the maximum sum ; Driver code"
Python;def MinimumCost ( a , n , x ) : NEW_LINE INDENT for i in range ( 1 , n , 1 ) : NEW_LINE INDENT a [ i ] = min ( a [ i ] , 2 * a [ i - 1 ] ) NEW_LINE DEDENT ind = 0 NEW_LINE sum = 0 NEW_LINE while ( x ) : NEW_LINE INDENT if ( x & 1 ) : NEW_LINE INDENT sum += a [ ind ] NEW_LINE DEDENT ind += 1 NEW_LINE x = x >> 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 20 , 50 , 60 , 90 ] NEW_LINE x = 7 NEW_LINE n = len ( a ) NEW_LINE print ( MinimumCost ( a , n , x ) ) NEW_LINE DEDENT;"Minimum cost to form a number X by adding up powers of 2 | Function to return the minimum cost ; Re - compute the array ; Add answers for set bits ; If bit is set ; Increase the counter ; Right shift the number ; Driver code"
Python;def countWays ( n , l , r ) : NEW_LINE INDENT tL , tR = l , r NEW_LINE L = [ 0 for i in range ( 2 ) ] NEW_LINE R = [ 0 for i in range ( 2 ) ] NEW_LINE L [ l % 2 ] = l NEW_LINE R [ r % 2 ] = r NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE if ( l <= tR and r >= tL ) : NEW_LINE INDENT L [ l % 2 ] , R [ r % 2 ] = l , r NEW_LINE DEDENT cnt0 , cnt1 = 0 , 0 NEW_LINE if ( R [ 0 ] and L [ 0 ] ) : NEW_LINE INDENT cnt0 = ( R [ 0 ] - L [ 0 ] ) // 2 + 1 NEW_LINE DEDENT if ( R [ 1 ] and L [ 1 ] ) : NEW_LINE INDENT cnt1 = ( R [ 1 ] - L [ 1 ] ) // 2 + 1 NEW_LINE DEDENT dp = [ [ 0 for i in range ( 2 ) ] for i in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = cnt0 NEW_LINE dp [ 1 ] [ 1 ] = cnt1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( cnt0 * dp [ i - 1 ] [ 0 ] + cnt1 * dp [ i - 1 ] [ 1 ] ) NEW_LINE dp [ i ] [ 1 ] = ( cnt0 * dp [ i - 1 ] [ 1 ] + cnt1 * dp [ i - 1 ] [ 0 ] ) NEW_LINE DEDENT return dp [ n ] [ 0 ] NEW_LINE DEDENT n , l , r = 2 , 1 , 3 NEW_LINE print ( countWays ( n , l , r ) ) NEW_LINE;"Ways to form an array having integers in given range such that total sum is divisible by 2 | Function to return the number of ways to form an array of size n such that sum of all elements is divisible by 2 ; Represents first and last numbers of each type ( modulo 0 and 1 ) ; Count of numbers of each type between range ; Base Cases ; Ways to form array whose sum upto i numbers modulo 2 is 0 ; Ways to form array whose sum upto i numbers modulo 2 is 1 ; Return the required count of ways ; Driver Code"
Python;"M = 1001 ; NEW_LINE MOD = 998244353 ; NEW_LINE dp = [ [ - 1 ] * M ] * M NEW_LINE def solve ( idx , diff , N , M , K ) : NEW_LINE INDENT if ( idx > N ) : NEW_LINE INDENT if ( diff == K ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ idx ] [ diff ] != - 1 ) : NEW_LINE INDENT return dp [ idx ] ; NEW_LINE DEDENT ans = solve ( idx + 1 , diff , N , M , K ) ; NEW_LINE ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; NEW_LINE dp [ idx ] [ diff ] = ans % MOD ; NEW_LINE return dp [ idx ] [ diff ] NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 3 NEW_LINE M = 3 NEW_LINE K = 0 NEW_LINE print ( M * solve ( 2 , 0 , N , M , K ) ) NEW_LINE DEDENT";"Color N boxes using M colors such that K boxes have different color from the box on its left | Python3 Program to Paint N boxes using M colors such that K boxes have color different from color of box on its left ; This function returns the required number of ways where idx is the current index and diff is number of boxes having different color from box on its left ; Base Case ; If already computed ; Either paint with same color as previous one ; Or paint with remaining ( M - 1 ) colors ; Driver code ; Multiply M since first box can be painted with any of the M colors and start solving from 2 nd box"
Python;"N = 3 NEW_LINE def maxPathSum ( tri ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( N - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( 0 , N - i ) : NEW_LINE INDENT if ( j - 1 >= 0 ) : NEW_LINE INDENT tri [ i ] [ j ] += max ( tri [ i + 1 ] [ j ] , tri [ i + 1 ] [ j - 1 ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; NEW_LINE DEDENT ans = max ( ans , tri [ i ] [ j ] ) ; NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT tri = [ [ 1 , 5 , 3 ] , [ 4 , 8 , 0 ] , [ 1 , 0 , 0 ] ] NEW_LINE print ( maxPathSum ( tri ) ) NEW_LINE";"Maximum path sum in an Inverted triangle | SET 2 | Python program implementation of Max sum problem in a triangle ; Function for finding maximum sum ; Loop for bottom - up calculation ; For each element , check both elements just below the number and below left to the number add the maximum of them to it ; Return the maximum sum ; Driver Code"
Python;from math import log2 NEW_LINE def subsetXOR ( arr , n , K ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] > max_ele ) : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT DEDENT m = ( 1 << int ( log2 ( max_ele ) + 1 ) ) - 1 NEW_LINE dp = [ [ [ 0 for i in range ( n + 1 ) ] for j in range ( m + 1 ) ] for k in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT for k in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] NEW_LINE if ( k != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] [ k - 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += dp [ n ] [ K ] [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 1 NEW_LINE n = len ( arr ) NEW_LINE print ( subsetXOR ( arr , n , k ) ) NEW_LINE DEDENT;"Count no . of ordered subsets having a particular XOR value | Python 3 implementation of the approach ; Returns count of ordered subsets of arr [ ] with XOR value = K ; Find maximum element in arr [ ] ; Maximum possible XOR value ; The value of dp [ i ] [ j ] [ k ] is the number of subsets of length k having XOR of their elements as j from the set arr [ 0. . . i - 1 ] ; Initializing all the values of dp [ i ] [ j ] [ k ] as 0 ; The xor of empty subset is 0 ; Fill the dp table ; The answer is the number of subsets of all lengths from set arr [ 0. . n - 1 ] having XOR of elements as k ; Driver Code"
Python;"def get_max_splits ( num_string ) : NEW_LINE INDENT count = 0 NEW_LINE running_sum = 0 NEW_LINE for i in range ( len ( num_string ) ) : NEW_LINE INDENT current_num = int ( num_string [ i ] ) NEW_LINE running_sum += current_num NEW_LINE if current_num % 3 == 0 or ( running_sum != 0 and running_sum % 3 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE running_sum = 0 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT print get_max_splits ( ""12345"" ) NEW_LINE";"Possible cuts of a number such that maximum parts are divisible by 3 | Python3 program to find the maximum number of numbers divisible by 3 in a large number ; This will contain the count of the splits ; This will keep sum of all successive integers , when they are indivisible by 3 ; This is the condition of finding a split ; Driver code"
Python;"M = 20 NEW_LINE dp = [ ] NEW_LINE d , K = None , None NEW_LINE def count ( pos , cnt , tight , nonz , num : list ) : NEW_LINE INDENT if pos == len ( num ) : NEW_LINE INDENT if cnt == K : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if dp [ pos ] [ cnt ] [ tight ] [ nonz ] != - 1 : NEW_LINE INDENT return dp [ pos ] [ cnt ] [ tight ] [ nonz ] NEW_LINE DEDENT ans = 0 NEW_LINE limit = 9 if tight else num [ pos ] NEW_LINE for dig in range ( limit + 1 ) : NEW_LINE INDENT currCnt = cnt NEW_LINE if dig == d : NEW_LINE INDENT if d != 0 or not d and nonz : NEW_LINE INDENT currCnt += 1 NEW_LINE DEDENT DEDENT currTight = tight NEW_LINE if dig < num [ pos ] : NEW_LINE INDENT currTight = 1 NEW_LINE DEDENT ans += count ( pos + 1 , currCnt , currTight , ( nonz or dig != 0 ) , num ) NEW_LINE DEDENT dp [ pos ] [ cnt ] [ tight ] [ nonz ] = ans NEW_LINE return dp [ pos ] [ cnt ] [ tight ] [ nonz ] NEW_LINE DEDENT def solve ( x ) : NEW_LINE INDENT global dp , K , d NEW_LINE num = [ ] NEW_LINE while x : NEW_LINE INDENT num . append ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT num . reverse ( ) NEW_LINE dp = [ [ [ [ - 1 , - 1 ] for i in range ( 2 ) ] for j in range ( M ) ] for k in range ( M ) ] NEW_LINE return count ( 0 , 0 , 0 , 0 , num ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT L = 11 NEW_LINE R = 100 NEW_LINE d = 2 NEW_LINE K = 1 NEW_LINE print ( solve ( R ) - solve ( L - 1 ) ) NEW_LINE DEDENT";"Count of Numbers in a Range where digit d occurs exactly K times | Python Program to find the count of numbers in a range where digit d occurs exactly K times ; states - position , count , tight , nonz ; d is required digit and K is occurrence ; This function returns the count of required numbers from 0 to num ; Last position ; If this result is already computed simply return it ; Maximum limit upto which we can place digit . If tight is 1 , means number has already become smaller so we can place any digit , otherwise num [ pos ] ; Nonz is true if we placed a non zero digit at the starting of the number ; At this position , number becomes smaller ; Next recursive call , also set nonz to 1 if current digit is non zero ; Function to convert x into its digit vector and uses count ( ) function to return the required count ; Initialize dp ; Driver Code"
Python;def solve ( x ) : NEW_LINE INDENT ans , temp = 0 , x NEW_LINE if ( x < 10 ) : NEW_LINE INDENT return x NEW_LINE DEDENT last = x % 10 NEW_LINE while ( x ) : NEW_LINE INDENT first = x % 10 NEW_LINE x = x // 10 NEW_LINE DEDENT if ( first <= last ) : NEW_LINE INDENT ans = 9 + temp // 10 NEW_LINE DEDENT else : NEW_LINE INDENT ans = 8 + temp // 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT L , R = 2 , 60 NEW_LINE print ( solve ( R ) - solve ( L - 1 ) ) NEW_LINE L , R = 1 , 1000 NEW_LINE print ( solve ( R ) - solve ( L - 1 ) ) NEW_LINE;"Count of Numbers in Range where first digit is equal to last digit of the number | Python3 program to implement the above approach ; Base Case ; Calculating the last digit ; Calculating the first digit ; Driver Code"
Python;def findMinimumCost ( n , x , y ) : NEW_LINE INDENT dp = [ 0 for i in range ( n + 1 ) ] NEW_LINE dp [ 1 ] = x NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i & 1 : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + x , dp [ ( i + 1 ) // 2 ] + y + x ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] + x , dp [ i // 2 ] + y ) NEW_LINE DEDENT DEDENT return dp [ n ] NEW_LINE DEDENT n , x , y = 4 , 2 , 1 NEW_LINE print ( findMinimumCost ( n , x , y ) ) NEW_LINE;"Form N | function returns the minimum cost to form a n - copy string Here , x -> Cost to add / remove a single character ' G ' and y -> cost to append the string to itself ; base case : ro form a 1 - copy string we need tp perform an operation of type 1 ( i , e Add ) ; case1 . Perform a Add operation on ( i - 1 ) copy string case2 . perform a type 2 operation on ( ( i + 1 ) / 2 ) - copy string ; case1 . Perform a Add operation on ( i - 1 ) - copy string case2 . Perform a type operation on ( i / 2 ) - copy string ; Driver code"
Python;r = 4 NEW_LINE col = 5 NEW_LINE def findMinSteps ( mat , n , m , dp , vis ) : NEW_LINE INDENT if ( n == 0 or m == 0 or n == ( r - 1 ) or m == ( col - 1 ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ n ] [ m ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ m ] NEW_LINE DEDENT vis [ n ] [ m ] = True NEW_LINE ans1 , ans2 , ans3 , ans4 = 10 ** 9 , 10 ** 9 , 10 ** 9 , 10 ** 9 NEW_LINE if ( mat [ n - 1 ] [ m ] == 0 ) : NEW_LINE INDENT if ( vis [ n - 1 ] [ m ] == False ) : NEW_LINE INDENT ans1 = 1 + findMinSteps ( mat , n - 1 , m , dp , vis ) NEW_LINE DEDENT DEDENT if ( mat [ n ] [ m + 1 ] == 0 ) : NEW_LINE INDENT if ( vis [ n ] [ m + 1 ] == False ) : NEW_LINE INDENT ans2 = 1 + findMinSteps ( mat , n , m + 1 , dp , vis ) NEW_LINE DEDENT DEDENT if ( mat [ n ] [ m - 1 ] == 0 ) : NEW_LINE INDENT if ( vis [ n ] [ m - 1 ] == False ) : NEW_LINE INDENT ans3 = 1 + findMinSteps ( mat , n , m - 1 , dp , vis ) NEW_LINE DEDENT DEDENT if ( mat [ n + 1 ] [ m ] == 0 ) : NEW_LINE INDENT if ( vis [ n + 1 ] [ m ] == False ) : NEW_LINE INDENT ans4 = 1 + findMinSteps ( mat , n + 1 , m , dp , vis ) NEW_LINE DEDENT DEDENT dp [ n ] [ m ] = min ( ans1 , min ( ans2 , min ( ans3 , ans4 ) ) ) NEW_LINE return dp [ n ] [ m ] NEW_LINE DEDENT def minimumSteps ( mat , n , m ) : NEW_LINE INDENT twox = - 1 NEW_LINE twoy = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 2 ) : NEW_LINE INDENT twox = i NEW_LINE twoy = j NEW_LINE break NEW_LINE DEDENT DEDENT if ( twox != - 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT dp = [ [ - 1 for i in range ( col ) ] for i in range ( r ) ] NEW_LINE vis = [ [ False for i in range ( col ) ] for i in range ( r ) ] NEW_LINE res = findMinSteps ( mat , twox , twoy , dp , vis ) NEW_LINE if ( res >= 10 ** 9 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT mat = [ [ 1 , 1 , 1 , 0 , 1 ] , [ 1 , 0 , 2 , 0 , 1 ] , [ 0 , 0 , 1 , 0 , 1 ] , [ 1 , 0 , 1 , 1 , 0 ] ] NEW_LINE print ( minimumSteps ( mat , r , col ) ) NEW_LINE;"Minimum steps to reach any of the boundary edges of a matrix | Set 1 | Python program to find Minimum steps to reach any of the boundary edges of a matrix ; Function to find out minimum steps ; boundary edges reached ; already had a route through this point , hence no need to re - visit ; visiting a position ; vertically up ; horizontally right ; horizontally left ; vertically down ; minimum of every path ; Function that returns the minimum steps ; index to store the location at which you are standing ; find '2' in the matrix ; Initialize dp matrix with - 1 ; Initialize vis matrix with false ; Call function to find out minimum steps using memoization and recursion ; if not possible ; Driver Code"
Python;def nCr ( n , r ) : NEW_LINE INDENT ans = 1 NEW_LINE if r > n - r : NEW_LINE INDENT r = n - r NEW_LINE DEDENT for i in range ( r ) : NEW_LINE INDENT ans *= ( n - i ) NEW_LINE ans /= ( i + 1 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def countDerangements ( n ) : NEW_LINE INDENT der = [ 0 for i in range ( n + 3 ) ] NEW_LINE der [ 0 ] = 1 NEW_LINE der [ 1 ] = 0 NEW_LINE der [ 2 ] = 1 NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) NEW_LINE DEDENT return der [ n ] NEW_LINE DEDENT def countPermutations ( n , k ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n - k , n + 1 ) : NEW_LINE INDENT ways = nCr ( n , i ) NEW_LINE ans += ways * countDerangements ( n - i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT n , k = 5 , 3 NEW_LINE print ( countPermutations ( n , k ) ) NEW_LINE;"Count the number of special permutations | function to return the number of ways to chooser objects out of n objects ; function to return the number of degrangemnets of n ; function to return the required number of permutations ; ways to chose i indices from n indices ; Dearrangements of ( n - i ) indices ; Driver Code"
Python;n = 3 NEW_LINE dp = [ [ 0 for i in range ( n ) ] for j in range ( n ) ] NEW_LINE def answerQueries ( queries , q ) : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT x = queries [ i ] [ 0 ] NEW_LINE x -= 1 NEW_LINE y = queries [ i ] [ 1 ] NEW_LINE y -= 1 NEW_LINE print ( dp [ x ] [ y ] ) NEW_LINE DEDENT DEDENT def pre_compute ( a ) : NEW_LINE INDENT if a [ 0 ] [ 0 ] == ' a ' : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 0 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT for row in range ( n ) : NEW_LINE INDENT for col in range ( n ) : NEW_LINE INDENT if ( row != 0 or col != 0 ) : NEW_LINE INDENT dp [ row ] [ col ] = 9999 NEW_LINE DEDENT if ( row != 0 ) : NEW_LINE INDENT dp [ row ] [ col ] = min ( dp [ row ] [ col ] , dp [ row - 1 ] [ col ] ) NEW_LINE DEDENT if ( col != 0 ) : NEW_LINE INDENT dp [ row ] [ col ] = min ( dp [ row ] [ col ] , dp [ row ] [ col - 1 ] ) NEW_LINE DEDENT if ( a [ row ] [ col ] != ' a ' and ( row != 0 or col != 0 ) ) : NEW_LINE INDENT dp [ row ] [ col ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ ( ' a ' , ' b ' , ' a ' ) , ( ' a ' , ' c ' , ' d ' ) , ( ' b ' , ' a ' , ' b ' ) ] NEW_LINE queries = [ ( 1 , 3 ) , ( 3 , 3 ) ] NEW_LINE q = 2 NEW_LINE pre_compute ( a ) NEW_LINE answerQueries ( queries , q ) NEW_LINE DEDENT;"Paths with maximum number of ' a ' from ( 1 , 1 ) to ( X , Y ) vertically or horizontally | Python3 program to find paths with maximum number of ' a ' from ( 1 , 1 ) to ( X , Y ) vertically or horizontally ; Function to answer queries ; Iterate till query ; Decrease to get 0 - based indexing ; Print answer ; Function that pre - computes the dp array ; Check for the first character ; Iterate in row and columns ; If not first row or not first column ; Not first row ; Not first column ; If it is not ' a ' then increase by 1 ; Driver code ; Character N X N array ; Queries ; Number of queries ; Function call to pre - compute ; function call to answer every query"
Python;def squares ( i ) : NEW_LINE INDENT if ( ( i & 1 ) == 1 ) : NEW_LINE INDENT return int ( i / 4 ) * 2 + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return int ( ( i - 1 ) / 4 ) * 2 + 2 NEW_LINE DEDENT DEDENT def bishop_placements ( n , k ) : NEW_LINE INDENT if ( k > 2 * n - 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT dp = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n * 2 ) ] NEW_LINE for i in range ( n * 2 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = 1 NEW_LINE DEDENT dp [ 1 ] [ 1 ] = 1 NEW_LINE for i in range ( 2 , n * 2 , 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 , 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 2 ] [ j ] + dp [ i - 2 ] [ j - 1 ] * ( squares ( i ) - j + 1 ) ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 0 , k + 1 , 1 ) : NEW_LINE INDENT ans += ( dp [ n * 2 - 1 ] [ i ] * dp [ n * 2 - 2 ] [ k - i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE k = 2 NEW_LINE ans = bishop_placements ( n , k ) NEW_LINE print ( ans ) NEW_LINE DEDENT;"Ways to place K bishops on an NÃ — N chessboard so that no two attack | returns the number of squares in diagonal i ; returns the number of ways to fill a n * n chessboard with k bishops so that no two bishops attack each other . ; return 0 if the number of valid places to be filled is less than the number of bishops ; dp table to store the values ; Setting the base conditions ; calculate the required number of ways ; stores the answer ; Driver code"
Python;"MAX = 10 NEW_LINE F = [ [ - 1 for i in range ( MAX ) ] for j in range ( MAX ) ] NEW_LINE C = [ None ] * MAX NEW_LINE def noOfAssignments ( S , n , i , c_x ) : NEW_LINE INDENT if F [ i ] [ c_x ] != - 1 : NEW_LINE INDENT return F [ i ] [ c_x ] NEW_LINE DEDENT if i == n : NEW_LINE INDENT F [ i ] [ c_x ] = not c_x NEW_LINE return F [ i ] [ c_x ] NEW_LINE DEDENT c_y = C [ i ] - c_x NEW_LINE if S [ i ] == ' ( ' : NEW_LINE INDENT F [ i ] [ c_x ] = noOfAssignments ( S , n , i + 1 , c_x + 1 ) + noOfAssignments ( S , n , i + 1 , c_x ) NEW_LINE return F [ i ] [ c_x ] NEW_LINE DEDENT F [ i ] [ c_x ] = 0 NEW_LINE if c_x : NEW_LINE INDENT F [ i ] [ c_x ] += noOfAssignments ( S , n , i + 1 , c_x - 1 ) NEW_LINE DEDENT if c_y : NEW_LINE INDENT F [ i ] [ c_x ] += noOfAssignments ( S , n , i + 1 , c_x ) NEW_LINE DEDENT return F [ i ] [ c_x ] NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT S = "" ( ) "" NEW_LINE n = len ( S ) NEW_LINE C [ 0 ] = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if S [ i ] == ' ( ' : NEW_LINE INDENT C [ i + 1 ] = C [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i + 1 ] = C [ i ] - 1 NEW_LINE DEDENT DEDENT print ( noOfAssignments ( S , n , 0 , 0 ) ) NEW_LINE DEDENT";"Number of ways to partition a string into two balanced subsequences | For maximum length of input string ; Declaring the DP table ; Declaring the prefix array ; Function to calculate the number of valid assignments ; Return 1 if X is balanced . ; Increment the count if it is an opening bracket ; Decrement the count if it is a closing bracket ; Driver code ; Creating the prefix array ; Initial value for c_x and c_y is zero"
Python;"import sys NEW_LINE n = 3 NEW_LINE def minFallingPathSum ( A ) : NEW_LINE INDENT for R in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for C in range ( n ) : NEW_LINE INDENT best = A [ R + 1 ] [ C ] NEW_LINE if C > 0 : NEW_LINE INDENT best = min ( best , A [ R + 1 ] [ C - 1 ] ) NEW_LINE DEDENT if C + 1 < n : NEW_LINE INDENT best = min ( best , A [ R + 1 ] [ C + 1 ] ) NEW_LINE DEDENT A [ R ] [ C ] = A [ R ] [ C ] + best NEW_LINE DEDENT DEDENT ans = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = min ( ans , A [ 0 ] [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE print ( minFallingPathSum ( A ) ) NEW_LINE DEDENT";"Minimum sum falling path in a NxN grid | Python3 Program to minimum required sum ; Function to return minimum path falling sum ; R = Row and C = Column We begin from second last row and keep adding maximum sum . ; best = min ( A [ R + 1 ] [ C - 1 ] , A [ R + 1 ] [ C ] , A [ R + 1 ] [ C + 1 ] ) ; Driver code ; function to print required answer"
Python;"N = 100 NEW_LINE n = 3 NEW_LINE m = 4 NEW_LINE def maxPlus ( arr ) : NEW_LINE INDENT ans = 0 NEW_LINE left = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE right = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE up = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE down = [ [ 0 for x in range ( N ) ] for y in range ( N ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT left [ i ] [ j ] = ( max ( 0 , ( left [ i ] [ j - 1 ] if j else 0 ) ) + arr [ i ] [ j ] ) NEW_LINE up [ i ] [ j ] = ( max ( 0 , ( up [ i - 1 ] [ j ] if i else 0 ) ) + arr [ i ] [ j ] ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT right [ i ] [ j ] = max ( 0 , ( 0 if ( j + 1 == m ) else right [ i ] [ j + 1 ] ) ) + arr [ i ] [ j ] NEW_LINE down [ i ] [ j ] = max ( 0 , ( 0 if ( i + 1 == n ) else down [ i + 1 ] [ j ] ) ) + arr [ i ] [ j ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT for j in range ( 1 , m - 1 ) : NEW_LINE INDENT ans = max ( ans , up [ i - 1 ] [ j ] + down [ i + 1 ] [ j ] + left [ i ] [ j - 1 ] + right [ i ] [ j + 1 ] + arr [ i ] [ j ] ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ [ 1 , 1 , 1 , 1 ] , [ - 6 , 1 , 1 , - 4 ] , [ 1 , 1 , 1 , 1 ] ] NEW_LINE print ( maxPlus ( arr ) ) NEW_LINE DEDENT";"Find the maximum sum of Plus shape pattern in a 2 | Python 3 program to find the maximum value of a + shaped pattern in 2 - D array ; Function to return maximum Plus value ; Initializing answer with the minimum value ; Initializing all four arrays ; Initializing left and up array . ; Initializing right and down array . ; calculating value of maximum Plus ( + ) sign ; Driver code ; Function call to find maximum value"
Python;"def countStaircases ( N ) : NEW_LINE INDENT memo = [ [ 0 for x in range ( N + 5 ) ] for y in range ( N + 5 ) ] NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( N + 1 ) : NEW_LINE INDENT memo [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT memo [ 3 ] [ 2 ] = memo [ 4 ] [ 2 ] = 1 NEW_LINE for i in range ( 5 , N + 1 ) : NEW_LINE INDENT for j in range ( 2 , i + 1 ) : NEW_LINE INDENT if ( j == 2 ) : NEW_LINE INDENT memo [ i ] [ j ] = memo [ i - j ] [ j ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT memo [ i ] [ j ] = ( memo [ i - j ] [ j ] + memo [ i - j ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT answer = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT answer = answer + memo [ N ] [ i ] NEW_LINE DEDENT return answer NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 7 NEW_LINE print ( countStaircases ( N ) ) NEW_LINE DEDENT";"Total number of different staircase that can made from N boxes | Function to find the total number of different staircase that can made from N boxes ; DP table , there are two states . First describes the number of boxes and second describes the step ; Initialize all the elements of the table to zero ; Base case ; When step is equal to 2 ; When step is greater than 2 ; Count the total staircase from all the steps ; Driver Code"
Python;"def maxCost ( a , n , l , r ) : NEW_LINE INDENT mx = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mx = max ( mx , a [ i ] ) NEW_LINE DEDENT count = [ 0 ] * ( mx + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ a [ i ] ] += 1 NEW_LINE DEDENT res = [ 0 ] * ( mx + 1 ) NEW_LINE res [ 0 ] = 0 NEW_LINE l = min ( l , r ) NEW_LINE for num in range ( 1 , mx + 1 ) : NEW_LINE INDENT k = max ( num - l - 1 , 0 ) NEW_LINE res [ num ] = max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) NEW_LINE DEDENT return res [ mx ] NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = [ 2 , 1 , 2 , 3 , 2 , 2 , 1 ] NEW_LINE l , r = 1 , 1 NEW_LINE n = len ( a ) NEW_LINE print ( maxCost ( a , n , l , r ) ) NEW_LINE DEDENT";"Find maximum points which can be obtained by deleting elements from array | function to return maximum cost obtained ; find maximum element of the array . ; create and initialize count of all elements to zero . ; calculate frequency of all elements of array . ; stores cost of deleted elements . ; selecting minimum range from L and R . ; finds upto which elements are to be deleted when element num is selected . ; get maximum when selecting element num or not . ; Driver code ; size of array ; function call to find maximum cost"
Python;"def countPaths ( m , n ) : NEW_LINE INDENT if m == 1 or n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return ( countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 5 NEW_LINE m = 5 NEW_LINE print ( countPaths ( n , m ) ) NEW_LINE DEDENT";"Count the number of ways to traverse a Matrix | Returns The number of way from top - left to mat [ m - 1 ] [ n - 1 ] ; Return 1 if it is the first row or first column ; Recursively find the no of way to reach the last cell . ; Driver code"
Python;"def countPaths ( m , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i == 1 or j == 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 5 NEW_LINE m = 5 NEW_LINE print ( countPaths ( n , m ) ) NEW_LINE DEDENT";"Count the number of ways to traverse a Matrix | Returns The number of way from top - left to mat [ m - 1 ] [ n - 1 ] ; Driver code"
Python;dp = [ [ 0 for i in range ( 1000 ) ] for i in range ( 1000 ) ] NEW_LINE def createPalindrome ( input , isOdd ) : NEW_LINE INDENT n = input NEW_LINE palin = input NEW_LINE if ( isOdd ) : NEW_LINE INDENT n //= 10 NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT palin = palin * 10 + ( n % 10 ) NEW_LINE n //= 10 NEW_LINE DEDENT return palin NEW_LINE DEDENT def generatePalindromes ( N ) : NEW_LINE INDENT palindromes = [ ] NEW_LINE number = 0 NEW_LINE for j in range ( 2 ) : NEW_LINE INDENT i = 1 NEW_LINE number = createPalindrome ( i , j ) NEW_LINE while number <= N : NEW_LINE INDENT number = createPalindrome ( i , j ) NEW_LINE palindromes . append ( number ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return palindromes NEW_LINE DEDENT def minimumSubsetSize ( A , i , j , N ) : NEW_LINE INDENT if ( not N ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i > j or A [ i ] > N ) : NEW_LINE INDENT return 10 ** 9 NEW_LINE DEDENT if ( dp [ i ] [ N ] ) : NEW_LINE INDENT return dp [ i ] [ N ] NEW_LINE DEDENT dp [ i ] [ N ] = min ( 1 + minimumSubsetSize ( A , i + 1 , j , N - A [ i ] ) , minimumSubsetSize ( A , i + 1 , j , N ) ) NEW_LINE return dp [ i ] [ N ] NEW_LINE DEDENT def minimumNoOfPalindromes ( N ) : NEW_LINE INDENT palindromes = generatePalindromes ( N ) NEW_LINE palindromes = sorted ( palindromes ) NEW_LINE return minimumSubsetSize ( palindromes , 0 , len ( palindromes ) - 1 , N ) NEW_LINE DEDENT N = 65 NEW_LINE print ( minimumNoOfPalindromes ( N ) ) NEW_LINE;"Minimum number of palindromes required to express N as a sum | Set 1 | Declaring the DP table as global variable ; A utility for creating palindrome ; checks if number of digits is odd or even if odd then neglect the last digit of input in finding reverse as in case of odd number of digits middle element occur once ; Creates palindrome by just appending reverse of number to itself ; Function to generate palindromes ; Run two times for odd and even length palindromes ; Creates palindrome numbers with first half as i . Value of j decides whether we need an odd length or even length palindrome . ; Function to find the minimum number of elements in a sorted array A [ i . . j ] such that their sum is N ; Function to find the minimum number of palindromes that N can be expressed as a sum of ; Getting the list of all palindromes upto N ; Sorting the list of palindromes ; Returning the required value ; Driver code"
Python;"def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 ; NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k ; NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) ; NEW_LINE res /= ( i + 1 ) ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n , n ) ; NEW_LINE return int ( c / ( n + 1 ) ) ; NEW_LINE DEDENT n = 3 ; NEW_LINE print ( catalan ( n ) ) ; NEW_LINE";"Number of ways a convex polygon of n + 2 sides can split into triangles by connecting vertices | Returns value of Binomial Coefficient C ( n , k ) ; Since C ( n , k ) = C ( n , n - k ) ; Calculate value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] / [ k * ( k - 1 ) * -- - * 1 ] ; A Binomial coefficient based function to find nth catalan number in O ( n ) time ; Calculate value of 2 nCn ; return 2 nCn / ( n + 1 ) ; Driver code"
Python;"def alternateFib ( n ) : NEW_LINE INDENT if ( n < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT f1 = 0 ; NEW_LINE f2 = 1 ; NEW_LINE print ( f1 , end = "" ▁ "" ) ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f3 = f2 + f1 ; NEW_LINE if ( i % 2 == 0 ) : NEW_LINE INDENT print ( f3 , end = "" ▁ "" ) ; NEW_LINE DEDENT f1 = f2 ; NEW_LINE f2 = f3 ; NEW_LINE DEDENT DEDENT N = 15 ; NEW_LINE alternateFib ( N ) ; NEW_LINE";"Alternate Fibonacci Numbers | Alternate Fibonacci Series using Dynamic Programming ; 0 th and 1 st number of the series are 0 and 1 ; Driver Code"
Python;def totalWays ( N , M , X ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( 2 ) ] for j in range ( N + 1 ) ] NEW_LINE if ( X == 1 ) : NEW_LINE INDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ 1 ] = 0 NEW_LINE DEDENT if ( X == 1 ) : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 0 NEW_LINE dp [ 1 ] [ 1 ] = M - 1 NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 1 ] [ 0 ] = 1 NEW_LINE dp [ 1 ] [ 1 ] = ( M - 2 ) NEW_LINE DEDENT for i in range ( 2 , N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] NEW_LINE dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) NEW_LINE DEDENT return dp [ N - 1 ] [ 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE M = 3 NEW_LINE X = 2 NEW_LINE print ( totalWays ( N , M , X ) ) NEW_LINE DEDENT;"Number of ways to form an array with distinct adjacent elements | Returns the total ways to form arrays such that every consecutive element is different and each element except the first and last can take values from 1 to M ; define the dp [ ] [ ] array ; if the first element is 1 ; there is only one way to place a 1 at the first index ; the value at first index needs to be 1 , thus there is no way to place a non - one integer ; if the first element was 1 then at index 1 , only non one integer can be placed thus there are M - 1 ways to place a non one integer at index 2 and 0 ways to place a 1 at the 2 nd index ; Else there is one way to place a one at index 2 and if a non one needs to be placed here , there are ( M - 2 ) options , i . e neither the element at this index should be 1 , neither should it be equal to the previous element ; Build the dp array in bottom up manner ; f ( i , one ) = f ( i - 1 , non - one ) ; f ( i , non - one ) = f ( i - 1 , one ) * ( M - 1 ) + f ( i - 1 , non - one ) * ( M - 2 ) ; last element needs to be one , so return dp [ n - 1 ] [ 0 ] ; Driver Code"
Python;def fib ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE print ( fib ( n ) ) NEW_LINE DEDENT;"Memoization ( 1D , 2D and 3D ) | Fibonacci Series using Recursion ; Base case ; recursive calls ; Driver Code"
Python;term = [ 0 for i in range ( 1000 ) ] NEW_LINE def fib ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return n NEW_LINE DEDENT if term [ n ] != 0 : NEW_LINE INDENT return term [ n ] NEW_LINE DEDENT else : NEW_LINE INDENT term [ n ] = fib ( n - 1 ) + fib ( n - 2 ) NEW_LINE return term [ n ] NEW_LINE DEDENT DEDENT n = 6 NEW_LINE print ( fib ( n ) ) NEW_LINE;"Memoization ( 1D , 2D and 3D ) | Python program to find the Nth term of Fibonacci series ; Fibonacci Series using memoized Recursion ; base case ; if fib ( n ) has already been computed we do not do further recursive calls and hence reduce the number of repeated work ; store the computed value of fib ( n ) in an array term at index n to so that it does not needs to be precomputed again ; Driver Code"
Python;"def lcs ( X , Y , m , n ) : NEW_LINE INDENT if ( m == 0 or n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( X [ m - 1 ] == Y [ n - 1 ] ) : NEW_LINE INDENT return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X = "" AGGTAB "" ; NEW_LINE Y = "" GXTXAYB "" ; NEW_LINE m = len ( X ) ; NEW_LINE n = len ( Y ) ; NEW_LINE print ( "" Length ▁ of ▁ LCS ▁ is ▁ { } n "" . format ( lcs ( X , Y , m , n ) ) ) NEW_LINE DEDENT";"Memoization ( 1D , 2D and 3D ) | Returns length of LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ] ; Driver Code"
Python;dp = [ [ - 1 for i in range ( 8101 ) ] for i in range ( 901 ) ] NEW_LINE def minimumNumberOfDigits ( a , b ) : NEW_LINE INDENT if ( a > b or a < 0 or b < 0 or a > 900 or b > 8100 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT if ( a == 0 and b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( dp [ a ] [ b ] != - 1 ) : NEW_LINE INDENT return dp [ a ] [ b ] NEW_LINE DEDENT ans = 101 NEW_LINE for i in range ( 9 , 0 , - 1 ) : NEW_LINE INDENT k = minimumNumberOfDigits ( a - i , b - ( i * i ) ) NEW_LINE if ( k != - 1 ) : NEW_LINE INDENT ans = min ( ans , k + 1 ) NEW_LINE DEDENT DEDENT dp [ a ] [ b ] = ans NEW_LINE return ans NEW_LINE DEDENT def printSmallestNumber ( a , b ) : NEW_LINE INDENT for i in range ( 901 ) : NEW_LINE INDENT for j in range ( 8101 ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT dp [ 0 ] [ 0 ] = 0 NEW_LINE k = minimumNumberOfDigits ( a , b ) NEW_LINE if ( k == - 1 or k > 100 ) : NEW_LINE INDENT print ( - 1 , end = ' ' ) NEW_LINE DEDENT else : NEW_LINE INDENT while ( a > 0 and b > 0 ) : NEW_LINE INDENT for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( a >= i and b >= i * i and 1 + dp [ a - i ] [ b - i * i ] == dp [ a ] [ b ] ) : NEW_LINE INDENT print ( i , end = ' ' ) NEW_LINE a -= i NEW_LINE b -= i * i NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 18 NEW_LINE b = 162 NEW_LINE printSmallestNumber ( a , b ) NEW_LINE DEDENT;"Smallest number with given sum of digits and sum of square of digits | Python3 program to find the Smallest number with given sum of digits and sum of square of digits ; Top down dp to find minimum number of digits with given sum of dits a and sum of square of digits as b ; Invalid condition ; Number of digits satisfied ; Memoization ; Initialize ans as maximum as we have to find the minimum number of digits ; Check for all possible combinations of digits ; recurrence call ; If the combination of digits cannot give sum as a and sum of square of digits as b ; Returns the minimum number of digits ; Function to print the digits that gives sum as a and sum of square of digits as b ; initialize the dp array as ; base condition ; function call to get the minimum number of digits ; When there does not exists any number ; Printing the digits from the most significant digit ; Trying all combinations ; checking conditions for minimum digits ; Driver Code ; Function call to print the smallest number"
Python;"MAX = 100 ; NEW_LINE def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) , 0 , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] ; NEW_LINE DEDENT DEDENT return C [ k ] ; NEW_LINE DEDENT def sumOfproduct ( n ) : NEW_LINE INDENT return binomialCoeff ( 2 * n , n - 1 ) ; NEW_LINE DEDENT n = 3 ; NEW_LINE print ( sumOfproduct ( n ) ) ; NEW_LINE";"Sum of product of consecutive Binomial Coefficients | Python3 Program to find sum of product of consecutive Binomial Coefficient . ; Find the binomial coefficient up to nth term ; C [ 0 ] = 1 ; nC0 is 1 ; Compute next row of pascal triangle using the previous row ; Return the sum of the product of consecutive binomial coefficient . ; Driver Code"
Python;"MAX = 100 NEW_LINE def check ( i , add , n , k , a , dp ) : NEW_LINE INDENT if add <= 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if i >= n : NEW_LINE INDENT if add == k : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if dp [ i ] [ add ] != - 1 : NEW_LINE INDENT return dp [ i ] [ add ] NEW_LINE DEDENT dp [ i ] [ add ] = ( check ( i + 1 , add - 2 * a [ i ] , n , k , a , dp ) or check ( i + 1 , add , n , k , a , dp ) ) NEW_LINE dp [ i ] [ add ] = ( check ( i + 1 , add - ( i + 1 ) , n , k , a , dp ) or dp [ i ] [ add ] ) NEW_LINE dp [ i ] [ add ] = ( check ( i + 1 , add + i + 1 , n , k , a , dp ) or dp [ i ] [ add ] ) NEW_LINE return dp [ i ] [ add ] NEW_LINE DEDENT def wrapper ( n , k , a ) : NEW_LINE INDENT add = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT add += a [ i ] NEW_LINE DEDENT dp = [ - 1 ] * MAX NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT dp [ i ] = [ - 1 ] * MAX NEW_LINE DEDENT return check ( 0 , add , n , k , a , dp ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = [ 1 , 2 , 3 , 4 ] NEW_LINE n = 4 NEW_LINE k = 5 NEW_LINE print ( "" Yes "" ) if wrapper ( n , k , a ) else print ( "" No "" ) NEW_LINE DEDENT";"Check if array sum can be made K by three operations on it | Python program to find if Array can have sum of K by applying three types of possible operations on it ; Check if it is possible to achieve a sum with three operation allowed ; if sum id negative . ; If going out of bound . ; If sum is achieved . ; If the current state is not evaluated yet . ; Replacing element with negative value of the element . ; Substracting index number from the element . ; Adding index number to the element . ; Wrapper Function ; Driver Code"
Python;def fib ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if ( n >= 0 ) : NEW_LINE INDENT print ( a , end = ' ▁ ' ) NEW_LINE DEDENT if ( n >= 1 ) : NEW_LINE INDENT print ( b , end = ' ▁ ' ) NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE print ( c , end = ' ▁ ' ) NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT DEDENT fib ( 9 ) NEW_LINE;"Print Fibonacci sequence using 2 variables | Simple Python3 Program to print Fibonacci sequence ; Driver code"
Python;def pre_compute ( a , n , index , k ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if a [ i ] > a [ 0 ] : NEW_LINE INDENT dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ 0 ] [ i ] = a [ i ] NEW_LINE DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if a [ j ] > a [ i ] and j > i : NEW_LINE INDENT if dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return dp [ index ] [ k ] NEW_LINE DEDENT a = [ 1 , 101 , 2 , 3 , 100 , 4 , 5 ] NEW_LINE n = len ( a ) NEW_LINE index = 4 NEW_LINE k = 6 NEW_LINE print ( pre_compute ( a , n , index , k ) ) NEW_LINE;"Maximum sum increasing subsequence from a prefix and a given element after prefix is must | Python3 program to find maximum sum increasing subsequence till i - th index and including k - th index . ; Initializing the first row of the dp [ ] [ ] ; Creating the dp [ ] [ ] matrix . ; To calculate for i = 4 and k = 6. ; Driver code"
Python;"def gen ( n ) : NEW_LINE INDENT S = [ 0 , 1 ] NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT S . append ( 4 * S [ int ( i / 2 ) ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT S . append ( 4 * S [ int ( i / 2 ) ] + 1 ) ; NEW_LINE DEDENT DEDENT z = S [ n ] ; NEW_LINE return z ; NEW_LINE DEDENT def moserDeBruijn ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( gen ( i ) , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT n = 15 NEW_LINE print ( "" First "" , n , "" terms ▁ of ▁ "" , "" Moser - de ▁ Brujn ▁ Sequence : "" ) NEW_LINE moserDeBruijn ( n ) NEW_LINE";"Moser | Function to generate nth term of Moser - de Bruijn Sequence ; S ( 2 * n ) = 4 * S ( n ) ; S ( 2 * n + 1 ) = 4 * S ( n ) + 1 ; Generating the first ' n ' terms of Moser - de Bruijn Sequence ; Driver Code"
Python;"import numpy as np NEW_LINE def LCSubStr ( X , Y ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE result = 0 NEW_LINE len_mat = np . zeros ( ( 2 , n ) ) NEW_LINE currRow = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( i == 0 j == 0 ) : NEW_LINE INDENT len_mat [ currRow ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT len_mat [ currRow ] [ j ] = len_mat [ 1 - currRow ] [ j - 1 ] + 1 NEW_LINE result = max ( result , len_mat [ currRow ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT len_mat [ currRow ] [ j ] = 0 NEW_LINE DEDENT DEDENT currRow = 1 - currRow NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT X = "" GeeksforGeeks "" NEW_LINE Y = "" GeeksQuiz "" NEW_LINE print ( LCSubStr ( X , Y ) ) NEW_LINE DEDENT";"Longest Common Substring ( Space optimized DP solution ) | Space optimized Python3 implementation of longest common substring . ; Function to find longest common substring . ; Find length of both the strings . ; Variable to store length of longest common substring . ; Matrix to store result of two consecutive rows at a time . ; Variable to represent which row of matrix is current row . ; For a particular value of i and j , len_mat [ currRow ] [ j ] stores length of longest common substring in string X [ 0. . i ] and Y [ 0. . j ] . ; Make current row as previous row and previous row as new current row . ; Driver Code"
Python;"INT_MAX = 100000000 NEW_LINE def minimalSteps ( s , n ) : NEW_LINE INDENT dp = [ INT_MAX for i in range ( n ) ] NEW_LINE s1 = "" "" NEW_LINE s2 = "" "" NEW_LINE dp [ 0 ] = 1 NEW_LINE s1 += s [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s1 += s [ i ] NEW_LINE s2 = s [ i + 1 : i + 1 + i + 1 ] NEW_LINE dp [ i ] = min ( dp [ i ] , dp [ i - 1 ] + 1 ) NEW_LINE if ( s1 == s2 ) : NEW_LINE INDENT dp [ i * 2 + 1 ] = min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) NEW_LINE DEDENT DEDENT return dp [ n - 1 ] NEW_LINE DEDENT s = "" aaaaaaaa "" NEW_LINE n = len ( s ) NEW_LINE print ( minimalSteps ( s , n ) ) NEW_LINE";"Minimal moves to form a string by adding characters or appending string itself | Python program to print the Minimal moves to form a string by appending string and adding characters ; function to return the minimal number of moves ; initializing dp [ i ] to INT_MAX ; initialize both strings to null ; base case ; check if it can be appended ; addition of character takes one step ; appending takes 1 step , and we directly reach index i * 2 + 1 after appending so the number of steps is stord in i * 2 + 1 ; Driver Code ; function call to return minimal number of moves"
Python;"def func ( n , m , A ) : NEW_LINE INDENT ModArray = [ 0 ] * n NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ModArray [ i ] = A [ i ] % m NEW_LINE Sum += ModArray [ i ] NEW_LINE DEDENT Sum = Sum % m NEW_LINE if ( Sum % m == 0 ) : NEW_LINE INDENT print ( "" True "" ) NEW_LINE return NEW_LINE DEDENT if ( Sum % 2 != 0 ) : NEW_LINE INDENT print ( "" False "" ) NEW_LINE DEDENT else : NEW_LINE INDENT ModArray . pop ( 0 ) NEW_LINE i = 0 NEW_LINE j = len ( ModArray ) - 1 NEW_LINE ModArray . sort ( ) NEW_LINE Sum = Sum // 2 NEW_LINE while ( i <= j ) : NEW_LINE INDENT s = ModArray [ i ] + ModArray [ j ] NEW_LINE if ( s == Sum ) : NEW_LINE INDENT i1 = i NEW_LINE i2 = j NEW_LINE print ( "" True "" ) NEW_LINE break NEW_LINE DEDENT elif ( s > Sum ) : NEW_LINE INDENT j -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT m = 2 NEW_LINE a = [ 1 , 3 , 9 ] NEW_LINE n = len ( a ) NEW_LINE func ( n , m , a ) NEW_LINE";"Check if any valid sequence is divisible by M | Function to check if any valid sequence is divisible by M ; DEclare mod array ; Calculate the mod array ; Check if sum is divisible by M ; Check if sum is not divisible by 2 ; Remove the first element from the ModArray since it is not possible to place minus on the first element ; Decrease the size of array ; Sort the array ; Loop until the pointer cross each other ; Check if sum becomes equal ; Increase and decrease the pointer accordingly ; Driver code ; Function call"
Python;"def Golomb ( n ) : NEW_LINE INDENT dp = [ 0 ] * ( n + 1 ) NEW_LINE dp [ 1 ] = 1 NEW_LINE print ( dp [ 1 ] , end = "" ▁ "" ) NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = 1 + dp [ i - dp [ dp [ i - 1 ] ] ] NEW_LINE print ( dp [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT n = 9 NEW_LINE Golomb ( n ) NEW_LINE";"Golomb sequence | Print the first n term of Golomb Sequence ; base cases ; Finding and pring first n terms of Golomb Sequence . ; Driver Code"
Python;"N = 1000 NEW_LINE def arrangeBraces ( n , pos , k ) : NEW_LINE INDENT h = [ False for i in range ( N ) ] NEW_LINE dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ] NEW_LINE for i in range ( k ) : NEW_LINE INDENT h [ pos [ i ] ] = 1 NEW_LINE DEDENT dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , 2 * n + 1 ) : NEW_LINE INDENT for j in range ( 2 * n + 1 ) : NEW_LINE INDENT if ( h [ i ] ) : NEW_LINE INDENT if ( j != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = 0 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( j != 0 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT return dp [ 2 * n ] [ 0 ] NEW_LINE DEDENT n = 3 NEW_LINE pos = [ 2 , ] ; NEW_LINE k = len ( pos ) NEW_LINE print ( arrangeBraces ( n , pos , k ) ) NEW_LINE";"Balanced expressions such that given positions have opening brackets | Python 3 code to find number of ways of arranging bracket with proper expressions ; function to calculate the number of proper bracket sequence ; hash array to mark the positions of opening brackets ; dp 2d array ; mark positions in hash array ; first position marked as 1 ; iterate and formulate the recurrences ; if position has a opening bracket ; return answer ; Driver Code ; positions where opening braces will be placed"
Python;"def findLength ( string , n ) : NEW_LINE INDENT current_sum = 0 NEW_LINE max_sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT current_sum += ( 1 if string [ i ] == '0' else - 1 ) NEW_LINE if current_sum < 0 : NEW_LINE INDENT current_sum = 0 NEW_LINE DEDENT max_sum = max ( current_sum , max_sum ) NEW_LINE DEDENT return max_sum if max_sum else 0 NEW_LINE DEDENT s = ""11000010001"" NEW_LINE n = 11 NEW_LINE print ( findLength ( s , n ) ) NEW_LINE";"Maximum difference of zeros and ones in binary string | Set 2 ( O ( n ) time ) | Returns the length of substring with maximum difference of zeroes and ones in binary string ; traverse a binary string from left to right ; add current value to the current_sum according to the Character if it ' s ▁ ' 0 ' add 1 else -1 ; update maximum sum ; return - 1 if string does not contain any zero that means all ones otherwise max_sum ; Driven Program"
Python;DP_s = 9 NEW_LINE def getNumStrictMonotone ( ln ) : NEW_LINE INDENT DP = [ [ 0 ] * DP_s for _ in range ( ln ) ] NEW_LINE for i in range ( DP_s ) : NEW_LINE INDENT DP [ 0 ] [ i ] = i + 1 NEW_LINE DEDENT for i in range ( 1 , ln ) : NEW_LINE INDENT for j in range ( 1 , DP_s ) : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i - 1 ] [ j - 1 ] + DP [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return DP [ ln - 1 ] [ DP_s - 1 ] NEW_LINE DEDENT print ( getNumStrictMonotone ( 2 ) ) NEW_LINE;"Number of decimal numbers of length k , that are strict monotone | Python3 program to count numbers of k digits that are strictly monotone . ; DP [ i ] [ j ] is going to store monotone numbers of length i + 1 considering j + 1 digits ( 1 , 2 , 3 , . .9 ) ; Unit length numbers ; Building dp [ ] in bottom up ; Driver code"
Python;def chordCnt ( A ) : NEW_LINE INDENT n = 2 * A NEW_LINE dpArray = [ 0 ] * ( n + 1 ) NEW_LINE dpArray [ 0 ] = 1 NEW_LINE dpArray [ 2 ] = 1 NEW_LINE for i in range ( 4 , n + 1 , 2 ) : NEW_LINE INDENT for j in range ( 0 , i - 1 , 2 ) : NEW_LINE INDENT dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) NEW_LINE DEDENT DEDENT return int ( dpArray [ n ] ) NEW_LINE DEDENT N = 2 NEW_LINE print ( chordCnt ( N ) ) NEW_LINE N = 1 NEW_LINE print ( chordCnt ( N ) ) NEW_LINE N = 4 NEW_LINE print ( chordCnt ( N ) ) NEW_LINE;"Count ways to divide circle using N non | python code to count ways to divide circle using N non - intersecting chords . ; n = no of points required ; dp array containing the sum ; returning the required number ; driver code"
Python;"row = 5 NEW_LINE col = 5 NEW_LINE def isPath ( arr ) : NEW_LINE INDENT arr [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , row ) : NEW_LINE INDENT if ( arr [ i ] [ 0 ] != - 1 ) : NEW_LINE INDENT arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] NEW_LINE DEDENT DEDENT for j in range ( 1 , col ) : NEW_LINE INDENT if ( arr [ 0 ] [ j ] != - 1 ) : NEW_LINE INDENT arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] NEW_LINE DEDENT DEDENT for i in range ( 1 , row ) : NEW_LINE INDENT for j in range ( 1 , col ) : NEW_LINE INDENT if ( arr [ i ] [ j ] != - 1 ) : NEW_LINE INDENT arr [ i ] [ j ] = max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return ( arr [ row - 1 ] [ col - 1 ] == 1 ) NEW_LINE DEDENT arr = [ [ 0 , 0 , 0 , - 1 , 0 ] , [ - 1 , 0 , 0 , - 1 , - 1 ] , [ 0 , 0 , 0 , - 1 , 0 ] , [ - 1 , 0 , - 1 , 0 , - 1 ] , [ 0 , 0 , - 1 , 0 , 0 ] ] NEW_LINE if ( isPath ( arr ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Check for possible path in 2D matrix | Python3 program to find if there is path from top left to right bottom ; to find the path from top left to bottom right ; set arr [ 0 ] [ 0 ] = 1 ; Mark reachable ( from top left ) nodes in first row and first column . ; Mark reachable nodes in remaining matrix . ; return yes if right bottom index is 1 ; Given array ; path from arr [ 0 ] [ 0 ] to arr [ row ] [ col ]"
Python;def nswp ( n ) : NEW_LINE INDENT if n == 0 or n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) NEW_LINE DEDENT n = 3 NEW_LINE print ( nswp ( n ) ) NEW_LINE;"Newmanâ €“ Shanksâ €“ Williams prime | return nth NewmanaShanksaWilliams prime ; Base case ; Recursive step ; Driven Program"
Python;"def nswp ( n ) : NEW_LINE INDENT dp = [ 1 for x in range ( n + 1 ) ] ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] = ( 2 * dp [ i - 1 ] + dp [ i - 2 ] ) ; NEW_LINE DEDENT return dp [ n ] ; NEW_LINE DEDENT n = 3 ; NEW_LINE print ( nswp ( n ) ) ; NEW_LINE";"Newman Shanks Williams prime | return nth Newman Shanks Williams prime ; Base case ; Finding nth Newman Shanks Williams prime ; Driver Code"
Python;"MAX = 256 NEW_LINE def numberofways ( A , B , N , M ) : NEW_LINE INDENT pos = [ [ ] for _ in range ( MAX ) ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT pos [ ord ( B [ i ] ) ] . append ( i + 1 ) NEW_LINE DEDENT dpl = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT for j in range ( 1 , M + 1 ) : NEW_LINE INDENT if A [ i - 1 ] == B [ j - 1 ] : NEW_LINE INDENT dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dpl [ i ] [ j ] = max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT LCS = dpl [ N ] [ M ] NEW_LINE dpr = [ [ 0 ] * ( M + 2 ) for _ in range ( N + 2 ) ] NEW_LINE for i in range ( N , 0 , - 1 ) : NEW_LINE INDENT for j in range ( M , 0 , - 1 ) : NEW_LINE INDENT if A [ i - 1 ] == B [ j - 1 ] : NEW_LINE INDENT dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT dpr [ i ] [ j ] = max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) NEW_LINE DEDENT DEDENT DEDENT ans = 0 NEW_LINE for i in range ( N + 1 ) : NEW_LINE INDENT for j in range ( MAX ) : NEW_LINE INDENT for x in pos [ j ] : NEW_LINE INDENT if dpl [ i ] [ x - 1 ] + dpr [ i + 1 ] [ x + 1 ] == LCS : NEW_LINE INDENT ans += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A = "" aa "" NEW_LINE B = "" baaa "" NEW_LINE N = len ( A ) NEW_LINE M = len ( B ) NEW_LINE print ( numberofways ( A , B , N , M ) ) NEW_LINE DEDENT";"Number of ways to insert a character to increase the LCS by one | Python Program to Number of ways to insert a character to increase LCS by one ; Return the Number of ways to insert a character to increase the Longest Common Subsequence by one ; Insert all positions of all characters in string B ; Longest Common Subsequence ; Longest Common Subsequence from reverse ; inserting character between position i and i + 1 ; Driver Code"
Python;"def lcs ( X , Y , m , n ) : NEW_LINE INDENT L = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 2 * ( ord ( X [ i - 1 ] ) - 48 ) NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ m ] [ n ] NEW_LINE DEDENT def findMinCost ( X , Y ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE cost = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT cost += ord ( X [ i ] ) - 48 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT cost += ord ( Y [ i ] ) - 48 NEW_LINE DEDENT ans = cost - lcs ( X , Y , m , n ) NEW_LINE return ans NEW_LINE DEDENT X = ""3759"" NEW_LINE Y = ""9350"" NEW_LINE print ( "" Minimum ▁ Cost ▁ to ▁ make ▁ two ▁ strings ▁ "" , "" identical ▁ is ▁ = ▁ "" , findMinCost ( X , Y ) ) NEW_LINE";"Minimum cost to make two strings identical by deleting the digits | Function to returns cost of removing the identical characters in LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ] ; Following steps build L [ m + 1 ] [ n + 1 ] in bottom up fashion . Note that L [ i ] [ j ] contains cost of removing identical characters in LCS of X [ 0. . i - 1 ] and Y [ 0. . j - 1 ] ; If both characters are same , add both of them ; Otherwise find the maximum cost among them ; Returns cost of making X [ ] and Y [ ] identical ; Find LCS of X [ ] and Y [ ] ; Initialize the cost variable ; Find cost of all acters in both strings ; Driver program to test above function"
Python;"def isSubSeqDivisible ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE arr = [ int ( ch ) for ch in st ] NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT for j in range ( i , l ) : NEW_LINE INDENT for k in range ( j , l ) : NEW_LINE INDENT if ( arr [ i ] % 8 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 and i != j ) : NEW_LINE INDENT return True NEW_LINE DEDENT elif ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 and i != j and j != k and i != k ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT DEDENT return False NEW_LINE DEDENT st = ""3144"" NEW_LINE if ( isSubSeqDivisible ( st ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Given a large number , check if a subsequence of digits is divisible by 8 | Function to calculate any permutation divisible by 8. If such permutation exists , the function will return that permutation else it will return - 1 ; Generating all possible permutations and checking if any such permutation is divisible by 8 ; Driver function"
Python;"Str = ""129365"" NEW_LINE mp = { } NEW_LINE no = 8 NEW_LINE while ( no < 100 ) : NEW_LINE INDENT no = no + 8 NEW_LINE mp [ ( no // 10 ) % 10 ] = no % 10 NEW_LINE DEDENT visited = [ False ] * 10 NEW_LINE for i in range ( len ( Str ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( Str [ i ] == '8' ) : NEW_LINE INDENT print ( "" Yes "" , end = "" "" ) NEW_LINE break NEW_LINE DEDENT if visited [ mp [ ord ( Str [ i ] ) - ord ( '0' ) ] ] : NEW_LINE INDENT print ( "" Yes "" , end = "" "" ) NEW_LINE break NEW_LINE DEDENT visited [ ord ( Str [ i ] ) - ord ( '0' ) ] = True NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Given a large number , check if a subsequence of digits is divisible by 8 | Python3 program to check if given string has a subsequence divisible by 8 ; map key will be tens place digit of number that is divisible by 8 and value will be units place digit ; For filling the map let start with initial value 8 ; key is digit at tens place and value is digit at units place mp . insert ( { key , value } ) ; Create a hash to check if we visited a number ; Iterate from last index to 0 th index ; If 8 is present in string then 8 divided 8 hence print yes ; considering present character as the second digit of two digits no we check if the value of this key is marked in hash or not If marked then we a have a number divisible by 8 ; If no subsequence divisible by 8"
Python;"def maxLength ( s , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' and s [ i + 1 ] == ' ) ' ) : NEW_LINE INDENT dp [ i ] [ i + 1 ] = 2 NEW_LINE DEDENT DEDENT for l in range ( 2 , n ) : NEW_LINE INDENT i = - 1 NEW_LINE for j in range ( l , n ) : NEW_LINE INDENT i += 1 NEW_LINE if ( s [ i ] == ' ( ' and s [ j ] == ' ) ' ) : NEW_LINE INDENT dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE DEDENT s = "" ( ) ( ( ( ( ( ( ) "" NEW_LINE n = len ( s ) NEW_LINE print ( maxLength ( s , n ) ) NEW_LINE";"Length of Longest Balanced Subsequence | Python3 program to find length of the longest balanced subsequence ; Considering all balanced substrings of length 2 ; Considering all other substrings ; Driver Code"
Python;"def maxSumBitonicSubArr ( arr , n ) : NEW_LINE INDENT max_sum = - 10 ** 9 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT j = i NEW_LINE while ( j + 1 < n and arr [ j ] < arr [ j + 1 ] ) : NEW_LINE INDENT j += 1 NEW_LINE DEDENT while ( i < j and arr [ i ] <= 0 ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT k = j NEW_LINE while ( k + 1 < n and arr [ k ] > arr [ k + 1 ] ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT last = k NEW_LINE while ( k > j and arr [ k ] <= 0 ) : NEW_LINE INDENT k -= 1 NEW_LINE DEDENT nn = arr [ i : j + 1 ] NEW_LINE sum_inc = sum ( nn ) NEW_LINE nn = arr [ j : k + 1 ] NEW_LINE sum_dec = sum ( nn ) NEW_LINE sum_all = sum_inc + sum_dec - arr [ j ] NEW_LINE max_sum = max ( [ max_sum , sum_inc , sum_dec , sum_all ] ) NEW_LINE i = max ( last , i + 1 ) NEW_LINE DEDENT return max_sum NEW_LINE DEDENT arr = [ 5 , 3 , 9 , 2 , 7 , 6 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( "" Maximum ▁ Sum ▁ = ▁ "" , maxSumBitonicSubArr ( arr , n ) ) NEW_LINE arr2 = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n2 = len ( arr2 ) NEW_LINE print ( "" Maximum ▁ Sum ▁ = ▁ "" , maxSumBitonicSubArr ( arr2 , n2 ) ) NEW_LINE arr3 = [ 5 , 4 , 3 , 2 , 1 ] NEW_LINE n3 = len ( arr3 ) NEW_LINE print ( "" Maximum ▁ Sum ▁ = ▁ "" , maxSumBitonicSubArr ( arr3 , n3 ) ) NEW_LINE arr4 = [ 5 , 5 , 5 , 5 ] NEW_LINE n4 = len ( arr4 ) NEW_LINE print ( "" Maximum ▁ Sum ▁ = ▁ "" , maxSumBitonicSubArr ( arr4 , n4 ) ) NEW_LINE arr5 = [ - 1 , 0 , 1 , 2 , 3 , 1 , 0 , - 1 , - 10 ] NEW_LINE n5 = len ( arr5 ) NEW_LINE print ( "" Maximum ▁ Sum ▁ = ▁ "" , maxSumBitonicSubArr ( arr5 , n5 ) ) NEW_LINE arr6 = [ - 1 , 0 , 1 , 2 , 0 , - 1 , - 2 , 0 , 1 , 3 ] NEW_LINE n6 = len ( arr6 ) NEW_LINE print ( "" Maximum ▁ Sum ▁ = ▁ "" , maxSumBitonicSubArr ( arr6 , n6 ) ) NEW_LINE";"Maximum sum bitonic subarray | Function to find the maximum sum bitonic subarray . ; to store the maximum sum bitonic subarray ; Find the longest increasing subarray starting at i . ; Now we know that a [ i . . j ] is an increasing subarray . Remove non - positive elements from the left side as much as possible . ; Find the longest decreasing subarray starting at j . ; Now we know that a [ j . . k ] is a decreasing subarray . Remove non - positive elements from the right side as much as possible . last is needed to keep the last seen element . ; Compute the max sum of the increasing part . ; Compute the max sum of the decreasing part . ; The overall max sum is the sum of both parts minus the peak element , because it was counted twice . ; If the next element is equal to the current , i . e . arr [ i + 1 ] == arr [ i ] , last == i . To ensure the algorithm has progress , get the max of last and i + 1. ; required maximum sum ; The example from the article , the answer is 19. ; Always increasing , the answer is 15. ; Always decreasing , the answer is 15. ; All are equal , the answer is 5. ; The whole array is bitonic , but the answer is 7. ; The answer is 4 ( the tail ) ."
Python;"import sys NEW_LINE def smallestSumSubarr ( arr , n ) : NEW_LINE INDENT min_ending_here = sys . maxsize NEW_LINE min_so_far = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( min_ending_here > 0 ) : NEW_LINE INDENT min_ending_here = arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT min_ending_here += arr [ i ] NEW_LINE DEDENT min_so_far = min ( min_so_far , min_ending_here ) NEW_LINE DEDENT return min_so_far NEW_LINE DEDENT arr = [ 3 , - 4 , 2 , - 3 , - 1 , 7 , - 5 ] NEW_LINE n = len ( arr ) NEW_LINE print "" Smallest ▁ sum : ▁ "" , smallestSumSubarr ( arr , n ) NEW_LINE";"Smallest sum contiguous subarray | Python program to find the smallest sum contiguous subarray ; function to find the smallest sum contiguous subarray ; to store the minimum value that is ending up to the current index ; to store the minimum value encountered so far ; traverse the array elements ; if min_ending_here > 0 , then it could not possibly contribute to the minimum sum further ; else add the value arr [ i ] to min_ending_here ; update min_so_far ; required smallest sum contiguous subarray value ; Driver code"
Python;def ans ( n ) : NEW_LINE INDENT if ( n < 6 ) : NEW_LINE INDENT return n NEW_LINE DEDENT return n % 6 + 10 * ( ans ( n // 6 ) ) - 1 NEW_LINE DEDENT def getSpecialNumber ( N ) : NEW_LINE INDENT return ans ( N ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 17 NEW_LINE answer = getSpecialNumber ( N ) NEW_LINE print ( answer ) NEW_LINE DEDENT;"n | Python3 code to find nth number with digits 0 , 1 , 2 , 3 , 4 , 5 ; If the Number is less than 6 return the number as it is . ; Call the function again and again the get the desired result . And convert the number to base 6. ; Decrease the Number by 1 and Call ans function to convert N to base 6 ; Driver code"
Python;MAX = 300 NEW_LINE dp = [ [ 0 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE def minimumSquare ( m , n ) : NEW_LINE INDENT vertical_min = 10000000000 NEW_LINE horizontal_min = 10000000000 NEW_LINE if n == 13 and m == 11 : NEW_LINE INDENT return 6 NEW_LINE DEDENT if m == 13 and n == 11 : NEW_LINE INDENT return 6 NEW_LINE DEDENT if m == n : NEW_LINE INDENT return 1 NEW_LINE DEDENT if dp [ m ] [ n ] != 0 : NEW_LINE INDENT return dp [ m ] [ n ] NEW_LINE DEDENT for i in range ( 1 , m // 2 + 1 ) : NEW_LINE INDENT horizontal_min = min ( minimumSquare ( i , n ) + minimumSquare ( m - i , n ) , horizontal_min ) NEW_LINE DEDENT for j in range ( 1 , n // 2 + 1 ) : NEW_LINE INDENT vertical_min = min ( minimumSquare ( m , j ) + minimumSquare ( m , n - j ) , vertical_min ) NEW_LINE DEDENT dp [ m ] [ n ] = min ( vertical_min , horizontal_min ) NEW_LINE return dp [ m ] [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 30 NEW_LINE n = 35 NEW_LINE print ( minimumSquare ( m , n ) ) NEW_LINE DEDENT;"Paper Cut into Minimum Number of Squares | Set 2 | Python3 program to find minimum number of squares to cut a paper using Dynamic Programming ; Returns min number of squares needed ; Initializing max values to vertical_min and horizontal_min ; N = 11 & M = 13 is a special case ; If the given rectangle is already a square ; If the answer for the given rectangle is previously calculated return that answer ; The rectangle is cut horizontally and vertically into two parts and the cut with minimum value is found for every recursive call . ; Calculating the minimum answer for the rectangles with width equal to n and length less than m for finding the cut point for the minimum answer ; Calculating the minimum answer for the rectangles with width equal to n and length less than m for finding the cut point for the minimum answer ; Minimum of the vertical cut or horizontal cut to form a square is the answer ; Driver code ; Function call"
Python;"def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def nCr ( n , r ) : NEW_LINE INDENT return fact ( n ) // ( ( fact ( r ) * fact ( n - r ) ) ) NEW_LINE DEDENT n = 2 NEW_LINE print ( "" Number ▁ of ▁ Non - Decreasing ▁ digits : ▁ "" , nCr ( n + 9 , 9 ) ) NEW_LINE";"Number of n | Returns factorial of n ; returns nCr ; Driver code"
Python;"def countWays ( n , k ) : NEW_LINE INDENT total = k NEW_LINE mod = 1000000007 NEW_LINE same , diff = 0 , k NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT same = diff NEW_LINE diff = total * ( k - 1 ) NEW_LINE diff = diff % mod NEW_LINE total = ( same + diff ) % mod NEW_LINE DEDENT return total NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n , k = 3 , 2 NEW_LINE print ( countWays ( n , k ) ) NEW_LINE DEDENT";"Painting Fence Algorithm | Returns count of ways to color k posts using k colors ; There are k ways to color first post ; There are 0 ways for single post to violate ( same color_ and k ways to not violate ( different color ) ; Fill for 2 posts onwards ; Current same is same as previous diff ; We always have k - 1 choices for next post ; Total choices till i . ; Driver code"
Python;"def sumOfSubstrings ( num ) : NEW_LINE INDENT sum = 0 NEW_LINE INDENT mf = 1 NEW_LINE for i in range ( len ( num ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT sum = sum + ( int ( num [ i ] ) ) * ( i + 1 ) * mf NEW_LINE mf = mf * 10 + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = ""6759"" NEW_LINE print ( sumOfSubstrings ( num ) ) NEW_LINE DEDENT";"Sum of all substrings of a string representing a number | Set 2 ( Constant Extra Space ) | Returns sum of all substring of num ; Initialize result ; Here traversing the array in reverse order . Initializing loop from last element . mf is multiplying factor . ; Each time sum is added to its previous sum . Multiplying the three factors as explained above . int ( s [ i ] ) is done to convert char to int . ; Making new multiplying factor as explained above . ; Driver code to test above methods"
Python;def maxSumWithK ( a , n , k ) : NEW_LINE INDENT maxSum = [ 0 for i in range ( n ) ] NEW_LINE maxSum [ 0 ] = a [ 0 ] NEW_LINE curr_max = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT curr_max = max ( a [ i ] , curr_max + a [ i ] ) NEW_LINE maxSum [ i ] = curr_max NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( k ) : NEW_LINE INDENT sum += a [ i ] NEW_LINE DEDENT result = sum NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = sum + a [ i ] - a [ i - k ] NEW_LINE result = max ( result , sum ) NEW_LINE result = max ( result , sum + maxSum [ i - k ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT a = [ 1 , 2 , 3 , - 10 , - 3 ] NEW_LINE k = 4 NEW_LINE n = len ( a ) NEW_LINE print ( maxSumWithK ( a , n , k ) ) NEW_LINE;"Largest sum subarray with at | Returns maximum sum of a subarray with at - least k elements . ; maxSum [ i ] is going to store maximum sum till index i such that a [ i ] is part of the sum . ; We use Kadane 's algorithm to fill maxSum[]  Below code is taken from method3 of  https:www.geeksforgeeks.org/largest-sum-contiguous-subarray/ ; Sum of first k elements ; Use the concept of sliding window ; Compute sum of k elements ending with a [ i ] . ; Update result if required ; Include maximum sum till [ i - k ] also if it increases overall max . ; Driver code"
Python;def getTotalNumberOfSequences ( m , n ) : NEW_LINE INDENT if m < n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = ( getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m // 2 , n - 1 ) ) NEW_LINE return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 10 NEW_LINE n = 4 NEW_LINE print ( ' Total ▁ number ▁ of ▁ possible ▁ sequences : ' , getTotalNumberOfSequences ( m , n ) ) NEW_LINE DEDENT;"Sequences of given length where every element is more than or equal to twice of previous | Recursive function to find the number of special sequences ; A special sequence cannot exist if length n is more than the maximum value m . ; If n is 0 , found an empty special sequence ; There can be two possibilities : ( 1 ) Reduce last element value ( 2 ) Consider last element as m and reduce number of terms ; Driver Code"
Python;def getTotalNumberOfSequences ( m , n ) : NEW_LINE INDENT T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT T [ i ] [ j ] = 0 NEW_LINE DEDENT elif i < j : NEW_LINE INDENT T [ i ] [ j ] = 0 NEW_LINE DEDENT elif j == 1 : NEW_LINE INDENT T [ i ] [ j ] = i NEW_LINE DEDENT else : NEW_LINE INDENT T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i // 2 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return T [ m ] [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 10 NEW_LINE n = 4 NEW_LINE print ( ' Total ▁ number ▁ of ▁ possible ▁ sequences ▁ ' , getTotalNumberOfSequences ( m , n ) ) NEW_LINE DEDENT;"Sequences of given length where every element is more than or equal to twice of previous | DP based function to find the number of special sequence ; define T and build in bottom manner to store number of special sequences of length n and maximum value m ; Base case : If length of sequence is 0 or maximum value is 0 , there cannot exist any special sequence ; if length of sequence is more than the maximum value , special sequence cannot exist ; If length of sequence is 1 then the number of special sequences is equal to the maximum value For example with maximum value 2 and length 1 , there can be 2 special sequences { 1 } , { 2 } ; otherwise calculate ; Driver Code"
Python;"def lcs ( str1 , str2 , m , n ) : NEW_LINE INDENT L = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ m ] [ n ] NEW_LINE DEDENT def printMinDelAndInsert ( str1 , str2 ) : NEW_LINE INDENT m = len ( str1 ) NEW_LINE n = len ( str2 ) NEW_LINE leng = lcs ( str1 , str2 , m , n ) NEW_LINE print ( "" Minimum ▁ number ▁ of ▁ deletions ▁ = ▁ "" , m - leng , sep = ' ▁ ' ) NEW_LINE print ( "" Minimum ▁ number ▁ of ▁ insertions ▁ = ▁ "" , n - leng , sep = ' ▁ ' ) NEW_LINE DEDENT str1 = "" heap "" NEW_LINE str2 = "" pea "" NEW_LINE printMinDelAndInsert ( str1 , str2 ) NEW_LINE";"Minimum number of deletions and insertions to transform one string into another | Returns length of length common subsequence for str1 [ 0. . m - 1 ] , str2 [ 0. . n - 1 ] ; Following steps build L [ m + 1 ] [ n + 1 ] in bottom up fashion . Note that L [ i ] [ j ] contains length of LCS of str1 [ 0. . i - 1 ] and str2 [ 0. . j - 1 ] ; L [ m ] [ n ] contains length of LCS for X [ 0. . n - 1 ] and Y [ 0. . m - 1 ] ; function to find minimum number of deletions and insertions ; Driver Code ; Function Call"
Python;"def lis ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE lis = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT lis [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] and lis [ i ] < lis [ j ] + 1 ) : NEW_LINE INDENT lis [ i ] = lis [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( result < lis [ i ] ) : NEW_LINE INDENT result = lis [ i ] NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT def minimumNumberOfDeletions ( arr , n ) : NEW_LINE INDENT len = lis ( arr , n ) NEW_LINE return ( n - len ) NEW_LINE DEDENT arr = [ 30 , 40 , 2 , 5 , 1 , 7 , 45 , 50 , 8 ] NEW_LINE n = len ( arr ) NEW_LINE print ( "" Minimum ▁ number ▁ of ▁ deletions ▁ = ▁ "" , minimumNumberOfDeletions ( arr , n ) ) NEW_LINE";"Minimum number of deletions to make a sorted sequence | lis ( ) returns the length of the longest increasing subsequence in arr [ ] of size n ; Initialize LIS values for all indexes ; Compute optimized LIS values in bottom up manner ; Pick resultimum of all LIS values ; Function to calculate minimum number of deletions ; Find longest increasing subsequence ; After removing elements other than the lis , we get sorted sequence . ; Driver Code"
Python;"inf = 1000000000 ; NEW_LINE def minCost ( a , n , k ) : NEW_LINE INDENT dp = [ [ inf for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] ; NEW_LINE dp [ 0 ] [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , k + 1 ) : NEW_LINE INDENT for m in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; NEW_LINE DEDENT DEDENT DEDENT return dp [ n ] [ k ] ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 2 ; NEW_LINE a = [ 1 , 5 , 8 , 10 ] ; NEW_LINE n = len ( a ) ; NEW_LINE print ( minCost ( a , n , k ) ) ; NEW_LINE DEDENT";"Clustering / Partitioning an array such that sum of square differences is minimum | Python3 program to find minimum cost k partitions of array . ; Returns minimum cost of partitioning a [ ] in k clusters . ; Create a dp [ ] [ ] table and initialize all values as infinite . dp [ i ] [ j ] is going to store optimal partition cost for arr [ 0. . i - 1 ] and j partitions ; Fill dp [ ] [ ] in bottom up manner ; Current ending position ( After i - th iteration result for a [ 0. . i - 1 ] is computed . ; j is number of partitions ; Picking previous partition for current i . ; Driver code"
Python;"' NEW_LINE def lps ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE L = [ [ 0 for x in range ( n ) ] for y in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if ( str [ i ] == str [ j ] and cl == 2 ) : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif ( str [ i ] == str [ j ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT def minimumNumberOfDeletions ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE l = lps ( str ) NEW_LINE return ( n - l ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT str = "" geeksforgeeks "" NEW_LINE print ( "" Minimum ▁ number ▁ of ▁ deletions ▁ = ▁ "" , minimumNumberOfDeletions ( str ) ) NEW_LINE DEDENT";"Minimum number of deletions to make a string palindrome | Returns the length of the longest palindromic subsequence in 'str ; Create a table to store results of subproblems ; Strings of length 1 are palindrome of length 1 ; Build the table . Note that the lower diagonal values of table are useless and not filled in the process . c1 is length of substring ; length of longest palindromic subseq ; function to calculate minimum number of deletions ; Find longest palindromic subsequence ; After removing characters other than the lps , we get palindrome . ; Driver Code"
Python;def offeringNumber ( n , templeHeight ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT left = 0 NEW_LINE right = 0 NEW_LINE for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) : NEW_LINE INDENT left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) : NEW_LINE INDENT right += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT sum += max ( right , left ) + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT arr1 = [ 1 , 2 , 2 ] NEW_LINE print ( offeringNumber ( 3 , arr1 ) ) NEW_LINE arr2 = [ 1 , 4 , 3 , 6 , 2 , 1 ] NEW_LINE print ( offeringNumber ( 6 , arr2 ) ) NEW_LINE;"Temple Offerings | Returns minimum offerings required ; Go through all templs one by one ; Go to left while height keeps increasing ; Go to right while height keeps increasing ; This temple should offer maximum of two values to follow the rule . ; Driver Code"
Python;"def modularSum ( arr , n , m ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT return True NEW_LINE DEDENT DP = [ False for i in range ( m ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( DP [ 0 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT temp = [ False for i in range ( m ) ] NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( DP [ j ] == True ) : NEW_LINE INDENT if ( DP [ ( j + arr [ i ] ) % m ] == False ) : NEW_LINE INDENT temp [ ( j + arr [ i ] ) % m ] = True NEW_LINE DEDENT DEDENT DEDENT for j in range ( m ) : NEW_LINE INDENT if ( temp [ j ] ) : NEW_LINE INDENT DP [ j ] = True NEW_LINE DEDENT DEDENT DP [ arr [ i ] % m ] = True NEW_LINE DEDENT return DP [ 0 ] NEW_LINE DEDENT arr = [ 1 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE m = 5 NEW_LINE print ( "" YES "" ) if ( modularSum ( arr , n , m ) ) else print ( "" NO "" ) NEW_LINE";"Subset with sum divisible by m | Returns true if there is a subset of arr [ ] with sum divisible by m ; This array will keep track of all the possible sum ( after modulo m ) which can be made using subsets of arr [ ] initialising boolean array with all false ; we 'll loop through all the elements of arr[] ; anytime we encounter a sum divisible by m , we are done ; To store all the new encountered sum ( after modulo ) . It is used to make sure that arr [ i ] is added only to those entries for which DP [ j ] was true before current iteration . ; For each element of arr [ ] , we loop through all elements of DP table from 1 to m and we add current element i . e . , arr [ i ] to all those elements which are true in DP table ; if an element is true in DP table ; We update it in temp and update to DP once loop of j is over ; Updating all the elements of temp to DP table since iteration over j is over ; Also since arr [ i ] is a single element subset , arr [ i ] % m is one of the possible sum ; Driver code"
Python;def maxSum ( tri , n ) : NEW_LINE INDENT if n > 1 : NEW_LINE INDENT tri [ 1 ] [ 1 ] = tri [ 1 ] [ 1 ] + tri [ 0 ] [ 0 ] NEW_LINE tri [ 1 ] [ 0 ] = tri [ 1 ] [ 0 ] + tri [ 0 ] [ 0 ] NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT tri [ i ] [ 0 ] = tri [ i ] [ 0 ] + tri [ i - 1 ] [ 0 ] NEW_LINE tri [ i ] [ i ] = tri [ i ] [ i ] + tri [ i - 1 ] [ i - 1 ] NEW_LINE for j in range ( 1 , i ) : NEW_LINE INDENT if tri [ i ] [ j ] + tri [ i - 1 ] [ j - 1 ] >= tri [ i ] [ j ] + tri [ i - 1 ] [ j ] : NEW_LINE INDENT tri [ i ] [ j ] = tri [ i ] [ j ] + tri [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT tri [ i ] [ j ] = tri [ i ] [ j ] + tri [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print max ( tri [ n - 1 ] ) NEW_LINE DEDENT tri = [ [ 1 ] , [ 2 , 1 ] , [ 3 , 3 , 2 ] ] NEW_LINE maxSum ( tri , 3 ) NEW_LINE;"Maximum sum of a path in a Right Number Triangle | tri [ ] [ ] is a 2D array that stores the triangle , n is number of lines or rows . ; Adding the element of row 1 to both the elements of row 2 to reduce a step from the loop ; Traverse remaining rows ; Loop to traverse columns ; tri [ i ] would store the possible combinations of sum of the paths ; array at n - 1 index ( tri [ i ] ) stores all possible adding combination , finding the maximum one out of them ; driver program"
Python;def maximumDifferenceSum ( arr , N ) : NEW_LINE INDENT dp = [ [ 0 , 0 ] for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 NEW_LINE DEDENT for i in range ( N - 1 ) : NEW_LINE INDENT dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ) NEW_LINE dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ) NEW_LINE DEDENT return max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 2 , 1 , 4 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE print ( maximumDifferenceSum ( arr , N ) ) NEW_LINE DEDENT;"Modify array to maximize sum of adjacent differences | Returns maximum - difference - sum with array modifications allowed . ; Initialize dp [ ] [ ] with 0 values . ; for [ i + 1 ] [ 0 ] ( i . e . current modified value is 1 ) , choose maximum from dp [ i ] [ 0 ] + abs ( 1 - 1 ) = dp [ i ] [ 0 ] and dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ; for [ i + 1 ] [ 1 ] ( i . e . current modified value is arr [ i + 1 ] ) , choose maximum from dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) and dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ; Driver Code"
Python;"def countStrUtil ( dp , n , bCount = 1 , cCount = 2 ) : NEW_LINE INDENT if ( bCount < 0 or cCount < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( bCount == 0 and cCount == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ n ] [ bCount ] [ cCount ] != - 1 ) : NEW_LINE INDENT return dp [ n ] [ bCount ] [ cCount ] NEW_LINE DEDENT res = countStrUtil ( dp , n - 1 , bCount , cCount ) NEW_LINE res += countStrUtil ( dp , n - 1 , bCount - 1 , cCount ) NEW_LINE res += countStrUtil ( dp , n - 1 , bCount , cCount - 1 ) NEW_LINE dp [ n ] [ bCount ] [ cCount ] = res NEW_LINE return dp [ n ] [ bCount ] [ cCount ] NEW_LINE DEDENT def countStr ( n ) : NEW_LINE INDENT dp = [ [ [ - 1 for x in range ( n + 2 ) ] for y in range ( 3 ) ] for z in range ( 4 ) ] NEW_LINE return countStrUtil ( dp , n ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 3 NEW_LINE print ( countStr ( n ) ) NEW_LINE DEDENT";"Count of strings that can be formed using a , b and c under given constraints | n is total number of characters . bCount and cCount are counts of ' b ' and ' c ' respectively . ; Base cases ; if we had saw this combination previously ; Three cases , we choose , a or b or c In all three cases n decreases by 1. ; A wrapper over countStrUtil ( ) ; Driver code ; Total number of characters"
Python;N = 8 NEW_LINE dx = [ 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 ] NEW_LINE dy = [ 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 ] NEW_LINE def inside ( x , y ) : NEW_LINE INDENT return ( x >= 0 and x < N and y >= 0 and y < N ) NEW_LINE DEDENT def findProb ( start_x , start_y , steps ) : NEW_LINE INDENT dp1 = [ [ [ 0 for i in range ( N + 5 ) ] for j in range ( N + 5 ) ] for k in range ( steps + 5 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT dp1 [ i ] [ j ] [ 0 ] = 1 NEW_LINE DEDENT DEDENT for s in range ( 1 , steps + 1 ) : NEW_LINE INDENT for x in range ( N ) : NEW_LINE INDENT for y in range ( N ) : NEW_LINE INDENT prob = 0.0 NEW_LINE for i in range ( 8 ) : NEW_LINE INDENT nx = x + dx [ i ] NEW_LINE ny = y + dy [ i ] NEW_LINE if ( inside ( nx , ny ) ) : NEW_LINE INDENT prob += dp1 [ nx ] [ ny ] [ s - 1 ] / 8.0 NEW_LINE DEDENT DEDENT dp1 [ x ] [ y ] [ s ] = prob NEW_LINE DEDENT DEDENT DEDENT return dp1 [ start_x ] [ start_y ] [ steps ] NEW_LINE DEDENT K = 3 NEW_LINE print ( findProb ( 0 , 0 , K ) ) NEW_LINE;"Probability of Knight to remain in the chessboard | size of the chessboard ; Direction vector for the Knight ; returns true if the knight is inside the chessboard ; Bottom up approach for finding the probability to go out of chessboard . ; dp array ; For 0 number of steps , each position will have probability 1 ; for every number of steps s ; for every position ( x , y ) after s number of steps ; For every position reachable from ( x , y ) ; if this position lie inside the board ; store the result ; return the result ; number of steps ; Function Call"
Python;def countSubarray ( arr , n , k ) : NEW_LINE INDENT s = 0 NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( arr [ i ] > k ) : NEW_LINE INDENT i = i + 1 NEW_LINE continue NEW_LINE DEDENT count = 0 NEW_LINE while ( i < n and arr [ i ] <= k ) : NEW_LINE INDENT i = i + 1 NEW_LINE count = count + 1 NEW_LINE DEDENT s = s + ( ( count * ( count + 1 ) ) // 2 ) NEW_LINE DEDENT return ( n * ( n + 1 ) // 2 - s ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( countSubarray ( arr , n , k ) ) NEW_LINE;"Count of subarrays whose maximum element is greater than k | Return number of subarrays whose maximum element is less than or equal to K . ; To store count of subarrays with all elements less than or equal to k . ; Traversing the array . ; If element is greater than k , ignore . ; Counting the subarray length whose each element is less than equal to k . ; Suming number of subarray whose maximum element is less than equal to k . ; Driver code"
Python;def nCr ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT def resultOfAllSubsets ( arr , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT for n in range ( 1 , N + 1 ) : NEW_LINE INDENT result += ( sum * ( nCr ( N - 1 , n - 1 ) ) ) / n NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 7 ] NEW_LINE N = len ( arr ) NEW_LINE print ( resultOfAllSubsets ( arr , N ) ) NEW_LINE;"Sum of average of all subsets | Returns value of Binomial Coefficient C ( n , k ) ; Calculate value of Binomial Coefficient in bottom up manner ; Base Cases ; Calculate value using previously stored values ; Method returns sum of average of all subsets ; Find sum of elements ; looping once for all subset of same size ; each element occurs nCr ( N - 1 , n - 1 ) times while considering subset of size n ; Driver code"
Python;"arr = [ 100 , 1000 , 100 , 1000 , 1 ] NEW_LINE sum = [ - 1 ] * 10000 NEW_LINE def maxSumWO3Consec ( n ) : NEW_LINE INDENT if ( sum [ n ] != - 1 ) : NEW_LINE INDENT return sum [ n ] NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT sum [ n ] = 0 NEW_LINE return sum [ n ] NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT sum [ n ] = arr [ 0 ] NEW_LINE return sum [ n ] NEW_LINE DEDENT if ( n == 2 ) : NEW_LINE INDENT sum [ n ] = arr [ 1 ] + arr [ 0 ] NEW_LINE return sum [ n ] NEW_LINE DEDENT sum [ n ] = max ( max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n ] ) , arr [ n ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) NEW_LINE return sum [ n ] NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = len ( arr ) NEW_LINE print ( maxSumWO3Consec ( n ) ) NEW_LINE DEDENT";"Maximum subsequence sum such that no three are consecutive | Python3 program to find the maximum sum such that no three are consecutive using recursion . ; Returns maximum subsequence sum such that no three elements are consecutive ; 3 Base cases ( process first three elements ) ; Process rest of the elements We have three cases ; Driver code"
Python;def maxSumPairWithDifferenceLessThanK ( arr , N , k ) : NEW_LINE INDENT maxSum = 0 NEW_LINE arr . sort ( ) NEW_LINE i = N - 1 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] < k ) : NEW_LINE INDENT maxSum += arr [ i ] NEW_LINE maxSum += arr [ i - 1 ] NEW_LINE i -= 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return maxSum NEW_LINE DEDENT arr = [ 3 , 5 , 10 , 15 , 17 , 12 , 9 ] NEW_LINE N = len ( arr ) NEW_LINE K = 4 NEW_LINE print ( maxSumPairWithDifferenceLessThanK ( arr , N , K ) ) NEW_LINE;"Maximum sum of pairs with specific difference | Method to return maximum sum we can get by finding less than K difference pairs ; Sort elements to ensure every i and i - 1 is closest possible pair ; To get maximum possible sum , iterate from largest to smallest , giving larger numbers priority over smaller numbers . ; Case I : Diff of arr [ i ] and arr [ i - 1 ] is less then K , add to maxSum Case II : Diff between arr [ i ] and arr [ i - 1 ] is not less then K , move to next i since with sorting we know , arr [ i ] - arr [ i - 1 ] < arr [ i ] - arr [ i - 2 ] and so on . ; Assuming only positive numbers . ; When a match is found skip this pair ; Driver Code"
Python;"def countGroups ( position , previous_sum , length , num ) : NEW_LINE INDENT if ( position == length ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( position , length ) : NEW_LINE INDENT sum = sum + int ( num [ i ] ) NEW_LINE if ( sum >= previous_sum ) : NEW_LINE INDENT res = res + countGroups ( i + 1 , sum , length , num ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT num = ""1119"" NEW_LINE len = len ( num ) NEW_LINE print ( countGroups ( 0 , 0 , len , num ) ) NEW_LINE DEDENT";"Count digit groupings of a number with given constraints | Function to find the subgroups ; Terminating Condition ; sum of digits ; Traverse all digits from current position to rest of the length of string ; If forward_sum is greater than the previous sum , then call the method again ; Note : We pass current sum as previous sum ; Total number of subgroups till the current position ; Driver Code"
Python;"MAX = 40 NEW_LINE dp = [ [ - 1 for i in range ( 9 * MAX + 1 ) ] for i in range ( MAX ) ] NEW_LINE def countGroups ( position , previous_sum , length , num ) : NEW_LINE INDENT if ( position == length ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( dp [ position ] [ previous_sum ] != - 1 ) : NEW_LINE INDENT return dp [ position ] [ previous_sum ] NEW_LINE DEDENT dp [ position ] [ previous_sum ] = 0 NEW_LINE res = 0 NEW_LINE sum = 0 NEW_LINE for i in range ( position , length ) : NEW_LINE INDENT sum += ( ord ( num [ i ] ) - ord ( '0' ) ) NEW_LINE if ( sum >= previous_sum ) : NEW_LINE INDENT res += countGroups ( i + 1 , sum , length , num ) NEW_LINE DEDENT DEDENT dp [ position ] [ previous_sum ] = res NEW_LINE return res NEW_LINE DEDENT num = ""1119"" NEW_LINE len = len ( num ) NEW_LINE print ( countGroups ( 0 , 0 , len , num ) ) NEW_LINE";"Count digit groupings of a number with given constraints | Maximum length of input number string ; A memoization table to store results of subproblems length of string is 40 and maximum sum will be 9 * 40 = 360. ; Function to find the count of splits with given condition ; Terminating Condition ; If already evaluated for a given sub problem then return the value ; countGroups for current sub - group is 0 ; sum of digits ; Traverse all digits from current position to rest of the length of string ; If forward_sum is greater than the previous sum , then call the method again ; Note : We pass current sum as previous sum ; total number of subgroups till the current position ; Driver Code"
Python;"def KnapSack ( val , wt , n , W ) : NEW_LINE INDENT dp = [ 0 ] * ( W + 1 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( W , wt [ i ] , - 1 ) : NEW_LINE INDENT dp [ j ] = max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; NEW_LINE DEDENT DEDENT return dp [ W ] ; NEW_LINE DEDENT val = [ 7 , 8 , 4 ] ; NEW_LINE wt = [ 3 , 8 , 6 ] ; NEW_LINE W = 10 ; n = 3 ; NEW_LINE print ( KnapSack ( val , wt , n , W ) ) ; NEW_LINE";"A Space Optimized DP solution for 0 | val [ ] is for storing maximum profit for each weight wt [ ] is for storing weights n number of item W maximum capacity of bag dp [ W + 1 ] to store final result ; initially profit with 0 to W KnapSack capacity is 0 ; iterate through all items ; traverse dp array from right to left ; above line finds out maximum of dp [ j ] ( excluding ith element value ) and val [ i ] + dp [ j - wt [ i ] ] ( including ith element value and the profit with "" KnapSack ▁ capacity ▁ - ▁ ith ▁ element ▁ weight "" ) * ; Driver program to test the cases"
Python;"def count ( a , b ) : NEW_LINE INDENT m = len ( a ) NEW_LINE n = len ( b ) NEW_LINE lookup = [ [ 0 ] * ( n + 1 ) for i in range ( m + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT lookup [ 0 ] [ i ] = 0 NEW_LINE DEDENT for i in range ( m + 1 ) : NEW_LINE INDENT lookup [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT if a [ i - 1 ] == b [ j - 1 ] : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return lookup [ m ] [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = "" GeeksforGeeks "" NEW_LINE b = "" Gks "" NEW_LINE print ( count ( a , b ) ) NEW_LINE DEDENT";"Find number of times a string occurs as a subsequence in given string | Iterative DP function to find the number of times the second string occurs in the first string , whether continuous or discontinuous ; Create a table to store results of sub - problems ; If first string is empty ; If second string is empty ; Fill lookup [ ] [ ] in bottom up manner ; If last characters are same , we have two options - 1. consider last characters of both strings in solution 2. ignore last character of first string ; If last character are different , ignore last character of first string ; Driver code"
Python;def lenOfLongestGP ( sett , n ) : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT return n NEW_LINE DEDENT if n == 2 : NEW_LINE INDENT return 2 if ( sett [ 1 ] % sett [ 0 ] == 0 ) else 1 NEW_LINE DEDENT sett . sort ( ) NEW_LINE L = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE llgp = 1 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT if sett [ n - 1 ] % sett [ i ] == 0 : NEW_LINE INDENT L [ i ] [ n - 1 ] = 2 NEW_LINE if 2 > llgp : NEW_LINE INDENT llgp = 2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT L [ i ] [ n - 1 ] = 1 NEW_LINE DEDENT DEDENT L [ n - 1 ] [ n - 1 ] = 1 NEW_LINE for j in range ( n - 2 , 0 , - 1 ) : NEW_LINE INDENT i = j - 1 NEW_LINE k = j + 1 NEW_LINE while i >= 0 and k <= n - 1 : NEW_LINE INDENT if sett [ i ] * sett [ k ] < sett [ j ] * sett [ j ] : NEW_LINE INDENT k += 1 NEW_LINE DEDENT elif sett [ i ] * sett [ k ] > sett [ j ] * sett [ j ] : NEW_LINE INDENT if sett [ j ] % sett [ i ] == 0 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT if sett [ j ] % sett [ i ] == 0 : NEW_LINE INDENT L [ i ] [ j ] = L [ j ] [ k ] + 1 NEW_LINE if L [ i ] [ j ] > llgp : NEW_LINE INDENT llgp = L [ i ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = 1 NEW_LINE DEDENT i -= 1 NEW_LINE k += 1 NEW_LINE DEDENT DEDENT while i >= 0 : NEW_LINE INDENT if sett [ j ] % sett [ i ] == 0 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = 1 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT return llgp NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT set1 = [ 1 , 3 , 9 , 27 , 81 , 243 ] NEW_LINE n1 = len ( set1 ) NEW_LINE print ( lenOfLongestGP ( set1 , n1 ) ) NEW_LINE set2 = [ 1 , 3 , 4 , 9 , 7 , 27 ] NEW_LINE n2 = len ( set2 ) NEW_LINE print ( lenOfLongestGP ( set2 , n2 ) ) NEW_LINE set3 = [ 2 , 3 , 5 , 7 , 11 , 13 ] NEW_LINE n3 = len ( set3 ) NEW_LINE print ( lenOfLongestGP ( set3 , n3 ) ) NEW_LINE DEDENT;"Longest Geometric Progression | Returns length of the longest GP subset of sett [ ] ; Base cases ; let us sort the sett first ; An entry L [ i ] [ j ] in this table stores LLGP with sett [ i ] and sett [ j ] as first two elements of GP and j > i . ; Initialize result ( A single element is always a GP ) ; Initialize values of last column ; Consider every element as second element of GP ; Search for i and k for j ; Two cases when i , j and k don 't form  a GP. ; i , j and k form GP , LLGP with i and j as first two elements is equal to LLGP with j and k as first two elements plus 1. L [ j ] [ k ] must have been filled before as we run the loop from right side ; Update overall LLGP ; Change i and k to fill more L [ i ] [ j ] values for current j ; If the loop was stopped due to k becoming more than n - 1 , set the remaining entries in column j as 1 or 2 based on divisibility of sett [ j ] by sett [ i ] ; Return result ; Driver code"
Python;"class Pair : NEW_LINE INDENT def __init__ ( self , a , b ) : NEW_LINE INDENT self . a = a NEW_LINE self . b = b NEW_LINE DEDENT def __lt__ ( self , other ) : NEW_LINE INDENT return self . a < other . a NEW_LINE DEDENT DEDENT def maxChainLength ( arr ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE L = [ [ ] for x in range ( len ( arr ) ) ] NEW_LINE L [ 0 ] . append ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ j ] . b < arr [ i ] . a and len ( L [ j ] ) > len ( L [ i ] ) ) : NEW_LINE INDENT L [ i ] = L [ j ] NEW_LINE DEDENT DEDENT L [ i ] . append ( arr [ i ] ) NEW_LINE DEDENT maxChain = [ ] NEW_LINE for x in L : NEW_LINE INDENT if len ( x ) > len ( maxChain ) : NEW_LINE INDENT maxChain = x NEW_LINE DEDENT DEDENT for pair in maxChain : NEW_LINE INDENT print ( "" ( { a } , { b } ) "" . format ( a = pair . a , b = pair . b ) , end = "" ▁ "" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ Pair ( 5 , 29 ) , Pair ( 39 , 40 ) , Pair ( 15 , 28 ) , Pair ( 27 , 40 ) , Pair ( 50 , 90 ) ] NEW_LINE n = len ( arr ) NEW_LINE maxChainLength ( arr ) NEW_LINE DEDENT";"Print Maximum Length Chain of Pairs | Dynamic Programming solution to construct Maximum Length Chain of Pairs ; comparator function for sort function ; Function to construct Maximum Length Chain of Pairs ; Sort by start time ; L [ i ] stores maximum length of chain of arr [ 0. . i ] that ends with arr [ i ] . ; L [ 0 ] is equal to arr [ 0 ] ; start from index 1 ; for every j less than i ; L [ i ] = { Max ( L [ j ] ) } + arr [ i ] where j < i and arr [ j ] . b < arr [ i ] . a ; print max length vector ; Driver Code"
Python;"def _print ( arr : list , size : int ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT def printLBS ( arr : list , n : int ) : NEW_LINE INDENT LIS = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT LIS [ i ] = [ ] NEW_LINE DEDENT LIS [ 0 ] . append ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( ( arr [ j ] < arr [ i ] ) and ( len ( LIS [ j ] ) > len ( LIS [ i ] ) ) ) : NEW_LINE INDENT LIS [ i ] = LIS [ j ] . copy ( ) NEW_LINE DEDENT DEDENT LIS [ i ] . append ( arr [ i ] ) NEW_LINE DEDENT LDS = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT LDS [ i ] = [ ] NEW_LINE DEDENT LDS [ n - 1 ] . append ( arr [ n - 1 ] ) NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( n - 1 , i , - 1 ) : NEW_LINE INDENT if ( ( arr [ j ] < arr [ i ] ) and ( len ( LDS [ j ] ) > len ( LDS [ i ] ) ) ) : NEW_LINE INDENT LDS [ i ] = LDS [ j ] . copy ( ) NEW_LINE DEDENT DEDENT LDS [ i ] . append ( arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT LDS [ i ] = list ( reversed ( LDS [ i ] ) ) NEW_LINE DEDENT max = 0 NEW_LINE maxIndex = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( len ( LIS [ i ] ) + len ( LDS [ i ] ) - 1 > max ) : NEW_LINE INDENT max = len ( LIS [ i ] ) + len ( LDS [ i ] ) - 1 NEW_LINE maxIndex = i NEW_LINE DEDENT DEDENT _print ( LIS [ maxIndex ] , len ( LIS [ maxIndex ] ) - 1 ) NEW_LINE _print ( LDS [ maxIndex ] , len ( LDS [ maxIndex ] ) ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 11 , 2 , 10 , 4 , 5 , 2 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE printLBS ( arr , n ) NEW_LINE DEDENT";"Printing Longest Bitonic Subsequence | Utility function to print Longest Bitonic Subsequence ; Function to construct and print Longest Bitonic Subsequence ; LIS [ i ] stores the length of the longest increasing subsequence ending with arr [ i ] ; initialize LIS [ 0 ] to arr [ 0 ] ; Compute LIS values from left to right ; for every j less than i ; LDS [ i ] stores the length of the longest decreasing subsequence starting with arr [ i ] ; initialize LDS [ n - 1 ] to arr [ n - 1 ] ; Compute LDS values from right to left ; for every j greater than i ; reverse as vector as we 're inserting at end ; LDS [ i ] now stores Maximum Decreasing Subsequence of arr [ i . . n ] that starts with arr [ i ] ; Find maximum value of size of LIS [ i ] + size of LDS [ i ] - 1 ; print all but last element of LIS [ maxIndex ] vector ; print all elements of LDS [ maxIndex ] vector ; Driver Code"
Python;"def isKPalDP ( str1 , str2 , m , n ) : NEW_LINE INDENT dp = [ [ 0 ] * ( n + 1 ) for _ in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if not i : NEW_LINE elif not j : NEW_LINE elif ( str1 [ i - 1 ] == str2 [ j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE DEDENT DEDENT return dp [ m ] [ n ] NEW_LINE DEDENT def isKPal ( string , k ) : NEW_LINE INDENT revStr = string [ : : - 1 ] NEW_LINE l = len ( string ) NEW_LINE return ( isKPalDP ( string , revStr , l , l ) <= k * 2 ) NEW_LINE DEDENT string = "" acdcb "" NEW_LINE k = 2 NEW_LINE print ( "" Yes "" if isKPal ( string , k ) else "" No "" ) NEW_LINE";"Find if string is K | Find if given string is K - Palindrome or not ; Create a table to store results of subproblems ; Fill dp [ ] [ ] in bottom up manner ; If first string is empty , only option is to remove all characters of second string ; If second string is empty , only option is to remove all characters of first string ; If last characters are same , ignore last character and recur for remaining string ; If last character are different , remove it and find minimum ; dp [ i ] [ j ] = 1 + min ( dp [ i - 1 ] [ j ] , Remove from str1 ( dp [ i ] [ j - 1 ] ) ) Remove from str2 ; Returns true if str is k palindrome . ; Driver program"
Python;"def lcs ( X , Y ) : NEW_LINE INDENT m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE L = [ [ 0 for i in range ( n + 1 ) ] for j in range ( 2 ) ] NEW_LINE bi = bool NEW_LINE for i in range ( m ) : NEW_LINE INDENT bi = i & 1 NEW_LINE for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ bi ] [ j ] = 0 NEW_LINE DEDENT elif ( X [ i ] == Y [ j - 1 ] ) : NEW_LINE INDENT L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ bi ] [ j ] = max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ bi ] [ n ] NEW_LINE DEDENT X = "" AGGTAB "" NEW_LINE Y = "" GXTXAYB "" NEW_LINE print ( "" Length ▁ of ▁ LCS ▁ is "" , lcs ( X , Y ) ) NEW_LINE";"A Space Optimized Solution of LCS | Returns length of LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ] ; Find lengths of two strings ; Binary index , used to index current row and previous row . ; Compute current binary index ; Last filled entry contains length of LCS for X [ 0. . n - 1 ] and Y [ 0. . m - 1 ] ; Driver Code"
Python;"import math NEW_LINE def subsetXOR ( arr , n , k ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if arr [ i ] > max_ele : NEW_LINE INDENT max_ele = arr [ i ] NEW_LINE DEDENT DEDENT m = ( 1 << ( int ) ( math . log2 ( max_ele ) + 1 ) ) - 1 NEW_LINE if ( k > m ) : NEW_LINE return 0 NEW_LINE dp = [ [ 0 for i in range ( m + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE dp [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( m + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = ( dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] ) NEW_LINE DEDENT DEDENT return dp [ n ] [ k ] NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( "" Count ▁ of ▁ subsets ▁ is "" , subsetXOR ( arr , n , k ) ) NEW_LINE";"Count number of subsets having a particular XOR value | Python 3 arr dynamic programming solution to finding the number of subsets having xor of their elements as k ; Returns count of subsets of arr [ ] with XOR value equals to k . ; Find maximum element in arr [ ] ; Maximum possible XOR value ; Initializing all the values of dp [ i ] [ j ] as 0 ; The xor of empty subset is 0 ; Fill the dp table ; The answer is the number of subset from set arr [ 0. . n - 1 ] having XOR of elements as k ; Driver Code"
Python;"import sys NEW_LINE def findMin ( a , n ) : NEW_LINE INDENT su = 0 NEW_LINE su = sum ( a ) NEW_LINE dp = [ [ 0 for i in range ( su + 1 ) ] for j in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = True NEW_LINE DEDENT for j in range ( 1 , su + 1 ) : NEW_LINE INDENT dp [ 0 ] [ j ] = False NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , su + 1 ) : NEW_LINE INDENT dp [ i ] [ j ] = dp [ i - 1 ] [ j ] NEW_LINE if a [ i - 1 ] <= j : NEW_LINE INDENT dp [ i ] [ j ] |= dp [ i - 1 ] [ j - a [ i - 1 ] ] NEW_LINE DEDENT DEDENT DEDENT diff = sys . maxsize NEW_LINE for j in range ( su // 2 , - 1 , - 1 ) : NEW_LINE INDENT if dp [ n ] [ j ] == True : NEW_LINE INDENT diff = su - ( 2 * j ) NEW_LINE break NEW_LINE DEDENT DEDENT return diff NEW_LINE DEDENT a = [ 3 , 1 , 4 , 2 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( "" The ▁ minimum ▁ difference ▁ between ▁ "" ""2 ▁ sets ▁ is ▁ "" , findMin ( a , n ) ) NEW_LINE";"Partition a set into two subsets such that the difference of subset sums is minimum | A Recursive Python3 program to solve minimum sum partition problem . ; Returns the minimum value of the difference of the two sets . ; Calculate sum of all elements ; Create an 2d list to store results of subproblems ; Initialize first column as true . 0 sum is possible with all elements . ; Initialize top row , except dp [ 0 ] [ 0 ] , as false . With 0 elements , no other sum except 0 is possible ; Fill the partition table in bottom up manner ; If i 'th element is excluded ; If i 'th element is included ; Initialize difference of two sums . ; Find the largest j such that dp [ n ] [ j ] is true where j loops from sum / 2 t0 0 ; Driver code"
Python;"MAX = 100 NEW_LINE dp = [ [ [ [ - 1 for col in range ( 2 ) ] for col in range ( MAX ) ] for row in range ( MAX ) ] for row in range ( MAX ) ] NEW_LINE def countPathsUtil ( i , j , k , d ) : NEW_LINE INDENT if ( i < 0 or j < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( i == 0 and j == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( k == 0 ) : NEW_LINE INDENT if ( d == 0 and i == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( d == 1 and j == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ i ] [ j ] [ k ] [ d ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ j ] [ k ] [ d ] NEW_LINE DEDENT if ( d == 0 ) : NEW_LINE INDENT dp [ i ] [ j ] [ k ] [ d ] = countPathsUtil ( i , j - 1 , k , d ) + countPathsUtil ( i - 1 , j , k - 1 , not d ) NEW_LINE return dp [ i ] [ j ] [ k ] [ d ] NEW_LINE DEDENT dp [ i ] [ j ] [ k ] [ d ] = countPathsUtil ( i - 1 , j , k , d ) + countPathsUtil ( i , j - 1 , k - 1 , not d ) NEW_LINE return dp [ i ] [ j ] [ k ] [ d ] NEW_LINE DEDENT def countPaths ( i , j , k ) : NEW_LINE INDENT if ( i == 0 and j == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return countPathsUtil ( i - 1 , j , k , 1 ) + countPathsUtil ( i , j - 1 , k , 0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 3 NEW_LINE n = 3 NEW_LINE k = 2 NEW_LINE print ( "" Number ▁ of ▁ paths ▁ is "" , countPaths ( m - 1 , n - 1 , k ) ) NEW_LINE DEDENT";"Count number of paths with at | Python3 program to count number of paths with maximum k turns allowed ; table to store results of subproblems ; Returns count of paths to reach ( i , j ) from ( 0 , 0 ) using at - most k turns . d is current direction , d = 0 indicates along row , d = 1 indicates along column . ; If invalid row or column indexes ; If current cell is top left itself ; If 0 turns left ; If direction is row , then we can reach here only if direction is row and row is 0. ; If direction is column , then we can reach here only if direction is column and column is 0. ; If this subproblem is already evaluated ; If current direction is row , then count paths for two cases 1 ) We reach here through previous row . 2 ) We reach here through previous column , so number of turns k reduce by 1. ; Similar to above if direction is column ; This function mainly initializes ' dp ' array as - 1 and calls countPathsUtil ( ) ; If ( 0 , 0 ) is target itself ; Recur for two cases : moving along row and along column ; Driver Code"
Python;MAX = 1000 NEW_LINE dp = [ [ - 1 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE def minSizeRec ( arr , low , high , k ) : NEW_LINE INDENT if dp [ low ] [ high ] != - 1 : NEW_LINE INDENT return dp [ low ] [ high ] NEW_LINE DEDENT if ( high - low + 1 ) < 3 : NEW_LINE INDENT return ( high - low + 1 ) NEW_LINE DEDENT res = 1 + minSizeRec ( arr , low + 1 , high , k ) NEW_LINE for i in range ( low + 1 , high ) : NEW_LINE INDENT for j in range ( i + 1 , high + 1 ) : NEW_LINE INDENT if ( arr [ i ] == ( arr [ low ] + k ) and arr [ j ] == ( arr [ low ] + 2 * k ) and minSizeRec ( arr , low + 1 , i - 1 , k ) == 0 and minSizeRec ( arr , i + 1 , j - 1 , k ) == 0 ) : NEW_LINE INDENT res = min ( res , minSizeRec ( arr , j + 1 , high , k ) ) NEW_LINE DEDENT DEDENT DEDENT dp [ low ] [ high ] = res NEW_LINE return res NEW_LINE DEDENT def minSize ( arr , n , k ) : NEW_LINE INDENT dp = [ [ - 1 for i in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE return minSizeRec ( arr , 0 , n - 1 , k ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 5 , 6 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE k = 1 NEW_LINE print ( minSize ( arr , n , k ) ) NEW_LINE DEDENT;"Find minimum possible size of array with given rules for removing elements | Python3 program to find size of minimum possible array after removing elements according to given rules ; dp [ i ] [ j ] denotes the minimum number of elements left in the subarray arr [ i . . j ] . ; If already evaluated ; If size of array is less than 3 ; Initialize result as the case when first element is separated ( not removed using given rules ) ; Now consider all cases when first element forms a triplet and removed . Check for all possible triplets ( low , i , j ) ; Check if this triplet follows the given rules of removal . And elements between ' low ' and ' i ' , and between ' i ' and ' j ' can be recursively removed . ; Insert value in table and return result ; This function mainly initializes dp table and calls recursive function minSizeRec ; Driver program to test above function"
Python;def countSol ( coeff , start , end , rhs ) : NEW_LINE INDENT if ( rhs == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT result = 0 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT if ( coeff [ i ] <= rhs ) : NEW_LINE INDENT result += countSol ( coeff , i , end , rhs - coeff [ i ] ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT coeff = [ 2 , 2 , 5 ] NEW_LINE rhs = 4 NEW_LINE n = len ( coeff ) NEW_LINE print ( countSol ( coeff , 0 , n - 1 , rhs ) ) NEW_LINE;"Find number of solutions of a linear equation of n variables | Recursive function that returns count of solutions for given rhs value and coefficients coeff [ stat ... end ] ; Base case ; Initialize count of solutions ; One by one subtract all smaller or equal coefficients and recur ; Driver Code"
Python;"def getMaxRec ( string , i , n , lookup ) : NEW_LINE INDENT if i >= n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if lookup [ i ] != - 1 : NEW_LINE INDENT return lookup [ i ] NEW_LINE DEDENT ans = 1 + getMaxRec ( string , i + 1 , n , lookup ) NEW_LINE if i + 1 < n : NEW_LINE INDENT if string [ i ] != string [ i + 1 ] : NEW_LINE INDENT ans = max ( 4 + getMaxRec ( string , i + 2 , n , lookup ) , ans ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = max ( 3 + getMaxRec ( string , i + 2 , n , lookup ) , ans ) NEW_LINE DEDENT DEDENT lookup [ i ] = ans NEW_LINE return ans NEW_LINE DEDENT def getMaxWeight ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE lookup = [ - 1 ] * ( n ) NEW_LINE return getMaxRec ( string , 0 , len ( string ) , lookup ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT string = "" AAAAABB "" NEW_LINE print ( "" Maximum ▁ weight ▁ of ▁ a ▁ transformation ▁ of "" , string , "" is "" , getMaxWeight ( string ) ) NEW_LINE DEDENT";"Maximum weight transformation of a given string | Returns weight of the maximum weight transformation ; Base Case ; If this subproblem is already solved ; Don 't make pair, so  weight gained is 1 ; If we can make pair ; If elements are dissimilar ; if elements are similar so for making a pair we toggle any of them . Since toggle cost is 1 so overall weight gain becomes 3 ; save and return maximum of above cases ; Initializes lookup table and calls getMaxRec ( ) ; Create and initialize lookup table ; Call recursive function ; Driver Code"
Python;"import sys NEW_LINE def steps ( source , step , dest ) : NEW_LINE INDENT if ( abs ( source ) > ( dest ) ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT if ( source == dest ) : NEW_LINE INDENT return step NEW_LINE DEDENT pos = steps ( source + step + 1 , step + 1 , dest ) NEW_LINE neg = steps ( source - step - 1 , step + 1 , dest ) NEW_LINE return min ( pos , neg ) NEW_LINE DEDENT dest = 11 ; NEW_LINE print ( "" No . ▁ of ▁ steps ▁ required "" , "" ▁ to ▁ reach ▁ "" , dest , "" ▁ is ▁ "" , steps ( 0 , 0 , dest ) ) ; NEW_LINE";"Minimum steps to reach a destination | python program to count number of steps to reach a point ; source -> source vertex step -> value of last step taken dest -> destination vertex ; base cases ; if we go on positive side ; if we go on negative side ; minimum of both cases ; Driver Code"
Python;"def LCSubStr ( s , t , n , m ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( m + 1 ) ] for j in range ( 2 ) ] NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( s [ i - 1 ] == t [ j - 1 ] ) : NEW_LINE INDENT dp [ i % 2 ] [ j ] = dp [ ( i - 1 ) % 2 ] [ j - 1 ] + 1 NEW_LINE if ( dp [ i % 2 ] [ j ] > res ) : NEW_LINE INDENT res = dp [ i % 2 ] [ j ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT dp [ i % 2 ] [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT X = "" OldSite : GeeksforGeeks . org "" NEW_LINE Y = "" NewSite : GeeksQuiz . com "" NEW_LINE m = len ( X ) NEW_LINE n = len ( Y ) NEW_LINE print ( LCSubStr ( X , Y , m , n ) ) NEW_LINE";"Longest Common Substring | DP | Function to find the length of the longest LCS ; Create DP table ; Driver Code ; Function call"
Python;"def lcs ( i , j , count ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT return count NEW_LINE DEDENT if ( X [ i - 1 ] == Y [ j - 1 ] ) : NEW_LINE INDENT count = lcs ( i - 1 , j - 1 , count + 1 ) NEW_LINE DEDENT count = max ( count , max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) NEW_LINE return count NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT X = "" abcdxyz "" NEW_LINE Y = "" xyzabcd "" NEW_LINE n = len ( X ) NEW_LINE m = len ( Y ) NEW_LINE print ( lcs ( n , m , 0 ) ) NEW_LINE DEDENT";"Longest Common Substring | DP | Returns length of function for longest common substring of X [ 0. . m - 1 ] and Y [ 0. . n - 1 ] ; Driver code"
Python;"def possibleEqualArray ( A , N ) : NEW_LINE INDENT tot_XOR = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT tot_XOR ^= A [ i ] NEW_LINE DEDENT if ( tot_XOR == 0 ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE return NEW_LINE DEDENT cur_XOR = 0 NEW_LINE cnt = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT cur_XOR ^= A [ i ] NEW_LINE if ( cur_XOR == tot_XOR ) : NEW_LINE INDENT cnt += 1 NEW_LINE cur_XOR = 0 NEW_LINE DEDENT DEDENT if ( cnt > 2 ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 0 , 2 , 2 ] NEW_LINE N = len ( A ) NEW_LINE possibleEqualArray ( A , N ) NEW_LINE DEDENT";"Make Array elements equal by replacing adjacent elements with their XOR | Function to check if it is possible to make all the array elements equal using the given operation ; Stores the XOR of all elements of array A [ ] ; Case 1 , check if the XOR of the array A [ ] is 0 ; Maintains the XOR till the current element ; Iterate over the array ; If the current XOR is equal to the total XOR increment the count and initialize current XOR as 0 ; Print Answer ; Driver Code ; Function Call"
Python;"def countPalindrome ( S ) : NEW_LINE INDENT N = len ( S ) NEW_LINE Z = [ 0 ] * N NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT if i <= r : NEW_LINE INDENT Z [ i ] = min ( r - i + 1 , Z [ i - 1 ] ) NEW_LINE DEDENT while ( ( i + Z [ i ] ) < N and ( S [ Z [ i ] ] == S [ i + Z [ i ] ] ) ) : NEW_LINE INDENT Z [ i ] += 1 NEW_LINE DEDENT if ( ( i + Z [ i ] - 1 ) > r ) : NEW_LINE INDENT l = ir = i + Z [ i ] - 1 NEW_LINE DEDENT DEDENT sum = 0 NEW_LINE for i in range ( 0 , len ( Z ) ) : NEW_LINE INDENT sum += Z [ i ] + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT S = "" abab "" NEW_LINE print ( countPalindrome ( S ) ) NEW_LINE";"Count of palindromes that can be obtained by concatenating equal length prefix and substrings | Function to calculate the number of palindromes ; Calculation of Z - array ; Calculation of sigma ( Z [ i ] + 1 ) ; return the count ; Given String"
Python;"def printSubsInDelimeters ( string ) : NEW_LINE INDENT dels = [ ] ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == ' [ ' ) : NEW_LINE INDENT dels . append ( i ) ; NEW_LINE DEDENT elif ( string [ i ] == ' ] ' and len ( dels ) != 0 ) : NEW_LINE INDENT pos = dels [ - 1 ] ; NEW_LINE dels . pop ( ) ; NEW_LINE length = i - 1 - pos ; NEW_LINE ans = string [ pos + 1 : pos + 1 + length ] ; NEW_LINE print ( ans ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT string = "" [ This ▁ is ▁ first ] ▁ ignored ▁ text ▁ [ This ▁ is ▁ second ] "" ; NEW_LINE printSubsInDelimeters ( string ) ; NEW_LINE DEDENT";"Extract substrings between any pair of delimiters | Function to print strings present between any pair of delimeters ; Stores the indices ; If opening delimeter is encountered ; If closing delimeter is encountered ; Extract the position of opening delimeter ; Length of substring ; Extract the substring ; Driver Code"
Python;"def printDiagonalTraversal ( nums ) : NEW_LINE INDENT m = len ( nums ) NEW_LINE q = [ ] NEW_LINE q . append ( [ 0 , 0 ] ) NEW_LINE while ( len ( q ) != 0 ) : NEW_LINE INDENT p = q [ 0 ] NEW_LINE q . pop ( 0 ) ; NEW_LINE print ( nums [ p [ 0 ] ] [ p [ 1 ] ] , end = "" ▁ "" ) NEW_LINE if ( p [ 1 ] == 0 and p [ 0 ] + 1 < m ) : NEW_LINE INDENT q . append ( [ p [ 0 ] + 1 , p [ 1 ] ] ) ; NEW_LINE DEDENT if ( p [ 1 ] + 1 < len ( nums [ p [ 0 ] ] ) ) : NEW_LINE INDENT q . append ( [ p [ 0 ] , p [ 1 ] + 1 ] ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE printDiagonalTraversal ( arr ) ; NEW_LINE DEDENT";"Print matrix elements from top | Function to traverse the matrix diagonally upwards ; Store the number of rows ; Initialize queue ; Push the index of first element i . e . , ( 0 , 0 ) ; Get the front element ; Pop the element at the front ; Insert the element below if the current element is in first column ; Insert the right neighbour if it exists ; Driver Code ; Given vector of vectors arr ; Function call"
Python;"def restore ( arr , N ) : NEW_LINE INDENT result = [ ] NEW_LINE mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if not arr [ i ] in mp : NEW_LINE INDENT result . append ( arr [ i ] ) NEW_LINE mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT def print_result ( result ) : NEW_LINE INDENT for i in range ( len ( result ) ) : NEW_LINE INDENT print ( result [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT arr = [ 1 , 13 , 1 , 24 , 13 , 24 , 2 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE print_result ( restore ( arr , N ) ) NEW_LINE DEDENT main ( ) NEW_LINE";"Find original sequence from Array containing the sequence merged many times in order | Function that returns the restored permutation ; List to store the result ; Map to mark the elements which are taken in result ; Checking if the element is coming first time ; Push in result vector ; Mark it in the map ; Return the answer ; Function to print the result ; Driver code ; Given array ; Function call"
Python;"def restore ( arr , N ) : NEW_LINE INDENT result = [ ] NEW_LINE count1 = 1 NEW_LINE s = set ( [ ] ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE if ( len ( s ) == count1 ) : NEW_LINE INDENT result . append ( arr [ i ] ) NEW_LINE count1 += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT def print_result ( result ) : NEW_LINE INDENT for i in range ( len ( result ) ) : NEW_LINE INDENT print ( result [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 13 , 1 , 24 , 13 , 24 , 2 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE print_result ( restore ( arr , N ) ) NEW_LINE DEDENT";"Find original sequence from Array containing the sequence merged many times in order | Function that returns the restored permutation ; Vector to store the result ; Set to insert unique elements ; Check if the element is coming first time ; Push in result vector ; Function to print the result ; Driver Code ; Given Array ; Function Call"
Python;"def sum ( n ) : NEW_LINE INDENT return n * ( n - 1 ) // 2 NEW_LINE DEDENT def BSpattern ( N ) : NEW_LINE INDENT Val = 0 NEW_LINE Pthree = 0 , NEW_LINE cnt = 0 NEW_LINE initial = - 1 NEW_LINE s = "" * * "" NEW_LINE for i in range ( N ) : NEW_LINE INDENT cnt = 0 NEW_LINE if ( i > 0 ) : NEW_LINE INDENT print ( s , end = "" "" ) NEW_LINE s += "" * * "" NEW_LINE DEDENT for j in range ( i , N ) : NEW_LINE INDENT if ( i > 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT Val += 1 NEW_LINE print ( Val , end = "" "" ) NEW_LINE print ( 0 , end = "" "" ) NEW_LINE DEDENT if ( i == 0 ) : NEW_LINE INDENT Sumbeforelast = sum ( Val ) * 2 NEW_LINE Pthree = Val + Sumbeforelast + 1 NEW_LINE initial = Pthree NEW_LINE DEDENT initial = initial - cnt NEW_LINE Pthree = initial NEW_LINE for k in range ( i , N ) : NEW_LINE INDENT print ( Pthree , end = "" "" ) NEW_LINE Pthree += 1 NEW_LINE if ( k != N - 1 ) : NEW_LINE INDENT print ( 0 , end = "" "" ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT DEDENT N = 5 NEW_LINE BSpattern ( N ) NEW_LINE";"Program to print the pattern 1020304017018019020 * * 50607014015016 * * * * 809012013 * * * * * * 10011. . . | Function to find the sum of N integers from 1 to N ; Function to print the given pattern ; Iterate over [ 0 , N - 1 ] ; Sub - Pattern - 1 ; Sub - Pattern - 2 ; Count the number of element in rows and sub - pattern 2 and 3 will have same rows ; Increment Val to print the series 1 , 2 , 3 , 4 , 5 ... ; Finally , add the ( N - 1 ) th element i . e . , 5 and increment it by 1 ; Initial is used to give the initial value of the row in Sub - Pattern 3 ; Sub - Pattern 3 ; Skip printing zero at the last ; Given N ; Function call"
Python;"def checkprefix ( A , B ) : NEW_LINE INDENT s1 = str ( A ) NEW_LINE s2 = str ( B ) NEW_LINE n1 = len ( s1 ) NEW_LINE n2 = len ( s2 ) NEW_LINE if n1 < n2 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 0 , n2 ) : NEW_LINE INDENT if s1 [ i ] != s2 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = 12345 NEW_LINE B = 12 NEW_LINE result = checkprefix ( A , B ) NEW_LINE if result : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT";"Check if a number starts with another number or not | Function to check if B is a prefix of A or not ; Convert numbers into strings ; Find the length of s1 and s2 ; Base case ; Traverse the string s1 and s2 ; If at any index characters are unequal then return False ; Return true ; Driver code ; Given numbers ; Function call ; If B is a prefix of A , then print Yes"
Python;"def possibleToReach ( x , y , z ) : NEW_LINE INDENT if ( z < abs ( x ) + abs ( y ) or ( z - abs ( x ) - abs ( y ) ) % 2 ) : NEW_LINE INDENT print ( "" Not ▁ Possible "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Possible "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 5 NEW_LINE y = 5 NEW_LINE z = 11 NEW_LINE possibleToReach ( x , y , z ) NEW_LINE DEDENT";"Check if it is possible to reach ( x , y ) from origin in exactly Z steps using only plus movements | Function to check if it is possible to reach ( x , y ) from origin in exactly z steps ; Condition if we can 't reach in Z steps ; Driver Code ; Destination pocoordinate ; Number of steps allowed ; Function call"
Python;def nCycle ( N ) : NEW_LINE INDENT return ( N ) * ( N - 1 ) + 1 NEW_LINE DEDENT N = 4 NEW_LINE print ( nCycle ( N ) ) NEW_LINE;"Number of cycles in a Polygon with lines from Centroid to Vertices | Function to find the Number of Cycles ; Driver code"
Python;import math NEW_LINE a = [ 0 ] * 65 NEW_LINE def Count ( i ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( i < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a [ i ] == 0 ) : NEW_LINE INDENT a [ i ] = ( i + 1 ) + 2 * Count ( i - 1 ) NEW_LINE return a [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT return a [ i ] NEW_LINE DEDENT DEDENT def solve ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT i = int ( math . log2 ( n ) ) NEW_LINE n = n - pow ( 2 , i ) NEW_LINE sum = sum + ( i + 1 ) + Count ( i - 1 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 7 NEW_LINE print ( solve ( n ) ) NEW_LINE;"Sum of consecutive bit differences of first N non | Python3 program for the above problem ; Recursive function to count the sum of bit differences of numbers from 1 to pow ( 2 , ( i + 1 ) ) - 1 ; Base cases ; Recursion call if the sum of bit difference of numbers around i are not calculated ; Return the sum of bit differences if already calculated ; Function to calculate the sum of bit differences up to N ; Nearest smaller power of 2 ; Remaining numbers ; Calculate the count of bit diff ; Driver code"
Python;"import math NEW_LINE def count_ht ( s , N ) : NEW_LINE INDENT if s == "" H "" : NEW_LINE INDENT h = math . floor ( N / 2 ) NEW_LINE t = math . ceil ( N / 2 ) NEW_LINE DEDENT elif s == "" T "" : NEW_LINE INDENT h = math . ceil ( N / 2 ) NEW_LINE t = math . floor ( N / 2 ) NEW_LINE DEDENT return [ h , t ] NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT C = "" H "" NEW_LINE N = 5 NEW_LINE l = count_ht ( C , n ) NEW_LINE print ( "" Head ▁ = ▁ "" , l [ 0 ] ) NEW_LINE print ( "" Tail ▁ = ▁ "" , l [ 1 ] ) NEW_LINE DEDENT";"Count of total Heads and Tails after N flips in a coin | Function to find count of head and tail ; Check if initially all the coins are facing towards head ; Check if initially all the coins are facing towards tail ; Driver Code"
Python;"def findPalindrome ( C ) : NEW_LINE INDENT S = C [ : : - 1 ] NEW_LINE C = C [ : ] + ' & ' + S NEW_LINE n = len ( C ) NEW_LINE longestPalindrome = [ 0 for i in range ( n ) ] NEW_LINE longestPalindrome [ 0 ] = 0 NEW_LINE ll = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( C [ i ] == C [ ll ] ) : NEW_LINE INDENT ll += 1 NEW_LINE longestPalindrome [ i ] = ll NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( ll != 0 ) : NEW_LINE INDENT ll = longestPalindrome [ ll - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT longestPalindrome [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT ans = C [ 0 : longestPalindrome [ n - 1 ] ] NEW_LINE return ans NEW_LINE DEDENT def findAns ( s ) : NEW_LINE INDENT A = "" "" NEW_LINE B = "" "" NEW_LINE F = "" "" NEW_LINE i = 0 NEW_LINE j = len ( s ) - 1 NEW_LINE ll = len ( s ) NEW_LINE while ( i < j and s [ i ] == s [ j ] ) : NEW_LINE INDENT i = i + 1 NEW_LINE j = j - 1 NEW_LINE DEDENT if ( i > 0 ) : NEW_LINE INDENT A = s [ 0 : i ] NEW_LINE B = s [ ll - i : ll ] NEW_LINE DEDENT if ( ll > 2 * i ) : NEW_LINE INDENT C = s [ i : i + ( len ( s ) - 2 * i ) ] NEW_LINE D = findPalindrome ( C ) NEW_LINE C = C [ : : - 1 ] NEW_LINE E = findPalindrome ( C ) NEW_LINE if ( len ( D ) > len ( E ) ) : NEW_LINE INDENT F = D NEW_LINE DEDENT else : NEW_LINE INDENT F = E NEW_LINE DEDENT DEDENT answer = A + F + B NEW_LINE return answer NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT str = "" abcdefghiedcba "" NEW_LINE print ( findAns ( str ) ) NEW_LINE DEDENT";"Longest palindromic string possible after removal of a substring | Function to find the longest palindrome from the start of the string using KMP match ; Append S ( reverse of C ) to C ; Use KMP algorithm ; Function to return longest palindromic string possible from the given string after removal of any substring ; Initialize three strings A , B AND F ; Loop to find longest substrings from both ends which are reverse of each other ; Proceed to third step of our approach ; Remove the substrings A and B ; Find the longest palindromic substring from beginning of C ; Find the longest palindromic substring from end of C ; Store the maximum of D and E in F ; Find the final answer ; Driver code"
Python;"def nthTerm ( N ) : NEW_LINE INDENT nth = 0 ; NEW_LINE if ( N % 2 == 1 ) : NEW_LINE INDENT nth = ( N * N ) + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT nth = ( N * N ) - 1 ; NEW_LINE DEDENT return nth ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 5 ; NEW_LINE print ( nthTerm ( N ) ) ; NEW_LINE DEDENT";"Find Nth term of the series 2 , 3 , 10 , 15 , 26. ... | Function to find Nth term ; Nth term ; Driver Method"
Python;"def nthTerm ( N ) : NEW_LINE INDENT nth = 0 ; first_term = 12 ; NEW_LINE nth = ( first_term * ( pow ( 2 , N - 1 ) ) ) + 11 * ( ( pow ( 2 , N - 1 ) ) - 1 ) ; NEW_LINE return nth ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 5 ; NEW_LINE print ( nthTerm ( N ) ) ; NEW_LINE DEDENT";"Find the Nth term in series 12 , 35 , 81 , 173 , 357 , ... | Function to find Nth term ; Nth term ; Driver Method"
Python;"def nthTerm ( N ) : NEW_LINE INDENT nth = 0 ; first_term = 4 ; NEW_LINE pi = 1 ; po = 1 ; NEW_LINE n = N ; NEW_LINE while ( n > 1 ) : NEW_LINE INDENT pi *= n - 1 ; NEW_LINE n -= 1 ; NEW_LINE po *= 2 ; NEW_LINE DEDENT nth = ( first_term * pi ) // po ; NEW_LINE return nth ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 5 ; NEW_LINE print ( nthTerm ( N ) ) ; NEW_LINE DEDENT";"Find Nth term of the series 4 , 2 , 2 , 3 , 6 , ... | Function to find Nth term ; Nth term ; Driver code"
Python;from math import gcd as __gcd NEW_LINE def finalNum ( arr , n ) : NEW_LINE INDENT result = arr [ 0 ] NEW_LINE for i in arr : NEW_LINE INDENT result = __gcd ( result , i ) NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 3 , 9 , 6 , 36 ] NEW_LINE n = len ( arr ) NEW_LINE print ( finalNum ( arr , n ) ) NEW_LINE;"Find the final number obtained after performing the given operation | Python3 implementation of the approach ; Function to return the final number obtained after performing the given operation ; Find the gcd of the array elements ; Driver code"
Python;"def isVowel ( ch ) : NEW_LINE INDENT if ch in [ ' i ' , ' a ' , ' e ' , ' o ' , ' u ' ] : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT def isSatisfied ( st , n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( isVowel ( st [ i ] ) == False and isVowel ( st [ i - 1 ] ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( isVowel ( st [ i ] ) and isVowel ( st [ i - 1 ] ) == False and isVowel ( st [ i + 1 ] ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT st = "" acaba "" NEW_LINE n = len ( st ) NEW_LINE if ( isSatisfied ( st , n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Check whether all the substrings have number of vowels atleast as that of consonants | Function that returns true if acter ch is a vowel ; Compares two integers according to their digit sum ; Check if there are two consecutive consonants ; Check if there is any vowel surrounded by two consonants ; Driver code"
Python;"def LengthlongestPrefixSuffix ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE lps = [ 0 for i in range ( n ) ] NEW_LINE len1 = 0 NEW_LINE i = 1 NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( s [ i ] == s [ len1 ] ) : NEW_LINE INDENT len1 += 1 NEW_LINE lps [ i ] = len1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( len1 != 0 ) : NEW_LINE INDENT len1 = lps [ len1 - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT lps [ i ] = 0 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT DEDENT res = lps [ n - 1 ] NEW_LINE if ( res > int ( n / 2 ) ) : NEW_LINE INDENT return int ( n / 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT def longestPrefixSuffix ( s ) : NEW_LINE INDENT len1 = LengthlongestPrefixSuffix ( s ) NEW_LINE prefix = "" "" NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT prefix += s [ i ] NEW_LINE DEDENT return prefix NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = "" abcab "" NEW_LINE ans = longestPrefixSuffix ( s ) NEW_LINE if ( ans == "" "" ) : NEW_LINE INDENT print ( "" - 1"" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans ) NEW_LINE DEDENT DEDENT";"Print the longest prefix of the given string which is also the suffix of the same string | Returns length of the longest prefix which is also suffix and the two do not overlap . This function mainly is copy of computeLPSArray ( ) in KMP Algorithm ; Length of the previous longest prefix suffix ; Loop to calculate lps [ i ] for i = 1 to n - 1 ; This is tricky . Consider the example . AAACAAAA and i = 7. The idea is similar to search step . ; If len = 0 ; Since we are looking for non overlapping parts ; Function that returns the prefix ; Get the length of the longest prefix ; Stores the prefix ; Traverse and add characters ; Returns the prefix ; Driver code"
Python;"from math import pow NEW_LINE ' NEW_LINE def no_of_characters ( M ) : NEW_LINE INDENT k = 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( pow ( 2 , k + 1 ) - 2 < M ) : NEW_LINE INDENT k += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return k NEW_LINE DEDENT ' NEW_LINE def print_string ( M ) : NEW_LINE INDENT k = no_of_characters ( M ) NEW_LINE N = M - ( pow ( 2 , k ) - 2 ) NEW_LINE while ( k > 0 ) : NEW_LINE INDENT num = pow ( 2 , k - 1 ) NEW_LINE if ( num >= N ) : NEW_LINE INDENT print ( "" A "" , end = "" "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" B "" , end = "" "" ) NEW_LINE N -= num NEW_LINE DEDENT k -= 1 NEW_LINE DEDENT print ( "" "" , ▁ end ▁ = ▁ "" "" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT M = 30 ; NEW_LINE print_string ( M ) NEW_LINE M = 55 NEW_LINE print_string ( M ) NEW_LINE M = 100 NEW_LINE print_string ( M ) NEW_LINE DEDENT";"Print a number as string of ' A ' and ' B ' in lexicographic order | Python 3 program to implement the above approach ; Function to calculate number of characters in corresponding string of ' A ' and 'B ; Since the minimum number of characters will be 1 ; Calculating number of characters ; Since k length string can represent at most pow ( 2 , k + 1 ) - 2 that is if k = 4 , it can represent at most pow ( 2 , 4 + 1 ) - 2 = 30 so we have to calculate the length of the corresponding string ; return the length of the corresponding string ; Function to print corresponding string of ' A ' and 'B ; Find length of string ; Since the first number that can be represented by k length string will be ( pow ( 2 , k ) - 2 ) + 1 and it will be AAA ... A , k times , therefore , N will store that how much we have to print ; At a particular time , we have to decide whether we have to print ' A ' or ' B ' , this can be check by calculating the value of pow ( 2 , k - 1 ) ; Print new line ; Driver code"
Python;"def updateString ( S , A , B ) : NEW_LINE INDENT l = len ( A ) NEW_LINE i = 0 NEW_LINE while i + l <= len ( S ) : NEW_LINE INDENT curr = S [ i : i + l ] NEW_LINE if curr == A : NEW_LINE INDENT new_string = S [ 0 : i ] + B + S [ i + l : len ( S ) ] NEW_LINE S = new_string NEW_LINE i += l - 1 NEW_LINE DEDENT else : NEW_LINE INDENT new_string = S [ 0 : i ] + A + S [ i + l : len ( S ) ] NEW_LINE S = new_string NEW_LINE i += l - 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return S NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT S = "" aab "" NEW_LINE A = "" aa "" NEW_LINE B = "" bb "" NEW_LINE print ( updateString ( S , A , B ) ) NEW_LINE DEDENT";"Replace two substrings ( of a string ) with each other | Function to return the resultant string ; Iterate through all positions i ; Current sub - string of length = len ( A ) = len ( B ) ; If current sub - string gets equal to A or B ; Update S after replacing A ; Update S after replacing B ; Return the updated string ; Driver code"
Python;"def printPattern ( n , m ) : NEW_LINE INDENT if ( m > 2 * ( n + 1 ) or m < n - 1 ) : NEW_LINE INDENT print ( "" - 1"" , end = "" "" ) NEW_LINE DEDENT elif ( abs ( n - m ) <= 1 ) : NEW_LINE INDENT while ( n > 0 and m > 0 ) : NEW_LINE INDENT print ( ""01"" , end = "" "" ) ; NEW_LINE n -= 1 NEW_LINE m -= 1 NEW_LINE DEDENT if ( n != 0 ) : NEW_LINE INDENT print ( ""0"" , end = "" "" ) NEW_LINE DEDENT if ( m != 0 ) : NEW_LINE INDENT print ( ""1"" , end = "" "" ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while ( m - n > 1 and n > 0 ) : NEW_LINE INDENT print ( ""110"" , end = "" "" ) NEW_LINE m = m - 2 NEW_LINE n = n - 1 NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT print ( ""10"" , end = "" "" ) NEW_LINE n -= 1 NEW_LINE m -= 1 NEW_LINE DEDENT while ( m > 0 ) : NEW_LINE INDENT print ( ""1"" , end = "" "" ) NEW_LINE m -= 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE m = 8 NEW_LINE printPattern ( n , m ) NEW_LINE DEDENT";"Print n 0 s and m 1 s such that no two 0 s and no three 1 s are together | Function to print the required pattern ; When condition fails ; When m = n - 1 ; Driver Code"
Python;"def countDecreasing ( A , n ) : NEW_LINE INDENT len = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( A [ i + 1 ] < A [ i ] ) : NEW_LINE INDENT len += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) // 2 ) ; NEW_LINE len = 1 NEW_LINE DEDENT DEDENT if ( len > 1 ) : NEW_LINE INDENT cnt += ( ( ( len - 1 ) * len ) // 2 ) NEW_LINE DEDENT return cnt NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A = [ 100 , 3 , 1 , 13 ] NEW_LINE n = len ( A ) NEW_LINE print ( countDecreasing ( A , n ) ) NEW_LINE DEDENT";"Find the count of Strictly decreasing Subarrays | Function to count the number of strictly decreasing subarrays ; Initialize length of current decreasing subarray ; Traverse through the array ; If arr [ i + 1 ] is less than arr [ i ] , then increment length ; Else Update count and reset length ; If last length is more than 1 ; Driver Code"
Python;"import sys NEW_LINE def minimumChar ( S1 , S2 ) : NEW_LINE INDENT n , m = len ( S1 ) , len ( S2 ) NEW_LINE ans = sys . maxsize NEW_LINE for i in range ( m - n + 1 ) : NEW_LINE INDENT minRemovedChar = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( S1 [ j ] != S2 [ i + j ] ) : NEW_LINE INDENT minRemovedChar += 1 NEW_LINE DEDENT DEDENT ans = min ( minRemovedChar , ans ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S1 = "" abc "" NEW_LINE S2 = "" paxzk "" NEW_LINE print ( minimumChar ( S1 , S2 ) ) NEW_LINE DEDENT";"Minimum changes required to make first string substring of second string | Python3 program to find the minimum number of characters to be replaced in string S2 , such that S1 is a substring of S2 ; Function to find the minimum number of characters to be replaced in string S2 , such that S1 is a substring of S2 ; Get the sizes of both strings ; Traverse the string S2 ; From every index in S2 , check the number of mis - matching characters in substring of length of S1 ; Take minimum of prev and current mis - match ; return answer ; Driver Code"
Python;"def countFreq ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE res = 0 NEW_LINE for i in range ( N - M + 1 ) : NEW_LINE INDENT j = 0 NEW_LINE while j < M : NEW_LINE INDENT if ( txt [ i + j ] != pat [ j ] ) : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT if ( j == M ) : NEW_LINE INDENT res += 1 NEW_LINE j = 0 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT txt = "" dhimanman "" NEW_LINE pat = "" man "" NEW_LINE print ( countFreq ( pat , txt ) ) NEW_LINE DEDENT";"Frequency of a substring in a string | Simple python program to count occurrences of pat in txt . ; A loop to slide pat [ ] one by one ; For current index i , check for pattern match ; if pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; Driver Code"
Python;"def search ( pat , txt ) : NEW_LINE INDENT M = len ( pat ) NEW_LINE N = len ( txt ) NEW_LINE i = 0 NEW_LINE while i <= N - M : NEW_LINE INDENT for j in xrange ( M ) : NEW_LINE INDENT if txt [ i + j ] != pat [ j ] : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE print "" Pattern ▁ found ▁ at ▁ index ▁ "" + str ( i ) NEW_LINE i = i + M NEW_LINE DEDENT elif j == 0 : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT else : NEW_LINE INDENT i = i + j NEW_LINE DEDENT DEDENT DEDENT txt = "" ABCEABCDABCEABCD "" NEW_LINE pat = "" ABCD "" NEW_LINE search ( pat , txt ) NEW_LINE";"Optimized Naive Algorithm for Pattern Searching | A modified Naive Pattern Searching algorithm that is optimized for the cases when all characters of pattern are different ; For current index i , check for pattern match ; if j == M : if pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; slide the pattern by j ; Driver program to test the above function"
Python;"def findMissingDigit ( a , b , c ) : NEW_LINE INDENT w = 1 NEW_LINE a_mod_11 = 0 NEW_LINE for i in range ( len ( a ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT a_mod_11 = ( a_mod_11 + w * ( ord ( a [ i ] ) - ord ( '0' ) ) ) % 11 NEW_LINE w = w * - 1 NEW_LINE DEDENT b_mod_11 = 0 NEW_LINE w = 1 NEW_LINE for i in range ( len ( b ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT b_mod_11 = ( b_mod_11 + w * ( ord ( b [ i ] ) - ord ( '0' ) ) ) % 11 NEW_LINE w = w * - 1 NEW_LINE DEDENT c_mod_11 = 0 NEW_LINE xSignIsPositive = True NEW_LINE w = 1 NEW_LINE for i in range ( len ( c ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( c [ i ] == ' x ' ) : NEW_LINE INDENT xSignIsPositive = ( w == 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT c_mod_11 = ( c_mod_11 + w * ( ord ( c [ i ] ) - ord ( '0' ) ) ) % 11 NEW_LINE DEDENT w = w * - 1 NEW_LINE DEDENT x = ( ( a_mod_11 * b_mod_11 ) - c_mod_11 ) % 11 NEW_LINE if ( not xSignIsPositive ) : NEW_LINE INDENT x = - x NEW_LINE DEDENT return ( x % 11 + 11 ) % 11 NEW_LINE DEDENT A = ""123456789"" NEW_LINE B = ""987654321"" NEW_LINE C = ""12193263111x635269"" NEW_LINE print ( findMissingDigit ( A , B , C ) ) NEW_LINE";"Find the missing digit in given product of large positive integers | Function to find the replaced digit in the product of a * b ; Keeps track of the sign of the current digit ; Stores the value of a % 11 ; Find the value of a mod 11 for large value of a as per the derived formula ; Stores the value of b % 11 ; Find the value of b mod 11 for large value of a as per the derived formula ; Stores the value of c % 11 ; Keeps track of the sign of x ; If the current digit is the missing digit , then keep the track of its sign ; Find the value of x using the derived equation ; Check if x has a negative sign ; Return positive equivaluent of x mod 11 ; Driver Code"
Python;"def findIfPossible ( N , str_ ) : NEW_LINE INDENT countG = 0 NEW_LINE countF = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if str_ [ i ] == ' G ' : NEW_LINE INDENT countG += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countF += 1 NEW_LINE DEDENT DEDENT if 2 * countF != countG : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT else : NEW_LINE INDENT id = 0 NEW_LINE flag = True NEW_LINE for i in range ( N ) : NEW_LINE INDENT if str_ [ i ] == ' G ' : NEW_LINE INDENT countG -= 1 NEW_LINE id += 1 NEW_LINE DEDENT else : NEW_LINE INDENT countF -= 1 NEW_LINE id -= 1 NEW_LINE DEDENT if id < 0 : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT if countG < countF : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT DEDENT DEDENT n = 6 NEW_LINE str_ = "" GFGFGG "" NEW_LINE findIfPossible ( n , str_ ) NEW_LINE";"Check if a string can be made empty by repeatedly removing given subsequence | Function to check if a string can be made empty by removing all subsequences of the form "" GFG "" or not ; Driver Code"
Python;"def isPossible ( str1 , str2 ) : NEW_LINE INDENT arr = { } NEW_LINE l1 = len ( str1 ) NEW_LINE l2 = len ( str2 ) NEW_LINE possible = True NEW_LINE for i in range ( l1 ) : NEW_LINE INDENT arr [ str1 [ i ] ] = 1 NEW_LINE DEDENT for i in range ( l2 ) : NEW_LINE INDENT if str2 [ i ] != ' ▁ ' : NEW_LINE INDENT if arr [ str2 [ i ] ] == 1 : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT possible = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if possible : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT str1 = "" we ▁ all ▁ love ▁ geeksforgeeks "" NEW_LINE str2 = "" we ▁ all ▁ love ▁ geeks "" NEW_LINE isPossible ( str1 , str2 ) NEW_LINE";"Check whether second string can be formed from characters of first string used any number of times | Function to check if str2 can be made by characters of str1 or not ; To store the occurrence of every character ; Length of the two strings ; Assume that it is possible to compose the string str2 from str1 ; Iterate over str1 ; Store the presence or every element ; Iterate over str2 ; Ignore the spaces ; Check for the presence of character in str1 ; If it is possible to make str2 from str1 ; Given strings ; Function call ."
Python;"def find_Min_Inversion ( n , s1 , s2 ) : NEW_LINE INDENT count = 0 NEW_LINE s1 = list ( s1 ) NEW_LINE s2 = list ( s2 ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s1 [ i ] != s2 [ i ] ) : NEW_LINE INDENT if ( s1 [ i ] == '1' ) : NEW_LINE INDENT s1 [ i ] = '0' NEW_LINE DEDENT else : NEW_LINE INDENT s1 [ i ] = '1' NEW_LINE DEDENT if ( s1 [ i + 1 ] == '1' ) : NEW_LINE INDENT s1 [ i + 1 ] = '0' NEW_LINE DEDENT else : NEW_LINE INDENT s1 [ i + 1 ] = '1' NEW_LINE DEDENT count += 1 NEW_LINE DEDENT DEDENT s1 = ' ' . join ( s1 ) NEW_LINE s2 = ' ' . join ( s2 ) NEW_LINE if ( s1 == s2 ) : NEW_LINE INDENT return count NEW_LINE DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE s1 = ""0101"" NEW_LINE s2 = ""1111"" NEW_LINE print ( find_Min_Inversion ( n , s1 , s2 ) ) NEW_LINE DEDENT";"Minimum number of flipping adjacent bits required to make given Binary Strings equal | Function to find the minimum number of inversions required . ; Initializing the answer ; Iterate over the range ; If s1 [ i ] != s2 [ i ] , then inverse the characters at i snd ( i + 1 ) positions in s1 . ; Adding 1 to counter if characters are not same ; Driver Code"
Python;"def findSubsequence ( S , ch ) : NEW_LINE INDENT N = len ( S ) NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] == ch ) : NEW_LINE INDENT ans += 1 NEW_LINE ch = chr ( ord ( ch ) + 1 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def findMaxSubsequence ( S ) : NEW_LINE INDENT ans = 0 NEW_LINE for ch in range ( ord ( ' a ' ) , ord ( ' z ' ) + 1 ) : NEW_LINE INDENT ans = max ( ans , findSubsequence ( S , chr ( ch ) ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = "" abcabefghijk "" NEW_LINE print ( findMaxSubsequence ( S ) ) NEW_LINE DEDENT";"Longest subsequence with consecutive English alphabets | Function to find the length of subsequence starting with character ch ; Length of the string ; Stores the maximum length ; Traverse the given string ; If s [ i ] is required character ch ; Increment ans by 1 ; Increment character ch ; Return the current maximum length with character ch ; Function to find the maximum length of subsequence of consecutive characters ; Stores the maximum length of consecutive characters ; Update ans ; Return the maximum length of subsequence ; Driver Code ; Input ; Function Call"
Python;"def minOpsToEmptyString ( s ) : NEW_LINE INDENT ans = - 10 ** 9 NEW_LINE cn0 = 0 NEW_LINE cn1 = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT if ( cn1 > 0 ) : NEW_LINE INDENT cn1 -= 1 NEW_LINE DEDENT cn0 += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( cn0 > 0 ) : NEW_LINE INDENT cn0 -= 1 NEW_LINE DEDENT cn1 += 1 NEW_LINE DEDENT ans = max ( [ ans , cn0 , cn1 ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = ""010101"" NEW_LINE minOpsToEmptyString ( S ) NEW_LINE DEDENT";"Minimum number of alternate subsequences required to be removed to empty a Binary String | Function to find the minimum number of operations to empty a binary string ; Stores the resultant number of operations ; Stores the number of 0 s ; Stores the number of 1 s ; Traverse the given string ; To balance 0 with 1 if possible ; Increment the value of cn0 by 1 ; To balance 1 with 0 if possible ; Increment the value of cn1 ; Update the maximum number of unused 0 s and 1 s ; Print resultant count ; Driver Code"
Python;"def findLength ( str , n ) : NEW_LINE INDENT pre = [ 0 ] * n NEW_LINE post = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT pre [ i ] += pre [ i - 1 ] NEW_LINE DEDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT pre [ i ] += 1 NEW_LINE DEDENT DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( i != ( n - 1 ) ) : NEW_LINE INDENT post [ i ] += post [ i + 1 ] NEW_LINE DEDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT post [ i ] += 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT ans = max ( ans , pre [ i ] + post [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT S = ""0101110110100001011"" NEW_LINE n = len ( S ) NEW_LINE print ( findLength ( S , n ) ) NEW_LINE";"Longest Non | Function to find the length of the longest non - increasing subsequence ; Stores the prefix and suffix count of 1 s and 0 s respectively ; Store the number of '1' s up to current index i in pre ; Find the prefix sum ; If the current element is '1' , update the pre [ i ] ; Store the number of '0' s over the range [ i , N - 1 ] ; Find the suffix sum ; If the current element is '0' , update post [ i ] ; Stores the maximum length ; Find the maximum value of pre [ i ] + post [ i ] ; Return the answer ; Driver Code"
Python;"def countSubstring ( S , N ) : NEW_LINE INDENT prevSum = { } NEW_LINE res = 0 NEW_LINE currentSum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] >= ' A ' and S [ i ] <= ' Z ' ) : NEW_LINE INDENT currentSum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT currentSum -= 1 NEW_LINE DEDENT if ( currentSum == 0 ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( currentSum in prevSum ) : NEW_LINE INDENT res += ( prevSum [ currentSum ] ) NEW_LINE DEDENT if currentSum in prevSum : NEW_LINE INDENT prevSum [ currentSum ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT prevSum [ currentSum ] = 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = "" gEEk "" NEW_LINE print ( countSubstring ( S , len ( S ) ) ) NEW_LINE DEDENT";"Number of substrings having an equal number of lowercase and uppercase letters | Function to find the count of substrings having an equal number of uppercase and lowercase characters ; Stores the count of prefixes having sum S considering uppercase and lowercase characters as 1 and - 1 ; Stores the count of substrings having equal number of lowercase and uppercase characters ; Stores the sum obtained so far ; If the character is uppercase ; Otherwise ; If currsum is o ; If the current sum exists in the HashMap prevSum ; Increment the resultant count by 1 ; Update the frequency of the current sum by 1 ; Return the resultant count of the subarrays ; Driver Code"
Python;"def subString ( s , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for len in range ( i + 1 , n + 1 ) : NEW_LINE INDENT test_str = ( s [ i : len ] ) NEW_LINE res = { } NEW_LINE for keys in test_str : NEW_LINE INDENT res [ keys ] = res . get ( keys , 0 ) + 1 NEW_LINE DEDENT flag = 0 NEW_LINE for keys in res : NEW_LINE INDENT if res [ keys ] % 2 != 0 : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if flag == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT S = "" abbaa "" NEW_LINE N = len ( S ) NEW_LINE print ( subString ( S , N ) ) NEW_LINE";"Number of substrings with each character occurring even times | Function to count substrings having even frequency of each character ; Stores the total count of substrings ; Traverse the range [ 0 , N ] : ; Traverse the range [ i + 1 , N ] ; Stores the substring over the range of indices [ i , len ] ; Stores the frequency of characters ; Count frequency of each character ; Traverse the dictionary ; If any of the keys have odd count ; Otherwise ; Return count ; Driver Code"
Python;"def countStringPairs ( a , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT p = a [ i ] NEW_LINE q = a [ j ] NEW_LINE if ( p [ 0 ] != q [ 0 ] ) : NEW_LINE INDENT p = list ( p ) NEW_LINE q = list ( q ) NEW_LINE temp = p [ 0 ] NEW_LINE p [ 0 ] = q [ 0 ] NEW_LINE q [ 0 ] = temp NEW_LINE p = ' ' . join ( p ) NEW_LINE q = ' ' . join ( q ) NEW_LINE flag1 = 0 NEW_LINE flag2 = 0 NEW_LINE for k in range ( n ) : NEW_LINE INDENT if ( a [ k ] == p ) : NEW_LINE INDENT flag1 = 1 NEW_LINE DEDENT if ( a [ k ] == q ) : NEW_LINE INDENT flag2 = 1 NEW_LINE DEDENT DEDENT if ( flag1 == 0 and flag2 == 0 ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ "" good "" , "" bad "" , "" food "" ] NEW_LINE N = len ( arr ) NEW_LINE countStringPairs ( arr , N ) NEW_LINE DEDENT";"Count new pairs of strings that can be obtained by swapping first characters of pairs of strings from given array | Function to count new pairs of strings that can be obtained by swapping first characters of any pair of strings ; Stores the count of pairs ; Generate all possible pairs of strings from the array arr [ ] ; Stores the current pair of strings ; Swap the first characters ; Check if they are already present in the array or not ; If both the strings are not present ; Increment the ans by 1 ; Print the resultant count ; Driver Code"
Python;"def isPossible ( S , R , N ) : NEW_LINE ' NEW_LINE INDENT cntl = 0 NEW_LINE cntr = 0 NEW_LINE DEDENT ' NEW_LINE INDENT cntu = 0 NEW_LINE cntd = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( S [ i ] == ' L ' ) : NEW_LINE INDENT cntl += 1 NEW_LINE DEDENT elif ( S [ i ] == ' R ' ) : NEW_LINE INDENT cntr += 1 NEW_LINE DEDENT elif ( S [ i ] == ' U ' ) : NEW_LINE INDENT cntu += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cntd += 1 NEW_LINE DEDENT DEDENT if ( max ( max ( cntl , cntr ) , max ( cntu , cntd ) ) >= R ) : NEW_LINE INDENT return "" Yes "" NEW_LINE DEDENT mp = { } NEW_LINE r_square = R * R NEW_LINE i = 1 NEW_LINE while i * i <= r_square : NEW_LINE INDENT mp [ i * i ] = i NEW_LINE if ( ( r_square - i * i ) in mp ) : NEW_LINE INDENT if ( max ( cntl , cntr ) >= mp [ r_square - i * i ] and max ( cntu , cntd ) >= i ) : NEW_LINE INDENT return "" Yes "" NEW_LINE DEDENT if ( max ( cntl , cntr ) >= i and max ( cntu , cntd ) >= mp [ r_square - i * i ] ) : NEW_LINE INDENT return "" Yes "" NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return "" No "" NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT S = "" RDLLDDLDU "" NEW_LINE R = 5 NEW_LINE N = len ( S ) NEW_LINE print ( isPossible ( S , R , N ) ) NEW_LINE DEDENT";"Check if it is possible to reach any point on the circumference of a given circle from origin | Function to check if it is possible to reach any point on circumference of the given circle from ( 0 , 0 ) ; Stores the count of ' L ' , 'R ; Stores the count of ' U ' , 'D ; Traverse the string S ; Update the count of L ; Update the count of R ; Update the count of U ; Update the count of D ; Condition 1 for reaching the circumference ; Store the the value of ( i * i ) in the Map ; Check if ( r_square - i * i ) already present in HashMap ; If it is possible to reach the point ( mp [ r_square - i * i ] , i ) ; If it is possible to reach the point ( i , mp [ r_square - i * i ] ) ; If it is impossible to reach ; Driver Code"
Python;"def addASCII ( S , N ) : NEW_LINE INDENT for i in range ( len ( S ) ) : NEW_LINE INDENT a = ord ( N [ i ] ) - ord ( '0' ) NEW_LINE b = ord ( S [ i ] ) + a NEW_LINE if ( b > 122 ) : NEW_LINE INDENT b -= 26 NEW_LINE DEDENT S = S . replace ( S [ i ] , chr ( b ) ) NEW_LINE DEDENT print ( S ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT S = "" sun "" NEW_LINE N = ""966"" NEW_LINE addASCII ( S , N ) NEW_LINE DEDENT";"Modify characters of a string by adding integer values of same | Function to modify a given string by adding ASCII value of characters from a string S to integer values of same indexed characters in string N ; Traverse the string ; Stores integer value of character in string N ; Stores ASCII value of character in string S ; If b exceeds 122 ; Replace the character ; Print resultant string ; Driver Code ; Given strings ; Function call to modify string S by given operations"
Python;"def decHex ( n ) : NEW_LINE INDENT alpha = [ ' A ' , ' B ' , ' C ' , ' D ' , ' E ' , ' F ' ] NEW_LINE ans = ' ' NEW_LINE while n : NEW_LINE INDENT if n % 16 < 10 : NEW_LINE INDENT ans += str ( n % 16 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += alpha [ n % 16 - 10 ] NEW_LINE DEDENT n //= 16 NEW_LINE DEDENT ans = ans [ : : - 1 ] NEW_LINE return ans NEW_LINE DEDENT def hexDec ( convertedHex ) : NEW_LINE INDENT mp = { "" A "" : 10 , "" B "" : 11 , "" C "" : 12 , "" D "" : 13 , "" E "" : 14 , "" F "" : 15 } NEW_LINE ans = 0 NEW_LINE pos = 0 NEW_LINE for i in convertedHex [ : : - 1 ] : NEW_LINE INDENT if i . isdigit ( ) : NEW_LINE INDENT ans += ( 16 ** pos ) * int ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( 16 ** pos ) * mp [ i ] NEW_LINE DEDENT pos += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def removeChars ( hexaVal , S ) : NEW_LINE INDENT setk = set ( ) NEW_LINE for i in S : NEW_LINE INDENT setk . add ( i ) NEW_LINE DEDENT ans = ' ' NEW_LINE for i in hexaVal : NEW_LINE INDENT if i in setk : NEW_LINE INDENT continue NEW_LINE DEDENT ans += i NEW_LINE DEDENT return ans NEW_LINE DEDENT def convertArr ( arr , S ) : NEW_LINE INDENT for i in range ( len ( arr ) ) : NEW_LINE INDENT hexaVal = decHex ( arr [ i ] ) NEW_LINE convertedHex = removeChars ( hexaVal , S ) NEW_LINE decVal = hexDec ( convertedHex ) NEW_LINE arr [ i ] = decVal NEW_LINE DEDENT print ( arr ) NEW_LINE DEDENT arr = [ 74 , 91 , 31 , 122 ] NEW_LINE S = ""1AB "" NEW_LINE convertArr ( arr , S ) NEW_LINE";"Modify array by removing characters from their Hexadecimal representations which are present in a given string | Function to convert a decimal number to its equivalent hexadecimal number ; Function to convert hexadecimal number to its equavalent decimal number ; Stores characters with their respective hexadecimal values ; Stores answer ; Traverse the string ; If digit ; If character ; Return the answer ; Function to move all the alphabets to front ; Function to modify each array element by removing characters from their hexadecimal representation which are present in a given string ; Traverse the array ; Stores hexadecimal value ; Remove the characters from hexadecimal representation present in string S ; Stores decimal value ; Replace array element ; Print the modified array ; Given array ; Given string ; Function call to modify array by given operations"
Python;"def fillString ( s , k ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] != ' ? ' ) : NEW_LINE INDENT mp [ i % k ] = s [ i ] NEW_LINE DEDENT DEDENT s = list ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( ( i % k ) not in mp ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT s [ i ] = mp [ i % k ] NEW_LINE DEDENT s = ' ' . join ( s ) NEW_LINE print ( s ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = "" ? ? ? ? abcd "" NEW_LINE K = 4 NEW_LINE fillString ( S , K ) NEW_LINE DEDENT";"Modify string by inserting characters such that every K | Function to replace all ' ? ' characters in a string such that the given conditions are satisfied ; Traverse the string to Map the characters with respective positions ; Traverse the string again and replace all unknown characters ; If i % k is not found in the Map M , then return - 1 ; Update S [ i ] ; Print the string S ; Driver Code"
Python;"def rearrangeString ( s1 , s2 ) : NEW_LINE INDENT cnt = [ 0 ] * 26 NEW_LINE for i in range ( len ( s2 ) ) : NEW_LINE INDENT cnt [ ord ( s2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT unique = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( cnt [ i ] != 0 ) : NEW_LINE INDENT unique += 1 NEW_LINE DEDENT DEDENT if ( unique == 1 ) : NEW_LINE INDENT count_in_s2 = len ( s2 ) NEW_LINE count_in_s1 = 0 NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT if ( s1 [ i ] == s2 [ 0 ] ) : NEW_LINE INDENT count_in_s1 += 1 NEW_LINE DEDENT DEDENT if ( count_in_s1 < count_in_s2 ) : NEW_LINE INDENT print ( s1 , end = "" "" ) NEW_LINE return NEW_LINE DEDENT print ( - 1 , end = "" "" ) NEW_LINE DEDENT else : NEW_LINE INDENT inc = 1 NEW_LINE for i in range ( len ( s2 ) - 1 ) : NEW_LINE INDENT if ( s2 [ i ] > s2 [ i + 1 ] ) : NEW_LINE INDENT inc = 0 NEW_LINE DEDENT DEDENT if ( inc == 1 ) : NEW_LINE INDENT s1 = sorted ( s1 ) [ : : - 1 ] NEW_LINE print ( "" "" . join ( s1 ) , end = "" "" ) NEW_LINE DEDENT else : NEW_LINE INDENT s1 = sorted ( s1 ) NEW_LINE print ( "" "" . join ( s1 ) , end = "" "" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 , s2 = "" abcd "" , "" ab "" NEW_LINE rearrangeString ( s1 , s2 ) NEW_LINE DEDENT";"Rearrange a string S1 such that another given string S2 is not its subsequence | Function to rearrange characters in S1 such that S2 is not a subsequence of it ; Store the frequencies of characters of s2 ; Traverse the s2 ; Update the frequency ; Find the number of unique characters in s2 ; Increment unique by 1 if the condition satisfies ; Check if the number of unique characters in s2 is 1 ; Store the unique character frequency ; Store occurence of it in s1 ; Find count of that character in the s1 ; Increment count by 1 if that unique character is same as current character ; If count count_in_s1 is less than count_in_s2 , then prs1 and return ; Otherwise , there is no possible arrangement ; Checks if any character in s2 is less than its next character ; Iterate the string , s2 ; If s [ i ] is greater than the s [ i + 1 ] ; Set inc to 0 ; If inc = 1 , prs1 in decreasing order ; Otherwise , prs1 in increasing order ; Driver code"
Python;"def isReducible ( Str ) : NEW_LINE INDENT N = len ( Str ) NEW_LINE s = [ ] NEW_LINE for i in range ( N ) : NEW_LINE if ( Str [ i ] == '1' ) : NEW_LINE INDENT s . append ( Str [ i ] ) NEW_LINE DEDENT elif ( len ( s ) > 0 ) : NEW_LINE INDENT del s [ len ( s ) - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT if ( len ( s ) == 0 ) : NEW_LINE return True NEW_LINE else : NEW_LINE return False NEW_LINE DEDENT Str = ""11011000"" NEW_LINE if ( isReducible ( Str ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Check if a string can be emptied by removing all subsequences of the form ""10"" | Function to find if string is reducible to NULL ; Length of string ; Stack to store all 1 s ; Iterate over the characters of the string ; If current character is 1 ; Push it into the stack ; Pop from the stack ; If the stack is empty ; Driver code"
Python;"def solution ( S ) : NEW_LINE INDENT vowels = [ ] NEW_LINE consonants = [ ] NEW_LINE for i in S : NEW_LINE INDENT if ( i == ' a ' or i == ' e ' or i == ' i ' or i == ' o ' or i == ' u ' ) : NEW_LINE INDENT vowels . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT consonants . append ( i ) NEW_LINE DEDENT DEDENT Nc = len ( consonants ) NEW_LINE Nv = len ( vowels ) NEW_LINE M = Nc // ( Nv - 1 ) NEW_LINE ans = "" "" NEW_LINE consonant_till = 0 NEW_LINE for i in vowels : NEW_LINE INDENT ans += i NEW_LINE temp = 0 NEW_LINE for j in range ( consonant_till , min ( Nc , consonant_till + M ) ) : NEW_LINE INDENT ans += consonants [ j ] NEW_LINE temp += 1 NEW_LINE DEDENT consonant_till += temp NEW_LINE DEDENT return ans NEW_LINE DEDENT S = "" aaaabbbcc "" NEW_LINE print ( solution ( S ) ) NEW_LINE";"Rearrange a string to maximize the minimum distance between any pair of vowels | Function to rearrange the string such that the minimum distance between any of vowels is maximum . ; store vowels and consonants ; Iterate over the characters of string ; if current character is a vowel ; if current character is consonant ; store count of vowels and consonants respectively ; store the resultant string ; store count of consonants append into ans ; Append vowel to ans ; Append consonants ; Appendconsonant to ans ; update temp ; Remove the taken elements of consonant ; return final answer ; Driver code ; Function Call"
Python;"def smallestlexicographicstring ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE DEDENT ' NEW_LINE INDENT if ( k >= n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT s [ i ] = ' a ' ; NEW_LINE DEDENT print ( s , end = ' ' ) NEW_LINE return ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( k == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( s [ j ] > s [ i ] ) : NEW_LINE INDENT s [ j ] = s [ i ] ; NEW_LINE break ; NEW_LINE DEDENT elif ( j == n - 1 ) : NEW_LINE INDENT s [ j ] = s [ i ] ; NEW_LINE DEDENT DEDENT s [ i ] = ' a ' ; NEW_LINE k -= 1 NEW_LINE DEDENT print ( ' ' . join ( s ) , end = ' ' ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = list ( "" geeksforgeeks "" ) ; NEW_LINE k = 6 ; NEW_LINE smallestlexicographicstring ( s , k ) ; NEW_LINE DEDENT";"Lexicographically smallest string possible by performing K operations on a given string | Function to find the lexicographically smallest possible string by performing K operations on string S ; Store the size of string , s ; Check if k >= n , if true , convert every character to 'a ; Iterate in range [ 0 , n - 1 ] using i ; When k reaches 0 , break the loop ; If current character is ' a ' , continue ; Otherwise , iterate in the range [ i + 1 , n - 1 ] using j ; Check if s [ j ] > s [ i ] ; If true , set s [ j ] = s [ i ] and break out of the loop ; Check if j reaches the last index ; Update S [ i ] ; Decrement k by 1 ; Print string ; Driver Code ; Given String , s ; Given k ; Function Call"
Python;"def maximum_pallindromic ( arr ) : NEW_LINE INDENT res = 0 NEW_LINE c1 = 0 NEW_LINE c2 = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT res += arr [ i ] // 3 NEW_LINE arr [ i ] = arr [ i ] % 3 NEW_LINE if ( arr [ i ] == 1 ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT elif ( arr [ i ] == 2 ) : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT DEDENT res += min ( c1 , c2 ) NEW_LINE t = min ( c1 , c2 ) NEW_LINE c1 -= t NEW_LINE c2 -= t NEW_LINE res += 2 * ( c2 // 3 ) NEW_LINE c2 %= 3 NEW_LINE res += c2 // 2 NEW_LINE print ( res ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 4 , 5 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE maximum_pallindromic ( arr ) NEW_LINE DEDENT";"Maximize palindromic strings of length 3 possible from given count of alphabets | Function to count maximum number of palindromic string of length 3 ; Stores the final count of palindromic strings ; Traverse the array ; Increment res by arr [ i ] / 3 , i . e forming string of only i + ' a ' character ; Store remainder ; Increment c1 by one , if current frequency is 1 ; Increment c2 by one , if current frequency is 2 ; Count palindromic strings of length 3 having the character at the ends different from that present in the middle ; Update c1 and c2 ; Increment res by 2 * c2 / 3 ; Finally print the result ; Driver Code ; Given array ; Function Call"
Python;"def find_Winner ( arr , N ) : NEW_LINE INDENT Q = [ 0 ] * N NEW_LINE for i in range ( N ) : NEW_LINE INDENT Q [ i ] = [ ] NEW_LINE DEDENT M = len ( arr ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT Len = len ( arr [ i ] ) NEW_LINE for j in range ( Len ) : NEW_LINE INDENT Q [ i ] . append ( ord ( arr [ i ] [ j ] ) - 1 ) NEW_LINE DEDENT DEDENT player = 0 NEW_LINE while ( len ( Q [ player ] ) > 0 ) : NEW_LINE INDENT nextPlayer = Q [ player ] [ 0 ] - ord ( '0' ) NEW_LINE del Q [ player ] [ 0 ] NEW_LINE player = nextPlayer NEW_LINE DEDENT print ( "" Player "" , ( player + 1 ) ) NEW_LINE DEDENT N = 3 NEW_LINE arr = [ ""323"" , ""2"" , ""2"" ] NEW_LINE find_Winner ( arr , N ) NEW_LINE";"Find the winner of game of repeatedly removing the first character to empty given string | Function to find the winner of a game of repeatedly removing the first character to empty a string ; Store characters of each string of the array arr [ ] ; Stores count of strings in arr [ ] ; Traverse the array arr [ ] ; Stores length of current string ; Traverse the string ; Insert arr [ i ] [ j ] ; 1 st Player starts the game ; Stores the player number for the next turn ; Remove 1 st character of current string ; Update player number for the next turn ; Driver Code"
Python;"def longestSubstring ( s ) : NEW_LINE INDENT dp = [ 1024 for i in range ( 1024 ) ] NEW_LINE res , mask = 0 , 0 NEW_LINE dp [ 0 ] = - 1 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT mask ^= 1 << ( ord ( s [ i ] ) - ord ( '0' ) ) NEW_LINE res = max ( res , i - dp [ mask ] ) NEW_LINE for j in range ( 10 ) : NEW_LINE INDENT res = max ( res , i - dp [ mask ^ ( 1 << j ) ] ) NEW_LINE DEDENT dp [ mask ] = min ( dp [ mask ] , i ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = ""3242415"" NEW_LINE print ( longestSubstring ( s ) ) NEW_LINE DEDENT";"Longest Substring that can be made a palindrome by swapping of characters | Function to find the Longest substring that can be made a palindrome by swapping of characters ; Initialize dp array of size 1024 ; Initializing mask and res ; Traverse the string ; Find the mask of the current character ; Finding the length of the longest substring in s which is a palindrome for even count ; Finding the length of the longest substring in s which is a palindrome for one odd count ; Finding maximum length of substring having one odd count ; dp [ mask ] is minimum of current i and dp [ mask ] ; Return longest length of the substring which forms a palindrome with swaps ; Driver Code ; Input String ; Function Call"
Python;"def Validate ( M ) : NEW_LINE INDENT lenn = len ( M ) NEW_LINE temp = "" "" NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( M [ i ] . isdigit ( ) ) : NEW_LINE INDENT temp += M [ i ] NEW_LINE DEDENT DEDENT nwlenn = len ( temp ) NEW_LINE if ( nwlenn != 10 ) : NEW_LINE INDENT print ( "" Invalid "" ) NEW_LINE return NEW_LINE DEDENT res = "" "" NEW_LINE x = temp [ 0 : 3 ] NEW_LINE res += "" ( "" + x + "" ) - "" NEW_LINE x = temp [ 3 : 3 + 3 ] NEW_LINE res += "" ( "" + x + "" ) - "" NEW_LINE x = temp [ 6 : 3 + 6 ] NEW_LINE res += "" ( "" + x + "" ) - "" NEW_LINE x = temp [ 9 : 1 + 9 ] NEW_LINE res += "" ( "" + x + "" ) "" NEW_LINE print ( res ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT M = ""91 ▁ 234rt5%34*0 ▁ 3"" NEW_LINE Validate ( M ) NEW_LINE DEDENT";"Convert given string to a valid mobile number | Function to print valid and formatted phone number ; Length of given ; Store digits in temp ; Iterate given M ; If any digit : append it to temp ; Find new length of ; If length is not equal to 10 ; Store final result ; Make groups of 3 digits and enclose them within ( ) and separate them with "" - "" 0 to 2 index 1 st group ; 3 to 5 index 2 nd group ; 6 to 8 index 3 rd group ; 9 to 9 index last group ; Print final result ; Driver Code ; Given ; Function Call"
Python;"def hexaModK ( s , k ) : NEW_LINE INDENT mp = { } ; NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT mp [ chr ( i + ord ( '0' ) ) ] = i ; NEW_LINE DEDENT mp [ ' A ' ] = 10 ; NEW_LINE mp [ ' B ' ] = 11 ; NEW_LINE mp [ ' C ' ] = 12 ; NEW_LINE mp [ ' D ' ] = 13 ; NEW_LINE mp [ ' E ' ] = 14 ; NEW_LINE mp [ ' F ' ] = 15 ; NEW_LINE m = int ( k ) ; NEW_LINE base = 1 ; NEW_LINE ans = 0 ; NEW_LINE for i in range ( len ( s ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT n = mp [ s [ i ] ] % m ; NEW_LINE ans = ( ans + ( base % m * n % m ) % m ) % m ; NEW_LINE base = ( base % m * 16 % m ) % m ; NEW_LINE DEDENT ans = hex ( int ( ans ) ) [ - 1 ] . upper ( ) NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = ""3E8"" ; NEW_LINE k = ""13"" ; NEW_LINE hexaModK ( n , k ) ; NEW_LINE DEDENT";"Modulus of two Hexadecimal Numbers | Function to calculate modulus of two Hexadecimal numbers ; Store all possible hexadecimal digits ; Iterate over the range [ '0' , '9' ] ; Convert given string to long ; Base to get 16 power ; Store N % K ; Iterate over the digits of N ; Stores i - th digit of N ; Update ans ; Update base ; Print the answer converting into hexadecimal ; Driver Code ; Given string N and K ; Function Call"
Python;"combination = "" "" ; NEW_LINE combinations = [ ] ; NEW_LINE def printSequences ( combinations ) : NEW_LINE INDENT for s in ( combinations ) : NEW_LINE INDENT print ( s , end = ' ▁ ' ) ; NEW_LINE DEDENT DEDENT def generateCombinations ( s , n ) : NEW_LINE INDENT global combination ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT combination += s [ i ] ; NEW_LINE x = int ( combination ) ; NEW_LINE if ( x <= n ) : NEW_LINE INDENT combinations . append ( combination ) ; NEW_LINE generateCombinations ( s , n ) ; NEW_LINE DEDENT combination = combination [ : - 1 ] ; NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT S = ""124"" ; NEW_LINE N = 100 ; NEW_LINE generateCombinations ( S , N ) ; NEW_LINE printSequences ( combinations ) ; NEW_LINE DEDENT";"Print all combinations generated by characters of a numeric string which does not exceed N | Store the current sequence of s ; Store the all the required sequences ; Function to print all sequences of S satisfying the required condition ; Print all strings in the set ; Function to generate all sequences of string S that are at most N ; Iterate over string s ; Push ith character to combination ; Convert the string to number ; Check if the condition is true ; Push the current string to the final set of sequences ; Recursively call function ; Backtrack to its previous state ; Driver Code ; Function Call ; Print required sequences"
Python;"def compute_hash ( str ) : NEW_LINE INDENT p = 31 NEW_LINE MOD = 10 ** 9 + 7 NEW_LINE hash_val = 0 NEW_LINE mul = 1 NEW_LINE for ch in str : NEW_LINE INDENT hash_val = ( hash_val + ( ord ( ch ) - ord ( ' a ' ) + 1 ) * mul ) % MOD NEW_LINE mul = ( mul * p ) % MOD NEW_LINE DEDENT return hash_val NEW_LINE DEDENT def distinct_str ( arr , n ) : NEW_LINE INDENT hash = [ 0 ] * ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash [ i ] = compute_hash ( arr [ i ] ) NEW_LINE DEDENT hash = sorted ( hash ) NEW_LINE cntElem = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( hash [ i ] != hash [ i - 1 ] ) : NEW_LINE INDENT cntElem += 1 NEW_LINE DEDENT DEDENT return cntElem NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ "" abcde "" , "" abcce "" , "" abcdf "" , "" abcde "" ] NEW_LINE N = len ( arr ) NEW_LINE print ( distinct_str ( arr , N ) ) NEW_LINE DEDENT";"Count Distinct Strings present in an array using Polynomial rolling hash function | Function to find the hash value of a ; Traverse the ; Update hash_val ; Update mul ; Return hash_val of str ; Function to find the count of distinct strings present in the given array ; Store the hash values of the strings ; Traverse the array ; Stores hash value of arr [ i ] ; Sort hash [ ] array ; Stores count of distinct strings in the array ; Traverse hash [ ] array ; Update cntElem ; Driver Code"
Python;"def SieveOfEratosthenes ( prime , n ) : NEW_LINE INDENT for i in range ( n + 1 ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT prime [ 0 ] = prime [ 1 ] = False NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT j = 2 NEW_LINE while i * j <= n : NEW_LINE INDENT prime [ i * j ] = False NEW_LINE j += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT DEDENT def removePrimeFrequencies ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE prime = [ False ] * ( n + 1 ) NEW_LINE SieveOfEratosthenes ( prime , n ) NEW_LINE m = { } NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] in m : NEW_LINE INDENT m [ s [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ s [ i ] ] = 1 NEW_LINE DEDENT DEDENT new_String = "" "" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( prime [ m [ s [ i ] ] ] ) : NEW_LINE INDENT continue NEW_LINE DEDENT new_String += s [ i ] NEW_LINE DEDENT print ( new_String , end = "" "" ) NEW_LINE DEDENT Str = "" geeksforgeeks "" NEW_LINE removePrimeFrequencies ( list ( Str ) ) NEW_LINE";"Remove characters from given string whose frequencies are a Prime Number | Function to perform the seive of eratosthenes algorithm ; Initialize all entries in prime [ ] as true ; Initialize 0 and 1 as non prime ; Traversing the prime array ; If i is prime ; All multiples of i must be marked false as they are non prime ; Function to remove characters which have prime frequency in the String ; Length of the String ; Create a bool array prime ; Sieve of Eratosthenes ; Stores the frequency of character ; Storing the frequencies ; New String that will be formed ; Removing the characters which have prime frequencies ; If the character has prime frequency then skip ; Else concatenate the character to the new String ; Print the modified String ; Driver Code ; Function Call"
Python;"def rearrange ( s ) : NEW_LINE INDENT s1 = [ ] NEW_LINE s2 = [ ] NEW_LINE for x in s : NEW_LINE INDENT if x . isalpha ( ) : NEW_LINE INDENT s1 . append ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT s2 . append ( x ) NEW_LINE DEDENT DEDENT n = len ( s1 ) NEW_LINE m = len ( s2 ) NEW_LINE if ( abs ( n - m ) > 1 ) : NEW_LINE INDENT return "" - 1"" NEW_LINE DEDENT i = 0 NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE flag = 0 NEW_LINE if ( n >= m ) : NEW_LINE INDENT flag = 1 NEW_LINE DEDENT else : NEW_LINE INDENT flag = 0 NEW_LINE DEDENT while ( i < n and j < m ) : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT s [ k ] = s1 [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT s [ k ] = s2 [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT flag = not flag NEW_LINE DEDENT return "" "" . join ( s ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = "" geeks2020"" NEW_LINE str1 = [ i for i in str ] NEW_LINE print ( rearrange ( str1 ) ) NEW_LINE DEDENT";"Rearrange string such that no pair of adjacent characters are of the same type | Function to rearrange given alphanumeric such that no two adjacent characters are of the same type ; Stores alphabets and digits ; Store the alphabets and digits separately in the strings ; Stores the count of alphabets and digits ; If respective counts differ by 1 ; Desired arrangement not possible ; Stores the indexes ; Check if first character should be alphabet or digit ; Place alphabets and digits alternatively ; If current character needs to be alphabet ; If current character needs to be a digit ; Flip flag for alternate arrangement ; Return resultant string ; Driver Code ; Given String ; Function call"
Python;"def charactersCount ( str , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT cur = str [ 0 ] ; NEW_LINE ind = 0 ; NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT if ( str [ j ] < cur ) : NEW_LINE INDENT cur = str [ j ] ; NEW_LINE ind = j ; NEW_LINE DEDENT DEDENT str = str [ 0 : ind ] + str [ ind + 1 : ] ; NEW_LINE n -= 1 ; NEW_LINE count += ind + 1 ; NEW_LINE DEDENT print ( count ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = "" aabbc "" ; NEW_LINE n = 5 ; NEW_LINE charactersCount ( str , n ) ; NEW_LINE DEDENT";"Find value after N operations to remove N characters of string S with given constraints | Function to find the value after N operations to remove all the N characters of String S ; Iterate till N ; Remove character at ind and decrease n ( size of String ) ; Increase count by ind + 1 ; Driver Code ; Given String str ; Function call"
Python;"def printMiddleCharacter ( str ) : NEW_LINE INDENT length = len ( str ) ; NEW_LINE middle = length // 2 ; NEW_LINE print ( str [ middle ] ) ; NEW_LINE DEDENT str = "" GeeksForGeeks "" ; NEW_LINE printMiddleCharacter ( str ) ; NEW_LINE";"Print the middle character of a string | Function that prints the middle character of a string ; Finding string length ; Finding middle index of string ; Prthe middle character of the string ; Given string str ; Function Call"
Python;"def check ( s ) : NEW_LINE INDENT a = set ( ) NEW_LINE for i in s : NEW_LINE INDENT if i in a : NEW_LINE INDENT return False NEW_LINE DEDENT a . add ( i ) NEW_LINE DEDENT return True NEW_LINE DEDENT def helper ( arr , ind ) : NEW_LINE INDENT if ( ind == len ( arr ) ) : NEW_LINE INDENT return [ "" "" ] NEW_LINE DEDENT tmp = helper ( arr , ind + 1 ) NEW_LINE ret = tmp NEW_LINE for i in tmp : NEW_LINE INDENT test = i + arr [ ind ] NEW_LINE if ( check ( test ) ) : NEW_LINE INDENT ret . append ( test ) NEW_LINE DEDENT DEDENT return ret NEW_LINE DEDENT def maxLength ( arr ) : NEW_LINE INDENT tmp = helper ( arr , 0 ) NEW_LINE l = 0 NEW_LINE for i in tmp : NEW_LINE INDENT l = l if l > len ( i ) else len ( i ) NEW_LINE DEDENT return l NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = [ ] NEW_LINE s . append ( "" abcdefgh "" ) NEW_LINE print ( maxLength ( s ) ) NEW_LINE DEDENT";"Maximize length of the String by concatenating characters from an Array of Strings | Function to check if all the string characters are unique ; Check for repetition in characters ; Function to generate all possible strings from the given array ; Base case ; Consider every string as a starting substring and store the generated string ; Add current string to result of other strings and check if characters are unique or not ; Function to find the maximum possible length of a string ; Return max length possible ; Return the answer ; Driver Code"
Python;"def Range_sum_query ( S , Query ) : NEW_LINE INDENT N = len ( S ) NEW_LINE A = [ 0 ] * N NEW_LINE A [ 0 ] = ord ( S [ 0 ] ) - ord ( ' a ' ) + 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT A [ i ] = ord ( S [ i ] ) - ord ( ' a ' ) + 1 NEW_LINE A [ i ] = A [ i ] + A [ i - 1 ] NEW_LINE DEDENT for i in range ( len ( Query ) ) : NEW_LINE INDENT if ( Query [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT print ( A [ Query [ i ] [ 1 ] - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( A [ Query [ i ] [ 1 ] - 1 ] - A [ Query [ i ] [ 0 ] - 2 ] ) NEW_LINE DEDENT DEDENT DEDENT S = "" abcd "" NEW_LINE Query = [ ] NEW_LINE Query . append ( [ 2 , 4 ] ) NEW_LINE Query . append ( [ 1 , 3 ] ) NEW_LINE Range_sum_query ( S , Query ) NEW_LINE";"Perform range sum queries on string as per given condition | Function to perform range sum queries on string as per the given condition ; Initialize N by string size ; Create array A [ ] for prefix sum ; Iterate till N ; Traverse the queries ; Check if if L == 1 range sum will be A [ R - 1 ] ; Condition if L > 1 range sum will be A [ R - 1 ] - A [ L - 2 ] ; Given string ; Given Queries ; Function call"
Python;"def permute ( st , l , r , n ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT p = ' ' . join ( st ) NEW_LINE j = int ( p ) NEW_LINE if ( j % n == 0 ) : NEW_LINE INDENT print ( p ) NEW_LINE DEDENT return NEW_LINE DEDENT for i in range ( l , r ) : NEW_LINE INDENT st [ l ] , st [ i ] = st [ i ] , st [ l ] NEW_LINE permute ( st , l + 1 , r , n ) NEW_LINE st [ l ] , st [ i ] = st [ i ] , st [ l ] NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT st = ""125"" NEW_LINE n = 5 NEW_LINE length = len ( st ) NEW_LINE if ( length > 0 ) : NEW_LINE p = list ( st ) NEW_LINE permute ( p , 0 , length , n ) ; NEW_LINE DEDENT";"Generate all possible permutations of a Number divisible by N | Function to generate all permutations and print the ones that are divisible by the N ; Convert string to integer ; Check for divisibility and print it ; Print all the permutations ; Swap characters ; Permute remaining characters ; Revoke the swaps ; Driver Code"
Python;"def decimalToBinary ( N ) : NEW_LINE INDENT ans = "" "" NEW_LINE while ( N > 0 ) : NEW_LINE INDENT if ( N & 1 ) : NEW_LINE INDENT ans = '1' + ans NEW_LINE DEDENT else : NEW_LINE INDENT ans = '0' + ans NEW_LINE DEDENT N //= 2 NEW_LINE DEDENT return ans NEW_LINE DEDENT def checkBinaryString ( str , N ) : NEW_LINE INDENT map = [ 0 ] * ( N + 10 ) NEW_LINE cnt = 0 NEW_LINE for i in range ( N , - 1 , - 1 ) : NEW_LINE INDENT if ( not map [ i ] ) : NEW_LINE INDENT t = i NEW_LINE s = decimalToBinary ( t ) NEW_LINE if ( s in str ) : NEW_LINE INDENT while ( t and not map [ t ] ) : NEW_LINE INDENT map [ t ] = 1 NEW_LINE cnt += 1 NEW_LINE t >>= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT ' NEW_LINE INDENT for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i ] == '0' ) : NEW_LINE INDENT cnt += 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( cnt == N + 1 ) : NEW_LINE INDENT return "" True "" NEW_LINE DEDENT else : NEW_LINE INDENT return "" False "" NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = ""0110"" NEW_LINE N = 3 NEW_LINE print ( checkBinaryString ( str , N ) ) NEW_LINE DEDENT";"Check if binary representations of 0 to N are present as substrings in given binary string | Function to convert decimal to binary representation ; Iterate over all bits of N ; If bit is 1 ; Return binary representation ; Function to check if binary conversion of numbers from N to 1 exists in the string as a substring or not ; To store the count of number exists as a substring ; Traverse from N to 1 ; If current number is not present in map ; Store current number ; Find binary of t ; If the string s is a substring of str ; Mark t as true ; Increment the count ; Update for t / 2 ; Special judgment '0 ; If the count is N + 1 , return "" yes "" ; Driver Code ; Given String ; Given Number ; Function Call"
Python;"def largestAnagramGrp ( arr ) : NEW_LINE INDENT prime = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , 73 , 79 , 83 , 89 , 97 , 101 ] NEW_LINE max = - 1 NEW_LINE maxpdt = - 1 NEW_LINE W = { } NEW_LINE P = { } NEW_LINE for temp in arr : NEW_LINE INDENT c = [ i for i in temp ] NEW_LINE pdt = 1 NEW_LINE for t in c : NEW_LINE INDENT pdt *= prime [ ord ( t ) - ord ( ' a ' ) ] NEW_LINE DEDENT if ( pdt in P ) : NEW_LINE INDENT P [ pdt ] = P . get ( pdt , 0 ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT W [ pdt ] = temp NEW_LINE P [ pdt ] = 1 NEW_LINE DEDENT DEDENT for e in P : NEW_LINE INDENT if ( max < P [ e ] ) : NEW_LINE INDENT max = P [ e ] NEW_LINE maxpdt = e NEW_LINE DEDENT DEDENT return W [ maxpdt ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = "" please ▁ be ▁ silent ▁ and ▁ listen ▁ to ▁ what ▁ the ▁ professor ▁ says "" NEW_LINE arr = S . split ( "" ▁ "" ) NEW_LINE print ( largestAnagramGrp ( arr ) ) NEW_LINE DEDENT";"Find the word with most anagrams in a given sentence | Function to find the word with maximum number of anagrams ; Primes assigned to 26 alphabets ; Stores the product and word mappings ; Stores the frequencies of products ; Calculate the product of primes assigned ; If product already exists ; Otherwise ; Fetch the most frequent product ; Return a string with that product ; Driver Code"
Python;"def print_next_vovel_string ( st ) : NEW_LINE INDENT m = { } NEW_LINE m [ ' a ' ] = 0 NEW_LINE m [ ' e ' ] = 1 NEW_LINE m [ ' i ' ] = 2 NEW_LINE m [ ' o ' ] = 3 NEW_LINE m [ ' u ' ] = 4 NEW_LINE arr = [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] NEW_LINE N = len ( st ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT c = st [ i ] NEW_LINE if ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) : NEW_LINE INDENT index = m [ st [ i ] ] + 1 NEW_LINE newindex = index % 5 NEW_LINE st = st . replace ( st [ i ] , arr [ newindex ] , 1 ) NEW_LINE DEDENT DEDENT return st NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT st = "" geeksforgeeks "" NEW_LINE print ( print_next_vovel_string ( st ) ) NEW_LINE DEDENT";"Replace every vowels with lexicographically next vowel in a String | Function to replace every vowel with next vowel lexicographically ; Storing the vowels in the map with custom numbers showing their index ; Iterate over the string ; If the current character is a vowel Find the index in Hash and Replace it with next vowel from Hash ; Driver function"
Python;"def isPalindrome ( Str ) : NEW_LINE INDENT Len = len ( Str ) NEW_LINE for i in range ( Len ) : NEW_LINE INDENT if ( Str [ i ] != Str [ Len - i - 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isCompressablePalindrome ( Str ) : NEW_LINE INDENT Len = len ( Str ) NEW_LINE compressed = "" "" NEW_LINE compressed += Str [ 0 ] NEW_LINE for i in range ( 1 , Len ) : NEW_LINE INDENT if ( Str [ i ] != Str [ i - 1 ] ) : NEW_LINE INDENT compressed += Str [ i ] NEW_LINE DEDENT DEDENT return isPalindrome ( compressed ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Str = "" abbcbbbaaa "" NEW_LINE if ( isCompressablePalindrome ( Str ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT";"Check if string is palindrome after removing all consecutive duplicates | Function to check if a string is palindrome or not ; Length of the string ; Check if its a palindrome ; If the palindromic condition is not met ; Return true as Str is palindromic ; Function to check if string str is palindromic after removing every consecutive characters from the str ; Length of the string str ; Create an empty compressed string ; The first character will always be included in final string ; Check all the characters of the string ; If the current character is not same as its previous one , then insert it in the final string ; Check if the compressed string is a palindrome ; Driver Code ; Given string ; Function call"
Python;"def isvowel ( ch ) : NEW_LINE INDENT return ( ch in "" aeiou "" ) NEW_LINE DEDENT def CountTotal ( s ) : NEW_LINE INDENT ans = 0 NEW_LINE n = len ( s ) NEW_LINE cnt = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( isvowel ( s [ i ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( cnt * ( cnt + 1 ) // 2 ) NEW_LINE cnt = 0 NEW_LINE DEDENT DEDENT if ( cnt != 0 ) : NEW_LINE INDENT ans += ( cnt * ( cnt + 1 ) // 2 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT s = "" geeksforgeeks "" NEW_LINE print ( CountTotal ( s ) ) NEW_LINE";"Count of substrings consisting only of vowels | function to check vowel or not ; Function to Count all substrings in a string which contains only vowels ; if current character is vowel ; increment ; Count all possible substring of calculated length ; Reset the length ; Add remaining possible substrings consisting of vowels occupying last indices of the string ; Driver Program"
Python;def getTotCount ( num ) : NEW_LINE INDENT totCount = 1 NEW_LINE firstCount = 1 NEW_LINE temp = 1 NEW_LINE while ( not ( num & temp ) ) : NEW_LINE INDENT temp = temp << 1 NEW_LINE totCount += 1 NEW_LINE DEDENT firstCount = totCount NEW_LINE temp = num >> totCount NEW_LINE while ( temp ) : NEW_LINE INDENT totCount += 1 NEW_LINE temp = temp >> 1 NEW_LINE DEDENT return totCount , firstCount NEW_LINE DEDENT def flipBitsFromRightMostSetBit ( num ) : NEW_LINE INDENT totbit , firstbit = getTotCount ( num ) NEW_LINE num1 = num ^ ( ( 1 << totbit ) - 1 ) NEW_LINE num1 = num1 ^ ( ( 1 << firstbit ) - 1 ) NEW_LINE return num1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 120 NEW_LINE print ( flipBitsFromRightMostSetBit ( n ) ) NEW_LINE DEDENT;"Number formed by flipping all bits to the left of rightmost set bit | Function to get the total count ; Moving until we get the rightmost set bit ; To get total number of bits in a number ; Function to find the integer formed after flipping all bits to the left of the rightmost set bit ; Find the total count of bits and the rightmost set bit ; XOR given number with the number which has is made up of only totbits set ; To avoid flipping the bits to the right of the set bit , take XOR with the number made up of only set firstbits ; Driver Code"
Python;"def isVowel ( x ) : NEW_LINE INDENT return ( x == ' a ' or x == ' e ' or x == ' i ' or x == ' o ' or x == ' u ' ) ; NEW_LINE DEDENT def findMaxLen ( s ) : NEW_LINE INDENT maxLen = 0 NEW_LINE cur = 0 NEW_LINE if ( isVowel ( s [ 0 ] ) ) : NEW_LINE INDENT maxLen = 1 ; NEW_LINE DEDENT cur = maxLen NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( isVowel ( s [ i ] ) ) : NEW_LINE INDENT if ( s [ i ] != s [ i - 1 ] ) : NEW_LINE INDENT cur += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cur = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT cur = 0 ; NEW_LINE DEDENT maxLen = max ( cur , maxLen ) ; NEW_LINE DEDENT return maxLen NEW_LINE DEDENT Str = "" aeoibsddaeiouudb "" NEW_LINE print ( findMaxLen ( Str ) ) NEW_LINE";"Longest substring of vowels with no two adjacent alphabets same | Function to check a character is vowel or not ; Function to find length of longest substring consisting only of vowels and no similar adjacent alphabets ; Stores max length of valid subString ; Stores length of current valid subString ; If curr and prev character are not same , include it ; If same as prev one , start new subString from here ; Store max in maxLen ; Driver code"
Python;def power ( base , pwr ) : NEW_LINE INDENT res = 1 NEW_LINE while ( pwr > 0 ) : NEW_LINE INDENT if ( pwr & 1 ) : NEW_LINE INDENT res = res * base NEW_LINE DEDENT base = base * base NEW_LINE pwr >>= 1 NEW_LINE DEDENT return res NEW_LINE DEDENT def countNonPalindromicString ( n , m ) : NEW_LINE INDENT total = power ( n , m ) NEW_LINE palindrome = power ( n , m // 2 + m % 2 ) NEW_LINE count = total - palindrome NEW_LINE return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE m = 5 NEW_LINE print ( countNonPalindromicString ( n , m ) ) NEW_LINE DEDENT;"Count of non | Iterative Function to calculate base ^ pow in O ( log y ) ; Function to return the count of non palindromic strings ; Count of strings using n characters with repetitions allowed ; Count of palindromic strings ; Count of non - palindromic strings ; Driver code"
Python;"freq = [ 0 ] * 26 NEW_LINE def checkPalindrome ( ) : NEW_LINE INDENT oddCnt = 0 NEW_LINE for x in freq : NEW_LINE INDENT if ( x % 2 == 1 ) : NEW_LINE INDENT oddCnt += 1 NEW_LINE DEDENT DEDENT return oddCnt <= 1 NEW_LINE DEDENT def countPalindromePermutation ( s , k ) : NEW_LINE INDENT for i in range ( k ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - 97 ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE if ( checkPalindrome ( ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT i = 0 NEW_LINE j = k NEW_LINE while ( j < len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - 97 ] -= 1 NEW_LINE i += 1 NEW_LINE freq [ ord ( s [ j ] ) - 97 ] += 1 NEW_LINE j += 1 NEW_LINE if ( checkPalindrome ( ) ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT str = "" abbaca "" NEW_LINE K = 3 NEW_LINE print ( countPalindromePermutation ( str , K ) ) NEW_LINE";"Count of K | To store the frequency array ; Function to check palindromic of of any substring using frequency array ; Initialise the odd count ; Traversing frequency array to compute the count of characters having odd frequency ; Returns true if odd count is atmost 1 ; Function to count the total number substring whose any permutations are palindromic ; Computing the frequency of first K character of the string ; To store the count of palindromic permutations ; Checking for the current window if it has any palindromic permutation ; Start and end poof window ; Decrementing count of first element of the window ; Incrementing count of next element of the window ; Checking current window character frequency count ; Return the final count ; Given string str ; Window of size K ; Function call"
Python;"def minFlips ( target ) : NEW_LINE INDENT curr = '1' NEW_LINE count = 0 NEW_LINE for i in range ( len ( target ) ) : NEW_LINE INDENT if ( target [ i ] == curr ) : NEW_LINE INDENT count += 1 NEW_LINE curr = chr ( 48 + ( ord ( curr ) + 1 ) % 2 ) NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT S = ""011000"" NEW_LINE print ( minFlips ( S ) ) NEW_LINE DEDENT";"Minimum flips required to form given binary string where every flip changes all bits to its right as well | Function to return the count of minimum flips required ; If curr occurs in the final string ; Switch curr to '0' if '1' or vice - versa ; Driver Code"
Python;"import math NEW_LINE def checkSuffix ( A , B ) : NEW_LINE INDENT digit_B = int ( math . log10 ( B ) ) + 1 ; NEW_LINE A -= B ; NEW_LINE return ( A % int ( math . pow ( 10 , digit_B ) ) ) ; NEW_LINE DEDENT A = 12345 ; B = 45 ; NEW_LINE result = checkSuffix ( A , B ) ; NEW_LINE if ( result == 0 ) : NEW_LINE INDENT print ( "" Yes "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) ; NEW_LINE DEDENT";"Check if a number ends with another number or not | Python3 program for the above approach ; Function to check if B is a suffix of A or not ; Find the number of digit in B ; Subtract B from A ; Returns true , if B is a suffix of A ; Given numbers ; Function Call ; If B is a suffix of A , then print "" Yes """
Python;"import sys NEW_LINE INT_MAX = sys . maxsize ; NEW_LINE def count_min_length ( s ) : NEW_LINE INDENT hash = [ 0 ] * 26 ; NEW_LINE ans = sys . maxsize ; NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT hash [ i ] = - 1 ; NEW_LINE DEDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == - 1 ) : NEW_LINE INDENT hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = i ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == i - 1 or hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] == i - 2 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT ans = min ( ans , i - hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] - 1 ) ; NEW_LINE hash [ ord ( s [ i ] ) - ord ( ' a ' ) ] = i ; NEW_LINE DEDENT DEDENT if ( ans == INT_MAX ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT string = "" abcdeba "" ; NEW_LINE print ( count_min_length ( string ) ) ; NEW_LINE DEDENT";"Minimum length of substring whose rotation generates a palindromic substring | Python3 program to find the minimum length of substring whose rotation generates a palindromic substring ; Function to return the minimum length of substring ; Store the index of previous occurrence of the character ; Variable to store the maximum length of substring ; If the current character hasn 't appeared yet ; If the character has occured within one or two previous index , a palindromic substring already exists ; Update the maximum ; Replace the previous index of the character by the current index ; If character appeared at least twice ; Driver Code"
Python;"import re NEW_LINE def RemoveHTMLTags ( strr ) : NEW_LINE INDENT print ( re . compile ( r ' < [ ^ > ] + > ' ) . sub ( ' ' , strr ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT strr = "" < div > < b > Geeks ▁ for ▁ Geeks < / b > < / div > "" NEW_LINE RemoveHTMLTags ( strr ) ; NEW_LINE DEDENT";"Program to remove HTML tags from a given String | Python3 program for the above approach ; Function to remove the HTML tags from the given tags ; Print string after removing tags ; Driver code ; Given String ; Function call to print the HTML string after removing tags"
Python;"class TreeNode : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . parent = None NEW_LINE self . children = [ ] NEW_LINE DEDENT def addChild ( self , node ) : NEW_LINE INDENT self . children . append ( node ) ; NEW_LINE DEDENT def setParent ( self , node ) : NEW_LINE INDENT self . parent = node ; NEW_LINE DEDENT def getParent ( self ) : NEW_LINE INDENT return self . parent ; NEW_LINE DEDENT def computeScore ( self ) : NEW_LINE INDENT if ( len ( self . children ) == 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT res = 0 ; NEW_LINE for curr in self . children : NEW_LINE INDENT res += curr . computeScore ( ) ; NEW_LINE DEDENT if ( self . parent == None ) : NEW_LINE INDENT return res ; NEW_LINE DEDENT else : NEW_LINE INDENT return 2 * res ; NEW_LINE DEDENT DEDENT DEDENT def computeTree ( s ) : NEW_LINE INDENT current = TreeNode ( ) ; NEW_LINE root = current ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT child = TreeNode ( ) ; NEW_LINE child . setParent ( current ) ; NEW_LINE current . addChild ( child ) ; NEW_LINE current = child ; NEW_LINE DEDENT else : NEW_LINE INDENT current = current . getParent ( ) ; NEW_LINE DEDENT DEDENT return root ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = "" ( ( ) ( ( ) ) ) "" ; NEW_LINE root = computeTree ( s ) ; NEW_LINE print ( root . computeScore ( ) ) NEW_LINE DEDENT";"Score of Parentheses using Tree | Customized tree class or struct , contains all required methods . ; Function to add a child into the list of children ; Function to change the parent pointer to the node passed ; Function to return the parent of the current node ; Function to compute the score recursively . ; Base case ; Adds scores of all children ; Function to create the tree structure ; Creating a node for every "" ( ) "" ; If we find "" ( "" we add a node as a child ; On finding "" ) "" which confirms that a pair is closed , we go back to the parent ; Driver code ; Generating the tree ; Computing the score"
Python;"def rec ( a , i ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT a . pop ( ) NEW_LINE print ( "" "" . join ( a ) ) NEW_LINE return NEW_LINE DEDENT if ( a [ i ] == ' x ' ) : NEW_LINE j = i NEW_LINE while ( a [ j ] != ' \0' and a [ j + 1 ] != ' \0' ) : NEW_LINE INDENT ( a [ j ] , a [ j + 1 ] ) = ( a [ j + 1 ] , a [ j ] ) NEW_LINE j += 1 NEW_LINE DEDENT rec ( a , i - 1 ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = [ ' g ' , ' e ' , ' e ' , ' k ' , ' x ' , ' s ' , ' x ' , ' x ' , ' k ' , ' s ' , ' \0' ] NEW_LINE n = 10 NEW_LINE rec ( a , n - 1 ) NEW_LINE DEDENT";"Move all occurrence of letter ' x ' from the string s to the end using Recursion | Recursive program to bring ' x ' to the end ; When the string is completed from reverse direction end of recursion ; If the character x is found ; Transverse the whole string ; Swap the x so that it moves to the last ; Call to the smaller problem now ; Driver code ; Size of a ; Call to rec"
Python;"def largestCharacter ( str ) : NEW_LINE INDENT uppercase = [ False ] * 26 NEW_LINE lowercase = [ False ] * 26 NEW_LINE arr = list ( str ) NEW_LINE for c in arr : NEW_LINE INDENT if ( c . islower ( ) ) : NEW_LINE INDENT lowercase [ ord ( c ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT if ( c . isupper ( ) ) : NEW_LINE INDENT uppercase [ ord ( c ) - ord ( ' A ' ) ] = True NEW_LINE DEDENT DEDENT for i in range ( 25 , - 1 , - 1 ) : NEW_LINE INDENT if ( uppercase [ i ] and lowercase [ i ] ) : NEW_LINE INDENT return chr ( i + ord ( ' A ' ) ) + "" "" NEW_LINE DEDENT DEDENT return "" - 1"" NEW_LINE DEDENT str = "" admeDCAB "" NEW_LINE print ( largestCharacter ( str ) ) NEW_LINE";"Find the largest Alphabetic character present in the string | Function to find the Largest Alphabetic Character ; Array for keeping track of both uppercase and lowercase english alphabets ; Iterate from right side of array to get the largest index character ; Check for the character if both its uppercase and lowercase exist or not ; Return - 1 if no such character whose uppercase and lowercase present in string str ; Driver code"
Python;"def finalString ( st ) : NEW_LINE INDENT x , y = 0 , 0 NEW_LINE n = len ( st ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( st [ i ] == '1' ) : NEW_LINE INDENT x += 1 NEW_LINE DEDENT else : NEW_LINE INDENT y += 1 NEW_LINE DEDENT DEDENT if ( x > y ) : NEW_LINE INDENT left = 1 NEW_LINE DEDENT else : NEW_LINE INDENT left = 0 NEW_LINE DEDENT length = n - 2 * min ( x , y ) ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT print ( left , end = "" "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT st = ""010110100100000"" NEW_LINE finalString ( st ) NEW_LINE DEDENT";"Print string after removing all ( “ 10 ” or “ 01 ” ) from the binary string | Function to print the final string after removing all the occurrences of ""10"" and ""01"" from the given binary string ; Variables to store the count of 1 ' s ▁ and ▁ 0' s ; Length of the string ; For loop to count the occurrences of 1 ' s ▁ and ▁ 0' s in the string ; To check if the count of 1 ' s ▁ is ▁ ▁ greater ▁ than ▁ the ▁ count ▁ of ▁ 0' s or not . If x is greater , then those many 1 's  are printed. ; Length of the final remaining string after removing all the occurrences ; Printing the final string ; Driver Code"
Python;"def printPalindrome ( left , mid , right ) : NEW_LINE INDENT for x in left : NEW_LINE INDENT print ( x , end = "" "" ) NEW_LINE DEDENT print ( mid , end = "" "" ) NEW_LINE right = right [ : : - 1 ] NEW_LINE for x in right : NEW_LINE INDENT print ( x , end = "" "" ) NEW_LINE DEDENT print ( ' ' , end = "" "" ) NEW_LINE DEDENT def findPalindrome ( S , N , M ) : NEW_LINE INDENT d = set ( ) NEW_LINE for i in range ( M ) : NEW_LINE INDENT d . add ( S [ i ] ) NEW_LINE DEDENT left = [ ] NEW_LINE right = [ ] NEW_LINE mid = "" "" NEW_LINE for i in range ( N ) : NEW_LINE INDENT t = S [ i ] NEW_LINE t = t [ : : - 1 ] NEW_LINE if ( t == S [ i ] ) : NEW_LINE INDENT mid = t NEW_LINE DEDENT elif ( t in d ) : NEW_LINE INDENT left . append ( S [ i ] ) NEW_LINE right . append ( t ) NEW_LINE d . remove ( S [ i ] ) NEW_LINE d . remove ( t ) NEW_LINE DEDENT DEDENT printPalindrome ( left , mid , right ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = [ "" tab "" , "" one "" , "" bat "" ] NEW_LINE M = 3 NEW_LINE N = len ( S ) NEW_LINE findPalindrome ( S , N , M ) NEW_LINE DEDENT";"Longest palindrome formed by concatenating and reordering strings of equal length | Function to print the longest palindrome ; Printing every string in left vector ; Printing the palindromic string in the middle ; Printing the reverse of the right vector to make the final output palindromic ; Function to find and print the longest palindrome that can be formed ; Inserting each string in the set ; Vectors to add the strings in the left and right side ; To add the already present palindrome string in the middle of the solution ; Iterating through all the given strings ; If the string is a palindrome it is added in the middle ; Checking if the reverse of the string is already present in the set ; Driver code"
Python;"def IsLexicographicallySmaller ( A , B ) : NEW_LINE INDENT if ( A < B ) : NEW_LINE INDENT return True NEW_LINE DEDENT temp = A NEW_LINE temp = ' ' . join ( sorted ( temp ) ) NEW_LINE index = - 1 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if ( A [ i ] != temp [ i ] ) : NEW_LINE INDENT index = i NEW_LINE break NEW_LINE DEDENT DEDENT if ( index == - 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT j = 0 NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if ( A [ i ] == temp [ index ] ) : NEW_LINE INDENT j = i NEW_LINE DEDENT DEDENT A = list ( A ) NEW_LINE A [ index ] , A [ j ] = A [ j ] , A [ index ] NEW_LINE A = ' ' . join ( A ) NEW_LINE if ( A < B ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT A = "" AGAIN "" NEW_LINE B = "" ACTION "" NEW_LINE if ( IsLexicographicallySmaller ( A , B ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Lexicographically smaller string by swapping at most one character pair | Function that finds whether is it possible to make string A lexicographically smaller than string B ; Condition if string A is already smaller than B ; Sorting temp string ; Condition for first changed character of string A and temp ; Condition if string A is already sorted ; Finding first changed character from last of string A ; Swap the two characters ; Condition if string A is smaller than B ; Driver Code"
Python;"def maxi ( x , y ) : NEW_LINE INDENT if x > y : NEW_LINE INDENT return x NEW_LINE DEDENT else : NEW_LINE INDENT return y NEW_LINE DEDENT DEDENT def longestPalindromic ( strn , i , j , count ) : NEW_LINE INDENT if i > j : NEW_LINE INDENT return count NEW_LINE DEDENT if i == j : NEW_LINE INDENT return ( count + 1 ) NEW_LINE DEDENT if strn [ i ] == strn [ j ] : NEW_LINE INDENT count = longestPalindromic ( strn , i + 1 , j - 1 , count + 2 ) NEW_LINE return maxi ( count , maxi ( longestPalindromic ( strn , i + 1 , j , 0 ) , longestPalindromic ( strn , i , j - 1 , 0 ) ) ) NEW_LINE DEDENT return maxi ( longestPalindromic ( strn , i + 1 , j , 0 ) , longestPalindromic ( strn , i , j - 1 , 0 ) ) NEW_LINE DEDENT def longest_palindromic_substr ( strn ) : NEW_LINE INDENT k = len ( strn ) - 1 NEW_LINE return longestPalindromic ( strn , 0 , k , 0 ) NEW_LINE DEDENT strn = "" aaaabbaa "" NEW_LINE print ( longest_palindromic_substr ( strn ) ) NEW_LINE";"Length of longest palindromic sub | Function to find maximum of the two variables ; Function to find the longest palindromic substring : Recursion ; Base condition when the start index is greater than end index ; Base condition when both the start and end index are equal ; Condition when corner characters are equal in the string ; Recursive call to find the longest Palindromic string by excluding the corner characters ; Recursive call to find the longest Palindromic string by including one corner character at a time ; Function to find the longest palindromic sub - string ; Utility function call ; Driver Code ; Function Call"
Python;def MaxPrefix ( string ) : NEW_LINE INDENT Dict = { } NEW_LINE maxprefix = 0 NEW_LINE for i in string : NEW_LINE INDENT Dict [ i ] = Dict . get ( i , 0 ) + 1 NEW_LINE DEDENT minfrequency = min ( Dict . values ( ) ) NEW_LINE countminFrequency = 0 NEW_LINE for x in Dict : NEW_LINE INDENT if ( Dict [ x ] == minfrequency ) : NEW_LINE INDENT countminFrequency += 1 NEW_LINE DEDENT DEDENT mapper = { } NEW_LINE indi = 0 NEW_LINE for i in string : NEW_LINE INDENT mapper [ i ] = mapper . get ( i , 0 ) + 1 NEW_LINE if ( mapper [ i ] > countminFrequency ) : NEW_LINE INDENT break NEW_LINE DEDENT indi += 1 NEW_LINE DEDENT print ( string [ : indi ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = ' aabcdaab ' NEW_LINE MaxPrefix ( str ) NEW_LINE DEDENT;"Maximum length prefix such that frequency of each character is atmost number of characters with minimum frequency | Function to find the maximum possible prefix of the string ; Hash map to store the frequency of the characters in the string ; Iterate over the string to find the occurence of each Character ; Minimum frequency of the Characters ; Loop to find the count of minimum frequency in the hash - map ; Loop to find the maximum possible length of the prefix in the string ; Condition to check if the frequency is greater than minimum possible freq ; maxprefix string and its length . ; Driver code ; String is initialize . ; str is passed in MaxPrefix function ."
Python;"def countSubstring ( S , L , n ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ( ord ( L [ i ] ) - ord ( ' a ' ) ) ] = 1 NEW_LINE DEDENT count , ans = 0 , 0 NEW_LINE for x in S : NEW_LINE INDENT if ( freq [ ord ( x ) - ord ( ' a ' ) ] ) : NEW_LINE INDENT ans += ( count * count + count ) // 2 NEW_LINE count = 0 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans += ( count * count + count ) // 2 NEW_LINE return ans NEW_LINE DEDENT S = "" abcpxyz "" NEW_LINE L = [ ' a ' , ' p ' , ' q ' ] NEW_LINE n = len ( L ) NEW_LINE print ( countSubstring ( S , L , n ) ) NEW_LINE";"Count of Substrings that can be formed without using the given list of Characters | Function to find the Number of sub - strings without using given character ; the freq array ; Count variable to store the count of the characters until a character from given L is encountered ; If a character from L is encountered , then the answer variable is incremented by the value obtained by using the mentioned formula and count is set to 0 ; For last remaining characters ; Driver code"
Python;"def checkIfStartsWithVowels ( string ) : NEW_LINE INDENT if ( not ( string [ 0 ] == ' A ' or string [ 0 ] == ' a ' or string [ 0 ] == ' E ' or string [ 0 ] == ' e ' or string [ 0 ] == ' I ' or string [ 0 ] == ' i ' or string [ 0 ] == ' O ' or string [ 0 ] == ' o ' or string [ 0 ] == ' U ' or string [ 0 ] == ' u ' ) ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT def check ( string ) : NEW_LINE INDENT if ( checkIfStartsWithVowels ( string ) ) : NEW_LINE INDENT print ( "" Not ▁ Accepted "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Accepted "" ) ; NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT string = "" animal "" ; NEW_LINE check ( string ) ; NEW_LINE string = "" zebra "" ; NEW_LINE check ( string ) ; NEW_LINE DEDENT";"Program to accept Strings starting with a Vowel | Function to check if first character is vowel ; Function to check ; Driver function"
Python;"def findNthOccur ( string , ch , N ) : NEW_LINE INDENT occur = 0 ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == ch ) : NEW_LINE INDENT occur += 1 ; NEW_LINE DEDENT if ( occur == N ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT string = "" geeks "" ; NEW_LINE ch = ' e ' ; NEW_LINE N = 2 ; NEW_LINE print ( findNthOccur ( string , ch , N ) ) ; NEW_LINE DEDENT";"Find the Nth occurrence of a character in the given String | Function to find the Nth occurrence of a character ; Loop to find the Nth occurrence of the character ; Driver Code"
Python;"def solve ( X , Y , N , K ) : NEW_LINE INDENT count = [ 0 ] * ( N + 1 ) ; NEW_LINE sol = 0 ; NEW_LINE count [ 0 ] = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT count [ i ] = ( count [ i - 1 ] + abs ( ord ( X [ i - 1 ] ) - ord ( Y [ i - 1 ] ) ) ) ; NEW_LINE DEDENT j = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT while ( ( count [ i ] - count [ j ] ) > K ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT sol = max ( sol , i - j ) ; NEW_LINE DEDENT return sol ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 ; NEW_LINE X = "" abcd "" ; NEW_LINE Y = "" bcde "" ; NEW_LINE K = 3 ; NEW_LINE print ( solve ( X , Y , N , K ) ) ; NEW_LINE DEDENT";"Longest equal substring with cost less than K | Function to find the maximum length ; Fill the prefix array with the difference of letters ; Update the maximum length ; Driver code"
Python;"from math import floor NEW_LINE def jaro_distance ( s1 , s2 ) : NEW_LINE INDENT if ( s1 == s2 ) : NEW_LINE INDENT return 1.0 ; NEW_LINE DEDENT len1 = len ( s1 ) ; NEW_LINE len2 = len ( s2 ) ; NEW_LINE if ( len1 == 0 or len2 == 0 ) : NEW_LINE INDENT return 0.0 ; NEW_LINE DEDENT max_dist = ( max ( len ( s1 ) , len ( s2 ) ) // 2 ) - 1 ; NEW_LINE match = 0 ; NEW_LINE hash_s1 = [ 0 ] * len ( s1 ) ; NEW_LINE hash_s2 = [ 0 ] * len ( s2 ) ; NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT for j in range ( max ( 0 , i - max_dist ) , min ( len2 , i + max_dist + 1 ) ) : NEW_LINE INDENT if ( s1 [ i ] == s2 [ j ] and hash_s2 [ j ] == 0 ) : NEW_LINE INDENT hash_s1 [ i ] = 1 ; NEW_LINE hash_s2 [ j ] = 1 ; NEW_LINE match += 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT if ( match == 0 ) : NEW_LINE INDENT return 0.0 ; NEW_LINE DEDENT t = 0 ; NEW_LINE point = 0 ; NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT if ( hash_s1 [ i ] ) : NEW_LINE INDENT while ( hash_s2 [ point ] == 0 ) : NEW_LINE INDENT point += 1 ; NEW_LINE DEDENT if ( s1 [ i ] != s2 [ point ] ) : NEW_LINE INDENT point += 1 ; NEW_LINE t += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT point += 1 ; NEW_LINE DEDENT DEDENT t /= 2 ; NEW_LINE DEDENT return ( ( match / len1 + match / len2 + ( match - t ) / match ) / 3.0 ) ; NEW_LINE DEDENT def jaro_Winkler ( s1 , s2 ) : NEW_LINE INDENT jaro_dist = jaro_distance ( s1 , s2 ) ; NEW_LINE if ( jaro_dist > 0.7 ) : NEW_LINE INDENT prefix = 0 ; NEW_LINE for i in range ( min ( len ( s1 ) , len ( s2 ) ) ) : NEW_LINE INDENT if ( s1 [ i ] == s2 [ i ] ) : NEW_LINE INDENT prefix += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT prefix = min ( 4 , prefix ) ; NEW_LINE jaro_dist += 0.1 * prefix * ( 1 - jaro_dist ) ; NEW_LINE DEDENT return jaro_dist ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s1 = "" TRATE "" ; s2 = "" TRACE "" ; NEW_LINE print ( "" Jaro - Winkler ▁ Similarity ▁ = "" , jaro_Winkler ( s1 , s2 ) ) ; NEW_LINE DEDENT";"Jaro and Jaro | Python3 implementation of above approach ; Function to calculate the Jaro Similarity of two strings ; If the strings are equal ; Length of two strings ; Maximum distance upto which matching is allowed ; Count of matches ; Hash for matches ; Traverse through the first string ; Check if there is any matches ; If there is a match ; If there is no match ; Number of transpositions ; Count number of occurrences where two characters match but there is a third matched character in between the indices ; Find the next matched character in second string ; Return the Jaro Similarity ; Jaro Winkler Similarity ; If the jaro Similarity is above a threshold ; Find the length of common prefix ; If the characters match ; Else break ; Maximum of 4 characters are allowed in prefix ; Calculate jaro winkler Similarity ; Driver code ; Print Jaro - Winkler Similarity of two strings"
Python;"def isWordPresent ( sentence , word ) : NEW_LINE INDENT s = sentence . split ( "" ▁ "" ) NEW_LINE for i in s : NEW_LINE INDENT if ( i == word ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT s = "" Geeks ▁ for ▁ Geeks "" NEW_LINE word = "" Geeks "" NEW_LINE if ( isWordPresent ( s , word ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Check if a word is present in a sentence | Function that returns true if the word is found ; To break the sentence in words ; To temporarily store each individual word ; Comparing the current word with the word to be searched ; Driver code"
Python;"def isWordPresent ( sentence , word ) : NEW_LINE INDENT word = word . upper ( ) NEW_LINE sentence = sentence . upper ( ) NEW_LINE s = sentence . split ( ) ; NEW_LINE for temp in s : NEW_LINE INDENT if ( temp == word ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s = "" Geeks ▁ for ▁ Geeks "" ; NEW_LINE word = "" geeks "" ; NEW_LINE if ( isWordPresent ( s , word ) ) : NEW_LINE INDENT print ( "" Yes "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) ; NEW_LINE DEDENT DEDENT";"Check if a word is present in a sentence | Function that returns true if the word is found ; To convert the word in uppercase ; To convert the complete sentence in uppercase ; To break the sentence in words ; To store the individual words of the sentence ; Compare the current word with the word to be searched ; Driver code"
Python;"def countChars ( string , n ) : NEW_LINE INDENT i = 0 ; cnt = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT if ( string [ i ] == '0' ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT i += 2 ; NEW_LINE DEDENT cnt += 1 ; NEW_LINE DEDENT return cnt ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT string = ""11010"" ; NEW_LINE n = len ( string ) ; NEW_LINE print ( countChars ( string , n ) ) ; NEW_LINE DEDENT";"Count of 1 | Function to return the count of required characters ; While there are characters left ; Single bit character ; Two - bit character ; Update the count ; Driver code"
Python;"MAX = 26 ; NEW_LINE def compressString ( s , n ) : NEW_LINE INDENT freq = [ 0 ] * MAX ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( MAX ) : NEW_LINE INDENT if ( freq [ i ] == 0 ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT print ( ( chr ) ( i + ord ( ' a ' ) ) , freq [ i ] , end = "" ▁ "" ) ; NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s = "" geeksforgeeks "" ; NEW_LINE n = len ( s ) ; NEW_LINE compressString ( s , n ) ; NEW_LINE DEDENT";"Print the frequency of each character in Alphabetical order | Python3 implementation of the approach ; Function to print the frequency of each of the characters of s in alphabetical order ; To store the frequency of the characters ; Update the frequency array ; Print the frequency in alphatecial order ; If the current alphabet doesn 't  appear in the string ; Driver code"
Python;"import math NEW_LINE def decBinary ( arr , n ) : NEW_LINE INDENT k = int ( math . log2 ( n ) ) NEW_LINE while ( n > 0 ) : NEW_LINE INDENT arr [ k ] = n % 2 NEW_LINE k = k - 1 NEW_LINE n = n // 2 NEW_LINE DEDENT DEDENT def binaryDec ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ans = ans + ( arr [ i ] << ( n - i - 1 ) ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def concat ( m , n ) : NEW_LINE INDENT k = int ( math . log2 ( m ) ) + 1 NEW_LINE l = int ( math . log2 ( n ) ) + 1 NEW_LINE a = [ 0 for i in range ( 0 , k ) ] NEW_LINE b = [ 0 for i in range ( 0 , l ) ] NEW_LINE c = [ 0 for i in range ( 0 , k + l ) ] NEW_LINE decBinary ( a , m ) ; NEW_LINE decBinary ( b , n ) ; NEW_LINE iin = 0 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT c [ iin ] = a [ i ] NEW_LINE iin = iin + 1 NEW_LINE DEDENT for i in range ( 0 , l ) : NEW_LINE INDENT c [ iin ] = b [ i ] NEW_LINE iin = iin + 1 NEW_LINE DEDENT return ( binaryDec ( c , k + l ) ) NEW_LINE DEDENT m = 4 NEW_LINE n = 5 NEW_LINE print ( concat ( m , n ) ) NEW_LINE";"Find the number obtained after concatenation of binary representation of M and N | Python3 implementation of the approach ; Function to convert decimal number n to its binary representation stored as an array arr [ ] ; Funtion to convert the number represented as a binary array arr [ ] its decimal equivalent ; Function to concatenate the binary numbers and return the decimal result ; Number of bits in both the numbers ; Convert the bits in both the gers to the arrays a [ ] and b [ ] ; c [ ] will be the binary array for the result ; Update the c [ ] array ; Return the decimal equivalent of the result ; Driver code"
Python;def getBinaryLength ( n ) : NEW_LINE INDENT length = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT length += 1 NEW_LINE n //= 2 NEW_LINE DEDENT return length NEW_LINE DEDENT def concat ( m , n ) : NEW_LINE INDENT length = getBinaryLength ( n ) NEW_LINE return ( m << length ) + n NEW_LINE DEDENT m , n = 4 , 5 NEW_LINE print ( concat ( m , n ) ) NEW_LINE;"Find the number obtained after concatenation of binary representation of M and N | Utility function to calculate binary length of a number . ; Function to concatenate the binary numbers and return the decimal result ; find binary length of n ; left binary shift m and then add n ; Driver code"
Python;"def addZeros ( strr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT strr = ""0"" + strr NEW_LINE DEDENT return strr NEW_LINE DEDENT def getXOR ( a , b ) : NEW_LINE INDENT aLen = len ( a ) NEW_LINE bLen = len ( b ) NEW_LINE if ( aLen > bLen ) : NEW_LINE INDENT b = addZeros ( b , aLen - bLen ) NEW_LINE DEDENT elif ( bLen > aLen ) : NEW_LINE INDENT a = addZeros ( a , bLen - aLen ) NEW_LINE DEDENT lenn = max ( aLen , bLen ) ; NEW_LINE res = "" "" NEW_LINE for i in range ( lenn ) : NEW_LINE INDENT if ( a [ i ] == b [ i ] ) : NEW_LINE INDENT res += ""0"" NEW_LINE DEDENT else : NEW_LINE INDENT res += ""1"" NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT a = ""11001"" NEW_LINE b = ""111111"" NEW_LINE print ( getXOR ( a , b ) ) NEW_LINE";"XOR two binary strings of unequal lengths | Function to insert n 0 s in the beginning of the given string ; Function to return the XOR of the given strings ; Lengths of the given strings ; Make both the strings of equal lengths by inserting 0 s in the beginning ; Updated length ; To store the resultant XOR ; Driver code"
Python;"MAX = 26 ; NEW_LINE def minOperation ( str , len ) : NEW_LINE INDENT first , last = [ 0 ] * MAX , [ 0 ] * MAX ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT first [ i ] = - 1 ; NEW_LINE last [ i ] = - 1 ; NEW_LINE DEDENT for i in range ( len ) : NEW_LINE INDENT index = ( ord ( str [ i ] ) - ord ( ' a ' ) ) ; NEW_LINE if ( first [ index ] == - 1 ) : NEW_LINE INDENT first [ index ] = i ; NEW_LINE DEDENT last [ index ] = i ; NEW_LINE DEDENT minOp = - 1 ; NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT if ( first [ i ] == - 1 or first [ i ] == last [ i ] ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT cnt = len - ( last [ i ] - first [ i ] + 1 ) ; NEW_LINE if ( minOp == - 1 or cnt < minOp ) : NEW_LINE INDENT minOp = cnt ; NEW_LINE DEDENT DEDENT return minOp ; NEW_LINE DEDENT str = "" abcda "" ; NEW_LINE len = len ( str ) ; NEW_LINE print ( minOperation ( str , len ) ) ; NEW_LINE";"Minimum operations required to make the string satisfy the given condition | Python implementation of the approach ; Function to return the minimum operations required ; To store the first and the last occurrence of all the characters ; Set the first and the last occurrence of all the characters to - 1 ; Update the occurrences of the characters ; Only set the first occurrence if it hasn 't already been set ; To store the minimum operations ; If the frequency of the current character in the string is less than 2 ; Count of characters to be removed so that the string starts and ends at the current character ; Driver code"
Python;"N = 2 ; NEW_LINE def isVowel ( ch ) : NEW_LINE INDENT return ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) ; NEW_LINE DEDENT def countVowels ( string , l , r ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT if ( isVowel ( string [ i ] ) ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT return cnt ; NEW_LINE DEDENT def performQueries ( string , queries , q ) : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT print ( countVowels ( string , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) ) ; NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT string = "" geeksforgeeks "" ; NEW_LINE queries = [ [ 1 , 3 ] , [ 2 , 4 ] , [ 1 , 9 ] ] ; NEW_LINE q = len ( queries ) NEW_LINE performQueries ( string , queries , q ) ; NEW_LINE DEDENT";"Queries to find the count of vowels in the substrings of the given string | Python3 implementation of the approach ; Function that returns true if ch is a vowel ; Function to return the count of vowels in the substring str [ l ... r ] ; To store the count of vowels ; For every character in the index range [ l , r ] ; If the current character is a vowel ; For every query ; Find the count of vowels for the current query ; Driver code"
Python;"class node : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT data = None NEW_LINE next = None NEW_LINE DEDENT DEDENT def add ( data ) : NEW_LINE INDENT newnode = node ( ) NEW_LINE newnode . data = data NEW_LINE newnode . next = None NEW_LINE return newnode NEW_LINE DEDENT def string_to_SLL ( text , head ) : NEW_LINE INDENT head = add ( text [ 0 ] ) NEW_LINE curr = head NEW_LINE for i in range ( len ( text ) - 1 ) : NEW_LINE INDENT curr . next = add ( text [ i + 1 ] ) NEW_LINE curr = curr . next NEW_LINE DEDENT return head NEW_LINE DEDENT def print_ ( head ) : NEW_LINE INDENT curr = head NEW_LINE while ( curr != None ) : NEW_LINE INDENT print ( ( curr . data ) , end = "" ▁ - ▁ > ▁ "" ) NEW_LINE curr = curr . next NEW_LINE DEDENT DEDENT text = "" GEEKS "" NEW_LINE head = None NEW_LINE head = string_to_SLL ( text , head ) NEW_LINE print_ ( head ) NEW_LINE";"Convert a String to a Singly Linked List | Structure for a Singly Linked List ; Function to add a node to the Linked List ; Function to convert the string to Linked List . ; curr pointer points to the current node where the insertion should take place ; Function to print the data present in all the nodes ; Driver code"
Python;"def minLength ( string , l ) : NEW_LINE INDENT s = [ ] ; NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( len ( s ) == 0 ) : NEW_LINE INDENT s . append ( string [ i ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT c = s [ - 1 ] ; NEW_LINE if ( c != string [ i ] and c . upper ( ) == string [ i ] . upper ( ) ) : NEW_LINE INDENT s . pop ( ) ; NEW_LINE DEDENT else : NEW_LINE INDENT s . append ( string [ i ] ) ; NEW_LINE DEDENT DEDENT DEDENT return len ( s ) ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT string = "" ASbBsd "" ; NEW_LINE l = len ( string ) ; NEW_LINE print ( minLength ( string , l ) ) ; NEW_LINE DEDENT";"Reduce the string to minimum length with the given operation | Function to return the minimum possible length str can be reduced to with the given operation ; Stack to store the characters of the given string ; For every character of the string ; If the stack is empty then push the current character in the stack ; Get the top character ; If the top element is not equal to the current element and it only differs in the case ; Pop the top element from stack ; Else push the current element ; Driver code"
Python;"MAX = 26 NEW_LINE def canBeMadeEqual ( str1 , str2 ) : NEW_LINE INDENT len1 = len ( str1 ) NEW_LINE len2 = len ( str2 ) NEW_LINE if ( len1 == len2 ) : NEW_LINE INDENT freq = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT freq [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len2 ) : NEW_LINE INDENT if ( freq [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] > 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT DEDENT return False NEW_LINE DEDENT str1 = "" abc "" NEW_LINE str2 = "" defa "" NEW_LINE if ( canBeMadeEqual ( str1 , str2 ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Check whether two strings can be made equal by copying their characters with the adjacent ones | Python3 implementation of the approach ; Function that returns true if both the strings can be made equal with the given operation ; Lengths of both the strings have to be equal ; To store the frequency of the characters of str1 ; For every character of str2 ; If current character of str2 also appears in str1 ; Driver code"
Python;"def getCount ( str1 , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n - 2 ) : NEW_LINE INDENT if ( str1 [ i ] == str1 [ i + 1 ] and str1 [ i ] == str1 [ i + 2 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE i = i + 2 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT str1 = "" aabbbcc "" NEW_LINE n = len ( str1 ) NEW_LINE print ( getCount ( str1 , n ) ) NEW_LINE";"Minimum characters that are to be inserted such that no three consecutive characters are same | Function to return the count of characters that are to be inserted in str1 such that no three consecutive characters are same ; To store the count of operations required ; A character needs to be inserted after str1 [ i + 1 ] ; Current three consecutive characters are not same ; Driver code"
Python;"def fact ( n ) : NEW_LINE INDENT fact = 1 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT fact *= i ; NEW_LINE DEDENT return fact ; NEW_LINE DEDENT def countStrings ( string , n ) : NEW_LINE INDENT distinct_char = set ( ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT distinct_char . add ( string [ i ] ) ; NEW_LINE DEDENT return fact ( len ( distinct_char ) ) ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT string = "" geeksforgeeks "" ; NEW_LINE n = len ( string ) ; NEW_LINE print ( countStrings ( string , n ) ) ; NEW_LINE DEDENT";"Find the number of strings formed using distinct characters of a given string | Function to return the factorial of n ; Function to return the count of all possible strings that can be formed with the characters of the given string without repeating characters ; To store the distinct characters of the string str ; Driver code"
Python;"def getChar ( strr ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( len ( strr ) ) : NEW_LINE INDENT summ += ( ord ( strr [ i ] ) - ord ( ' a ' ) + 1 ) NEW_LINE DEDENT if ( summ % 26 == 0 ) : NEW_LINE INDENT return ord ( ' z ' ) NEW_LINE DEDENT else : NEW_LINE INDENT summ = summ % 26 NEW_LINE return chr ( ord ( ' a ' ) + summ - 1 ) NEW_LINE DEDENT DEDENT strr = "" gfg "" NEW_LINE print ( getChar ( strr ) ) NEW_LINE";"Find the character made by adding all the characters of the given string | Function to return the required character ; To store the summ of the characters of the given string ; Add the current character to the summ ; Return the required character ; Driver code"
Python;"def reverse ( string , length , l , r ) : NEW_LINE INDENT if ( l < 0 or r >= length or l > r ) : NEW_LINE INDENT return string ; NEW_LINE DEDENT string = list ( string ) NEW_LINE while ( l < r ) : NEW_LINE INDENT c = string [ l ] ; NEW_LINE string [ l ] = string [ r ] ; NEW_LINE string [ r ] = c ; NEW_LINE l += 1 ; NEW_LINE r -= 1 ; NEW_LINE DEDENT return "" "" . join ( string ) ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT string = "" geeksforgeeks "" ; NEW_LINE length = len ( string ) ; NEW_LINE l = 5 ; r = 7 ; NEW_LINE print ( reverse ( string , length , l , r ) ) ; NEW_LINE DEDENT";"Reverse the given string in the range [ L , R ] | Function to return the string after reversing characters in the range [ L , R ] ; Invalid range ; While there are characters to swap ; Swap ( str [ l ] , str [ r ] ) ; Driver code"
Python;"def encrypt ( input_arr ) : NEW_LINE INDENT evenPos = ' @ ' ; oddPos = ' ! ' ; NEW_LINE for i in range ( len ( input_arr ) ) : NEW_LINE INDENT ascii = ord ( input_arr [ i ] ) ; NEW_LINE repeat = ( ascii - 96 ) if ascii >= 97 else ( ascii - 64 ) ; NEW_LINE for j in range ( repeat ) : NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT if ( i % 2 == 0 ) : NEW_LINE INDENT print ( oddPos , end = "" "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( evenPos , end = "" "" ) ; NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT input_arr = [ ' A ' , ' b ' , ' C ' , ' d ' ] ; NEW_LINE encrypt ( input_arr ) ; NEW_LINE DEDENT";"Program to Encrypt a String using ! and @ | Function to encrypt the string ; evenPos is for storing encrypting char at evenPosition oddPos is for storing encrypting char at oddPosition ; Get the number of times the character is to be repeated ; if i is odd , print ' ! ' else print '@ ; Driver code ; Encrypt the String"
Python;"def IsRedundantBraces ( A ) : NEW_LINE INDENT a , b = 0 , 0 ; NEW_LINE for i in range ( len ( A ) ) : NEW_LINE INDENT if ( A [ i ] == ' ( ' and A [ i + 2 ] == ' ) ' ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( A [ i ] == ' * ' or A [ i ] == ' + ' or A [ i ] == ' - ' or A [ i ] == ' / ' ) : NEW_LINE INDENT a += 1 ; NEW_LINE DEDENT if ( A [ i ] == ' ( ' ) : NEW_LINE INDENT b += 1 ; NEW_LINE DEDENT DEDENT if ( b > a ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = "" ( ( ( a + b ) ▁ + ▁ c ) ▁ + ▁ d ) "" ; NEW_LINE if ( IsRedundantBraces ( A ) ) : NEW_LINE INDENT print ( "" YES "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) ; NEW_LINE DEDENT DEDENT";"Check if expression contains redundant bracket or not | Set 2 | Function to check for redundant braces ; count of no of signs ; Driver Code"
Python;"def balancedBrackets ( Str ) : NEW_LINE INDENT dep = 0 NEW_LINE minDep = 0 NEW_LINE for i in Str : NEW_LINE INDENT if ( i == ' ( ' ) : NEW_LINE INDENT dep += 1 NEW_LINE DEDENT else : NEW_LINE INDENT dep -= 1 NEW_LINE DEDENT if ( minDep > dep ) : NEW_LINE INDENT minDep = dep NEW_LINE DEDENT DEDENT if ( minDep < 0 ) : NEW_LINE INDENT for i in range ( abs ( minDep ) ) : NEW_LINE INDENT Str = ' ( ' + Str NEW_LINE DEDENT DEDENT dep = 0 NEW_LINE for i in Str : NEW_LINE INDENT if ( i == ' ( ' ) : NEW_LINE INDENT dep += 1 NEW_LINE DEDENT else : NEW_LINE INDENT dep -= 1 NEW_LINE DEDENT DEDENT if ( dep != 0 ) : NEW_LINE INDENT for i in range ( dep ) : Str = Str + ' ) ' NEW_LINE DEDENT return Str NEW_LINE DEDENT Str = "" ) ) ) ( ) "" NEW_LINE print ( balancedBrackets ( Str ) ) NEW_LINE";"Convert an unbalanced bracket sequence to a balanced sequence | Function to return balancedBrackets String ; Initializing dep to 0 ; Stores maximum negative depth ; if dep is less than minDep ; if minDep is less than 0 then there is need to add ' ( ' at the front ; Reinitializing to check the updated String ; if dep is not 0 then there is need to add ' ) ' at the back ; Driver code"
Python;"def minOperations ( str , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( str [ i ] != str [ i + 1 ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count + 1 ) // 2 NEW_LINE DEDENT str = ""000111"" NEW_LINE n = len ( str ) NEW_LINE print ( minOperations ( str , n ) ) NEW_LINE";"Minimum operations required to convert a binary string to all 0 s or all 1 s | Function to return the count of minimum operations required ; Increment count when consecutive characters are different ; Answer is rounding off the ( count / 2 ) to lower ; Driver code"
Python;"def find_digit ( s , n ) : NEW_LINE INDENT first_digit = - 1 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] < '0' or s [ i ] > '9' : NEW_LINE INDENT first_digit = i NEW_LINE break NEW_LINE DEDENT DEDENT first_digit += 1 NEW_LINE s_len = first_digit NEW_LINE num = 0 NEW_LINE pw = 1 NEW_LINE i = n - 1 NEW_LINE while i >= 0 : NEW_LINE INDENT if s [ i ] >= '0' and s [ i ] <= '9' : NEW_LINE INDENT digit = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE num = num + ( pw * digit ) NEW_LINE if num >= s_len : NEW_LINE INDENT return - 1 NEW_LINE DEDENT pw = pw * 10 NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT num = num * 10 NEW_LINE req = s_len - num NEW_LINE if req > 9 or req < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return req NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s = "" abcd0"" NEW_LINE n = len ( s ) NEW_LINE print ( find_digit ( s , n ) ) NEW_LINE DEDENT";"Append a digit in the end to make the number equal to the length of the remaining string | Function to return the required digit ; To store the position of the first numeric digit in the string ; To store the length of the string without the numeric digits in the end ; pw stores the current power of 10 and num is to store the number which is appended in the end ; If current character is a numeric digit ; Get the current digit ; Build the number ; If number exceeds the length ; Next power of 10 ; Append 0 in the end ; Required number that must be added ; If number is not a single digit ; Driver code"
Python;"def canConvert ( str1 , str2 ) : NEW_LINE INDENT i , j = 0 , 0 ; NEW_LINE while ( i < len ( str1 ) and j < len ( str2 ) ) : NEW_LINE INDENT if ( str1 [ i ] != str2 [ j ] ) : NEW_LINE INDENT if ( str1 [ i ] == '0' and str2 [ j ] == '1' and i + 1 < len ( str1 ) and str1 [ i + 1 ] == '0' ) : NEW_LINE INDENT i += 2 ; NEW_LINE j += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT i += 1 ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT if ( i == len ( str1 ) and j == len ( str2 ) ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT str1 = ""00100"" ; NEW_LINE str2 = ""111"" ; NEW_LINE if ( canConvert ( str1 , str2 ) ) : NEW_LINE INDENT print ( "" Yes "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) ; NEW_LINE DEDENT";"Check whether str1 can be converted to str2 with the given operations | Function that returns true if str1 can be converted to str2 with the given operations ; Traverse from left to right ; If the two characters do not match ; If possible to combine ; If not possible to combine ; If the two characters match ; If possible to convert one string to another ; Driver code"
Python;"def reverse ( s ) : NEW_LINE INDENT stc = [ ] NEW_LINE temp = "" "" NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' ▁ ' : NEW_LINE stc . append ( temp ) NEW_LINE temp = "" "" NEW_LINE else : NEW_LINE temp = temp + s [ i ] NEW_LINE DEDENT stc . append ( temp ) NEW_LINE while len ( stc ) != 0 : NEW_LINE INDENT temp = stc [ len ( stc ) - 1 ] NEW_LINE print ( temp , end = "" ▁ "" ) NEW_LINE stc . pop ( ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT s = "" I ▁ Love ▁ To ▁ Code "" NEW_LINE reverse ( s ) NEW_LINE";"Reverse the Words of a String using Stack | function to reverse the words of the given string without using strtok ( ) . ; create an empty string stack ; create an empty temporary string ; traversing the entire string ; push the temporary variable into the stack ; assigning temporary variable as empty ; for the last word of the string ; Get the words in reverse order ; Driver code"
Python;"def printMatrix ( n , m ) : NEW_LINE INDENT if ( n < 5 or m < 5 ) : NEW_LINE INDENT print ( - 1 , end = "" ▁ "" ) ; NEW_LINE return ; NEW_LINE DEDENT s = "" aeiou "" ; NEW_LINE s = list ( s ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT print ( s [ j % 5 ] , end = "" ▁ "" ) ; NEW_LINE DEDENT print ( ) NEW_LINE c = s [ 0 ] ; NEW_LINE for i in range ( 4 ) : NEW_LINE INDENT s [ i ] = s [ i + 1 ] ; NEW_LINE DEDENT s [ 4 ] = c ; NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 5 ; m = 5 ; NEW_LINE printMatrix ( n , m ) ; NEW_LINE DEDENT";"Print an N x M matrix such that each row and column has all the vowels in it | Function to print the required matrix ; Impossible to generate the required matrix ; Store all the vowels ; Print the matrix ; Print vowels for every index ; Shift the vowels by one ; Driver code"
Python;"def isTwoAlter ( s ) : NEW_LINE INDENT for i in range ( len ( s ) - 2 ) : NEW_LINE INDENT if ( s [ i ] != s [ i + 2 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( s [ 0 ] == s [ 1 ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT str = "" ABAB "" NEW_LINE if ( isTwoAlter ( str ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT";"Check if a given string is made up of two alternating characters | Function that returns true if the string is made up of two alternating characters ; Check if ith character matches with the character at index ( i + 2 ) ; If string consists of a single character repeating itself ; Driver code"
Python;"def minOperations ( n , a , b , c ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = a [ i ] NEW_LINE y = b [ i ] NEW_LINE z = c [ i ] NEW_LINE if ( x == y and y == z ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( x == y or y == z or x == z ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += 2 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = "" place "" NEW_LINE b = "" abcde "" NEW_LINE c = "" plybe "" NEW_LINE n = len ( a ) NEW_LINE print ( minOperations ( n , a , b , c ) ) NEW_LINE DEDENT";"Number of character corrections in the given strings to make them equal | Function to return the count of operations required ; To store the count of operations ; No operation required ; One operation is required when any two characters are equal ; Two operations are required when none of the characters are equal ; Return the minimum count of operations required ; Driver code"
Python;"def check ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] > s [ i + 1 ] ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = "" geeksforgeeks "" NEW_LINE if ( check ( s ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT";"Check if string can be made lexicographically smaller by reversing any substring | Function that returns true if s can be made lexicographically smaller by reversing a sub - string in s ; Traverse in the string ; Check if s [ i + 1 ] < s [ i ] ; Not possible ; Driver code"
Python;"def countSubStr ( str , n , x ) : NEW_LINE INDENT res = 0 ; count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == x ) : NEW_LINE INDENT res += ( ( count + 1 ) * ( n - i ) ) ; NEW_LINE count = 0 ; NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT str = "" abcabc "" ; NEW_LINE n = len ( str ) ; NEW_LINE x = ' c ' ; NEW_LINE print ( countSubStr ( str , n , x ) ) ; NEW_LINE";"Count of sub | Function to return the count of required sub - strings ; Number of sub - strings from position of current x to the end of str ; To store the number of characters before x ; Driver code"
Python;"def countSubStr ( string , n ) : NEW_LINE INDENT length = len ( string ) ; NEW_LINE return ( length - n + 1 ) ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT string = "" geeksforgeeks "" ; NEW_LINE n = 5 ; NEW_LINE print ( countSubStr ( string , n ) ) ; NEW_LINE DEDENT";"Count of sub | Function to return the count of possible sub - strings of length n ; Driver code"
Python;"def countSubstrings ( s , c ) : NEW_LINE INDENT n = len ( s ) NEW_LINE cnt = 0 NEW_LINE Sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] != c ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT Sum += ( cnt * ( cnt + 1 ) ) // 2 NEW_LINE cnt = 0 NEW_LINE DEDENT DEDENT Sum += ( cnt * ( cnt + 1 ) ) // 2 NEW_LINE return Sum NEW_LINE DEDENT s = "" baa "" NEW_LINE c = ' b ' NEW_LINE print ( countSubstrings ( s , c ) ) NEW_LINE";"Count of sub | Function to return the number of sub - strings that do not contain the given character c ; Length of the string ; Traverse in the string ; If current character is different from the given character ; Update the number of sub - strings ; Reset count to 0 ; For the characters appearing after the last occurrence of c ; Driver code"
Python;"import sys NEW_LINE def getMinimizedSum ( string , length ) : NEW_LINE INDENT maxVal = - ( sys . maxsize - 1 ) NEW_LINE sum = 0 ; NEW_LINE occurrences = [ 0 ] * 26 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT occurrences [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE sum += ord ( string [ i ] ) ; NEW_LINE DEDENT for i in range ( 26 ) : NEW_LINE INDENT count = occurrences [ i ] * ( i + ord ( ' a ' ) ) NEW_LINE maxVal = max ( maxVal , count ) ; NEW_LINE DEDENT return ( sum - maxVal ) ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT string = "" geeksforgeeks "" ; NEW_LINE length = len ( string ) ; NEW_LINE print ( getMinimizedSum ( string , length ) ) ; NEW_LINE DEDENT";"Minimize ASCII values sum after removing all occurrences of one character | Python3 implementation of the approach ; Function to return the minimized sum ; To store the occurrences of each character of the string ; Update the occurrence ; Calculate the sum ; Get the character which is contributing the maximum value to the sum ; Count of occurrence of the character multiplied by its ASCII value ; Return the minimized sum ; Driver code"
Python;"def isPalindrome ( s ) : NEW_LINE INDENT i = 0 ; NEW_LINE j = len ( s ) - 1 ; NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( s [ i ] is not s [ j ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT i += 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def getIndex ( S1 , S2 , n ) : NEW_LINE INDENT S = "" "" ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = S + S1 [ i ] ; NEW_LINE Temp = "" "" ; NEW_LINE for j in range ( i + 1 , n ) : NEW_LINE INDENT Temp += S2 [ j ] ; NEW_LINE DEDENT if ( isPalindrome ( S + Temp ) ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT S1 = "" abcdf "" ; S2 = "" sfgba "" ; NEW_LINE n = len ( S1 ) ; NEW_LINE print ( getIndex ( S1 , S2 , n ) ) ; NEW_LINE";"Find index i such that prefix of S1 and suffix of S2 till i form a palindrome when concatenated | Function that returns true if s is palindrome ; Function to return the required index ; Copy the ith character in S ; Copy all the character of string s2 in Temp ; Check whether the string is palindrome ; Driver code"
Python;"def isPalindrome ( s , i , j ) : NEW_LINE INDENT while ( i < j ) : NEW_LINE INDENT if ( s [ i ] != s [ j ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT i += 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def getIndex ( s1 , s2 , length ) : NEW_LINE INDENT i = 0 ; j = length - 1 ; NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( s1 [ i ] != s2 [ j ] ) : NEW_LINE INDENT break ; NEW_LINE DEDENT i += 1 ; NEW_LINE j -= 1 ; NEW_LINE DEDENT if ( i == j ) : NEW_LINE INDENT return i - 1 ; NEW_LINE DEDENT elif ( isPalindrome ( s2 , i , j ) ) : NEW_LINE INDENT return i - 1 ; NEW_LINE DEDENT elif ( isPalindrome ( s1 , i , j ) ) : NEW_LINE INDENT return j ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s1 = "" abcdf "" ; NEW_LINE s2 = "" sfgba "" ; NEW_LINE length = len ( s1 ) ; NEW_LINE print ( getIndex ( s1 , s2 , length ) ) ; NEW_LINE DEDENT";"Find index i such that prefix of S1 and suffix of S2 till i form a palindrome when concatenated | Function that returns true if the sub - string starting from index i and ending at index j is a palindrome ; Function to get the required index ; Start comparing the two strings from both ends . ; Break from the loop at first mismatch ; If it is possible to concatenate the strings to form palindrome , return index ; If remaining part for s2 is palindrome ; If remaining part for s1 is palindrome ; If not possible , return - 1 ; Driver Code"
Python;"def count_acronym ( n , arr ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( arr [ i ] [ 0 ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT st = arr [ i ] NEW_LINE num = [ 0 ] * 26 NEW_LINE for j in range ( len ( st ) ) : NEW_LINE INDENT num [ ord ( st [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT flag = True NEW_LINE for j in range ( 1 , 26 ) : NEW_LINE INDENT if num [ j ] > freq [ j ] : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT x = ord ( st [ 0 ] ) - ord ( ' a ' ) NEW_LINE if freq [ x ] - 1 < num [ x ] : NEW_LINE INDENT flag = False NEW_LINE DEDENT if flag : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ "" abc "" , "" bcad "" , "" cabd "" , "" cba "" , "" dzzz "" ] NEW_LINE n = 5 NEW_LINE print ( count_acronym ( n , arr ) ) NEW_LINE DEDENT";"Acronym words | Function to return the number of strings that can be an acronym for other strings ; Frequency array to store the frequency of the first character of every string in the array ; To store the count of required strings ; Current word ; Frequency array to store the frequency of each of the character of the current string ; Check if the frequency of every character in the current string is <= its value in freq [ ] ; First character of the current string ; Driver Code"
Python;"def valid ( cnt ) : NEW_LINE INDENT for i in range ( 0 , 26 ) : NEW_LINE INDENT if cnt [ i ] >= 2 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def getGoodString ( s , n ) : NEW_LINE INDENT if n < 26 : NEW_LINE INDENT return "" - 1"" NEW_LINE DEDENT for i in range ( 25 , n ) : NEW_LINE INDENT cnt = [ 0 ] * 26 NEW_LINE for j in range ( i , i - 26 , - 1 ) : NEW_LINE INDENT if s [ j ] != ' ? ' : NEW_LINE INDENT cnt [ ord ( s [ j ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT if valid ( cnt ) : NEW_LINE INDENT cur = 0 NEW_LINE while cur < 26 and cnt [ cur ] > 0 : NEW_LINE INDENT cur += 1 NEW_LINE DEDENT for j in range ( i - 25 , i + 1 ) : NEW_LINE INDENT if s [ j ] == ' ? ' : NEW_LINE INDENT s [ j ] = chr ( cur + ord ( ' a ' ) ) NEW_LINE cur += 1 NEW_LINE while cur < 26 and cnt [ cur ] > 0 : NEW_LINE INDENT cur += 1 NEW_LINE DEDENT DEDENT DEDENT return ' ' . join ( s ) NEW_LINE DEDENT DEDENT return "" - 1"" NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s = "" abcdefghijkl ? nopqrstuvwxy ? "" NEW_LINE n = len ( s ) NEW_LINE print ( getGoodString ( list ( s ) , n ) ) NEW_LINE DEDENT";"Sub | Function that returns true if every lowercase character appears atmost once ; Every character frequency must be not greater than one ; Function that returns the modified good string if possible ; If the length of the string is less than n ; Sub - strings of length 26 ; To store frequency of each character ; Get the frequency of each character in the current sub - string ; Check if we can get sub - string containing the 26 characters all ; Find which character is missing ; Fill with missing characters ; Find the next missing character ; Return the modified good string ; Driver code"
Python;"def isVowel ( c ) : NEW_LINE INDENT c = c . lower ( ) ; NEW_LINE if ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT def swapRepeated ( string ) : NEW_LINE INDENT for i in range ( len ( string ) - 1 ) : NEW_LINE INDENT if ( ( isVowel ( string [ i ] ) and isVowel ( string [ i + 1 ] ) ) or ( not ( isVowel ( string [ i ] ) ) and not ( isVowel ( string [ i + 1 ] ) ) ) ) : NEW_LINE INDENT ( string [ i ] , string [ i + 1 ] ) = ( string [ i + 1 ] , string [ i ] ) ; NEW_LINE DEDENT DEDENT string = "" "" . join ( string ) NEW_LINE return string ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT string = "" geeksforgeeks "" ; NEW_LINE print ( swapRepeated ( list ( string ) ) ) ; NEW_LINE DEDENT";"Modify the string by swapping continuous vowels or consonants | Function to check if a character is a vowel ; Function to swap two consecutively repeated vowels or consonants ; Traverse through the length of the string ; Check if the two consecutive characters are vowels or consonants ; swap the two characters ; Driver code"
Python;"def largestPalinSub ( s ) : NEW_LINE INDENT res = "" "" NEW_LINE mx = s [ 0 ] NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT mx = max ( mx , s [ i ] ) NEW_LINE DEDENT for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT if s [ i ] == mx : NEW_LINE INDENT res += s [ i ] NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s = "" geeksforgeeks "" NEW_LINE print ( largestPalinSub ( s ) ) NEW_LINE DEDENT";"Find the lexicographically largest palindromic Subsequence of a String | Function to find the largest palindromic subsequence ; Find the largest character ; Append all occurrences of largest character to the resultant string ; Driver Code"
Python;"def printString ( Str1 , n ) : NEW_LINE INDENT ones = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( Str1 [ i ] == '1' ) : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT DEDENT used = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( Str1 [ i ] == '2' and used == False ) : NEW_LINE INDENT used = 1 NEW_LINE for j in range ( ones ) : NEW_LINE INDENT print ( ""1"" , end = "" "" ) NEW_LINE DEDENT DEDENT if ( Str1 [ i ] != '1' ) : NEW_LINE INDENT print ( Str1 [ i ] , end = "" "" ) NEW_LINE DEDENT DEDENT if ( used == False ) : NEW_LINE INDENT for j in range ( ones ) : NEW_LINE INDENT print ( ""1"" , end = "" "" ) NEW_LINE DEDENT DEDENT DEDENT Str1 = ""100210"" NEW_LINE n = len ( Str1 ) NEW_LINE printString ( Str1 , n ) NEW_LINE";"Generate lexicographically smallest string of 0 , 1 and 2 with adjacent swaps allowed | Function to print the required string ; count number of 1 s ; To check if the all the 1 s have been used or not ; Print all the 1 s if any 2 is encountered ; If Str1 [ i ] = 0 or Str1 [ i ] = 2 ; If 1 s are not printed yet ; Driver code"
Python;"import math as mt NEW_LINE def findPermutation ( string , k ) : NEW_LINE INDENT has = [ False for i in range ( 26 ) ] NEW_LINE cnt = 0 NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( has [ ord ( string [ i ] ) - ord ( ' a ' ) ] == False ) : NEW_LINE INDENT cnt += 1 NEW_LINE has [ ord ( string [ i ] ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT DEDENT ans = 1 NEW_LINE for i in range ( 2 , cnt + 1 ) : NEW_LINE INDENT ans *= i NEW_LINE DEDENT for i in range ( cnt - k , 1 , - 1 ) : NEW_LINE INDENT ans //= i NEW_LINE DEDENT return ans NEW_LINE DEDENT string = "" geeksforgeeks "" NEW_LINE k = 4 NEW_LINE print ( findPermutation ( string , k ) ) NEW_LINE";"K length words that can be formed from given characters without repetition | Python3 implementation of the approach ; Function to return the required count ; To store the count of distinct characters in str ; Traverse str character by character ; If current character is appearing for the first time in str ; Increment the distinct character count ; Update the appearance of the current character ; Since P ( n , r ) = n ! / ( n - r ) ! ; Return the answer ; Driver code"
Python;"def product ( x ) : NEW_LINE INDENT prod = 1 NEW_LINE while ( x ) : NEW_LINE INDENT prod *= ( x % 10 ) NEW_LINE x //= 10 ; NEW_LINE DEDENT return prod NEW_LINE DEDENT def findNumber ( l , r ) : NEW_LINE INDENT a = str ( l ) ; NEW_LINE b = str ( r ) ; NEW_LINE ans = r NEW_LINE for i in range ( len ( b ) ) : NEW_LINE INDENT if ( b [ i ] == '0' ) : NEW_LINE INDENT continue NEW_LINE DEDENT curr = list ( b ) NEW_LINE curr [ i ] = str ( ( ( ord ( curr [ i ] ) - ord ( '0' ) ) - 1 ) + ord ( '0' ) ) NEW_LINE for j in range ( i + 1 , len ( curr ) ) : NEW_LINE INDENT curr [ j ] = str ( ord ( '9' ) ) NEW_LINE DEDENT num = 0 NEW_LINE for c in curr : NEW_LINE INDENT num = num * 10 + ( int ( c ) - ord ( '0' ) ) NEW_LINE DEDENT if ( num >= l and product ( ans ) < product ( num ) ) : NEW_LINE INDENT ans = num NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT l , r = 1 , 10 NEW_LINE print ( findNumber ( l , r ) ) NEW_LINE l , r = 51 , 62 NEW_LINE print ( findNumber ( l , r ) ) NEW_LINE DEDENT";"Find the number in a range having maximum product of the digits | Returns the product of digits of number x ; This function returns the number having maximum product of the digits ; Converting both integers to strings ; Let the current answer be r ; Stores the current number having current digit one less than current digit in b ; Replace all following digits with 9 to maximise the product ; Convert string to number ; Check if it lies in range and its product is greater than max product ; Driver Code"
Python;"vowels = [ ' a ' , ' e ' , ' i ' , ' o ' , ' u ' ] NEW_LINE mapping = { ' a ' : 0 , ' e ' : 1 , ' i ' : 2 , ' o ' : 3 , ' u ' : 4 } NEW_LINE def isValidSequence ( subList ) : NEW_LINE INDENT for vowel in vowels : NEW_LINE INDENT if vowel not in subList : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def longestSubsequence ( string , subList , index ) : NEW_LINE INDENT if index == len ( string ) : NEW_LINE INDENT if isValidSequence ( subList ) == True : NEW_LINE INDENT return subList NEW_LINE DEDENT else : NEW_LINE INDENT return [ ] NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if len ( subList ) == 0 : NEW_LINE INDENT if string [ index ] != ' a ' : NEW_LINE INDENT return longestSubsequence ( string , subList , index + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return longestSubsequence ( string , subList +   \ [ string [ index ] ] , index + 1 ) NEW_LINE DEDENT DEDENT elif mapping [ subList [ - 1 ] ] == mapping [ string [ index ] ] : NEW_LINE INDENT return longestSubsequence ( string , subList +   \ [ string [ index ] ] , index + 1 ) NEW_LINE DEDENT elif ( mapping [ subList [ - 1 ] ] + 1 ) == mapping [ string [ index ] ] : NEW_LINE INDENT sub1 = longestSubsequence ( string , subList +   \ [ string [ index ] ] , index + 1 ) NEW_LINE sub2 = longestSubsequence ( string , subList , index + 1 ) NEW_LINE if len ( sub1 ) > len ( sub2 ) : NEW_LINE INDENT return sub1 NEW_LINE DEDENT else : NEW_LINE INDENT return sub2 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT return longestSubsequence ( string , subList , index + 1 ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT string = "" aeiaaioooauuaeiou "" NEW_LINE subsequence = longestSubsequence ( string , [ ] , 0 ) NEW_LINE if len ( subsequence ) == 0 : NEW_LINE INDENT print ( "" No ▁ subsequence ▁ possible "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( subsequence ) NEW_LINE DEDENT DEDENT";"Longest Ordered Subsequence of Vowels | Python3 program to find the longest subsequence of vowels in the specified order ; Mapping values for vowels ; Function to check if given subsequence contains all the vowels or not ; not contain vowel ; Function to find the longest subsequence of vowels in the given string in specified order ; If we have reached the end of the string , return the subsequence if it is valid , else return an empty list ; If there is no vowel in the subsequence yet , add vowel at current index if it is ' a ' , else move on to the next character in the string ; If the last vowel in the subsequence until now is same as the vowel at current index , add it to the subsequence ; If the vowel at the current index comes right after the last vowel in the subsequence , we have two options : either to add the vowel in the subsequence , or move on to next character . We choose the one which gives the longest subsequence . ; Driver Code"
Python;"def printExpansion ( str ) : NEW_LINE INDENT for i in range ( len ( str ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( i , len ( str ) ) : NEW_LINE INDENT print ( str [ j ] , end = "" "" ) NEW_LINE DEDENT DEDENT DEDENT str = "" geeks "" NEW_LINE printExpansion ( str ) NEW_LINE";"Concatenate suffixes of a String | Function to print the expansion of the string ; Take sub - string from i to n - 1 ; Print the sub - string ; Driver code"
Python;"def constructBinString ( a , b , x ) : NEW_LINE INDENT d = x // 2 NEW_LINE if x % 2 == 0 and x // 2 != a : NEW_LINE INDENT d -= 1 NEW_LINE print ( ""0"" , end = "" "" ) NEW_LINE a -= 1 NEW_LINE DEDENT for i in range ( d ) : NEW_LINE INDENT print ( ""10"" , end = "" "" ) NEW_LINE DEDENT a = a - d NEW_LINE b = b - d NEW_LINE for i in range ( b ) : NEW_LINE INDENT print ( ""1"" , end = "" "" ) NEW_LINE DEDENT for i in range ( a ) : NEW_LINE INDENT print ( ""0"" , end = "" "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a , b , x = 4 , 3 , 2 NEW_LINE constructBinString ( a , b , x ) NEW_LINE DEDENT";"Construct a binary string following the given constraints | Function to print a binary string which has ' a ' number of 0 ' s , ▁ ' b ' ▁ number ▁ of ▁ 1' s and there are at least ' x ' indices such that s [ i ] != s [ i + 1 ] ; Divide index value by 2 and store it into d ; If index value x is even and x / 2 is not equal to a ; Loop for d for each d print 10 ; subtract d from a and b ; Loop for b to print remaining 1 's ; Loop for a to print remaining 0 's ; Driver Code"
Python;"def matchPattern ( s ) : NEW_LINE INDENT count = 0 ; NEW_LINE n = len ( s ) ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT while ( i < n and s [ i ] == ' a ' ) : NEW_LINE INDENT count += 1 ; NEW_LINE i = + 1 ; NEW_LINE DEDENT while ( i < n and s [ i ] == ' b ' ) : NEW_LINE INDENT count -= 1 ; NEW_LINE i += 1 ; NEW_LINE DEDENT if ( count != 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT s = "" bb "" ; NEW_LINE if ( matchPattern ( s ) == True ) : NEW_LINE INDENT print ( "" Yes "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) ; NEW_LINE DEDENT";"Check If every group of a ' s ▁ is ▁ followed ▁ by ▁ a ▁ group ▁ of ▁ b ' s of same length | Function to match whether there are always n consecutive b ' s ▁ followed ▁ by ▁ n ▁ consecutive ▁ a ' s throughout the string ; Traverse through the string ; Count a 's in current segment ; Count b 's in current segment ; If both counts are not same . ; Driver code"
Python;"def maximum_one ( s , n ) : NEW_LINE INDENT cnt_one = 0 NEW_LINE cnt , max_cnt = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT cnt_one += 1 NEW_LINE cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT max_cnt = max ( max_cnt , cnt ) NEW_LINE cnt = 0 NEW_LINE DEDENT DEDENT max_cnt = max ( max_cnt , cnt ) NEW_LINE left = [ 0 ] * n NEW_LINE right = [ 0 ] * n NEW_LINE if ( s [ 0 ] == '1' ) : NEW_LINE INDENT left [ 0 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT left [ 0 ] = 0 NEW_LINE DEDENT if ( s [ n - 1 ] == '1' ) : NEW_LINE INDENT right [ n - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ n - 1 ] = 0 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT left [ i ] = left [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT left [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT right [ i ] = right [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT right [ i ] = 0 NEW_LINE DEDENT DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT sum = left [ i - 1 ] + right [ i + 1 ] NEW_LINE if ( sum < cnt_one ) : NEW_LINE INDENT max_cnt = max ( max_cnt , sum + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT max_cnt = max ( max_cnt , sum ) NEW_LINE DEDENT DEDENT DEDENT return max_cnt NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s = ""111011101"" NEW_LINE print ( maximum_one ( s , len ( s ) ) ) NEW_LINE DEDENT";"Length of longest consecutive ones by at most one swap in a Binary String | Function to calculate the length of the longest consecutive 1 's ; To count all 1 's in the string ; To store cumulative 1 's ; Counting cumulative 1 's from left ; If 0 then start new cumulative one from that i ; perform step 3 of the approach ; step 3 ; Driver Code ; string"
Python;"def MaxFreq ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT string = ' ' NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT string += s [ j ] NEW_LINE if string in m . keys ( ) : NEW_LINE INDENT m [ string ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ string ] = 1 NEW_LINE DEDENT DEDENT DEDENT maxi = 0 NEW_LINE maxi_str = ' ' NEW_LINE for i in m : NEW_LINE INDENT if m [ i ] > maxi : NEW_LINE INDENT maxi = m [ i ] NEW_LINE maxi_str = i NEW_LINE DEDENT elif m [ i ] == maxi : NEW_LINE INDENT ss = i NEW_LINE if len ( ss ) > len ( maxi_str ) : NEW_LINE INDENT maxi_str = ss NEW_LINE DEDENT DEDENT DEDENT return maxi_str NEW_LINE DEDENT string = "" ababecdecd "" NEW_LINE INDENT print ( MaxFreq ( string ) ) NEW_LINE DEDENT";"Maximum length substring with highest frequency in a string | function to return maximum occurred substring of a string ; size of string ; to store maximum frequency ; To store string which has maximum frequency ; return substring which has maximum freq ; Driver code ; Function call"
Python;"def maxFreq ( s , a , b ) : NEW_LINE INDENT fre = [ 0 for i in range ( 10 ) ] NEW_LINE n = len ( s ) NEW_LINE if ( a > b ) : NEW_LINE INDENT swap ( a , b ) NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT a = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE fre [ a ] += 1 NEW_LINE DEDENT if ( fre [ a ] == 0 and fre [ b ] == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT elif ( fre [ a ] >= fre [ b ] ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return b NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 4 NEW_LINE b = 7 NEW_LINE s = ""47744"" NEW_LINE print ( maxFreq ( s , a , b ) ) NEW_LINE DEDENT";"Lexicographically smallest substring with maximum occurrences containing a ' s ▁ and ▁ b ' s only | Function to Find the lexicographically smallest substring in a given string with maximum frequency and contains a ' s ▁ and ▁ b ' s only . ; To store frequency of digits ; size of string ; Take lexicographically larger digit in b ; get frequency of each character ; If no such string exits ; Maximum frequency ; Driver program"
Python;"def convert ( n , a , b ) : NEW_LINE INDENT l = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] != b [ i ] ) : NEW_LINE INDENT l [ i ] = 1 NEW_LINE DEDENT DEDENT cc = 0 NEW_LINE vl = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( l [ i ] == 0 ) : NEW_LINE INDENT if ( vl != 0 ) : NEW_LINE INDENT cc += 1 NEW_LINE DEDENT vl = 0 NEW_LINE DEDENT else : NEW_LINE INDENT vl += 1 NEW_LINE DEDENT DEDENT if ( vl != 0 ) : NEW_LINE INDENT cc += 1 NEW_LINE DEDENT print ( cc ) NEW_LINE DEDENT a = ""101010"" NEW_LINE b = ""110011"" NEW_LINE n = len ( a ) NEW_LINE convert ( n , a , b ) NEW_LINE";"Minimum steps to convert one binary string to other only using negation | Function to find the minimum steps to convert string a to string b ; List to mark the positions needed to be negated ; If two character are not same then they need to be negated ; To count the blocks of 1 ; To count the number of 1 ' s ▁ in ▁ each ▁ ▁ block ▁ of ▁ 1' s ; For the last block of 1 's ; Driver code"
Python;"def StringMatch ( S ) : NEW_LINE INDENT lo , hi = 0 , len ( S ) NEW_LINE ans = [ ] NEW_LINE for x in S : NEW_LINE INDENT if x == ' I ' : NEW_LINE INDENT ans . append ( lo ) NEW_LINE lo += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans . append ( hi ) NEW_LINE hi -= 1 NEW_LINE DEDENT DEDENT return ans + [ lo ] NEW_LINE DEDENT S = "" IDID "" NEW_LINE print ( StringMatch ( S ) ) NEW_LINE";"Generate a sequence with the given operations | function to find minimum required permutation ; Driver code"
Python;"def countWays ( s1 , s2 , n ) : NEW_LINE INDENT a = b = c = d = 0 NEW_LINE result = 0 ; NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( s2 [ i ] == '0' ) : NEW_LINE INDENT if ( s1 [ i ] == '0' ) : NEW_LINE INDENT c += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT d += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( s1 [ i ] == '0' ) : NEW_LINE INDENT a += 1 NEW_LINE DEDENT else : NEW_LINE INDENT b += 1 NEW_LINE DEDENT DEDENT DEDENT result = a * d + b * c + c * d NEW_LINE return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE s1 = ""01011"" NEW_LINE s2 = ""11001"" NEW_LINE print ( countWays ( s1 , s2 , n ) ) NEW_LINE DEDENT";"Number of ways to swap two bit of s1 so that bitwise OR of s1 and s2 changes | Function to find number of ways ; initialise result that store No . of swaps required ; Traverse both strings and check the bits as explained ; calculate result ; Driver code"
Python;"def returnWinner ( s , l ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( 0 , l , 1 ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT if ( cnt == 0 or cnt & 1 == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 2 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = "" abaaab "" NEW_LINE l = len ( s ) NEW_LINE winner = returnWinner ( s , l ) NEW_LINE print ( "" Player - "" , winner ) NEW_LINE DEDENT";"Find the player who rearranges the characters to get a palindrome string first | Function that returns the winner of the game ; Initialize the freq array to 0 ; Iterate and count the frequencies of each character in the string ; Count the odd occurring character ; If odd occurrence ; Check condition for Player - 1 winning the game ; Driver code ; Function call that returns the winner"
Python;"import sys NEW_LINE def maxProductSum ( string , m ) : NEW_LINE INDENT n = len ( string ) NEW_LINE maxProd , maxSum = ( - ( sys . maxsize ) - 1 , - ( sys . maxsize ) - 1 ) NEW_LINE for i in range ( n - m + 1 ) : NEW_LINE INDENT product , sum = 1 , 0 NEW_LINE for j in range ( i , m + i ) : NEW_LINE INDENT product = product * ( ord ( string [ j ] ) - ord ( '0' ) ) NEW_LINE sum = sum + ( ord ( string [ j ] ) - ord ( '0' ) ) NEW_LINE DEDENT maxProd = max ( maxProd , product ) NEW_LINE maxSum = max ( maxSum , sum ) NEW_LINE DEDENT print ( "" Maximum ▁ Product ▁ = "" , maxProd ) NEW_LINE print ( "" Maximum ▁ sum ▁ = "" , maxSum ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT string = ""3605356297"" NEW_LINE m = 3 NEW_LINE maxProductSum ( string , m ) NEW_LINE DEDENT";"Maximum sum and product of the M consecutive digits in a number | Python implementation of above approach ; Function to find the maximum product ; Driver code"
Python;"import sys NEW_LINE import math NEW_LINE def maxLength ( s , n ) : NEW_LINE INDENT right = 0 NEW_LINE left = 0 NEW_LINE coun = 0 NEW_LINE max_length = - ( sys . maxsize - 1 ) NEW_LINE s = s + '1' NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT if s [ i ] == ' o ' : NEW_LINE INDENT coun += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if coun > max_length : NEW_LINE INDENT right = 0 NEW_LINE left = 0 NEW_LINE if s [ i ] == ' x ' : NEW_LINE INDENT right = 1 NEW_LINE DEDENT if i - coun > 0 and s [ i - coun - 1 ] == ' x ' : NEW_LINE INDENT left = 1 NEW_LINE DEDENT coun = math . ceil ( float ( coun / ( right + left ) ) ) NEW_LINE max_length = max ( max_length , coun ) NEW_LINE DEDENT coun = 0 NEW_LINE DEDENT DEDENT return max_length NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = "" oooxoooooooooxooo "" NEW_LINE n = len ( s ) NEW_LINE print ( maxLength ( s , n ) ) NEW_LINE DEDENT";"Find time taken for signal to reach all positions in a string | Python3 program to Find time taken for signal to reach all positions in a string ; Returns time needed for signal to traverse through complete string . ; for the calculation of last index ; for strings like oxoooo , xoxxoooo ; if coun is greater than max_length ; if ' x ' is present at the right side of max_length ; if ' x ' is present at left side of max_length ; We use ceiling function to handle odd number ' o ' s ; Driver code"
Python;"def printLargestString ( s , l , r ) : NEW_LINE INDENT freq = [ 0 ] * 26 NEW_LINE l -= 1 NEW_LINE r -= 1 NEW_LINE for i in range ( min ( l , r ) , max ( l , r ) + 1 ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = "" "" NEW_LINE for i in range ( 25 , - 1 , - 1 ) : NEW_LINE INDENT while ( freq [ i ] ) : NEW_LINE INDENT ans += chr ( ord ( ' a ' ) + i ) NEW_LINE freq [ i ] -= 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s = "" striver "" NEW_LINE l = 3 NEW_LINE r = 5 NEW_LINE print ( printLargestString ( s , l , r ) ) NEW_LINE DEDENT";"Lexicographically largest string formed from the characters in range L and R | Function to return the lexicographically largest string ; hash array ; make 0 - based indexing ; iterate and count frequencies of character ; ans string ; iterate in frequency array ; add til all characters are added ; Driver Code"
Python;"def arrange ( s ) : NEW_LINE INDENT cc = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ""1"" ) : NEW_LINE INDENT cc += 1 NEW_LINE DEDENT DEDENT a = [ 0 ] * ( len ( s ) + 1 ) NEW_LINE qq = [ ( 2 , 3 ) , ( 5 , 5 ) ] NEW_LINE n = len ( qq ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT l , r = qq [ i ] [ 0 ] , qq [ i ] [ 1 ] NEW_LINE l -= 1 NEW_LINE r -= 1 NEW_LINE a [ l ] += 1 NEW_LINE a [ r + 1 ] -= 1 NEW_LINE DEDENT for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT a [ i ] = a [ i ] + a [ i - 1 ] NEW_LINE DEDENT zz = [ 0 ] * len ( s ) NEW_LINE for i in range ( len ( a ) - 1 ) : NEW_LINE INDENT if ( a [ i ] > 0 ) : NEW_LINE INDENT if ( cc > 0 ) : NEW_LINE INDENT zz [ i ] = 1 NEW_LINE cc -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( cc == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( cc > 0 ) : NEW_LINE INDENT for i in range ( len ( s ) ) : NEW_LINE INDENT if ( zz [ i ] == 0 ) : NEW_LINE INDENT zz [ i ] = 1 NEW_LINE cc -= 1 NEW_LINE DEDENT if ( cc == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT print ( * zz , sep = "" "" ) NEW_LINE DEDENT str = ""11100"" NEW_LINE arrange ( str ) NEW_LINE";"Arrange a binary string to get maximum value within a range of indices | Python implementation of the approach ; Storing the count of 1 's in the string ; Query of l and r ; Applying range update technique . ; Taking prefix sum to get the range update values ; Final array which will store the arranged string ; if after maximizing the ranges any 1 is left then we maximize the string lexicographically . ; Driver Code"
Python;"def areVowelsInOrder ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE c = chr ( 64 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( s [ i ] == ' a ' or s [ i ] == ' e ' or s [ i ] == ' i ' or s [ i ] == ' o ' or s [ i ] == ' u ' ) : NEW_LINE INDENT if s [ i ] < c : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT c = s [ i ] NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s = "" aabbbddeecc "" NEW_LINE if areVowelsInOrder ( s ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT";"Check whether the vowels in a string are in alphabetical order or not | Function that checks whether the vowel characters in a string are in alphabetical order or not ; ASCII Value 64 is less than all the alphabets so using it as a default value ; check if the vowels in the string are sorted or not ; if the vowel is smaller than the previous vowel ; store the vowel ; Driver code ; check whether the vowel characters in a string are in alphabetical order or not"
Python;"def printHyphen ( string ) : NEW_LINE INDENT lis = list ( string . split ( "" ▁ "" ) ) NEW_LINE string = ' - ' . join ( lis ) NEW_LINE return string NEW_LINE DEDENT string = "" Text ▁ contains ▁ malayalam ▁ and ▁ level ▁ words "" NEW_LINE print ( printHyphen ( string ) ) NEW_LINE";"Program to replace every space in a string with hyphen | Python program for the above approach ; Split by space and converting String to list and ; joining the list and storing in string ; returning thee string ; Driver code"
Python;"def newString ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE freq = [ 0 ] * ( 26 ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT ans = "" "" NEW_LINE for i in range ( 0 , 26 ) : NEW_LINE INDENT for j in range ( 0 , freq [ i ] ) : NEW_LINE INDENT ans += chr ( 97 + i ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s = "" aabab "" NEW_LINE print ( newString ( s ) ) NEW_LINE DEDENT";"Rearrange the string to maximize the number of palindromic substrings | Function to return the newString ; length of string ; hashing array ; iterate and count ; resulting string ; form the resulting string ; number of times character appears ; append to resulting string ; Driver Code"
Python;"def Remainder ( str , R ) : NEW_LINE INDENT l = len ( str ) NEW_LINE Rem = 0 NEW_LINE for i in range ( l ) : NEW_LINE INDENT Num = Rem * 10 + ( ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE Rem = Num % R NEW_LINE DEDENT return Rem NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT str = ""13589234356546756"" NEW_LINE R = 13 NEW_LINE print ( Remainder ( str , R ) ) NEW_LINE DEDENT";"Program to find remainder when large number is divided by r | Function to Return Remainder ; len is variable to store the length of Number string . ; loop that find Remainder ; Return the remainder ; Driver code ; Get the large number as string ; Get the divisor R ; Find and print the remainder"
Python;"def countWays ( a , n ) : NEW_LINE INDENT suff = [ 0 ] * n NEW_LINE if ( a [ n - 1 ] == 2 ) : NEW_LINE INDENT suff [ n - 1 ] = 1 NEW_LINE DEDENT for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( a [ i ] == 2 ) : NEW_LINE INDENT suff [ i ] = suff [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT suff [ i ] = suff [ i + 1 ] NEW_LINE DEDENT DEDENT ss = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT ss += suff [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( a [ i ] == 1 and a [ j ] == 1 and suff [ j ] >= 2 ) : NEW_LINE INDENT ss += ( suff [ j ] ) * ( suff [ j ] - 1 ) // 2 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( a [ i ] == 1 and a [ j ] == 1 and ( suff [ i ] - suff [ j ] ) >= 1 and suff [ j ] >= 1 ) : NEW_LINE INDENT ss += ( suff [ i ] - suff [ j ] ) * suff [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( ss ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = [ 1 , 2 , 1 , 1 , 2 , 2 ] NEW_LINE n = 6 NEW_LINE countWays ( a , n ) NEW_LINE DEDENT";"Number of balanced bracket subsequence of length 2 and 4 | Python 3 implementation of above approach ; Taking the frequency suffix sum of the number of 2 's present  after every index ; Storing the count of subsequence ; Subsequence of length 2 ; Subsequence of length 4 of type 1 1 2 2 ; Subsequence of length 4 of type 1 2 1 2 ; Driver Code"
Python;"def count_carry ( a , b ) : NEW_LINE INDENT carry = 0 ; NEW_LINE count = 0 ; NEW_LINE len_a = len ( a ) ; NEW_LINE len_b = len ( b ) ; NEW_LINE while ( len_a != 0 or len_b != 0 ) : NEW_LINE INDENT x = 0 ; NEW_LINE y = 0 ; NEW_LINE if ( len_a > 0 ) : NEW_LINE INDENT x = int ( a [ len_a - 1 ] ) + int ( '0' ) ; NEW_LINE len_a -= 1 ; NEW_LINE DEDENT if ( len_b > 0 ) : NEW_LINE INDENT y = int ( b [ len_b - 1 ] ) + int ( '0' ) ; NEW_LINE len_b -= 1 ; NEW_LINE DEDENT sum = x + y + carry ; NEW_LINE if ( sum >= 10 ) : NEW_LINE INDENT carry = 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT carry = 0 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT a = ""9555"" ; NEW_LINE b = ""555"" ; NEW_LINE count = count_carry ( a , b ) ; NEW_LINE if ( count == 0 ) : NEW_LINE INDENT print ( ""0"" ) ; NEW_LINE DEDENT elif ( count == 1 ) : NEW_LINE INDENT print ( ""1"" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( count ) ; NEW_LINE DEDENT";"Count the number of carry operations required to add two numbers | Function to count the number of carry operations ; Initialize the value of carry to 0 ; Counts the number of carry operations ; Initialize len_a and len_b with the sizes of strings ; Assigning the ascii value of the character ; Add both numbers / digits ; If sum > 0 , increment count and set carry to 1 ; Else , set carry to 0 ; Driver code"
Python;"def isInGivenBase ( Str , base ) : NEW_LINE INDENT if ( base > 16 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( base <= 10 ) : NEW_LINE INDENT for i in range ( len ( Str ) ) : NEW_LINE INDENT if ( Str [ i ] . isnumeric ( ) and ( ord ( Str [ i ] ) >= ord ( '0' ) and ord ( Str [ i ] ) < ( ord ( '0' ) + base ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT ' NEW_LINE INDENT else : NEW_LINE INDENT for i in range ( len ( Str ) ) : NEW_LINE INDENT if ( Str [ i ] . isnumeric ( ) and ( ( ord ( Str [ i ] ) >= ord ( '0' ) and ord ( Str [ i ] ) < ( ord ( '0' ) + base ) ) or ( ord ( Str [ i ] ) >= ord ( ' A ' ) and ord ( Str [ i ] ) < ( ord ( ' A ' ) + base - 10 ) ) ) == False ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT Str = "" AF87"" NEW_LINE if ( isInGivenBase ( Str , 16 ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Check if a number is in given base or not | Python3 program to check if given number is in given base or not . ; Allowed bases are till 16 ( Hexadecimal ) ; If base is below or equal to 10 , then all digits should be from 0 to 9. ; If base is below or equal to 16 , then all digits should be from 0 to 9 or from 'A ; Driver code"
Python;"def printIndex ( str , s ) : NEW_LINE INDENT flag = False ; NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( str [ i : i + len ( s ) ] == s ) : NEW_LINE INDENT print ( i , end = "" ▁ "" ) ; NEW_LINE flag = True ; NEW_LINE DEDENT DEDENT if ( flag == False ) : NEW_LINE INDENT print ( "" NONE "" ) ; NEW_LINE DEDENT DEDENT str1 = "" GeeksforGeeks "" ; NEW_LINE str2 = "" Geeks "" ; NEW_LINE printIndex ( str1 , str2 ) ; NEW_LINE";"Find indices of all occurrence of one string in other | Python program to find indices of all occurrences of one String in other . ; Driver code"
Python;"def merge ( s1 , s2 ) : NEW_LINE INDENT result = "" "" NEW_LINE i = 0 NEW_LINE while ( i < len ( s1 ) ) or ( i < len ( s2 ) ) : NEW_LINE INDENT if ( i < len ( s1 ) ) : NEW_LINE INDENT result += s1 [ i ] NEW_LINE DEDENT if ( i < len ( s2 ) ) : NEW_LINE INDENT result += s2 [ i ] NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT s1 = "" geeks "" NEW_LINE s2 = "" forgeeks "" NEW_LINE print ( merge ( s1 , s2 ) ) NEW_LINE";"Alternatively Merge two Strings in Java | Function for alternatively merging two strings ; To store the final string ; For every index in the strings ; First choose the ith character of the first string if it exists ; Then choose the ith character of the second string if it exists ; Driver Code"
Python;"def getMaxOccurringChar ( str ) : NEW_LINE INDENT freq = [ 0 for i in range ( 100 ) ] NEW_LINE max = - 1 NEW_LINE len__ = len ( str ) NEW_LINE DEDENT ' NEW_LINE INDENT for i in range ( 0 , len__ , 1 ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT for i in range ( 26 ) : NEW_LINE INDENT if ( max < freq [ i ] ) : NEW_LINE INDENT max = freq [ i ] NEW_LINE result = chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = "" sample ▁ program "" NEW_LINE print ( "" Maximum ▁ occurring ▁ character ▁ = "" , getMaxOccurringChar ( str ) ) NEW_LINE DEDENT";"Maximum occurring character in an input string | Set | function to find the maximum occurring character in an input string which is lexicographically first ; freq [ ] used as hash table ; to store maximum frequency ; length of str ; get frequency of each character of 'str ; for each character , where character is obtained by ( i + ' a ' ) check whether it is the maximum character so far and accodingly update 'result ; maximum occurring character ; Driver Code"
Python;"ALPHABET_SIZE = 26 ; NEW_LINE class trieNode : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . t = [ None for i in range ( ALPHABET_SIZE ) ] NEW_LINE self . isEnd = 0 NEW_LINE DEDENT DEDENT def getNode ( ) : NEW_LINE INDENT temp = trieNode ( ) NEW_LINE return temp ; NEW_LINE DEDENT def insert ( root , key ) : NEW_LINE INDENT trail = None NEW_LINE trail = root ; NEW_LINE for i in range ( len ( key ) ) : NEW_LINE INDENT if ( trail . t [ ord ( key [ i ] ) - ord ( ' a ' ) ] == None ) : NEW_LINE INDENT temp = None NEW_LINE temp = getNode ( ) ; NEW_LINE trail . t [ ord ( key [ i ] ) - ord ( ' a ' ) ] = temp ; NEW_LINE DEDENT trail = trail . t [ ord ( key [ i ] ) - ord ( ' a ' ) ] ; NEW_LINE DEDENT ( trail . isEnd ) += 1 NEW_LINE DEDENT def search_mod ( root , word ) : NEW_LINE INDENT trail = root ; NEW_LINE for i in range ( len ( word ) ) : NEW_LINE INDENT if ( trail . t [ ord ( word [ i ] ) - ord ( ' a ' ) ] == None ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT trail = trail . t [ ord ( word [ i ] ) - ord ( ' a ' ) ] ; NEW_LINE DEDENT if ( ( trail . isEnd ) > 0 and trail != None ) : NEW_LINE INDENT ( trail . isEnd ) -= 1 NEW_LINE return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT def checkPossibility ( sentence , m , root ) : NEW_LINE INDENT flag = 1 ; NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( search_mod ( root , sentence [ i ] ) == False ) : NEW_LINE INDENT print ( ' NO ' , end = ' ' ) NEW_LINE return ; NEW_LINE DEDENT DEDENT print ( ' YES ' ) NEW_LINE DEDENT def insertToTrie ( dictionary , n , root ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT insert ( root , dictionary [ i ] ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = getNode ( ) ; NEW_LINE dictionary = [ "" find "" , "" a "" , "" geeks "" , "" all "" , "" for "" , "" on "" , "" geeks "" , "" answers "" , "" inter "" ] NEW_LINE N = len ( dictionary ) NEW_LINE insertToTrie ( dictionary , N , root ) ; NEW_LINE sentence = [ "" find "" , "" all "" , "" answers "" , "" on "" , "" geeks "" , "" for "" , "" geeks "" ] NEW_LINE M = len ( sentence ) NEW_LINE checkPossibility ( sentence , M , root ) ; NEW_LINE DEDENT";"Check if the given string of words can be formed from words present in the dictionary | Python3 program to check if a sentence can be formed from a given set of words . include < bits / stdc ++ . h > ; here isEnd is an integer that will store count of words ending at that node ; utility function to create a new node ; Initialize new node with null ; Function to insert new words in trie ; Iterate for the length of a word ; If the next key does not contains the character ; isEnd is increment so not only the word but its count is also stored ; Search function to find a word of a sentence ; Iterate for the complete length of the word ; If the character is not present then word is also not present ; If present move to next character in Trie ; If word found then decrement count of the word ; if the word is found decrement isEnd showing one occurrence of this word is already taken so ; Function to check if string can be formed from the sentence ; Iterate for all words in the string ; if a word is not found in a string then the sentence cannot be made from this dictionary of words ; If possible ; Function to insert all the words of dict in the Trie ; Driver Code ; Dictionary of words ; Calling Function to insert words of dictionary to tree ; String to be checked ; Function call to check possibility"
Python;"def isGreaterThanEqualTo ( s1 , s2 ) : NEW_LINE INDENT if len ( s1 ) > len ( s2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return s1 == s2 NEW_LINE DEDENT def multiply ( s1 , s2 ) : NEW_LINE INDENT n , m = len ( s1 ) , len ( s2 ) NEW_LINE result = [ 0 ] * ( n + m ) NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( m - 1 , - 1 , - 1 ) : NEW_LINE INDENT result [ i + j + 1 ] += ( int ( s1 [ i ] ) * int ( s2 [ j ] ) ) NEW_LINE DEDENT DEDENT size = len ( result ) NEW_LINE for i in range ( size - 1 , 0 , - 1 ) : NEW_LINE INDENT if result [ i ] >= 10 : NEW_LINE INDENT result [ i - 1 ] += result [ i ] // 10 NEW_LINE result [ i ] = result [ i ] % 10 NEW_LINE DEDENT DEDENT i = 0 NEW_LINE while i < size and result [ i ] == 0 : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if i == size : NEW_LINE INDENT return ""0"" NEW_LINE DEDENT temp = "" "" NEW_LINE while i < size : NEW_LINE INDENT temp += str ( result [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT return temp NEW_LINE DEDENT def removeLeadingZeores ( s ) : NEW_LINE INDENT n , i = len ( s ) , 0 NEW_LINE while i < n and s [ i ] == '0' : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if i == n : NEW_LINE INDENT return ""0"" NEW_LINE DEDENT temp = "" "" NEW_LINE while i < n : NEW_LINE INDENT temp += s [ i ] NEW_LINE i += 1 NEW_LINE DEDENT return temp NEW_LINE DEDENT def isPower ( s1 , s2 ) : NEW_LINE INDENT s1 = removeLeadingZeores ( s1 ) NEW_LINE s2 = removeLeadingZeores ( s2 ) NEW_LINE if s1 == ""0"" or s2 == ""0"" : NEW_LINE INDENT return False NEW_LINE DEDENT if s1 == ""1"" and s2 == ""1"" : NEW_LINE INDENT return True NEW_LINE DEDENT if s1 == ""1"" and s2 == ""1"" : NEW_LINE INDENT return True NEW_LINE DEDENT if len ( s1 ) > len ( s2 ) : NEW_LINE INDENT return isPower ( s2 , s1 ) NEW_LINE DEDENT temp = s1 NEW_LINE while not isGreaterThanEqualTo ( s1 , s2 ) : NEW_LINE INDENT s1 = multiply ( s1 , temp ) NEW_LINE DEDENT return s1 == s2 NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s1 , s2 = ""374747"" , ""52627712618930723"" NEW_LINE if isPower ( s1 , s2 ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT s1 , s2 = ""4099"" , ""2"" NEW_LINE if isPower ( s1 , s2 ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT DEDENT";"Given two numbers as strings , find if one is a power of other | Python3 program to check if one number is a power of other ; Multiply the numbers . It multiplies each digit of second string to each digit of first and stores the result . ; If the digit exceeds 9 , add the cumulative carry to previous digit . ; If all zeroes , return ""0"" . ; Remove starting zeroes . ; Removes Extra zeroes from front of a string . ; Make sure there are no leading zeroes in the string . ; Making sure that s1 is smaller . If it is greater , we recur we reversed parameters . ; Driver Code"
Python;"def matchClosing ( X , start , end , open , close ) : NEW_LINE INDENT c = 1 NEW_LINE i = start + 1 NEW_LINE while ( i <= end ) : NEW_LINE INDENT if ( X [ i ] == open ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif ( X [ i ] == close ) : NEW_LINE INDENT c -= 1 NEW_LINE DEDENT if ( c == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return i NEW_LINE DEDENT def matchingOpening ( X , start , end , open , close ) : NEW_LINE INDENT c = - 1 NEW_LINE i = end - 1 NEW_LINE while ( i >= start ) : NEW_LINE INDENT if ( X [ i ] == open ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT elif ( X [ i ] == close ) : NEW_LINE INDENT c -= 1 NEW_LINE DEDENT if ( c == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def isBalanced ( X , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( X [ i ] == ' ( ' ) : NEW_LINE INDENT j = matchClosing ( X , i , n - 1 , ' ( ' , ' ) ' ) NEW_LINE DEDENT elif ( X [ i ] == ' { ' ) : NEW_LINE INDENT j = matchClosing ( X , i , n - 1 , ' { ' , ' } ' ) NEW_LINE DEDENT elif ( X [ i ] == ' [ ' ) : NEW_LINE INDENT j = matchClosing ( X , i , n - 1 , ' [ ' , ' ] ' ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( X [ i ] == ' ) ' ) : NEW_LINE INDENT j = matchingOpening ( X , 0 , i , ' ( ' , ' ) ' ) NEW_LINE DEDENT elif ( X [ i ] == ' } ' ) : NEW_LINE INDENT j = matchingOpening ( X , 0 , i , ' { ' , ' } ' ) NEW_LINE DEDENT elif ( X [ i ] == ' ] ' ) : NEW_LINE INDENT j = matchingOpening ( X , 0 , i , ' [ ' , ' ] ' ) NEW_LINE DEDENT if ( j < 0 or j >= i ) : NEW_LINE INDENT return False NEW_LINE DEDENT continue NEW_LINE DEDENT if ( j >= n or j < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT start = i NEW_LINE end = j NEW_LINE for k in range ( start + 1 , end ) : NEW_LINE INDENT if ( X [ k ] == ' ( ' ) : NEW_LINE INDENT x = matchClosing ( X , k , end , ' ( ' , ' ) ' ) NEW_LINE if ( not ( k < x and x < end ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT elif ( X [ k ] == ' ) ' ) : NEW_LINE INDENT x = matchingOpening ( X , start , k , ' ( ' , ' ) ' ) NEW_LINE if ( not ( start < x and x < k ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( X [ k ] == ' { ' ) : NEW_LINE INDENT x = matchClosing ( X , k , end , ' { ' , ' } ' ) NEW_LINE if ( not ( k < x and x < end ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT elif ( X [ k ] == ' } ' ) : NEW_LINE INDENT x = matchingOpening ( X , start , k , ' { ' , ' } ' ) NEW_LINE if ( not ( start < x and x < k ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if ( X [ k ] == ' [ ' ) : NEW_LINE INDENT x = matchClosing ( X , k , end , ' [ ' , ' ] ' ) NEW_LINE if ( not ( k < x and x < end ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT elif ( X [ k ] == ' ] ' ) : NEW_LINE INDENT x = matchingOpening ( X , start , k , ' [ ' , ' ] ' ) NEW_LINE if ( not ( start < x and x < k ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT X = "" [ ( ) ] ( ) "" NEW_LINE n = 6 NEW_LINE if ( isBalanced ( X , n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT Y = "" [ [ ( ) ] ] ) "" NEW_LINE n = 7 NEW_LINE if ( isBalanced ( Y , n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT";"Check for balanced parentheses in an expression | O ( 1 ) space | Function1 to match closing bracket ; Function1 to match opening bracket ; Function to check balanced parentheses ; helper variables ; Handling case of opening parentheses ; Handling case of closing parentheses ; If corresponding matching opening parentheses doesn 't lie in given  interval return 0 ; else continue ; If corresponding closing parentheses doesn 't lie in given interval, return 0 ; if found , now check for each opening and closing parentheses in this interval ; Driver Code"
Python;"def possibleToSort ( arr , n , str ) : NEW_LINE INDENT max_element = - 1 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT max_element = max ( max_element , arr [ i ] ) NEW_LINE if ( str [ i ] == '0' ) : NEW_LINE INDENT if ( max_element > i + 1 ) : NEW_LINE INDENT return "" No "" NEW_LINE DEDENT DEDENT DEDENT return "" Yes "" NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 2 , 5 , 3 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE str = ""01110"" NEW_LINE print ( possibleToSort ( arr , n , str ) ) NEW_LINE DEDENT";"Sorting array with conditional swapping | Function to check if it is possible to sort the array ; Calculating max_element at each iteration . ; if we can not swap the i - th element . ; if it is impossible to swap the max_element then we can not sort the array . ; Otherwise , we can sort the array . ; Driver Code"
Python;"def isPrimeString ( str1 ) : NEW_LINE INDENT len1 = len ( str1 ) NEW_LINE n = 0 NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT n += ord ( str1 [ i ] ) NEW_LINE DEDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT if n <= 3 : NEW_LINE INDENT return True NEW_LINE DEDENT if n % 2 == 0 or n % 3 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT while ( i * i <= n ) : NEW_LINE INDENT if n % i == 0 or n % ( i + 2 ) == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT i += 6 NEW_LINE DEDENT return True NEW_LINE DEDENT str1 = "" geekRam "" NEW_LINE if ( isPrimeString ( str1 ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Prime String | Function that checks if sum is prime or not ; corner cases ; This is checked so that we can skip middle five numbers in below loop ; Driver code"
Python;"def countWays ( s ) : NEW_LINE INDENT count = [ 0 ] * 26 ; NEW_LINE for x in s : NEW_LINE INDENT count [ ord ( x ) - ord ( ' a ' ) ] = ( count [ ord ( x ) - ord ( ' a ' ) ] ) + 1 ; NEW_LINE DEDENT count [ ord ( s [ 0 ] ) - ord ( ' a ' ) ] = 1 ; NEW_LINE ans = 1 ; NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT ans *= count [ i ] ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = "" acbbcc "" ; NEW_LINE print ( countWays ( s ) ) ; NEW_LINE DEDENT";"Ways to split string such that each partition starts with distinct character | Returns the number of we can split the string ; Finding the frequency of each character . ; making frequency of first character of string equal to 1. ; Finding the product of frequency of occurrence of each character . ; Driver Code"
Python;"def lexoString ( s , k ) : NEW_LINE INDENT n = len ( s ) NEW_LINE v = [ ] NEW_LINE mp = { s [ i ] : 0 for i in range ( len ( s ) ) } NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( mp [ s [ i ] ] == 0 ) : NEW_LINE INDENT mp [ s [ i ] ] = 1 NEW_LINE v . append ( s [ i ] ) NEW_LINE DEDENT DEDENT v . sort ( reverse = False ) NEW_LINE if ( k > n ) : NEW_LINE INDENT print ( s , end = "" "" ) NEW_LINE for i in range ( n , k , 1 ) : NEW_LINE INDENT print ( v [ 0 ] , end = "" "" ) NEW_LINE DEDENT return ; NEW_LINE DEDENT i = k - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT if ( s [ i ] != v [ len ( v ) - 1 ] ) : NEW_LINE INDENT for j in range ( 0 , i , 1 ) : NEW_LINE INDENT print ( s [ j ] , end = "" ▁ "" ) NEW_LINE DEDENT for j in range ( 0 , len ( v ) , 1 ) : NEW_LINE INDENT if ( v [ j ] > s [ i ] ) : NEW_LINE INDENT print ( v [ j ] , end = "" ▁ "" ) NEW_LINE break NEW_LINE DEDENT DEDENT for j in range ( i + 1 , k , 1 ) : NEW_LINE INDENT print ( v [ 0 ] , end = "" ▁ "" ) NEW_LINE DEDENT re1turn NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT print ( "" No ▁ lexicographically ▁ greater "" , "" string ▁ of ▁ length "" , k , "" possible ▁ here . "" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = "" gi "" NEW_LINE k = 3 NEW_LINE lexoString ( s , k ) NEW_LINE DEDENT";"Lexicographically next greater string using same character set | function to print output ; to store unique characters of the string ; to check uniqueness ; if mp [ s [ i ] ] = 0 then it is first time ; sort the unique characters ; simply add n - k smallest characters ; searching the first character left of index k and not equal to greatest character of the string ; finding the just next greater character than s [ i ] ; suffix with smallest character ; if we reach here then all indices to the left of k had the greatest character ; Driver code ; Function call"
Python;"MAX = 256 NEW_LINE def fact ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT return res NEW_LINE DEDENT def countPalinPermutations ( str ) : NEW_LINE INDENT global MAX NEW_LINE n = len ( str ) NEW_LINE freq = [ 0 ] * MAX ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ ord ( str [ i ] ) ] = freq [ ord ( str [ i ] ) ] + 1 ; NEW_LINE DEDENT res = fact ( int ( n / 2 ) ) NEW_LINE oddFreq = False NEW_LINE for i in range ( 0 , MAX ) : NEW_LINE INDENT half = int ( freq [ i ] / 2 ) NEW_LINE if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT if ( oddFreq == True ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT oddFreq = True NEW_LINE DEDENT res = int ( res / fact ( half ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT str = "" gffg "" NEW_LINE print ( countPalinPermutations ( str ) ) NEW_LINE";"Number of palindromic permutations | Set 1 | Python3 program to find number of palindromic permutations of a given string ; Returns factorial of n ; Returns count of palindromic permutations of str . ; Count frequencies of all characters ; Since half of the characters decide count of palindromic permutations , we take ( n / 2 ) ! ; To make sure that there is at most one odd occurring char ; Traverse through all counts ; To make sure that the string can permute to form a palindrome ; If there are more than one odd occurring chars ; Divide all permutations with repeated characters ; Driver code"
Python;"from collections import defaultdict NEW_LINE def getPalindrome ( st ) : NEW_LINE INDENT hmap = defaultdict ( int ) NEW_LINE for i in range ( len ( st ) ) : NEW_LINE INDENT hmap [ st [ i ] ] += 1 NEW_LINE DEDENT oddCount = 0 NEW_LINE for x in hmap : NEW_LINE INDENT if ( hmap [ x ] % 2 != 0 ) : NEW_LINE INDENT oddCount += 1 NEW_LINE oddChar = x NEW_LINE DEDENT DEDENT if ( oddCount > 1 or oddCount == 1 and len ( st ) % 2 == 0 ) : NEW_LINE INDENT return "" NO ▁ PALINDROME "" NEW_LINE DEDENT firstHalf = "" "" NEW_LINE secondHalf = "" "" NEW_LINE for x in sorted ( hmap . keys ( ) ) : NEW_LINE INDENT s = ( hmap [ x ] // 2 ) * x NEW_LINE firstHalf = firstHalf + s NEW_LINE secondHalf = s + secondHalf NEW_LINE DEDENT if ( oddCount == 1 ) : NEW_LINE INDENT return ( firstHalf + oddChar + secondHalf ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( firstHalf + secondHalf ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s = "" mdaam "" NEW_LINE print ( getPalindrome ( s ) ) NEW_LINE DEDENT";"Rearrange characters to form palindrome if possible | Python3 program to rearrange a string to make palindrome . ; Store counts of characters ; Find the number of odd elements . Takes O ( n ) ; odd_cnt = 1 only if the length of str is odd ; Generate first halh of palindrome ; Build a string of floor ( count / 2 ) occurrences of current character ; Attach the built string to end of and begin of second half ; Insert odd character if there is any ; Driver code"
Python;"def isVowel ( ch ) : NEW_LINE INDENT return ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) NEW_LINE DEDENT def isCons ( ch ) : NEW_LINE INDENT return ( ch != ' a ' and ch != ' e ' and ch != ' i ' and ch != ' o ' and ch != ' u ' ) NEW_LINE DEDENT def countSpecial ( str ) : NEW_LINE INDENT lent = len ( str ) NEW_LINE if lent == 0 : NEW_LINE return 0 ; NEW_LINE co = [ ] NEW_LINE vo = [ ] NEW_LINE for i in range ( 0 , lent + 1 ) : NEW_LINE INDENT co . append ( 0 ) NEW_LINE DEDENT for i in range ( 0 , lent + 1 ) : NEW_LINE INDENT vo . append ( 0 ) NEW_LINE DEDENT if isCons ( str [ lent - 1 ] ) == 1 : NEW_LINE INDENT co [ lent - 1 ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT vo [ lent - 1 ] = 1 NEW_LINE DEDENT for i in range ( lent - 2 , - 1 , - 1 ) : NEW_LINE INDENT if isCons ( str [ i ] ) == 1 : NEW_LINE INDENT co [ i ] = co [ i + 1 ] + 1 NEW_LINE vo [ i ] = vo [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT co [ i ] = co [ i + 1 ] NEW_LINE vo [ i ] = vo [ i + 1 ] + 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( lent ) : NEW_LINE INDENT if isVowel ( str [ i ] ) : NEW_LINE INDENT ans = ans + co [ i + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT ans = ans + vo [ i + 1 ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT str = "" adceba "" NEW_LINE print ( countSpecial ( str ) ) NEW_LINE";"Substrings starting with vowel and ending with consonants and vice versa | Returns true if ch is vowel ; Function to check consonant ; in case of empty string , we can 't fullfill the  required condition, hence we return ans as 0. ; co [ i ] is going to store counts of consonants from str [ len - 1 ] to str [ i ] . vo [ i ] is going to store counts of vowels from str [ len - 1 ] to str [ i ] . ; Counting consonants and vowels from end of string . ; Now we traverse string from beginning ; If vowel , then count of substrings starting with str [ i ] is equal to count of consonants after it . ; If consonant , then count of substrings starting with str [ i ] is equal to count of vowels after it . ; Driver Code"
Python;"def checkPalindrome ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = 0 NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT if ( str [ i ] != str [ n - i - 1 ] ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT if ( count <= 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT str = "" abccaa "" NEW_LINE if ( checkPalindrome ( str ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Convert the string into palindrome string by changing only one character | Function to check if it is possible to convert the string into palindrome ; Counting number of characters that should be changed . ; If count of changes is less than or equal to 1 ; Driver Code"
Python;"import math NEW_LINE def countSubstr ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE auxArr = [ 0 for i in range ( n ) ] NEW_LINE if ( s [ 0 ] == '1' ) : NEW_LINE INDENT auxArr [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE if ( s [ i ] == '1' ) : NEW_LINE INDENT auxArr [ i ] = auxArr [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT auxArr [ i ] = auxArr [ i - 1 ] NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT count += auxArr [ i ] NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT s = ""1101"" NEW_LINE print ( countSubstr ( s ) ) NEW_LINE";"Number of substrings with odd decimal value in a binary string | python program to count substrings with odd decimal value ; function to count number of substrings with odd decimal representation ; auxiliary array to store count of 1 's before ith index ; store count of 1 's before  i-th index ; variable to store answer ; traverse the string reversely to calculate number of odd substrings before i - th index ; Driver method"
Python;"def findSubStringIndices ( s , L ) : NEW_LINE INDENT size_word = len ( L [ 0 ] ) NEW_LINE word_count = len ( L ) NEW_LINE size_L = size_word * word_count NEW_LINE res = [ ] NEW_LINE if size_L > len ( s ) : NEW_LINE INDENT return res NEW_LINE DEDENT hash_map = dict ( ) NEW_LINE for i in range ( word_count ) : NEW_LINE INDENT if L [ i ] in hash_map : NEW_LINE INDENT hash_map [ L [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT hash_map [ L [ i ] ] = 1 NEW_LINE DEDENT DEDENT for i in range ( 0 , len ( s ) - size_L + 1 , 1 ) : NEW_LINE INDENT temp_hash_map = hash_map . copy ( ) NEW_LINE j = i NEW_LINE count = word_count NEW_LINE while j < i + size_L : NEW_LINE INDENT word = s [ j : j + size_word ] NEW_LINE if ( word not in hash_map or temp_hash_map [ word ] == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT temp_hash_map [ word ] -= 1 NEW_LINE count -= 1 NEW_LINE DEDENT j += size_word NEW_LINE DEDENT if count == 0 : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s = "" barfoothefoobarman "" NEW_LINE L = [ "" foo "" , "" bar "" ] NEW_LINE indices = findSubStringIndices ( s , L ) NEW_LINE print ( * indices ) NEW_LINE DEDENT";"Find the starting indices of the substrings in string ( S ) which is made by concatenating all words from a list ( L ) | Returns an integer vector consisting of starting indices of substrings present inside the string S ; Number of a characters of a word in list L . ; Number of words present inside list L . ; Total characters present in list L . ; Resultant vector which stores indices . ; If the total number of characters in list L is more than length of string S itself . ; Map stores the words present in list L against it 's occurrences inside list L ; Traverse the substring ; Extract the word ; If word not found or if frequency of current word is more than required simply break . ; Else decrement the count of word from hash_map ; Store the starting index of that substring when all the words in the list are in substring ; Driver Code"
Python;"def canMakeStr2 ( s1 , s2 ) : NEW_LINE INDENT count = { s1 [ i ] : 0 for i in range ( len ( s1 ) ) } NEW_LINE for i in range ( len ( s1 ) ) : NEW_LINE INDENT count [ s1 [ i ] ] += 1 NEW_LINE DEDENT for i in range ( len ( s2 ) ) : NEW_LINE INDENT if ( count . get ( s2 [ i ] ) == None or count [ s2 [ i ] ] == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT count [ s2 [ i ] ] -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT s1 = "" geekforgeeks "" NEW_LINE s2 = "" for "" NEW_LINE if canMakeStr2 ( s1 , s2 ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Check whether second string can be formed from characters of first string | Python program to check whether second string can be formed from first string ; Create a count array and count frequencies characters in s1 ; Now traverse through str2 to check if every character has enough counts ; Driver Code"
Python;"def finalPosition ( move ) : NEW_LINE INDENT l = len ( move ) NEW_LINE countUp , countDown = 0 , 0 NEW_LINE countLeft , countRight = 0 , 0 NEW_LINE DEDENT ' NEW_LINE INDENT for i in range ( l ) : NEW_LINE INDENT if ( move [ i ] == ' U ' ) : NEW_LINE INDENT countUp += 1 NEW_LINE DEDENT elif ( move [ i ] == ' D ' ) : NEW_LINE INDENT countDown += 1 NEW_LINE DEDENT elif ( move [ i ] == ' L ' ) : NEW_LINE INDENT countLeft += 1 NEW_LINE DEDENT elif ( move [ i ] == ' R ' ) : NEW_LINE INDENT countRight += 1 NEW_LINE DEDENT DEDENT print ( "" Final ▁ Position : ▁ ( "" , ( countRight - countLeft ) , "" , ▁ "" , ( countUp - countDown ) , "" ) "" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT move = "" UDDLLRUUUDUURUDDUULLDRRRR "" NEW_LINE finalPosition ( move ) NEW_LINE DEDENT";"Position of robot after given movements | function to find final position of robot after the complete movement ; traverse the instruction string 'move ; for each movement increment its respective counter ; required final position of robot ; Driver code"
Python;def maxbalancedprefix ( str , n ) : NEW_LINE INDENT _sum = 0 NEW_LINE maxi = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] == ' ( ' : NEW_LINE INDENT _sum += 1 NEW_LINE DEDENT else : NEW_LINE INDENT _sum -= 1 NEW_LINE DEDENT if _sum < 0 : NEW_LINE INDENT break NEW_LINE DEDENT if _sum == 0 : NEW_LINE INDENT maxi = i + 1 NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT str = ' ( ( ( ) ( ) ) ( ) ) ( ( ' NEW_LINE n = len ( str ) NEW_LINE print ( maxbalancedprefix ( str , n ) ) NEW_LINE;"Length of longest balanced parentheses prefix | Function to return the length of longest balanced parentheses prefix . ; Traversing the string . ; If open bracket add 1 to sum . ; If closed bracket subtract 1 from sum ; if first bracket is closing bracket then this condition would help ; If sum is 0 , store the index value . ; Driver Code"
Python;"def cost ( st ) : NEW_LINE INDENT l = len ( st ) NEW_LINE res = 0 NEW_LINE j = l - 1 NEW_LINE i = 0 NEW_LINE while ( i < j ) : NEW_LINE INDENT if ( st [ i ] != st [ j ] ) : NEW_LINE INDENT res += ( min ( ord ( st [ i ] ) , ord ( st [ j ] ) ) - ord ( ' a ' ) + 1 ) NEW_LINE DEDENT i = i + 1 NEW_LINE j = j - 1 NEW_LINE DEDENT return res NEW_LINE DEDENT st = "" abcdef "" ; NEW_LINE print ( cost ( st ) ) NEW_LINE";"Minimum cost to convert string into palindrome | Function to return cost ; length of string ; Iterate from both sides of string . If not equal , a cost will be there ; Driver code"
Python;"def isVowel ( c ) : NEW_LINE INDENT return ( c == ' A ' or c == ' E ' or c == ' I ' or c == ' O ' or c == ' U ' or c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) ; NEW_LINE DEDENT def pigLatin ( s ) : NEW_LINE INDENT length = len ( s ) ; NEW_LINE index = - 1 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( isVowel ( s [ i ] ) ) : NEW_LINE INDENT index = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( index == - 1 ) : NEW_LINE INDENT return "" - 1"" ; NEW_LINE DEDENT return s [ index : ] + s [ 0 : index ] + "" ay "" ; NEW_LINE DEDENT str = pigLatin ( "" graphic "" ) ; NEW_LINE if ( str == "" - 1"" ) : NEW_LINE INDENT print ( "" No ▁ vowels ▁ found . ▁ Pig ▁ Latin ▁ not ▁ possible "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( str ) ; NEW_LINE DEDENT";"Encoding a word into Pig Latin | Python program to encode a word to a Pig Latin . ; the index of the first vowel is stored . ; Pig Latin is possible only if vowels is present ; Take all characters after index ( including index ) . Append all characters which are before index . Finally append "" ay "" ; Driver code"
Python;"MAX_CHAR = 256 NEW_LINE def isPresent ( s , q ) : NEW_LINE INDENT freq = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , len ( s ) ) : NEW_LINE INDENT freq [ ord ( s [ i ] ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , len ( q ) ) : NEW_LINE INDENT freq [ ord ( q [ i ] ) ] -= 1 NEW_LINE if ( freq [ ord ( q [ i ] ) ] < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = "" abctd "" NEW_LINE q = "" cat "" NEW_LINE if ( isPresent ( s , q ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Possibility of a word from a given set of characters | Python 3 program to check if a query string is present is given set . ; Count occurrences of all characters in s . ; Check if number of occurrences of every character in q is less than or equal to that in s . ; driver program"
Python;"def countReduce ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , int ( n / 2 ) ) : NEW_LINE INDENT res += abs ( int ( ord ( str [ i ] ) ) - int ( ord ( str [ n - i - 1 ] ) ) ) NEW_LINE DEDENT return res NEW_LINE DEDENT str = "" abcd "" NEW_LINE print ( countReduce ( str ) ) NEW_LINE";"Minimum reduce operations to convert a given string into a palindrome | Returns count of minimum character reduce operations to make palindrome . ; Compare every character of first half with the corresponding character of second half and add difference to result . ; Driver code"
Python;"def calculate ( s ) : NEW_LINE INDENT ans = 6 NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT for k in range ( 10 ) : NEW_LINE INDENT for l in range ( 10 ) : NEW_LINE INDENT for m in range ( 10 ) : NEW_LINE INDENT for n in range ( 10 ) : NEW_LINE INDENT if ( i + j + k == l + m + n ) : NEW_LINE INDENT c = 0 NEW_LINE if ( i != ord ( s [ 0 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( j != ord ( s [ 1 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( k != ord ( s [ 2 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( l != ord ( s [ 3 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( m != ord ( s [ 4 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( n != ord ( s [ 5 ] ) - ord ( '0' ) ) : NEW_LINE INDENT c += 1 NEW_LINE DEDENT if ( c < ans ) : NEW_LINE INDENT ans = c NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s = ""123456"" NEW_LINE print ( calculate ( s ) ) NEW_LINE DEDENT";"Minimal operations to make a number magical | function to calculate the minimal changes ; maximum digits that can be changed ; nested loops to generate all 6 digit numbers ; counter to count the number of change required ; if first digit is equal ; if 2 nd digit is equal ; if 3 rd digit is equal ; if 4 th digit is equal ; if 5 th digit is equal ; if 6 th digit is equal ; checks if less then the previous calculate changes ; returns the answer ; driver program to test the above function ; number stored in string ; prints the minimum operations"
Python;def makeAndCheckString ( words , str ) : NEW_LINE INDENT n = len ( words ) NEW_LINE first = second = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if words [ i ] == str : NEW_LINE INDENT return True NEW_LINE DEDENT if str [ 0 ] == words [ i ] [ 1 ] : NEW_LINE INDENT first = True NEW_LINE DEDENT if str [ 1 ] == words [ i ] [ 0 ] : NEW_LINE INDENT second = True NEW_LINE DEDENT if first and second : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT str = ' ya ' NEW_LINE words = [ ' ah ' , ' oy ' , ' to ' , ' ha ' ] NEW_LINE if makeAndCheckString ( words , str ) : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT;"Check if a two character string can be made using given words | Function to check if str can be made using given words ; If str itself is present ; Match first character of str with second of word and vice versa ; If both characters found . ; Driver Code"
Python;"def getBinaryRep ( N , num_of_bits ) : NEW_LINE INDENT r = "" "" ; NEW_LINE num_of_bits -= 1 NEW_LINE while ( num_of_bits >= 0 ) : NEW_LINE INDENT if ( N & ( 1 << num_of_bits ) ) : NEW_LINE INDENT r += ( ""1"" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT r += ( ""0"" ) ; NEW_LINE DEDENT num_of_bits -= 1 NEW_LINE DEDENT return r ; NEW_LINE DEDENT def NBitBinary ( N ) : NEW_LINE INDENT r = [ ] NEW_LINE first = 1 << ( N - 1 ) ; NEW_LINE last = first * 2 ; NEW_LINE for i in range ( last - 1 , first - 1 , - 1 ) : NEW_LINE INDENT zero_cnt = 0 ; NEW_LINE one_cnt = 0 ; NEW_LINE t = i ; NEW_LINE num_of_bits = 0 ; NEW_LINE while ( t ) : NEW_LINE INDENT if ( t & 1 ) : NEW_LINE INDENT one_cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero_cnt += 1 NEW_LINE DEDENT num_of_bits += 1 NEW_LINE t = t >> 1 ; NEW_LINE DEDENT if ( one_cnt >= zero_cnt ) : NEW_LINE INDENT all_prefix_match = True ; NEW_LINE msk = ( 1 << num_of_bits ) - 2 ; NEW_LINE prefix_shift = 1 ; NEW_LINE while ( msk ) : NEW_LINE INDENT prefix = ( ( msk & i ) >> prefix_shift ) ; NEW_LINE prefix_one_cnt = 0 ; NEW_LINE prefix_zero_cnt = 0 ; NEW_LINE while ( prefix ) : NEW_LINE INDENT if ( prefix & 1 ) : NEW_LINE INDENT prefix_one_cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT prefix_zero_cnt += 1 NEW_LINE DEDENT prefix = prefix >> 1 ; NEW_LINE DEDENT if ( prefix_zero_cnt > prefix_one_cnt ) : NEW_LINE INDENT all_prefix_match = False ; NEW_LINE break ; NEW_LINE DEDENT prefix_shift += 1 NEW_LINE msk = msk & ( msk << 1 ) ; NEW_LINE DEDENT if ( all_prefix_match ) : NEW_LINE INDENT r . append ( getBinaryRep ( i , num_of_bits ) ) ; NEW_LINE DEDENT DEDENT DEDENT return r NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 4 ; NEW_LINE results = NBitBinary ( n ) ; NEW_LINE for i in range ( len ( results ) ) : NEW_LINE INDENT print ( results [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT";"Print N | Function to get the binary representation of the number N ; loop for each bit ; generate numbers in the range of ( 2 ^ N ) - 1 to 2 ^ ( N - 1 ) inclusive ; longest prefix check ; if counts of 1 is greater than counts of zero ; do sub - prefixes check ; Driver code ; Function call"
Python;"from collections import defaultdict NEW_LINE def findWinner ( votes ) : NEW_LINE INDENT mapObj = defaultdict ( int ) NEW_LINE for st in votes : NEW_LINE INDENT mapObj [ st ] += 1 NEW_LINE DEDENT maxValueInMap = 0 NEW_LINE winner = "" "" NEW_LINE for entry in mapObj : NEW_LINE INDENT key = entry NEW_LINE val = mapObj [ entry ] NEW_LINE if ( val > maxValueInMap ) : NEW_LINE INDENT maxValueInMap = val NEW_LINE winner = key NEW_LINE DEDENT elif ( val == maxValueInMap and winner > key ) : NEW_LINE INDENT winner = key NEW_LINE DEDENT DEDENT print ( winner ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT votes = [ "" john "" , "" johnny "" , "" jackie "" , "" johnny "" , "" john "" , "" jackie "" , "" jamie "" , "" jamie "" , "" john "" , "" johnny "" , "" jamie "" , "" johnny "" , "" john "" ] NEW_LINE findWinner ( votes ) NEW_LINE DEDENT";"Find winner of an election where votes are represented as candidate names | Python3 program to find winner in an election . ; We have four Candidates with name as ' John ' , ' Johnny ' , ' jamie ' , ' jackie ' . The votes in String array are as per the votes casted . Print the name of candidates received Max vote . ; Insert all votes in a hashmap ; Traverse through map to find the candidate with maximum votes . ; If there is a tie , pick lexicographically smaller . ; Driver code"
Python;"def checkLuhn ( cardNo ) : NEW_LINE INDENT nDigits = len ( cardNo ) NEW_LINE nSum = 0 NEW_LINE isSecond = False NEW_LINE for i in range ( nDigits - 1 , - 1 , - 1 ) : NEW_LINE INDENT d = ord ( cardNo [ i ] ) - ord ( '0' ) NEW_LINE if ( isSecond == True ) : NEW_LINE INDENT d = d * 2 NEW_LINE DEDENT nSum += d // 10 NEW_LINE nSum += d % 10 NEW_LINE isSecond = not isSecond NEW_LINE DEDENT if ( nSum % 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT cardNo = ""79927398713"" NEW_LINE if ( checkLuhn ( cardNo ) ) : NEW_LINE INDENT print ( "" This ▁ is ▁ a ▁ valid ▁ card "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" This ▁ is ▁ not ▁ a ▁ valid ▁ card "" ) NEW_LINE DEDENT DEDENT";"Luhn algorithm | Returns true if given card number is valid ; We add two digits to handle cases that make two digits after doubling ; Driver code"
Python;"MAX_CHAR = 26 NEW_LINE def distributingBalls ( k , n , string ) : NEW_LINE INDENT a = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( a [ i ] > k ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n , k = 6 , 3 NEW_LINE string = "" aacaab "" NEW_LINE if ( distributingBalls ( k , n , string ) ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT DEDENT";"Distributing all balls without repetition | Python3 program to find if its possible to distribute balls without repitiion ; function to find if its possible to distribute balls or not ; count array to count how many times each color has occurred ; increasing count of each color every time it appears ; to check if any color appears more than K times if it does we will print NO ; Driver code"
Python;"def isVowel ( x ) : NEW_LINE INDENT if ( x == ' a ' or x == ' e ' or x == ' i ' or x == ' o ' or x == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def FindSubstr1ing ( str1 ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT hash = dict ( ) NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( isVowel ( str1 [ j ] ) == False ) : NEW_LINE INDENT break NEW_LINE DEDENT hash [ str1 [ j ] ] = 1 NEW_LINE if ( len ( hash ) == 5 ) : NEW_LINE INDENT print ( str1 [ i : j + 1 ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT DEDENT DEDENT str1 = "" aeoibsddaeiouudb "" NEW_LINE FindSubstr1ing ( str1 ) NEW_LINE";"Find substrings that contain all vowels | Returns true if x is vowel . ; Function to check whether a character is vowel or not ; Outer loop picks starting character and inner loop picks ending character . ; If current character is not vowel , then no more result substr1ings possible starting from str1 [ i ] . ; If vowel , then we insert it in hash ; If all vowels are present in current substr1ing ; Driver code"
Python;"def check ( list , s ) : NEW_LINE INDENT n = len ( list ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( len ( list [ i ] ) != len ( s ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT diff = False NEW_LINE for j in range ( 0 , len ( list [ i ] ) , 1 ) : NEW_LINE INDENT if ( list [ i ] [ j ] != s [ j ] ) : NEW_LINE INDENT if ( diff == False ) : NEW_LINE INDENT diff = True NEW_LINE DEDENT else : NEW_LINE INDENT diff = False NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( diff ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = [ ] NEW_LINE s . append ( "" bana "" ) NEW_LINE s . append ( "" apple "" ) NEW_LINE s . append ( "" banacb "" ) NEW_LINE s . append ( "" bonanza "" ) NEW_LINE s . append ( "" banamf "" ) NEW_LINE print ( int ( check ( s , "" banana "" ) ) ) NEW_LINE DEDENT";"Find if an array contains a string with one mismatch | Python 3 program to find if given string is present with one mismatch . ; If the array is empty ; If sizes are same ; If first mismatch ; Second mismatch ; Driver code"
Python;"def sentencePalindrome ( s ) : NEW_LINE INDENT l , h = 0 , len ( s ) - 1 NEW_LINE s = s . lower ( ) NEW_LINE while ( l <= h ) : NEW_LINE INDENT if ( not ( s [ l ] >= ' a ' and s [ l ] <= ' z ' ) ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT elif ( not ( s [ h ] >= ' a ' and s [ h ] <= ' z ' ) ) : NEW_LINE INDENT h -= 1 NEW_LINE DEDENT elif ( s [ l ] == s [ h ] ) : NEW_LINE INDENT l += 1 NEW_LINE h -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = "" Too ▁ hot ▁ to ▁ hoot . "" NEW_LINE if ( sentencePalindrome ( s ) ) : NEW_LINE INDENT print "" Sentence ▁ is ▁ palindrome . "" NEW_LINE DEDENT else : NEW_LINE INDENT print "" Sentence ▁ is ▁ not ▁ palindrome . "" NEW_LINE DEDENT";"Sentence Palindrome ( Palindrome after removing spaces , dots , . . etc ) | To check sentence is palindrome or not ; Lowercase string ; Compares character until they are equal ; If there is another symbol in left of sentence ; If there is another symbol in right of sentence ; If characters are equal ; If characters are not equal then sentence is not palindrome ; Returns true if sentence is palindrome ; Driver program to test sentencePalindrome ( )"
Python;"def xorZero ( str ) : NEW_LINE INDENT one_count = 0 NEW_LINE zero_count = 0 NEW_LINE n = len ( str ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( str [ i ] == '1' ) : NEW_LINE INDENT one_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero_count += 1 NEW_LINE DEDENT DEDENT if ( one_count % 2 == 0 ) : NEW_LINE INDENT return zero_count NEW_LINE DEDENT return one_count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = ""11111"" NEW_LINE print ( xorZero ( str ) ) NEW_LINE DEDENT";"Ways to remove one element from a binary string so that XOR becomes zero | Return number of ways in which XOR become ZERO by remove 1 element ; Counting number of 0 and 1 ; If count of ones is even then return count of zero else count of one ; Driver Code"
Python;"MAX_CHAR = 26 NEW_LINE def checkCorrectOrNot ( s ) : NEW_LINE INDENT global MAX_CHAR NEW_LINE count = [ 0 ] * MAX_CHAR NEW_LINE n = len ( s ) NEW_LINE if n == 1 : NEW_LINE INDENT return true NEW_LINE DEDENT i = 0 ; j = n - 1 NEW_LINE while i < j : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE count [ ord ( s [ j ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE i += 1 ; j -= 1 NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT if count [ i ] != 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = "" abab "" NEW_LINE print ( "" Yes "" if checkCorrectOrNot ( s ) else "" No "" ) NEW_LINE";"Check if both halves of the string have same set of characters | Python3 program to check if it is possible to split string or not ; Function to check if we can split string or not ; Counter array initialized with 0 ; Length of the string ; Traverse till the middle element is reached ; First half ; Second half ; Checking if values are different , set flag to 1 ; String to be checked"
Python;"def check_isogram ( string ) : NEW_LINE INDENT length = len ( string ) ; NEW_LINE mapHash = [ 0 ] * 26 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT mapHash [ ord ( string [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE if ( mapHash [ ord ( string [ i ] ) - ord ( ' a ' ) ] > 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT string = "" geeks "" ; NEW_LINE string2 = "" computer "" ; NEW_LINE if ( check_isogram ( string ) ) : NEW_LINE INDENT print ( "" True "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" False "" ) ; NEW_LINE DEDENT if ( check_isogram ( string2 ) ) : NEW_LINE INDENT print ( "" True "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" False "" ) ; NEW_LINE DEDENT DEDENT";"Check if a string is Isogram or not | function to check isogram ; loop to store count of chars and check if it is greater than 1 ; if count > 1 , return false ; Driver code ; checking str as isogram ; checking str2 as isogram"
Python;"def checkString ( s ) : NEW_LINE INDENT Len = len ( s ) NEW_LINE first = len ( s ) + 1 NEW_LINE for i in range ( Len ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT first = i NEW_LINE break NEW_LINE DEDENT DEDENT last = 0 NEW_LINE for i in range ( Len - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == '1' ) : NEW_LINE INDENT last = i NEW_LINE break NEW_LINE DEDENT DEDENT for i in range ( first , last + 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT s = ""00011111111100000"" NEW_LINE if ( checkString ( s ) ) : NEW_LINE INDENT print ( "" VALID "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NOT ▁ VALID "" ) NEW_LINE DEDENT";"Check if a binary string has a 0 between 1 s or not | Set 1 ( General approach ) | Function returns 1 when string is valid else returns 0 ; Find first occurrence of 1 in s [ ] ; Find last occurrence of 1 in s [ ] ; Check if there is any 0 in range ; Driver code"
Python;"def printAllSubstrings ( s , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT temp = "" "" NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT temp += s [ j ] NEW_LINE print ( temp ) NEW_LINE DEDENT DEDENT DEDENT s = "" Geeky "" NEW_LINE printAllSubstrings ( s , len ( s ) ) NEW_LINE";"Program to print all substrings of a given string | * Function to print all ( n * ( n + 1 ) ) / 2 * substrings of a given string s of length n . ; Fix start index in outer loop . Reveal new character in inner loop till end of string . Prtill - now - formed string . ; Driver program to test above function"
Python;"def preserveSpace ( Str ) : NEW_LINE INDENT n = len ( Str ) NEW_LINE Str = list ( Str ) NEW_LINE start = 0 NEW_LINE end = n - 1 NEW_LINE while ( start < end ) : NEW_LINE INDENT if ( Str [ start ] == ' ▁ ' ) : NEW_LINE INDENT start += 1 NEW_LINE continue NEW_LINE DEDENT elif ( Str [ end ] == ' ▁ ' ) : NEW_LINE INDENT end -= 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT Str [ start ] , Str [ end ] = ( Str [ end ] , Str [ start ] ) NEW_LINE start += 1 NEW_LINE end -= 1 NEW_LINE DEDENT DEDENT print ( ' ' . join ( Str ) ) NEW_LINE DEDENT Str = "" internship ▁ at ▁ geeks ▁ for ▁ geeks "" NEW_LINE preserveSpace ( Str ) ; NEW_LINE";"Reverse a string preserving space positions | Python3 program to implement the above approach ; Initialize two pointers as two corners ; Move both pointers toward each other ; If character at start or end is space , ignore it ; If both are not spaces , do swap ; Driver code"
Python;"def amendSentence ( string ) : NEW_LINE INDENT string = list ( string ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if string [ i ] >= ' A ' and string [ i ] <= ' Z ' : NEW_LINE INDENT string [ i ] = chr ( ord ( string [ i ] ) + 32 ) NEW_LINE if i != 0 : NEW_LINE INDENT print ( "" ▁ "" , end = "" "" ) NEW_LINE DEDENT print ( string [ i ] , end = "" "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( string [ i ] , end = "" "" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT string = "" BruceWayneIsBatman "" NEW_LINE amendSentence ( string ) NEW_LINE DEDENT";"Put spaces between words starting with capital letters | Function to amend the sentence ; Traverse the string ; Convert to lowercase if its an uppercase character ; Print space before it if its an uppercase character ; Print the character ; if lowercase character then just print ; Driver Code"
Python;"def repeat ( s , n ) : NEW_LINE INDENT s1 = s NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT s += s1 NEW_LINE DEDENT return s NEW_LINE DEDENT s = "" geeks "" NEW_LINE n = 3 NEW_LINE print ( repeat ( s , n ) ) NEW_LINE";"C ++ program to concatenate a string given number of times | Function which return string by concatenating it . ; Copying given string to temporary string . ; Concatenating strings ; Driver code"
Python;"MAX_CHAR = 26 NEW_LINE def factorial ( n ) : NEW_LINE INDENT fact = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fact = fact * i ; NEW_LINE DEDENT return fact NEW_LINE DEDENT def countDistinctPermutations ( st ) : NEW_LINE INDENT length = len ( st ) NEW_LINE freq = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , length ) : NEW_LINE INDENT if ( st [ i ] >= ' a ' ) : NEW_LINE INDENT freq [ ( ord ) ( st [ i ] ) - 97 ] = freq [ ( ord ) ( st [ i ] ) - 97 ] + 1 ; NEW_LINE DEDENT DEDENT fact = 1 NEW_LINE for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT fact = fact * factorial ( freq [ i ] ) NEW_LINE DEDENT return factorial ( length ) / fact NEW_LINE DEDENT st = "" fvvfhvgv "" NEW_LINE print ( countDistinctPermutations ( st ) ) NEW_LINE";"Number of distinct permutation a String can have | Python program to find number of distinct permutations of a string . ; Utility function to find factorial of n . ; Returns count of distinct permutations of str . ; finding frequency of all the lower case alphabet and storing them in array of integer ; finding factorial of number of appearances and multiplying them since they are repeating alphabets ; finding factorial of size of string and dividing it by factorial found after multiplying ; Driver code"
Python;"import math NEW_LINE def uniqueCharacters ( str ) : NEW_LINE INDENT checker = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT bitAtIndex = ord ( str [ i ] ) - ord ( ' a ' ) NEW_LINE if ( ( bitAtIndex ) > 0 ) : NEW_LINE INDENT if ( ( checker & ( ( 1 << bitAtIndex ) ) ) > 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT checker = checker | ( 1 << bitAtIndex ) NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT input = "" geekforgeeks "" NEW_LINE if ( uniqueCharacters ( input ) ) : NEW_LINE INDENT print ( "" The ▁ String ▁ "" + input + "" ▁ has ▁ all ▁ unique ▁ characters "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" The ▁ String ▁ "" + input + "" ▁ has ▁ duplicate ▁ characters "" ) NEW_LINE DEDENT DEDENT";"Determine if a string has all Unique Characters | Python3 program to illustrate String with unique characters without using any data structure ; Assuming string can have characters a - z this has 32 bits set to 0 ; If that bit is already set in checker , return False ; Otherwise update and continue by setting that bit in the checker ; No duplicates encountered , return True ; Driver Code"
Python;"def isVowel ( ch ) : NEW_LINE INDENT if ( ch == ' a ' or ch == ' e ' or ch == ' i ' or ch == ' o ' or ch == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def createAltStr ( str1 , str2 , start , l ) : NEW_LINE INDENT finalStr = "" "" NEW_LINE i = 0 NEW_LINE for j in range ( start , l ) : NEW_LINE INDENT finalStr = ( finalStr + str1 [ i ] ) + str2 [ j ] NEW_LINE i + 1 NEW_LINE DEDENT return finalStr NEW_LINE DEDENT def findAltStr ( str1 ) : NEW_LINE INDENT nv = 0 NEW_LINE nc = 0 NEW_LINE vstr = "" "" NEW_LINE cstr = "" "" NEW_LINE l = len ( str1 ) NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT if ( isVowel ( str1 [ i ] ) ) : NEW_LINE INDENT nv += 1 NEW_LINE vstr = vstr + str1 [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT nc += 1 NEW_LINE cstr = cstr + str1 [ i ] NEW_LINE DEDENT DEDENT if ( abs ( nv - nc ) >= 2 ) : NEW_LINE INDENT return "" no ▁ such ▁ string "" NEW_LINE DEDENT if ( nv > nc ) : NEW_LINE INDENT return ( vstr [ 0 ] + createAltStr ( cstr , vstr , 1 , nv ) ) NEW_LINE DEDENT if ( nc > nv ) : NEW_LINE INDENT return ( cstr [ 0 ] + createAltStr ( vstr , cstr , 1 , nc ) ) NEW_LINE DEDENT if ( cstr [ 0 ] < vstr [ 0 ] ) : NEW_LINE INDENT return createAltStr ( cstr , vstr , 0 , nv ) NEW_LINE DEDENT return createAltStr ( vstr , cstr , 0 , nc ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT str1 = "" geeks "" NEW_LINE print ( findAltStr ( str1 ) ) NEW_LINE DEDENT";"Alternate vowel and consonant string | ' ch ' is vowel or not ; create alternate vowel and consonant string str1 [ 0. . . l1 - 1 ] and str2 [ start ... l2 - 1 ] ; first adding character of vowel / consonant then adding character of consonant / vowel ; function to find the required alternate vowel and consonant string ; count vowels and update vowel string ; count consonants and update consonant string ; no such string can be formed ; remove first character of vowel string then create alternate string with cstr [ 0. . . nc - 1 ] and vstr [ 1. . . nv - 1 ] ; remove first character of consonant string then create alternate string with vstr [ 0. . . nv - 1 ] and cstr [ 1. . . nc - 1 ] ; if both vowel and consonant strings are of equal length start creating string with consonant ; start creating string with vowel ; Driver Code"
Python;"def isKthBitSet ( n , k ) : NEW_LINE INDENT if n & ( 1 << ( k - 1 ) ) : NEW_LINE INDENT print ( "" SET "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NOT ▁ SET "" ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE k = 1 NEW_LINE isKthBitSet ( n , k ) NEW_LINE";"Check whether K | Python3 code to check if k - th bit of a given number is set or not ; Driver code"
Python;"str = "" geeksforgeeks "" ; NEW_LINE str = "" "" . join ( reversed ( str ) ) NEW_LINE print ( str ) ; NEW_LINE";"Reverse string without using any temporary variable | Reversing a string using reverse ( ) ; Reverse str [ beign . . end ]"
Python;"def isPalRec ( st , s , e ) : NEW_LINE INDENT if ( s == e ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( st [ s ] != st [ e ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( s < e + 1 ) : NEW_LINE INDENT return isPalRec ( st , s + 1 , e - 1 ) ; NEW_LINE DEDENT return True NEW_LINE DEDENT def isPalindrome ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return isPalRec ( st , 0 , n - 1 ) ; NEW_LINE DEDENT st = "" geeg "" NEW_LINE if ( isPalindrome ( st ) ) : NEW_LINE INDENT print "" Yes "" NEW_LINE DEDENT else : NEW_LINE INDENT print "" No "" NEW_LINE DEDENT";"Recursive function to check if a string is palindrome | A recursive function that check a str [ s . . e ] is palindrome or not . ; If there is only one character ; If first and last characters do not match ; If there are more than two characters , check if middle substring is also palindrome or not . ; An empty string is considered as palindrome ; Driver Code"
Python;"MAX_CHAR = 26 ; NEW_LINE def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( s ) ; NEW_LINE count = [ 0 ] * MAX_CHAR ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT count [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT for i in range ( MAX_CHAR ) : NEW_LINE INDENT result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT s = "" abcab "" ; NEW_LINE print ( countSubstringWithEqualEnds ( s ) ) ; NEW_LINE";"Count substrings with same first and last characters | assuming lower case only ; Calculating frequency of each character in the string . ; Computing result using counts ; Driver code"
Python;"def maxRepeating ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE count = 0 NEW_LINE res = str [ 0 ] NEW_LINE cur_count = 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i < n - 1 and str [ i ] == str [ i + 1 ] ) : NEW_LINE INDENT cur_count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if cur_count > count : NEW_LINE INDENT count = cur_count NEW_LINE res = str [ i ] NEW_LINE DEDENT cur_count = 1 NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT str = "" aaaabbaaccde "" NEW_LINE print ( maxRepeating ( str ) ) NEW_LINE DEDENT";"Maximum consecutive repeating character in string | Returns the maximum repeating character in a given string ; Traverse string except last character ; If current character matches with next ; If doesn 't match, update result  (if required) and reset count ; Driver code"
Python;"MAX = 10000 NEW_LINE CHAR_SIZE = 26 NEW_LINE def precompute ( mat , str , Len ) : NEW_LINE INDENT for i in range ( CHAR_SIZE ) : NEW_LINE INDENT mat [ Len ] [ i ] = Len NEW_LINE DEDENT for i in range ( Len - 1 , - 1 , - 1 ) : NEW_LINE INDENT for j in range ( CHAR_SIZE ) : NEW_LINE INDENT mat [ i ] [ j ] = mat [ i + 1 ] [ j ] NEW_LINE DEDENT mat [ i ] [ ord ( str [ i ] ) - ord ( ' a ' ) ] = i NEW_LINE DEDENT DEDENT def query ( mat , str , Len ) : NEW_LINE INDENT pos = 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if ( mat [ pos ] [ ord ( str [ i ] ) - ord ( ' a ' ) ] >= Len ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT pos = mat [ pos ] [ ord ( str [ i ] ) - ord ( ' a ' ) ] + 1 NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT S = "" geeksforgeeks "" NEW_LINE Len = len ( S ) NEW_LINE mat = [ [ 0 for i in range ( CHAR_SIZE ) ] for j in range ( MAX ) ] NEW_LINE precompute ( mat , S , Len ) NEW_LINE get = "" No "" NEW_LINE if ( query ( mat , "" gg "" , Len ) ) : NEW_LINE INDENT get = "" Yes "" NEW_LINE DEDENT print ( get ) NEW_LINE get = "" No "" NEW_LINE if ( query ( mat , "" gro "" , Len ) ) : NEW_LINE INDENT get = "" Yes "" NEW_LINE DEDENT print ( get ) NEW_LINE get = "" No "" NEW_LINE if ( query ( mat , "" gfg "" , Len ) ) : NEW_LINE INDENT get = "" Yes "" NEW_LINE DEDENT print ( get ) NEW_LINE get = "" No "" NEW_LINE if ( query ( mat , "" orf "" , Len ) ) : NEW_LINE INDENT get = "" Yes "" NEW_LINE DEDENT print ( get ) NEW_LINE";"Queries on subsequence of string | Python3 program to answer subsequence queries for a given string . ; Precompute the position of each character from each position of String S ; Computing position of each character from each position of String S ; Print "" Yes "" if T is subsequence of S , else "" No "" ; Traversing the string T ; If next position is greater than length of S set flag to false . ; Setting position of next character ; Driven code"
Python;"def query ( s , i , j ) : NEW_LINE INDENT n = len ( s ) NEW_LINE i %= n NEW_LINE j %= n NEW_LINE print ( "" Yes "" ) if s [ i ] == s [ j ] else print ( "" No "" ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT X = "" geeksforgeeks "" NEW_LINE query ( X , 0 , 8 ) NEW_LINE query ( X , 8 , 13 ) NEW_LINE query ( X , 6 , 15 ) NEW_LINE DEDENT";"Queries for characters in a repeated string | Print whether index i and j have same element or not . ; Finding relative position of index i , j . ; Checking is element are same at index i , j . ; Driver code"
Python;"def countPairs ( str1 ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( str1 ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( abs ( ord ( str1 [ i ] ) - ord ( str1 [ j ] ) ) == abs ( i - j ) ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT DEDENT return result ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT str1 = "" geeksforgeeks "" ; NEW_LINE print ( countPairs ( str1 ) ) ; NEW_LINE DEDENT";"Count of character pairs at same distance as in English alphabets | Function to count pairs ; Increment count if characters are at same distance ; Driver code"
Python;"def longestString ( str1 , str2 ) : NEW_LINE INDENT count1 = [ 0 ] * 26 NEW_LINE count2 = [ 0 ] * 26 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count1 [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( len ( str2 ) ) : NEW_LINE INDENT count2 [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT result = "" "" NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT for j in range ( 1 , min ( count1 [ i ] , count2 [ i ] ) + 1 ) : NEW_LINE INDENT result = result + chr ( ord ( ' a ' ) + i ) NEW_LINE DEDENT DEDENT print ( result ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT str1 = "" geeks "" NEW_LINE str2 = "" cake "" NEW_LINE longestString ( str1 , str2 ) NEW_LINE DEDENT";"Longest common subsequence with permutations allowed | Function to calculate longest string str1 -- > first string str2 -- > second string count1 [ ] -- > hash array to calculate frequency of characters in str1 count [ 2 ] -- > hash array to calculate frequency of characters in str2 result -- > resultant longest string whose permutations are sub - sequence of given two strings ; calculate frequency of characters ; Now traverse hash array ; append character ( ' a ' + i ) in resultant string ' result ' by min ( count1 [ i ] , count2i ] ) times ; Driver Code"
Python;"def checkPattern ( string , pattern ) : NEW_LINE INDENT l = len ( pattern ) NEW_LINE if len ( string ) < l : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( l - 1 ) : NEW_LINE INDENT x = pattern [ i ] NEW_LINE y = pattern [ i + 1 ] NEW_LINE last = string . rindex ( x ) NEW_LINE first = string . index ( y ) NEW_LINE if last == - 1 or first == - 1 or last > first : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT string = "" engineers ▁ rock "" NEW_LINE pattern = "" gsr "" NEW_LINE print ( checkPattern ( string , pattern ) ) NEW_LINE DEDENT";"Check if string follows order of characters defined by a pattern or not | Set 1 | Function to check if characters in the input string follows the same order as determined by characters present in the given pattern ; len stores length of the given pattern ; if length of pattern is more than length of input string , return false ; ; x , y are two adjacent characters in pattern ; find index of last occurrence of character x in the input string ; find index of first occurrence of character y in the input string ; return false if x or y are not present in the input string OR last occurrence of x is after the first occurrence of y in the input string ; return true if string matches the pattern ; Driver Code"
Python;"def findSum ( str1 ) : NEW_LINE INDENT temp = ""0"" NEW_LINE Sum = 0 NEW_LINE for ch in str1 : NEW_LINE INDENT if ( ch . isdigit ( ) ) : NEW_LINE INDENT temp += ch NEW_LINE DEDENT else : NEW_LINE INDENT Sum += int ( temp ) NEW_LINE temp = ""0"" NEW_LINE DEDENT DEDENT return Sum + int ( temp ) NEW_LINE DEDENT str1 = ""12abc20yz68"" NEW_LINE print ( findSum ( str1 ) ) NEW_LINE";"Calculate sum of all numbers present in a string | Function to calculate sum of all numbers present in a str1ing containing alphanumeric characters ; A temporary str1ing ; holds sum of all numbers present in the str1ing ; read each character in input string ; if current character is a digit ; if current character is an alphabet ; increment Sum by number found earlier ( if any ) ; reset temporary str1ing to empty ; atoi ( temp . c_str1 ( ) ) takes care of trailing numbers ; input alphanumeric str1ing ; Function call"
Python;"def countkDist ( str1 , k ) : NEW_LINE INDENT n = len ( str1 ) NEW_LINE res = 0 NEW_LINE cnt = [ 0 ] * 27 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT dist_count = 0 NEW_LINE cnt = [ 0 ] * 27 NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT if ( cnt [ ord ( str1 [ j ] ) - 97 ] == 0 ) : NEW_LINE INDENT dist_count += 1 NEW_LINE DEDENT cnt [ ord ( str1 [ j ] ) - 97 ] += 1 NEW_LINE if ( dist_count == k ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT if ( dist_count > k ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT str1 = "" abcbaa "" NEW_LINE k = 3 NEW_LINE print ( "" Total ▁ substrings ▁ with ▁ exactly "" , k , "" distinct ▁ characters ▁ : ▁ "" , end = "" "" ) NEW_LINE print ( countkDist ( str1 , k ) ) NEW_LINE DEDENT";"Count number of substrings with exactly k distinct characters | Function to count number of substrings with exactly k unique characters ; Initialize result ; To store count of characters from ' a ' to ' z ' ; Consider all substrings beginning with str [ i ] ; Initializing array with 0 ; Consider all substrings between str [ i . . j ] ; If this is a new character for this substring , increment dist_count . ; Increment count of current character ; If distinct character count becomes k , then increment result . ; Driver Code"
Python;"def to_upper ( string ) : NEW_LINE INDENT for i in range ( len ( string ) ) : NEW_LINE INDENT if ( ' a ' <= string [ i ] <= ' z ' ) : NEW_LINE INDENT string = ( string [ 0 : i ] + chr ( ord ( string [ i ] ) - ord ( ' a ' ) + ord ( ' A ' ) ) + string [ i + 1 : ] ) NEW_LINE DEDENT DEDENT return string ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = "" geeksforgeeks "" ; NEW_LINE print ( to_upper ( str ) ) ; NEW_LINE DEDENT";"Lower case to upper case | Converts a string to uppercase ; Driver code"
Python;"def findMinLength ( arr , n ) : NEW_LINE INDENT min = len ( arr [ 0 ] ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( len ( arr [ i ] ) < min ) : NEW_LINE INDENT min = len ( arr [ i ] ) NEW_LINE DEDENT DEDENT return ( min ) NEW_LINE DEDENT def commonPrefix ( arr , n ) : NEW_LINE INDENT minlen = findMinLength ( arr , n ) NEW_LINE result = "" "" NEW_LINE for i in range ( minlen ) : NEW_LINE INDENT current = arr [ 0 ] [ i ] NEW_LINE for j in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ j ] [ i ] != current ) : NEW_LINE INDENT return result NEW_LINE DEDENT DEDENT result = result + current NEW_LINE DEDENT return ( result ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ "" geeksforgeeks "" , "" geeks "" , "" geek "" , "" geezer "" ] NEW_LINE n = len ( arr ) NEW_LINE ans = commonPrefix ( arr , n ) NEW_LINE if ( len ( ans ) ) : NEW_LINE INDENT print ( "" The ▁ longest ▁ common ▁ prefix ▁ is ▁ "" , ans ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" There ▁ is ▁ no ▁ common ▁ prefix "" ) NEW_LINE DEDENT DEDENT";"Longest Common Prefix using Character by Character Matching | A Function to find the string having the minimum length and returns that length ; A Function that returns the longest common prefix from the array of strings ; Our resultant string char current ; The current character ; Current character ( must be same in all strings to be a part of result ) ; Append to result ; Driver program to test above function"
Python;"MAX_CHARS = 256 NEW_LINE def areIsomorphic ( string1 , string2 ) : NEW_LINE INDENT m = len ( string1 ) NEW_LINE n = len ( string2 ) NEW_LINE if m != n : NEW_LINE INDENT return False NEW_LINE DEDENT marked = [ False ] * MAX_CHARS NEW_LINE map = [ - 1 ] * MAX_CHARS NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT if map [ ord ( string1 [ i ] ) ] == - 1 : NEW_LINE INDENT if marked [ ord ( string2 [ i ] ) ] == True : NEW_LINE INDENT return False NEW_LINE DEDENT marked [ ord ( string2 [ i ] ) ] = True NEW_LINE map [ ord ( string1 [ i ] ) ] = string2 [ i ] NEW_LINE DEDENT elif map [ ord ( string1 [ i ] ) ] != string2 [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT print areIsomorphic ( "" aab "" , "" xxy "" ) NEW_LINE print areIsomorphic ( "" aab "" , "" xyz "" ) NEW_LINE";"Check if two given strings are isomorphic to each other | Python program to check if two strings are isomorphic ; This function returns true if str1 and str2 are isomorphic ; Length of both strings must be same for one to one corresponance ; To mark visited characters in str2 ; To store mapping of every character from str1 to that of str2 . Initialize all entries of map as - 1 ; Process all characters one by one ; if current character of str1 is seen first time in it . ; if current character of st2 is already seen , one to one mapping not possible ; Mark current character of str2 as visited ; Store mapping of current characters ; If this is not first appearance of current character in str1 , then check if previous appearance mapped to same character of str2 ; Driver program"
Python;"def isPalin ( str , st , end ) : NEW_LINE INDENT while ( st < end ) : NEW_LINE INDENT if ( str [ st ] != str [ end ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT st += 1 NEW_LINE end - - 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def findMinInsert ( str , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( isPalin ( str , 0 , i ) ) : NEW_LINE INDENT return ( n - i - 1 ) NEW_LINE DEDENT DEDENT DEDENT Input = "" JAVA "" NEW_LINE print ( findMinInsert ( Input , len ( Input ) ) ) NEW_LINE";"Minimum insertions to form shortest palindrome | Returns true if a string str [ st . . end ] is palindrome ; Returns count of insertions on left side to make str [ ] a palindrome ; Find the largest prefix of given string that is palindrome . ; Characters after the palindromic prefix must be added at the beginning also to make the complete string palindrome ; Driver Code"
Python;def removeRecur ( n ) : NEW_LINE INDENT prev_digit = n % 10 NEW_LINE pow = 10 NEW_LINE res = prev_digit NEW_LINE while ( n ) : NEW_LINE INDENT curr_digit = n % 10 NEW_LINE if ( curr_digit != prev_digit ) : NEW_LINE INDENT res += curr_digit * pow NEW_LINE prev_digit = curr_digit NEW_LINE pow *= 10 NEW_LINE DEDENT n = int ( n / 10 ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12224 NEW_LINE print ( removeRecur ( n ) ) NEW_LINE DEDENT;"Remove repeated digits in a given number | Python 3 program to remove repeated digits ; Store first digits as previous digit ; Initialize power ; Iterate through all digits of n , note that the digits are processed from least significant digit to most significant digit . ; Store current digit ; Add the current digit to the beginning of result ; Update previous result and power ; Remove last digit from n ; Driver Code"
Python;"def toList ( string ) : NEW_LINE INDENT l = [ ] NEW_LINE for x in string : NEW_LINE INDENT l . append ( x ) NEW_LINE DEDENT return l NEW_LINE DEDENT def toString ( l ) : NEW_LINE INDENT return ' ' . join ( l ) NEW_LINE DEDENT def stringFilter ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE i = - 1 NEW_LINE j = 0 NEW_LINE while j < n : NEW_LINE INDENT if j < n - 1 and string [ j ] == ' a ' and string [ j + 1 ] == ' c ' : NEW_LINE INDENT j += 2 NEW_LINE DEDENT elif string [ j ] == ' b ' : NEW_LINE INDENT j += 1 NEW_LINE DEDENT elif i >= 0 and string [ j ] == ' c ' and string [ i ] == ' a ' : NEW_LINE INDENT i -= 1 NEW_LINE j += 1 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE string [ i ] = string [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT i += 1 NEW_LINE return toString ( string [ : i ] ) NEW_LINE DEDENT string1 = "" ad "" NEW_LINE print "" Input ▁ = > ▁ "" + string1 +   "" NEW_LINE Output = >   "" , NEW_LINE print stringFilter ( toList ( string1 ) ) +   "" NEW_LINE "" NEW_LINE string2 = "" acbac "" NEW_LINE print "" Input ▁ = > ▁ "" + string2 +   "" NEW_LINE Output = >   "" , NEW_LINE print stringFilter ( toList ( string2 ) ) +   "" NEW_LINE "" NEW_LINE string3 = "" aaac "" NEW_LINE print "" Input ▁ = > ▁ "" + string3 +   "" NEW_LINE Output = >   "" , NEW_LINE print stringFilter ( toList ( string3 ) ) +   "" NEW_LINE "" NEW_LINE string4 = "" react "" NEW_LINE print "" Input ▁ = > ▁ "" + string4 +   "" NEW_LINE Output = >   "" , NEW_LINE print stringFilter ( toList ( string4 ) ) +   "" NEW_LINE "" NEW_LINE string5 = "" aa "" NEW_LINE print "" Input ▁ = > ▁ "" + string5 +   "" NEW_LINE Output = >   "" , NEW_LINE print stringFilter ( toList ( string5 ) ) +   "" NEW_LINE "" NEW_LINE string6 = "" ababaac "" NEW_LINE print "" Input ▁ = > ▁ "" + string6 +   "" NEW_LINE Output = >   "" , NEW_LINE print stringFilter ( toList ( string6 ) ) +   "" NEW_LINE "" NEW_LINE string7 = "" abc "" NEW_LINE print "" Input ▁ = > ▁ "" + string7 +   "" NEW_LINE Output = >   "" , NEW_LINE print stringFilter ( toList ( string7 ) ) +   "" NEW_LINE "" NEW_LINE";"Remove "" b "" and "" ac "" from a given string | Utility function to convert string to list ; Utility function to convert list to string ; length of string ; Check if current and next character forms ac ; If current character is b ; if current char is ' c ▁ & & ▁ last ▁ char ▁ in ▁ output ▁ ▁ is ▁ ' a ' so delete both ; Else copy curr char to output string ; Driver program"
Python;"import sys NEW_LINE def myAtoi ( Str ) : NEW_LINE INDENT sign , base , i = 1 , 0 , 0 NEW_LINE while ( Str [ i ] == ' ▁ ' ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT if ( Str [ i ] == ' - ' or Str [ i ] == ' + ' ) : NEW_LINE INDENT sign = 1 - 2 * ( Str [ i ] == ' - ' ) NEW_LINE i += 1 NEW_LINE DEDENT while ( i < len ( Str ) and Str [ i ] >= '0' and Str [ i ] <= '9' ) : NEW_LINE INDENT if ( base > ( sys . maxsize // 10 ) or ( base == ( sys . maxsize // 10 ) and ( Str [ i ] - '0' ) > 7 ) ) : NEW_LINE INDENT if ( sign == 1 ) : NEW_LINE INDENT return sys . maxsize NEW_LINE DEDENT else : NEW_LINE INDENT return - ( sys . maxsize ) NEW_LINE DEDENT DEDENT base = 10 * base + ( ord ( Str [ i ] ) - ord ( '0' ) ) NEW_LINE i += 1 NEW_LINE DEDENT return base * sign NEW_LINE DEDENT Str = list ( "" ▁ - 123"" ) NEW_LINE val = myAtoi ( Str ) NEW_LINE print ( val ) NEW_LINE";"Write your own atoi ( ) | A simple Python3 program for implementation of atoi ; If whitespaces then ignore . ; Sign of number ; Checking for valid input ; Handling overflow test case ; Driver Code ; Functional Code"
Python;"NO_OF_CHARS = 256 NEW_LINE def areAnagram ( str1 , str2 ) : NEW_LINE INDENT count = [ 0 for i in range ( NO_OF_CHARS ) ] NEW_LINE i = 0 NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT count [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE count [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] -= 1 ; NEW_LINE DEDENT if ( len ( str1 ) != len ( str2 ) ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT str1 = "" geeksforgeeks "" NEW_LINE str2 = "" forgeeksgeeks "" NEW_LINE if ( areAnagram ( str1 , str2 ) ) : NEW_LINE INDENT print ( "" The ▁ two ▁ strings ▁ are ▁ anagram ▁ of ▁ each ▁ other "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" The ▁ two ▁ strings ▁ are ▁ not ▁ anagram ▁ of ▁ each ▁ other "" ) NEW_LINE DEDENT";"Check whether two strings are anagram of each other | Python program to check if two strings are anagrams of each other ; function to check if two strings are anagrams of each other ; Create a count array and initialize all values as 0 ; For each character in input strings , increment count in the corresponding count array ; If both strings are of different length . Removing this condition will make the program fail for strings like "" aaca "" and "" aca "" ; See if there is any non - zero value in count array ; Driver code ; Function call"
Python;"def areDistinct ( strr , i , j ) : NEW_LINE INDENT visited = [ 0 ] * ( 26 ) NEW_LINE for k in range ( i , j + 1 ) : NEW_LINE INDENT if ( visited [ ord ( strr [ k ] ) - ord ( ' a ' ) ] == True ) : NEW_LINE INDENT return False NEW_LINE DEDENT visited [ ord ( strr [ k ] ) - ord ( ' a ' ) ] = True NEW_LINE DEDENT return True NEW_LINE DEDENT def longestUniqueSubsttr ( strr ) : NEW_LINE INDENT n = len ( strr ) NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( areDistinct ( strr , i , j ) ) : NEW_LINE INDENT res = max ( res , j - i + 1 ) NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT strr = "" geeksforgeeks "" NEW_LINE print ( "" The ▁ input ▁ is ▁ "" , strr ) NEW_LINE len = longestUniqueSubsttr ( strr ) NEW_LINE print ( "" The ▁ length ▁ of ▁ the ▁ longest ▁ "" "" non - repeating ▁ character ▁ substring ▁ is ▁ "" , len ) NEW_LINE DEDENT";"Length of the longest substring without repeating characters | This functionr eturns true if all characters in strr [ i . . j ] are distinct , otherwise returns false ; Note : Default values in visited are false ; Returns length of the longest substring with all distinct characters . ; Result ; Driver code"
Python;"def unique ( s ) : NEW_LINE INDENT st = "" "" NEW_LINE length = len ( s ) NEW_LINE for i in range ( length ) : NEW_LINE INDENT c = s [ i ] NEW_LINE if c not in st : NEW_LINE INDENT st += c NEW_LINE DEDENT DEDENT return st NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT s = "" geeksforgeeks "" NEW_LINE print ( unique ( s ) ) NEW_LINE DEDENT";"Remove duplicates from a given string | Function to make the string unique ; loop to traverse the string and check for repeating chars using IndexOf ( ) method in Java ; character at i 'th index of s ; if c is present in str , it returns the index of c , else it returns - 1 print ( st . index ( c ) ) ; adding c to str if - 1 is returned ; Driver code ; Input string with repeating chars"
Python;"import math NEW_LINE def isPerfect ( x ) : NEW_LINE INDENT sum_div = 1 NEW_LINE for i in range ( 2 , ( x // 2 ) + 1 ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT sum_div += i NEW_LINE DEDENT DEDENT if ( sum_div == x ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def subsetSum ( arr , l , r , sum ) : NEW_LINE INDENT if ( l > r ) : NEW_LINE INDENT if ( isPerfect ( sum ) != 0 ) : NEW_LINE INDENT print ( sum , end = "" ▁ "" ) NEW_LINE DEDENT return NEW_LINE DEDENT subsetSum ( arr , l + 1 , r , sum + arr [ l ] ) NEW_LINE subsetSum ( arr , l + 1 , r , sum ) NEW_LINE DEDENT arr = [ 5 , 4 , 6 ] NEW_LINE N = len ( arr ) NEW_LINE subsetSum ( arr , 0 , N - 1 , 0 ) NEW_LINE";"Sum of all subsets whose sum is a Perfect Number from a given array | Python3 program for the above approach ; Function to check is a given number is a perfect number or not ; Stores the sum of its divisors ; Add all divisors of x to sum_div ; If the sum of divisors is equal to the given number , return true ; Otherwise , return false ; Function to find sum of all subsets from an array whose sum is a perfect number ; Prthe current subset sum if it is a perfect number ; Check if sum is a perfect number or not ; Calculate sum of the subset including arr [ l ] ; Calculate sum of the subset excluding arr [ l ] ; Driver Code"
Python;"def PartitionSub ( arr , i , N , K , nos , v ) : NEW_LINE INDENT if ( i >= N ) : NEW_LINE INDENT if ( nos == K ) : NEW_LINE INDENT for x in range ( len ( v ) ) : NEW_LINE INDENT print ( "" { ▁ "" , end = "" "" ) NEW_LINE for y in range ( len ( v [ x ] ) ) : NEW_LINE INDENT print ( v [ x ] [ y ] , end = "" "" ) NEW_LINE if ( y == len ( v [ x ] ) - 1 ) : NEW_LINE INDENT print ( "" ▁ "" , end = "" "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" , ▁ "" , end = "" "" ) NEW_LINE DEDENT DEDENT if ( x == len ( v ) - 1 ) : NEW_LINE INDENT print ( "" } "" , end = "" "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" } , ▁ "" , end = "" "" ) NEW_LINE DEDENT DEDENT print ( "" "" , ▁ end ▁ = ▁ "" "" ) NEW_LINE DEDENT return NEW_LINE DEDENT for j in range ( K ) : NEW_LINE INDENT if ( len ( v [ j ] ) > 0 ) : NEW_LINE INDENT v [ j ] . append ( arr [ i ] ) NEW_LINE PartitionSub ( arr , i + 1 , N , K , nos , v ) NEW_LINE v [ j ] . remove ( v [ j ] [ len ( v [ j ] ) - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT v [ j ] . append ( arr [ i ] ) NEW_LINE PartitionSub ( arr , i + 1 , N , K , nos + 1 , v ) NEW_LINE v [ j ] . remove ( v [ j ] [ len ( v [ j ] ) - 1 ] ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT def partKSubsets ( arr , N , K ) : NEW_LINE INDENT v = [ [ ] for i in range ( K ) ] NEW_LINE if ( K == 0 or K > N ) : NEW_LINE INDENT print ( "" Not ▁ Possible "" , end = "" "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" The ▁ Subset ▁ Combinations ▁ are : ▁ "" ) NEW_LINE PartitionSub ( arr , 0 , N , K , 0 , v ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE K = 2 NEW_LINE N = len ( arr ) NEW_LINE partKSubsets ( arr , N , K ) NEW_LINE DEDENT";"Print all possible ways to split an array into K subsets | Utility function to find all possible ways to split array into K subsets ; If count of elements in K subsets are greater than or equal to N ; If count of subsets formed is equal to K ; Print K subsets by splitting array into K subsets ; Print current subset ; If current element is the last element of the subset ; Otherwise ; If any subset is occupied , then push the element in that first ; Recursively do the same for remaining elements ; Backtrack ; Otherwise , push it in an empty subset and increase the subset count by 1 ; Break to avoid the case of going in other empty subsets , if available , and forming the same combination ; Function to to find all possible ways to split array into K subsets ; Stores K subset by splitting array into K subsets ; Size of each subset must be less than the number of elements ; Driver Code ; Given array ; Given K ; Size of the array ; Prints all possible splits into subsets"
Python;MAX = 100 NEW_LINE store = [ 0 for i in range ( MAX ) ] NEW_LINE n = 0 NEW_LINE graph = [ [ 0 for j in range ( MAX ) ] for i in range ( MAX ) ] NEW_LINE d = [ 0 for i in range ( MAX ) ] NEW_LINE ans = 0 NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while ( p * p <= p_size ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def is_clique ( b ) : NEW_LINE INDENT for i in range ( 1 , b ) : NEW_LINE INDENT for j in range ( i + 1 , b ) : NEW_LINE INDENT if ( graph [ store [ i ] ] [ store [ j ] ] == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT def primeCliques ( i , l , prime ) : NEW_LINE INDENT global ans NEW_LINE for j in range ( i + 1 , n + 1 ) : NEW_LINE INDENT store [ l ] = j NEW_LINE if ( is_clique ( l + 1 ) ) : NEW_LINE INDENT if ( prime [ l ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT primeCliques ( j , l + 1 , prime ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT edges = [ [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 1 ] , [ 4 , 3 ] , [ 4 , 5 ] , [ 5 , 3 ] ] NEW_LINE size = len ( edges ) NEW_LINE n = 5 NEW_LINE prime = [ True for i in range ( n + 2 ) ] NEW_LINE SieveOfEratosthenes ( prime , n + 1 ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT graph [ edges [ i ] [ 0 ] ] [ edges [ i ] [ 1 ] ] = 1 NEW_LINE graph [ edges [ i ] [ 1 ] ] [ edges [ i ] [ 0 ] ] = 1 NEW_LINE d [ edges [ i ] [ 0 ] ] += 1 NEW_LINE d [ edges [ i ] [ 1 ] ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE primeCliques ( 0 , 1 , prime ) NEW_LINE print ( ans ) NEW_LINE DEDENT;"Count the number of Prime Cliques in an undirected graph | Python3 implementation to Count the number of Prime Cliques in an undirected graph ; Stores the vertices ; Graph ; Degree of the vertices ; To store the count of prime cliques ; Function to create Sieve to check primes ; false here indicates that it is not prime ; Condition if prime [ p ] is not changed , then it is a prime ; Update all multiples of p , set them to non - prime ; Function to check if the given set of vertices in store array is a clique or not ; Run a loop for all set of edges ; If any edge is missing ; Function to find the count of all the cliques having prime size ; Check if any vertices from i + 1 can be inserted ; Add the vertex to store ; If the graph is not a clique of size k then it cannot be a clique by adding another edge ; Increase the count of prime cliques if the size of current clique is prime ; Check if another edge can be added ; Driver code"
Python;"dim = 3 NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . prev = None NEW_LINE self . up = None NEW_LINE self . down = None NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def createNode ( data ) : NEW_LINE INDENT temp = Node ( data ) ; NEW_LINE return temp ; NEW_LINE DEDENT def constructDoublyListUtil ( mtrx , i , j , curr ) : NEW_LINE INDENT if ( i >= dim or j >= dim ) : NEW_LINE INDENT return None ; NEW_LINE DEDENT temp = createNode ( mtrx [ i ] [ j ] ) ; NEW_LINE temp . prev = curr ; NEW_LINE temp . up = curr ; NEW_LINE temp . next = constructDoublyListUtil ( mtrx , i , j + 1 , temp ) ; NEW_LINE temp . down = constructDoublyListUtil ( mtrx , i + 1 , j , temp ) ; NEW_LINE return temp ; NEW_LINE DEDENT def constructDoublyList ( mtrx ) : NEW_LINE INDENT return constructDoublyListUtil ( mtrx , 0 , 0 , None ) ; NEW_LINE DEDENT def display ( head ) : NEW_LINE INDENT rPtr = None NEW_LINE dPtr = head ; NEW_LINE while ( dPtr != None ) : NEW_LINE INDENT rPtr = dPtr ; NEW_LINE while ( rPtr != None ) : NEW_LINE INDENT print ( rPtr . data , end = ' ▁ ' ) NEW_LINE rPtr = rPtr . next ; NEW_LINE DEDENT print ( ) NEW_LINE dPtr = dPtr . down ; NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT mtrx = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] NEW_LINE list = constructDoublyList ( mtrx ) ; NEW_LINE display ( list ) ; NEW_LINE DEDENT";"Construct a Doubly linked linked list from 2D Matrix | define dimension of matrix ; struct node of doubly linked list with four pointer next , prev , up , down ; function to create a new node ; function to construct the doubly linked list ; Create Node with value contain in matrix at index ( i , j ) ; Assign address of curr into the prev pointer of temp ; Assign address of curr into the up pointer of temp ; Recursive call for next pointer ; Recursive call for down pointer ; Return newly constructed node whose all four node connected at it 's appropriate position ; Function to construct the doubly linked list ; function call for construct the doubly linked list ; function for displaying doubly linked list data ; pointer to move right ; pointer to move down ; loop till node -> down is not NULL ; loop till node -> right is not NULL ; Driver code ; initialise matrix"
Python;import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def newNode ( key ) : NEW_LINE INDENT temp = Node ( key ) NEW_LINE return temp NEW_LINE DEDENT def find_x ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT num = math . log10 ( n ) NEW_LINE x , no = 0 , 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT den = math . log10 ( i ) NEW_LINE p = num / den NEW_LINE no = int ( pow ( i , int ( p ) ) ) NEW_LINE if abs ( no - n ) < 1e-6 : NEW_LINE INDENT x = i NEW_LINE break NEW_LINE DEDENT DEDENT return x NEW_LINE DEDENT def is_key ( n , x ) : NEW_LINE INDENT p = math . log10 ( n ) / math . log10 ( x ) NEW_LINE no = int ( pow ( x , int ( p ) ) ) NEW_LINE if n == no : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def evenPaths ( node , count , x ) : NEW_LINE INDENT if node == None or not is_key ( node . key , x ) : NEW_LINE INDENT return count NEW_LINE DEDENT if node . left == None and node . right == None : NEW_LINE INDENT count += 1 NEW_LINE DEDENT count = evenPaths ( node . left , count , x ) NEW_LINE return evenPaths ( node . right , count , x ) NEW_LINE DEDENT def countExpPaths ( node , x ) : NEW_LINE INDENT return evenPaths ( node , 0 , x ) NEW_LINE DEDENT root = newNode ( 27 ) NEW_LINE root . left = newNode ( 9 ) NEW_LINE root . right = newNode ( 81 ) NEW_LINE root . left . left = newNode ( 3 ) NEW_LINE root . left . right = newNode ( 10 ) NEW_LINE root . right . left = newNode ( 70 ) NEW_LINE root . right . right = newNode ( 243 ) NEW_LINE root . right . right . left = newNode ( 81 ) NEW_LINE root . right . right . right = newNode ( 909 ) NEW_LINE x = find_x ( root . key ) NEW_LINE print ( countExpPaths ( root , x ) ) NEW_LINE;"Count of exponential paths in a Binary Tree | Python3 program to find the count exponential paths in Binary Tree ; Structure of a Tree node ; Function to create a new node ; Function to find x ; Take log10 of n ; Log ( n ) with base i ; Raising i to the power p ; Function to check whether the given node equals to x ^ y for some y > 0 ; Take logx ( n ) with base x ; Utility function to count the exponent path in a given Binary tree ; Base Condition , when node pointer becomes null or node value is not a number of pow ( x , y ) ; Increment count when encounter leaf node ; Left recursive call save the value of count ; Right recursive call and return value of count ; Function to count exponential paths ; Create Tree ; Retrieve the value of x ; Function call"
Python;N = 1000001 NEW_LINE c = 0 NEW_LINE n = 0 NEW_LINE m = 0 NEW_LINE a = 0 NEW_LINE b = 0 NEW_LINE def dfs ( a , b , v , vis ) : NEW_LINE INDENT global c NEW_LINE vis [ a ] = 1 NEW_LINE c += 1 NEW_LINE for i in v [ a ] : NEW_LINE INDENT if ( vis [ i ] == 0 and i != b ) : NEW_LINE INDENT dfs ( i , b , v , vis ) NEW_LINE DEDENT DEDENT DEDENT def Calculate ( v ) : NEW_LINE INDENT global c NEW_LINE vis = [ 0 for i in range ( n + 1 ) ] NEW_LINE c = 0 NEW_LINE dfs ( a , b , v , vis ) NEW_LINE ans1 = n - c - 1 NEW_LINE vis = [ 0 for i in range ( len ( vis ) ) ] NEW_LINE c = 0 NEW_LINE dfs ( b , a , v , vis ) NEW_LINE ans2 = n - c - 1 NEW_LINE print ( ans1 * ans2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 7 NEW_LINE m = 7 NEW_LINE a = 3 NEW_LINE b = 5 NEW_LINE edges = [ [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 4 ] , [ 4 , 5 ] , [ 5 , 6 ] , [ 6 , 7 ] , [ 7 , 5 ] ] NEW_LINE v = [ [ ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( m ) : NEW_LINE INDENT v [ edges [ i ] [ 0 ] ] . append ( edges [ i ] [ 1 ] ) NEW_LINE v [ edges [ i ] [ 1 ] ] . append ( edges [ i ] [ 0 ] ) NEW_LINE DEDENT Calculate ( v ) NEW_LINE DEDENT;"Number of pairs such that path between pairs has the two vertices A and B | Python 3 program to find the number of pairs such that the path between every pair contains two given vertices ; Function to perform DFS on the given graph by fixing the a vertex ; To mark a particular vertex as visited ; Variable to store the count of the vertices which can be reached from a ; Performing the DFS by iterating over the visited array ; If the vertex is not visited and removing the vertex b ; Function to return the number of pairs such that path between any two pairs consists of the given two vertices A and B ; Initializing the visited array and assigning it with 0 's ; Initially , the count of vertices is 0 ; Performing DFS by removing the vertex B ; Count the vertices which cannot be reached after removing the vertex B ; Again reinitializing the visited array ; Setting the count of vertices to 0 to perform the DFS again ; Performing the DFS by removing the vertex A ; Count the vertices which cannot be reached after removing the vertex A ; Multiplying both the vertices set ; Driver code ; Loop to store the graph"
Python;V = 4 NEW_LINE answer = [ ] NEW_LINE def tsp ( graph , v , currPos , n , count , cost ) : NEW_LINE INDENT if ( count == n and graph [ currPos ] [ 0 ] ) : NEW_LINE INDENT answer . append ( cost + graph [ currPos ] [ 0 ] ) NEW_LINE return NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( v [ i ] == False and graph [ currPos ] [ i ] ) : NEW_LINE INDENT v [ i ] = True NEW_LINE tsp ( graph , v , i , n , count + 1 , cost + graph [ currPos ] [ i ] ) NEW_LINE v [ i ] = False NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE graph = [ [ 0 , 10 , 15 , 20 ] , [ 10 , 0 , 35 , 25 ] , [ 15 , 35 , 0 , 30 ] , [ 20 , 25 , 30 , 0 ] ] NEW_LINE v = [ False for i in range ( n ) ] NEW_LINE v [ 0 ] = True NEW_LINE tsp ( graph , v , 0 , n , 1 , 0 ) NEW_LINE print ( min ( answer ) ) NEW_LINE DEDENT;"Travelling Salesman Problem implementation using BackTracking | Python3 implementation of the approach ; Function to find the minimum weight Hamiltonian Cycle ; If last node is reached and it has a link to the starting node i . e the source then keep the minimum value out of the total cost of traversal and "" ans "" Finally return to check for more possible values ; BACKTRACKING STEP Loop to traverse the adjacency list of currPos node and increasing the count by 1 and cost by graph [ currPos ] [ i ] value ; Mark as visited ; Mark ith node as unvisited ; n is the number of nodes i . e . V ; Boolean array to check if a node has been visited or not ; Mark 0 th node as visited ; Find the minimum weight Hamiltonian Cycle ; ans is the minimum weight Hamiltonian Cycle"
Python;"def printTheArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def generateAllBinaryStrings ( n , arr , i ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT printTheArray ( arr , n ) NEW_LINE return NEW_LINE DEDENT arr [ i ] = 0 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE arr [ i ] = 1 NEW_LINE generateAllBinaryStrings ( n , arr , i + 1 ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 4 NEW_LINE arr = [ None ] * n NEW_LINE generateAllBinaryStrings ( n , arr , 0 ) NEW_LINE DEDENT";"Generate all the binary strings of N bits | Function to print the output ; Function to generate all binary strings ; First assign ""0"" at ith position and try for all other permutations for remaining positions ; And then assign ""1"" at ith position and try for all other permutations for remaining positions ; Driver Code ; Print all binary strings"
Python;"def allCombinationsRec ( arr , elem , n ) : NEW_LINE INDENT if ( elem > n ) : NEW_LINE INDENT for i in ( arr ) : NEW_LINE INDENT print ( i , end = "" ▁ "" ) NEW_LINE DEDENT print ( "" "" ) NEW_LINE return NEW_LINE DEDENT for i in range ( 0 , 2 * n ) : NEW_LINE INDENT if ( arr [ i ] == - 1 and ( i + elem + 1 ) < 2 * n and arr [ i + elem + 1 ] == - 1 ) : NEW_LINE INDENT arr [ i ] = elem NEW_LINE arr [ i + elem + 1 ] = elem NEW_LINE allCombinationsRec ( arr , elem + 1 , n ) NEW_LINE arr [ i ] = - 1 NEW_LINE arr [ i + elem + 1 ] = - 1 NEW_LINE DEDENT DEDENT DEDENT def allCombinations ( n ) : NEW_LINE INDENT arr = [ - 1 ] * ( 2 * n ) NEW_LINE elem = 1 NEW_LINE allCombinationsRec ( arr , elem , n ) NEW_LINE DEDENT n = 3 NEW_LINE allCombinations ( n ) NEW_LINE";"Combinations where every element appears twice and distance between appearances is equal to the value | Find all combinations that satisfies given constraints ; if all elements are filled , print the solution ; Try all possible combinations for element elem ; if position i and ( i + elem + 1 ) are not occupied in the vector ; place elem at position i and ( i + elem + 1 ) ; recurse for next element ; backtrack ( remove elem from position i and ( i + elem + 1 ) ) ; create a vector of double the size of given number with ; all its elements initialized by 1 ; start from element 1 ; given number"
Python;"import math NEW_LINE result = [ ] NEW_LINE def solveBoard ( board , row , rowmask , ldmask , rdmask ) : NEW_LINE INDENT n = len ( board ) NEW_LINE all_rows_filled = ( 1 << n ) - 1 NEW_LINE if ( rowmask == all_rows_filled ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in board : NEW_LINE INDENT for j in range ( len ( i ) ) : NEW_LINE INDENT if i [ j ] == ' Q ' : NEW_LINE INDENT v . append ( j + 1 ) NEW_LINE DEDENT DEDENT DEDENT result . append ( v ) NEW_LINE DEDENT safe = all_rows_filled & ( ~ ( rowmask ldmask rdmask ) ) NEW_LINE while ( safe > 0 ) : NEW_LINE INDENT p = safe & ( - safe ) NEW_LINE col = ( int ) ( math . log ( p ) / math . log ( 2 ) ) NEW_LINE board [ row ] [ col ] = ' Q ' NEW_LINE solveBoard ( board , row + 1 , rowmask | p , ( ldmask p ) << 1 , ( rdmask p ) >> 1 ) NEW_LINE safe = safe & ( safe - 1 ) NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT board [ row ] [ col ] = ' ▁ ' NEW_LINE DEDENT def printBoard ( board ) : NEW_LINE INDENT for row in board : NEW_LINE INDENT print ( "" | "" + "" | "" . join ( row ) + "" ▁ "" ) NEW_LINE DEDENT DEDENT def main ( ) : NEW_LINE INDENT board = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT row = [ ] NEW_LINE for j in range ( n ) : NEW_LINE INDENT row . append ( ' ▁ ' ) NEW_LINE DEDENT board . append ( row ) NEW_LINE DEDENT rowmask = 0 NEW_LINE ldmask = 0 NEW_LINE rdmask = 0 NEW_LINE row = 0 NEW_LINE result . clear ( ) NEW_LINE solveBoard ( board , row , rowmask , ldmask , rdmask ) NEW_LINE result . sort ( ) NEW_LINE print ( result ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT";"Printing all solutions in N | Python program for above approach ; Program to solve N - Queens Problem ; All_rows_filled is a bit mask having all N bits set ; If rowmask will have all bits set , means queen has been placed successfully in all rows and board is displayed ; We extract a bit mask ( safe ) by rowmask , ldmask and rdmask . all set bits of ' safe ' indicates the safe column index for queen placement of this iteration for row index ( row ) . ; Extracts the right - most set bit ( safe column index ) where queen can be placed for this row ; these bit masks will keep updated in each iteration for next row ; Reset right - most set bit to 0 so , next iteration will continue by placing the queen at another safe column index of this row ; Backtracking , replace ' Q ' by '  ; Program to print board ; Driver Code ; n = 4 board size ; Function Call"
Python;"def printPowerSet ( arr , n ) : NEW_LINE INDENT _list = [ ] NEW_LINE for i in range ( 2 ** n ) : NEW_LINE INDENT subset = "" "" NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) != 0 : NEW_LINE INDENT subset += str ( arr [ j ] ) + "" | "" NEW_LINE DEDENT DEDENT if subset not in _list and len ( subset ) > 0 : NEW_LINE INDENT _list . append ( subset ) NEW_LINE DEDENT DEDENT for subset in _list : NEW_LINE INDENT arr = subset . split ( ' ▁ ' ) NEW_LINE for string in arr : NEW_LINE INDENT print ( string , end = "" ▁ "" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 12 , 12 ] NEW_LINE n = len ( arr ) NEW_LINE printPowerSet ( arr , n ) NEW_LINE DEDENT";"Find all distinct subsets of a given set using BitMasking Approach | Function to find all subsets of given set . Any repeated subset is considered only once in the output ; Run counter i from 000. . 0 to 111. . 1 ; consider each element in the set ; Check if jth bit in the i is set . If the bit is set , we consider jth element from set ; if subset is encountered for the first time If we use set < string > , we can directly insert ; consider every subset ; split the subset and print its elements ; Driver Code"
Python;"from queue import Queue NEW_LINE class node : NEW_LINE INDENT color = 1 NEW_LINE edges = set ( ) NEW_LINE DEDENT def canPaint ( nodes , n , m ) : NEW_LINE INDENT visited = [ 0 for _ in range ( n + 1 ) ] NEW_LINE maxColors = 1 NEW_LINE for _ in range ( 1 , n + 1 ) : NEW_LINE INDENT if visited [ _ ] : NEW_LINE INDENT continue NEW_LINE DEDENT visited [ _ ] = 1 NEW_LINE q = Queue ( ) NEW_LINE q . put ( _ ) NEW_LINE while not q . empty ( ) : NEW_LINE INDENT top = q . get ( ) NEW_LINE for _ in nodes [ top ] . edges : NEW_LINE INDENT if nodes [ top ] . color == nodes [ _ ] . color : NEW_LINE INDENT nodes [ _ ] . color += 1 NEW_LINE DEDENT maxColors = max ( maxColors , max ( nodes [ top ] . color , nodes [ _ ] . color ) ) NEW_LINE if maxColors > m : NEW_LINE INDENT print ( maxColors ) NEW_LINE return 0 NEW_LINE DEDENT if not visited [ _ ] : NEW_LINE INDENT visited [ _ ] = 1 NEW_LINE q . put ( _ ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return 1 NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 4 NEW_LINE graph = [ [ 0 , 1 , 1 , 1 ] , [ 1 , 0 , 1 , 0 ] , [ 1 , 1 , 0 , 1 ] , [ 1 , 0 , 1 , 0 ] ] NEW_LINE m = 3 NEW_LINE nodes = [ ] NEW_LINE for _ in range ( n + 1 ) : NEW_LINE INDENT nodes . append ( node ( ) ) NEW_LINE DEDENT for _ in range ( n ) : NEW_LINE INDENT for __ in range ( n ) : NEW_LINE INDENT if graph [ _ ] [ __ ] : NEW_LINE INDENT nodes [ _ ] . edges . add ( _ ) NEW_LINE nodes [ __ ] . edges . add ( __ ) NEW_LINE DEDENT DEDENT DEDENT print ( canPaint ( nodes , n , m ) ) NEW_LINE DEDENT";"m Coloring Problem | Backtracking | Python3 program for the above approach ; A node class which stores the color and the edges connected to the node ; Create a visited array of n nodes , initialized to zero ; maxColors used till now are 1 as all nodes are painted color 1 ; Do a full BFS traversal from all unvisited starting points ; If the starting point is unvisited , mark it visited and push it in queue ; BFS Travel starts here ; Checking all adjacent nodes to "" top "" edge in our queue ; IMPORTANT : If the color of the adjacent node is same , increase it by 1 ; If number of colors used shoots m , return 0 ; If the adjacent node is not visited , mark it visited and push it in queue ; Driver code ; Number of colors ; Create a vector of n + 1 nodes of type "" node "" The zeroth position is just dummy ( 1 to n to be used ) ; Add edges to each node as per given input ; Connect the undirected graph ; Display final answer"
Python;MOD = 1000000007 NEW_LINE def FastDoubling ( n , res ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT res [ 0 ] = 0 NEW_LINE res [ 1 ] = 1 NEW_LINE return NEW_LINE DEDENT FastDoubling ( ( n // 2 ) , res ) NEW_LINE a = res [ 0 ] NEW_LINE b = res [ 1 ] NEW_LINE c = 2 * b - a NEW_LINE if ( c < 0 ) : NEW_LINE INDENT c += MOD NEW_LINE DEDENT c = ( a * c ) % MOD NEW_LINE d = ( a * a + b * b ) % MOD NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT res [ 0 ] = c NEW_LINE res [ 1 ] = d NEW_LINE DEDENT else : NEW_LINE INDENT res [ 0 ] = d NEW_LINE res [ 1 ] = c + d NEW_LINE DEDENT DEDENT N = 6 NEW_LINE res = [ 0 ] * 2 NEW_LINE FastDoubling ( N , res ) NEW_LINE print ( res [ 0 ] ) NEW_LINE;"Fast Doubling method to find the Nth Fibonacci number | Python3 program to find the Nth Fibonacci number using Fast Doubling Method ; Function calculate the N - th fibanacci number using fast doubling method ; Base Condition ; Here a = F ( n ) ; Here b = F ( n + 1 ) ; As F ( 2 n ) = F ( n ) [ 2F ( n + 1 ) F ( n ) ] Here c = F ( 2 n ) ; As F ( 2 n + 1 ) = F ( n ) ^ 2 + F ( n + 1 ) ^ 2 Here d = F ( 2 n + 1 ) ; Check if N is odd or even ; Driver code"
Python;"def count ( arr , low , high , x ) : NEW_LINE INDENT if ( ( low > high ) or ( low == high and arr [ low ] != x ) ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( low == high and arr [ low ] == x ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return count ( arr , low , ( low + high ) // 2 , x ) + count ( arr , 1 + ( low + high ) // 2 , high , x ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 30 , 1 , 42 , 5 , 56 , 3 , 56 , 9 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE x = 56 ; NEW_LINE print ( count ( arr , 0 , n - 1 , x ) ) ; NEW_LINE DEDENT";"Frequency of an integer in the given array using Divide and Conquer | Function to return the frequency of x in the subarray arr [ low ... high ] ; If the subarray is invalid or the element is not found ; If there 's only a single element  which is equal to x ; Divide the array into two parts and then find the count of occurrences of x in both the parts ; Driver code"
Python;"import random NEW_LINE a , b = None , None ; NEW_LINE def Partition ( arr , l , r ) : NEW_LINE INDENT lst = arr [ r ] ; i = l ; j = l ; NEW_LINE while ( j < r ) : NEW_LINE INDENT if ( arr [ j ] < lst ) : NEW_LINE INDENT arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] ; NEW_LINE i += 1 ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT arr [ i ] , arr [ r ] = arr [ r ] , arr [ i ] ; NEW_LINE return i ; NEW_LINE DEDENT def randomPartition ( arr , l , r ) : NEW_LINE INDENT n = r - l + 1 ; NEW_LINE pivot = random . randrange ( 1 , 100 ) % n ; NEW_LINE arr [ l + pivot ] , arr [ r ] = arr [ r ] , arr [ l + pivot ] ; NEW_LINE return Partition ( arr , l , r ) ; NEW_LINE DEDENT def MedianUtil ( arr , l , r , k , a1 , b1 ) : NEW_LINE INDENT global a , b ; NEW_LINE if ( l <= r ) : NEW_LINE INDENT partitionIndex = randomPartition ( arr , l , r ) ; NEW_LINE if ( partitionIndex == k ) : NEW_LINE INDENT b = arr [ partitionIndex ] ; NEW_LINE if ( a1 != - 1 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT DEDENT elif ( partitionIndex == k - 1 ) : NEW_LINE INDENT a = arr [ partitionIndex ] ; NEW_LINE if ( b1 != - 1 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT DEDENT if ( partitionIndex >= k ) : NEW_LINE INDENT return MedianUtil ( arr , l , partitionIndex - 1 , k , a , b ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return MedianUtil ( arr , partitionIndex + 1 , r , k , a , b ) ; NEW_LINE DEDENT DEDENT return ; NEW_LINE DEDENT def findMedian ( arr , n ) : NEW_LINE INDENT global a ; NEW_LINE global b ; NEW_LINE a = - 1 ; NEW_LINE b = - 1 ; NEW_LINE if ( n % 2 == 1 ) : NEW_LINE INDENT MedianUtil ( arr , 0 , n - 1 , n // 2 , a , b ) ; NEW_LINE ans = b ; NEW_LINE DEDENT else : NEW_LINE INDENT MedianUtil ( arr , 0 , n - 1 , n // 2 , a , b ) ; NEW_LINE ans = ( a + b ) // 2 ; NEW_LINE DEDENT print ( "" Median ▁ = ▁ "" , ans ) ; NEW_LINE DEDENT arr = [ 12 , 3 , 5 , 7 , 4 , 19 , 26 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findMedian ( arr , n ) ; NEW_LINE";"Median of an unsorted array using Quick Select Algorithm | Python3 program to find median of an array ; Returns the correct position of pivot element ; Picks a random pivot element between l and r and partitions arr [ l . . r ] around the randomly picked element using partition ( ) ; Utility function to find median ; if l < r ; Find the partition index ; If partition index = k , then we found the median of odd number element in arr [ ] ; If index = k - 1 , then we get a & b as middle element of arr [ ] ; If partitionIndex >= k then find the index in first half of the arr [ ] ; If partitionIndex <= k then find the index in second half of the arr [ ] ; Function to find Median ; If n is odd ; If n is even ; Print the Median of arr [ ] ; Driver code"
Python;"def firstDigit ( n ) : NEW_LINE INDENT while ( n >= 10 ) : NEW_LINE INDENT n //= 10 ; NEW_LINE DEDENT return n ; NEW_LINE DEDENT def getCount ( n ) : NEW_LINE INDENT count = 1 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT leadDigit = firstDigit ( n ) ; NEW_LINE n -= leadDigit ; NEW_LINE count += 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def getLargestNumber ( k ) : NEW_LINE INDENT left = k ; NEW_LINE right = k * 10 ; NEW_LINE mid = ( left + right ) // 2 ; NEW_LINE length = getCount ( mid ) ; NEW_LINE while ( length != k ) : NEW_LINE INDENT mid = ( left + right ) // 2 ; NEW_LINE length = getCount ( mid ) ; NEW_LINE if ( length > k ) : NEW_LINE INDENT right = mid ; NEW_LINE DEDENT else : NEW_LINE INDENT left = mid ; NEW_LINE DEDENT DEDENT while ( length == k ) : NEW_LINE INDENT if ( length != getCount ( mid + 1 ) ) : NEW_LINE INDENT break ; NEW_LINE DEDENT mid += 1 ; NEW_LINE DEDENT return mid ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT k = 3 ; NEW_LINE print ( getLargestNumber ( k ) ) ; NEW_LINE DEDENT";"Largest number N which can be reduced to 0 in K steps | Utility function to return the first digit of a number . ; Remove last digit from number till only one digit is left ; return the first digit ; Utility function that returns the count of numbers written down when starting from n ; Function to find the largest number N which can be reduced to 0 in K steps ; Get the sequence length of the mid point ; Until k sequence length is reached ; Update mid point ; Get count of the new mid point ; Update right to mid ; Update left to mid ; Increment mid point by one while count is equal to k to get the maximum value of mid point ; Driver Code"
Python;"def checkReachability ( N , X , Y ) : NEW_LINE INDENT if ( X == 0 and Y == 0 ) : NEW_LINE INDENT return "" YES "" NEW_LINE DEDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return "" YES "" NEW_LINE DEDENT else : NEW_LINE INDENT if ( X % 2 != Y % 2 ) : NEW_LINE INDENT return "" NO "" NEW_LINE DEDENT else : NEW_LINE INDENT return "" YES "" NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 2 NEW_LINE X = 5 NEW_LINE Y = 4 NEW_LINE print ( checkReachability ( N , X , Y ) ) NEW_LINE DEDENT";"Check if point ( X , Y ) can be reached from origin ( 0 , 0 ) with jump of 1 and N perpendicularly simultaneously | Function to check if ( X , Y ) is reachable from ( 0 , 0 ) using the jumps of given type ; Case where source & destination are the same ; Check for even N ( X , Y ) is reachable or not ; If N is odd and parity of X and Y is different return , no valid sequence of jumps exist ; Driver Code"
Python;import math NEW_LINE import sys NEW_LINE def closestsAngle ( N , A ) : NEW_LINE INDENT mi = sys . maxsize NEW_LINE ans = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT angle = 180.0 * i / N NEW_LINE if ( math . fabs ( angle - A ) < math . fabs ( mi - A ) ) : NEW_LINE INDENT mi = angle NEW_LINE i += 1 NEW_LINE ans = i NEW_LINE DEDENT DEDENT print ( 2 , 1 , 2 + ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 NEW_LINE A = 15 NEW_LINE closestsAngle ( N , A ) NEW_LINE DEDENT;"Find three vertices in an N | Function to find three vertices that subtends an angle closest to A ; Stores the closest angle to A ; Stores the count of edge which subtend an angle of A ; Iterate in the range [ 1 , N - 2 ] ; Stores the angle subtended ; If absolute ( angle - A ) is less than absolute ( mi - A ) ; Update angle to mi , and also update i to ans ; Pr the vertices ; Driver Code"
Python;from math import sqrt NEW_LINE def areaOftriangle ( side ) : NEW_LINE INDENT a = sqrt ( pow ( side / 2 , 2 ) + pow ( side / 2 , 2 ) ) NEW_LINE b = sqrt ( pow ( side , 2 ) + pow ( side / 2 , 2 ) ) NEW_LINE c = sqrt ( pow ( side , 2 ) + pow ( side / 2 , 2 ) ) NEW_LINE s = ( a + b + c ) / 2 NEW_LINE area = sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) NEW_LINE return round ( area , 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 10 NEW_LINE print ( areaOftriangle ( N ) ) NEW_LINE DEDENT;"Area of a triangle with two vertices at midpoints of opposite sides of a square and the other vertex lying on vertex of a square | Python3 program for the above approach ; Function to find the area of the triangle that inscribed in square ; Stores the length of the first side of triangle ; Stores the length of the second side of triangle ; Stores the length of the third side of triangle ; Stores the area of the triangle ; Return the resultant area ; Driver Code"
Python;"import math NEW_LINE def findLine ( distance , degree ) : NEW_LINE INDENT x = degree * 3.14159 / 180 NEW_LINE if ( degree > 90 ) : NEW_LINE INDENT print ( "" Not ▁ Possible "" ) NEW_LINE return NEW_LINE DEDENT result_1 = math . sin ( x ) NEW_LINE result_2 = math . cos ( x ) NEW_LINE print ( ' % .2f ' % result_2 , "" x ▁ + "" , ' % .2f ' % result_1 , "" y ▁ = ▁ "" , distance , sep = "" "" ) NEW_LINE DEDENT D = 10 NEW_LINE A = 30 NEW_LINE findLine ( D , A ) NEW_LINE";"Equation of a straight line with perpendicular distance D from origin and an angle A between the perpendicular from origin and x | Python3 program for the approach ; Function to find equation of a line whose distance from origin and angle made by the perpendicular from origin with x - axis is given ; Convert angle from degree to radian ; Handle the special case ; Calculate the sin and cos of angle ; Print the equation of the line ; Given Input ; Function Call"
Python;"def centralPoints ( arr , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT c1 = 0 NEW_LINE c2 = 0 NEW_LINE c3 = 0 NEW_LINE c4 = 0 NEW_LINE x = arr [ i ] [ 0 ] NEW_LINE y = arr [ i ] [ 1 ] NEW_LINE for j in range ( N ) : NEW_LINE INDENT if ( arr [ j ] [ 0 ] > x and arr [ j ] [ 1 ] == y ) : NEW_LINE INDENT c1 = 1 NEW_LINE DEDENT if ( arr [ j ] [ 1 ] > y and arr [ j ] [ 0 ] == x ) : NEW_LINE INDENT c2 = 1 NEW_LINE DEDENT if ( arr [ j ] [ 0 ] < x and arr [ j ] [ 1 ] == y ) : NEW_LINE INDENT c3 = 1 NEW_LINE DEDENT if ( arr [ j ] [ 1 ] < y and arr [ j ] [ 0 ] == x ) : NEW_LINE INDENT c4 = 1 NEW_LINE DEDENT DEDENT if ( c1 + c2 + c3 + c4 == 4 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ [ 1 , 0 ] , [ 2 , 0 ] , [ 1 , 1 ] , [ 1 , - 1 ] ] NEW_LINE N = len ( arr ) NEW_LINE print ( centralPoints ( arr , N ) ) ; NEW_LINE DEDENT";"Count number of coordinates from an array satisfying the given conditions | Function to count the number of coordinates from a given set that satisfies the given conditions ; Stores the count of central points ; Find all possible pairs ; Initialize variables c1 , c2 , c3 , c4 to define the status of conditions ; Stores value of each point ; Check the conditions for each point by generating all possible pairs ; If arr [ j ] [ 0 ] > x and arr [ j ] [ 1 ] == y ; If arr [ j ] [ 0 ] < x and arr [ j ] [ 1 ] = = y ; If arr [ j ] [ 1 ] > y and arr [ j ] [ 0 ] == x ; If arr [ j ] [ 1 ] < y and arr [ j ] [ 0 ] = = x ; If all conditions satisfy then point is central point ; Increment the count by 1 ; Return the count ; Driver Code"
Python;from math import sqrt , floor NEW_LINE def finalPosition ( a , b , M ) : NEW_LINE INDENT n = 0 NEW_LINE s = 0 NEW_LINE e = 0 NEW_LINE w = 0 NEW_LINE p = ' N ' NEW_LINE for i in range ( M ) : NEW_LINE INDENT if ( p == ' N ' ) : NEW_LINE INDENT if ( a [ i ] == ' U ' ) : NEW_LINE INDENT p = ' N ' NEW_LINE n = n + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == ' D ' ) : NEW_LINE INDENT p = ' S ' NEW_LINE s = s + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == ' R ' ) : NEW_LINE INDENT p = ' E ' NEW_LINE e = e + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == ' L ' ) : NEW_LINE INDENT p = ' W ' NEW_LINE w = w + b [ i ] NEW_LINE DEDENT DEDENT elif ( p == ' S ' ) : NEW_LINE INDENT if ( a [ i ] == ' U ' ) : NEW_LINE INDENT p = ' S ' NEW_LINE s = s + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == ' D ' ) : NEW_LINE INDENT p = ' N ' NEW_LINE n = n + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == ' R ' ) : NEW_LINE INDENT p = ' W ' NEW_LINE w = w + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == ' L ' ) : NEW_LINE INDENT p = ' E ' NEW_LINE e = e + b [ i ] NEW_LINE DEDENT DEDENT elif ( p == ' E ' ) : NEW_LINE INDENT if ( a [ i ] == ' U ' ) : NEW_LINE INDENT p = ' E ' NEW_LINE e = e + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == ' D ' ) : NEW_LINE INDENT p = ' W ' NEW_LINE w = w + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == ' R ' ) : NEW_LINE INDENT p = ' S ' NEW_LINE s = s + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == ' L ' ) : NEW_LINE INDENT p = ' N ' NEW_LINE n = n + b [ i ] NEW_LINE DEDENT DEDENT elif ( p == ' W ' ) : NEW_LINE INDENT if ( a [ i ] == ' U ' ) : NEW_LINE INDENT p = ' W ' NEW_LINE w = w + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == ' D ' ) : NEW_LINE INDENT p = ' E ' NEW_LINE e = e + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == ' R ' ) : NEW_LINE INDENT p = ' N ' NEW_LINE n = n + b [ i ] NEW_LINE DEDENT elif ( a [ i ] == ' L ' ) : NEW_LINE INDENT p = ' S ' NEW_LINE s = s + b [ i ] NEW_LINE DEDENT DEDENT DEDENT ver_disp = n - s NEW_LINE hor_disp = e - w NEW_LINE displacement = floor ( sqrt ( ( ver_disp * ver_disp ) + ( hor_disp * hor_disp ) ) + 1 ) NEW_LINE print ( displacement , p ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ ' U ' , ' R ' , ' R ' , ' R ' , ' R ' ] NEW_LINE B = [ 1 , 1 , 1 , 1 , 0 ] NEW_LINE N = len ( A ) NEW_LINE finalPosition ( A , B , N ) NEW_LINE DEDENT;"Displacement from origin after N moves of given distances in specified directions | Python3 program for the above approach ; Function to find the displacement from the origin and direction after performing the given set of moves ; Stores the distances travelled in the directions North , South , East , and West respectively ; Store the initial position of robot ; Traverse the array B [ ] ; If the current direction is North ; If the current direction is South ; If the current direction is East ; If the current direction is West ; Stores the total vertical displacement ; Stores the total horizontal displacement ; Find the displacement ; Print the displacement and direction after N moves ; Driver Code"
Python;"def lengthOfLatusRectum ( A , B ) : NEW_LINE INDENT major = 2.0 * A NEW_LINE minor = 2.0 * B NEW_LINE latus_rectum = ( minor * minor ) / major NEW_LINE return latus_rectum NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A = 3.0 NEW_LINE B = 2.0 NEW_LINE print ( ' % .5f ' % lengthOfLatusRectum ( A , B ) ) NEW_LINE DEDENT";"Program to find Length of Latus Rectum of an Ellipse | Function to calculate the length of the latus rectum of an ellipse ; Length of major axis ; Length of minor axis ; Length of the latus rectum ; Driver Code ; Given lengths of semi - major and semi - minor axis ; Function call to calculate length of the latus rectum of a ellipse"
Python;"from math import sqrt , pow NEW_LINE def coneSlantHeight ( cone_h , cone_r ) : NEW_LINE INDENT slant_height_cone = sqrt ( pow ( cone_h , 2 ) + pow ( cone_r , 2 ) ) NEW_LINE print ( "" Slant ▁ height ▁ of ▁ cone ▁ is : "" , slant_height_cone ) NEW_LINE DEDENT def pyramidSlantHeight ( pyramid_h , pyramid_s ) : NEW_LINE INDENT slant_height_pyramid = sqrt ( pow ( pyramid_s / 2 , 2 ) + pow ( pyramid_h , 2 ) ) NEW_LINE print ( "" Slant ▁ height ▁ of ▁ pyramid ▁ is : "" , "" { : . 5f } "" . format ( slant_height_pyramid ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT H1 = 4.5 NEW_LINE R = 6 NEW_LINE coneSlantHeight ( H1 , R ) ; NEW_LINE H2 = 4 NEW_LINE S = 4.8 NEW_LINE pyramidSlantHeight ( H2 , S ) NEW_LINE DEDENT";"Program to find slant height of cone and pyramid | Python 3 program for the above approach ; Function to calculate slant height of a cone ; Store the slant height of cone ; Print the result ; Function to find the slant height of a pyramid ; Store the slant height of pyramid ; Print the result ; Driver Code ; Dimensions of Cone ; Function Call for slant height of Cone ; Dimensions of Pyramid ; Function to calculate slant height of a pyramid"
Python;"from math import sqrt NEW_LINE def distance ( x1 , y1 , x2 , y2 ) : NEW_LINE INDENT return sqrt ( ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) ) NEW_LINE DEDENT def lengthOfLatusRectum ( a , b , c ) : NEW_LINE INDENT vertex = [ ( - b / ( 2 * a ) ) , ( ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) ] NEW_LINE focus = [ ( - b / ( 2 * a ) ) , ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) ] NEW_LINE print ( "" { : . 6f } "" . format ( 4 * distance ( focus [ 0 ] , focus [ 1 ] , vertex [ 0 ] , vertex [ 1 ] ) ) ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = 3 NEW_LINE b = 5 NEW_LINE c = 1 NEW_LINE lengthOfLatusRectum ( a , b , c ) NEW_LINE DEDENT";"Program to find the length of Latus Rectum of a Parabola | Python 3 program for the above approach ; Function to calculate distance between two points ; Calculating distance ; Function to calculate length of the latus rectum of a parabola ; Stores the co - ordinates of the vertex of the parabola ; Stores the co - ordinates of the focus of parabola ; Print the distance between focus and vertex ; Driver Code ; Given a , b & c ; Function call"
Python;"import math NEW_LINE def ConvertDegToRad ( degree ) : NEW_LINE INDENT pi = 3.14159 NEW_LINE return ( degree * ( pi / 180.0 ) ) NEW_LINE DEDENT def ConvertToCartesian ( polar ) : NEW_LINE INDENT polar [ 1 ] = ConvertDegToRad ( polar [ 1 ] ) NEW_LINE cartesian = [ polar [ 0 ] * math . cos ( polar [ 1 ] ) , polar [ 0 ] * math . sin ( polar [ 1 ] ) ] NEW_LINE print ( ' % .3f ' % cartesian [ 0 ] , ' % .3f ' % cartesian [ 1 ] ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT polar = [ 1.4142 , 45 ] NEW_LINE ConvertToCartesian ( polar ) NEW_LINE DEDENT";"Program to convert polar co | Python 3 program for the above approach ; Function to convert degree to radian ; Function to convert the polar coordinate to cartesian ; Convert degerees to radian ; Applying the formula : x = rcos ( theata ) , y = rsin ( theta ) ; Print cartesian coordinates ; Driver Code ; Given polar coordinates ; Function to convert polar coordinates to equivalent cartesian coordinates"
Python;import math NEW_LINE def distance ( p1 , p2 ) : NEW_LINE INDENT x1 , x2 = p1 [ 0 ] , p2 [ 0 ] NEW_LINE y1 , y2 = p1 [ 1 ] , p2 [ 1 ] NEW_LINE return int ( math . sqrt ( pow ( x2 - x1 , 2 ) + pow ( y2 - y1 , 2 ) ) ) NEW_LINE DEDENT def find_orthocenter ( A , B , C ) : NEW_LINE INDENT AB = distance ( A , B ) NEW_LINE BC = distance ( B , C ) NEW_LINE CA = distance ( C , A ) NEW_LINE if ( AB > BC and AB > CA ) : NEW_LINE INDENT return C NEW_LINE DEDENT if ( BC > AB and BC > CA ) : NEW_LINE INDENT return A NEW_LINE DEDENT return B NEW_LINE DEDENT def find_circumcenter ( A , B , C ) : NEW_LINE INDENT AB = distance ( A , B ) NEW_LINE BC = distance ( B , C ) NEW_LINE CA = distance ( C , A ) NEW_LINE if ( AB > BC and AB > CA ) : NEW_LINE INDENT return ( ( A [ 0 ] + B [ 0 ] ) // 2 , ( A [ 1 ] + B [ 1 ] ) // 2 ) NEW_LINE DEDENT if ( BC > AB and BC > CA ) : NEW_LINE INDENT return ( ( B [ 0 ] + C [ 0 ] ) // 2 , ( B [ 1 ] + C [ 1 ] ) // 2 ) NEW_LINE DEDENT return ( ( C [ 0 ] + A [ 0 ] ) // 2 , ( C [ 1 ] + A [ 1 ] ) // 2 ) NEW_LINE DEDENT def findDistance ( A , B , C ) : NEW_LINE INDENT circumcenter = find_circumcenter ( A , B , C ) NEW_LINE orthocenter = find_orthocenter ( A , B , C ) NEW_LINE distance_between = distance ( circumcenter , orthocenter ) NEW_LINE print ( distance_between ) NEW_LINE DEDENT A = [ 0 , 0 ] NEW_LINE B = [ 6 , 0 ] NEW_LINE C = [ 0 , 8 ] NEW_LINE findDistance ( A , B , C ) NEW_LINE;"Distance between orthocenter and circumcenter of a right | Python3 program for the above approach ; Function to calculate Euclidean distance between the points p1 and p2 ; Stores x coordinates of both points ; Stores y coordinates of both points ; Return the Euclid distance using distance formula ; Function to find orthocenter of the right angled triangle ; Find the length of the three sides ; Orthocenter will be the vertex opposite to the largest side ; Function to find the circumcenter of right angle triangle ; Circumcenter will be located at center of hypotenuse ; If AB is the hypotenuse ; If BC is the hypotenuse ; If AC is the hypotenuse ; Function to find distance between orthocenter and circumcenter ; Find circumcenter ; Find orthocenter ; Find the distance between the orthocenter and circumcenter ; Print distance between orthocenter and circumcenter ; Given coordinates A , B , and C ; Function Call"
Python;"import time NEW_LINE import random NEW_LINE random . seed ( time . time ( ) ) NEW_LINE def generatePoints ( L , W ) : NEW_LINE INDENT hash = { } NEW_LINE total = ( L * W ) NEW_LINE for i in range ( total ) : NEW_LINE INDENT X = random . randint ( 0 , L ) % L NEW_LINE Y = random . randint ( 0 , W ) % W NEW_LINE while ( ( X , Y ) in hash ) : NEW_LINE INDENT X = random . randint ( 0 , L ) % L NEW_LINE Y = random . randint ( 0 , W ) % W NEW_LINE DEDENT hash [ ( X , Y ) ] = 1 NEW_LINE DEDENT for points in sorted ( hash ) : NEW_LINE INDENT print ( "" ( "" , points [ 0 ] , "" , ▁ "" , points [ 1 ] , "" ) ▁ "" , end = "" "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT L , W = 3 , 2 NEW_LINE generatePoints ( L , W ) NEW_LINE DEDENT";"Generate all integral points lying inside a rectangle | Python3 program to implement the above approach ; Function to generate coordinates lying within the rectangle ; Store all possible coordinates that lie within the rectangle ; Stores the number of possible coordinates that lie within the rectangle ; Generate all possible coordinates ; Generate all possible X - coordinates ; Generate all possible Y - coordinates ; If coordinates ( X , Y ) has not been generated already ; Insert the coordinates ( X , Y ) ; Print the coordinates ; Driver code ; Rectangle dimensions"
Python;def noOfTriangles ( n ) : NEW_LINE INDENT return n * ( n + 2 ) * ( 2 * n + 1 ) // 8 NEW_LINE DEDENT n = 3 NEW_LINE print ( noOfTriangles ( n ) ) NEW_LINE;"Count triangles required to form a House of Cards of height N | Function to find required number of triangles ; Driver Code ; Function call"
Python;"import math NEW_LINE def findNumberOfDigits ( n , base ) : NEW_LINE INDENT dig = ( math . floor ( math . log ( n ) / math . log ( base ) ) + 1 ) NEW_LINE return dig NEW_LINE DEDENT def isAllKs ( n , b , k ) : NEW_LINE INDENT len = findNumberOfDigits ( n , b ) NEW_LINE sum = k * ( 1 - pow ( b , len ) ) / ( 1 - b ) NEW_LINE return sum == N NEW_LINE DEDENT N = 13 NEW_LINE B = 3 NEW_LINE K = 1 NEW_LINE if ( isAllKs ( N , B , K ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Check if N contains all digits as K in base B | Python3 program for the above approach ; Function to print the number of digits ; Calculate log using base change property and then take its floor and then add 1 ; Return the output ; Function that returns true if n contains all one 's in base b ; Calculate the sum ; Given number N ; Given base B ; Given digit K ; Function call"
Python;"def checkRightAngled ( X1 , Y1 , X2 , Y2 , X3 , Y3 ) : NEW_LINE INDENT A = ( int ( pow ( ( X2 - X1 ) , 2 ) ) + int ( pow ( ( Y2 - Y1 ) , 2 ) ) ) NEW_LINE B = ( int ( pow ( ( X3 - X2 ) , 2 ) ) + int ( pow ( ( Y3 - Y2 ) , 2 ) ) ) NEW_LINE C = ( int ( pow ( ( X3 - X1 ) , 2 ) ) + int ( pow ( ( Y3 - Y1 ) , 2 ) ) ) NEW_LINE if ( ( A > 0 and B > 0 and C > 0 ) and ( A == ( B + C ) or B == ( A + C ) or C == ( A + B ) ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT X1 = 0 ; X2 = 0 ; X3 = 9 ; NEW_LINE Y1 = 2 ; Y2 = 14 ; Y3 = 2 ; NEW_LINE checkRightAngled ( X1 , Y1 , X2 , Y2 , X3 , Y3 ) NEW_LINE DEDENT";"Check if a right | Function to check if right - angled triangle can be formed by the given coordinates ; Calculate the sides ; Check Pythagoras Formula ; Driver code"
Python;def createPrefixArray ( n , arr , prefSize , pref ) : NEW_LINE INDENT for i in range ( prefSize ) : NEW_LINE INDENT pref [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT x = arr [ i ] + 1000000 NEW_LINE pref [ x ] += 1 NEW_LINE DEDENT for i in range ( 1 , prefSize ) : NEW_LINE INDENT pref [ i ] += pref [ i - 1 ] NEW_LINE DEDENT DEDENT def pointOfIntersection ( m , segments , size , pref ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( m ) : NEW_LINE INDENT x1 = segments [ i ] [ 0 ] NEW_LINE x2 = segments [ i ] [ 2 ] NEW_LINE x1 = x1 + 1000000 NEW_LINE x2 = x2 + 1000000 NEW_LINE if ( x1 != x2 ) : NEW_LINE INDENT if ( x1 > x2 ) : NEW_LINE INDENT x1 , x2 = x2 , x1 NEW_LINE DEDENT Occ_Till_Right = pref [ x2 - 1 ] NEW_LINE Occ_Till_Left = pref [ x1 ] NEW_LINE ans += ( Occ_Till_Right - Occ_Till_Left ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT N = 4 NEW_LINE M = 8 NEW_LINE size = 2000000 + 2 NEW_LINE pref = [ 0 ] * size NEW_LINE lines = [ - 5 , - 3 , 2 , 3 ] NEW_LINE segments = [ [ - 2 , 5 , 5 , - 6 ] , [ - 5 , - 2 , - 3 , - 5 ] , [ - 2 , 3 , - 6 , 1 ] , [ - 1 , - 3 , 4 , 2 ] , [ 2 , 5 , 2 , 1 ] , [ 4 , 5 , 4 , - 5 ] , [ - 2 , - 4 , 5 , 3 ] , [ 1 , 2 , - 2 , 1 ] ] NEW_LINE createPrefixArray ( N , lines , size , pref ) NEW_LINE print ( pointOfIntersection ( M , segments , size , pref ) ) NEW_LINE;"Count of intersections of M line segments with N vertical lines in XY plane | Function to create prefix sum array ; Initialize the prefix array to remove garbage values ; Marking the occurances of vertical lines ; Creating the prefix array ; Function that returns the count of total intersection ; ans is the number of points of intersection of the line segments with the vertical lines ; Index mapping ; we don 't consider a vertical   line segment because even if  it falls on a vertical line  then it just touches it and  not intersects. ; We have assumed that x1 will be left and x2 right but if not then just swap ; Number of vertical lines ; Number of line segments ; Format : x1 , y1 , x2 , y2 ; First create the prefix array ; Print the total number of intersections"
Python;def count_rectangles ( N , M ) : NEW_LINE INDENT p_x = ( N * ( N - 1 ) ) // 2 NEW_LINE p_y = ( M * ( M - 1 ) ) // 2 NEW_LINE return p_x * p_y NEW_LINE DEDENT N = 3 NEW_LINE M = 6 NEW_LINE print ( count_rectangles ( N , M ) ) NEW_LINE;"Count of rectangles possible from N and M straight lines parallel to X and Y axis respectively | Function to calculate number of rectangles ; Total number of ways to select two lines parallel to X axis ; Total number of ways to select two lines parallel to Y axis ; Total number of rectangles ; Driver code"
Python;"import math NEW_LINE def calculateAngle ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) : NEW_LINE INDENT ABx = x1 - x2 ; NEW_LINE ABy = y1 - y2 ; NEW_LINE ABz = z1 - z2 ; NEW_LINE BCx = x3 - x2 ; NEW_LINE BCy = y3 - y2 ; NEW_LINE BCz = z3 - z2 ; NEW_LINE dotProduct = ( ABx * BCx + ABy * BCy + ABz * BCz ) ; NEW_LINE magnitudeAB = ( ABx * ABx + ABy * ABy + ABz * ABz ) ; NEW_LINE magnitudeBC = ( BCx * BCx + BCy * BCy + BCz * BCz ) ; NEW_LINE angle = dotProduct ; NEW_LINE angle /= math . sqrt ( magnitudeAB * magnitudeBC ) ; NEW_LINE angle = ( angle * 180 ) / 3.14 ; NEW_LINE print ( round ( abs ( angle ) , 4 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x1 , y1 , z1 = 1 , 3 , 3 ; NEW_LINE x2 , y2 , z2 = 3 , 4 , 5 ; NEW_LINE x3 , y3 , z3 = 5 , 6 , 9 ; NEW_LINE calculateAngle ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ; NEW_LINE DEDENT";"Angle between a Pair of Lines in 3D | Python3 program for the above approach ; Function to find the angle between the two lines ; Find direction ratio of line AB ; Find direction ratio of line BC ; Find the dotProduct of lines AB & BC ; Find magnitude of line AB and BC ; Find the cosine of the angle formed by line AB and BC ; Find angle in radian ; Print angle ; Driver Code ; Given coordinates Points A ; Points B ; Points C ; Function Call"
Python;"import math NEW_LINE def calcAngle ( h , m ) : NEW_LINE INDENT if ( h < 0 or m < 0 or h > 12 or m > 60 ) : NEW_LINE INDENT print ( "" Wrong ▁ input "" ) NEW_LINE DEDENT if ( h == 12 ) : NEW_LINE INDENT h = 0 NEW_LINE DEDENT if ( m == 60 ) : NEW_LINE INDENT m = 0 NEW_LINE DEDENT hour_angle = 0.5 * ( h * 60 + m ) NEW_LINE minute_angle = 6 * m NEW_LINE angle = abs ( hour_angle - minute_angle ) NEW_LINE angle = min ( 360 - angle , angle ) NEW_LINE return angle NEW_LINE DEDENT def cal_cos ( n ) : NEW_LINE INDENT accuracy = 0.0001 NEW_LINE n = n * ( 3.142 / 180.0 ) NEW_LINE x1 = 1 NEW_LINE cosx = x1 NEW_LINE cosval = math . cos ( n ) NEW_LINE i = 1 NEW_LINE while True : NEW_LINE INDENT denominator = 2 * i * ( 2 * i - 1 ) NEW_LINE x1 = - x1 * n * n / denominator NEW_LINE cosx = cosx + x1 NEW_LINE i = i + 1 NEW_LINE if accuracy > math . fabs ( cosval - cosx ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return cosx NEW_LINE DEDENT def distanceEndpoints ( a , b , c ) : NEW_LINE INDENT angle = cal_cos ( c ) NEW_LINE return math . sqrt ( ( a * a ) + ( b * b ) - 2 * a * b * angle ) NEW_LINE DEDENT hour = 3 NEW_LINE Min = 30 NEW_LINE hourHand = 3 NEW_LINE minHand = 4 NEW_LINE angle = calcAngle ( hour , Min ) NEW_LINE distance = distanceEndpoints ( minHand , hourHand , angle ) NEW_LINE print ( ' % .5f ' % distance ) NEW_LINE";"Distance between end points of Hour and minute hand at given time | Python3 implementation to find the distance between the end points of the hour and minute hand ; Function to find the angle between Hour hand and minute hand ; Validate the input ; Calculate the angles moved by hour and minute hands with reference to 12 : 00 ; Find the difference between two angles ; Return the smaller angle of two possible angles ; Function to calculate cos value of angle c ; Converting degrees to radian ; Maps the sum along the series ; Holds the actual value of sin ( n ) ; Function to distance between the endpoints of the hour and minute hand ; Time ; Length of hour hand ; Length of minute hand ; calling Function for finding angle between hour hand and minute hand ; Function for finding distance between end points of minute hand and hour hand"
Python;def Pentadecagonal_num ( n ) : NEW_LINE INDENT return ( 13 * n * n - 11 * n ) / 2 NEW_LINE DEDENT n = 3 NEW_LINE print ( int ( Pentadecagonal_num ( n ) ) ) NEW_LINE n = 10 NEW_LINE print ( int ( Pentadecagonal_num ( n ) ) ) NEW_LINE;"Pentadecagonal Number | Function to find N - th pentadecagonal number ; Formula to calculate nth pentadecagonal number ; Driver code"
Python;def Octadecagonal_num ( n ) : NEW_LINE INDENT return ( 16 * n * n - 14 * n ) / 2 NEW_LINE DEDENT n = 3 NEW_LINE print ( int ( Octadecagonal_num ( n ) ) ) NEW_LINE n = 10 NEW_LINE print ( int ( Octadecagonal_num ( n ) ) ) NEW_LINE;"Octadecagonal Number | Function to find N - th octadecagonal number ; Formula to calculate nth octadecagonal number ; Driver code"
Python;"def IcositrigonalNum ( n ) : NEW_LINE INDENT return ( 21 * n * n - 19 * n ) / 2 ; NEW_LINE DEDENT n = 3 NEW_LINE print ( IcositrigonalNum ( n ) ) NEW_LINE n = 10 NEW_LINE print ( IcositrigonalNum ( n ) ) NEW_LINE";"Icositrigonal Number | Function to find N - th Icositrigonal number ; Formula to calculate nth Icositrigonal number ; Driver code"
Python;"def calculate_change ( length , breadth ) : NEW_LINE INDENT change = 0 NEW_LINE change = length + breadth + ( ( length * breadth ) // 100 ) NEW_LINE return change NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT cL = 20 NEW_LINE cB = - 10 NEW_LINE cA = calculate_change ( cL , cB ) NEW_LINE print ( cA ) NEW_LINE DEDENT";"Find the percentage change in the area of a Rectangle | Function to calculate percentage change in area of rectangle ; Driver code"
Python;def solve ( n , m , obstacles , rangee ) : NEW_LINE INDENT val = min ( n , m ) NEW_LINE rangee = sorted ( rangee ) NEW_LINE c = 1 NEW_LINE for i in range ( obstacles - 1 , - 1 , - 1 ) : NEW_LINE INDENT rangee [ i ] = 2 * rangee [ i ] NEW_LINE val -= rangee [ i ] NEW_LINE if ( val <= 0 ) : NEW_LINE INDENT return c NEW_LINE DEDENT else : NEW_LINE INDENT c += 1 NEW_LINE DEDENT DEDENT if ( val > 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT n = 4 NEW_LINE m = 5 NEW_LINE obstacles = 3 NEW_LINE rangee = [ 1.0 , 1.25 , 1.15 ] NEW_LINE print ( solve ( n , m , obstacles , rangee ) ) NEW_LINE;"Minimum number of Circular obstacles required to obstruct the path in a Grid | Function to find the minimum number of obstacles required ; Find the minimum rangee required to put obstacles ; Sorting the radius ; If val is less than zero then we have find the number of obstacles required ; Driver code"
Python;def area ( d1 , a ) : NEW_LINE INDENT d2 = ( 4 * ( a ** 2 ) - d1 ** 2 ) ** 0.5 NEW_LINE area = 0.5 * d1 * d2 NEW_LINE return ( area ) NEW_LINE DEDENT d = 7.07 NEW_LINE a = 5 NEW_LINE print ( area ( d , a ) ) NEW_LINE;"Program to calculate area of a rhombus whose one side and diagonal are given | function to calculate the area of the rhombus ; Second diagonal ; area of rhombus ; return the area ; driver code"
Python;"def pointsAreOnSameSideOfLine ( a , b , c , x1 , y1 , x2 , y2 ) : NEW_LINE INDENT fx1 = a * x1 + b * y1 - c NEW_LINE fx2 = a * x2 + b * y2 - c NEW_LINE if ( ( fx1 * fx2 ) > 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT a , b , c = 1 , 1 , 1 NEW_LINE x1 , y1 = 1 , 1 NEW_LINE x2 , y2 = 2 , 1 NEW_LINE if ( pointsAreOnSameSideOfLine ( a , b , c , x1 , y1 , x2 , y2 ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Check whether two points ( x1 , y1 ) and ( x2 , y2 ) lie on same side of a given line or not | Function to check if two points lie on the same side or not ; fx1 = 0 Variable to store a * x1 + b * y1 - c fx2 = 0 Variable to store a * x2 + b * y2 - c ; If fx1 and fx2 have same sign ; Driver code"
Python;"def newvol ( x ) : NEW_LINE INDENT print ( "" percentage ▁ increase "" "" in ▁ the ▁ volume ▁ of ▁ the ▁ cube ▁ is ▁ "" , ( ( x ** ( 3 ) ) / 10000 + 3 * x + ( 3 * ( x ** ( 2 ) ) ) / 100 ) , "" % "" ) ; NEW_LINE DEDENT x = 10 ; NEW_LINE newvol ( x ) ; NEW_LINE";"Percentage increase in volume of the cube if a side of cube is increased by a given percentage | Python program to find percentage increase in the volume of the cube if a side of cube is increased by a given percentage ; Driver code"
Python;"def findTriangles ( n ) : NEW_LINE INDENT num = n NEW_LINE print ( num , end = "" ▁ "" ) NEW_LINE print ( num * ( num - 4 ) * ( num - 5 ) // 6 ) NEW_LINE DEDENT n = 6 ; NEW_LINE findTriangles ( n ) NEW_LINE";"Number of triangles formed by joining vertices of n | Function to find the number of triangles ; print the number of triangles having two side common ; print the number of triangles having no side common ; initialize the number of sides of a polygon"
Python;"def radius ( n , d ) : NEW_LINE INDENT print ( "" The ▁ radius ▁ of ▁ each ▁ circle ▁ is ▁ "" , d / ( 2 * n - 2 ) ) ; NEW_LINE DEDENT d = 42 ; n = 4 ; NEW_LINE radius ( n , d ) ; NEW_LINE";"Find the radii of the circles which are lined in a row , and distance between the centers of first and last circle is given | Python program to find radii of the circles which are lined in a row and distance between the centers of first and last circle is given ; Driver code"
Python;"def radius ( n , d ) : NEW_LINE INDENT print ( "" The ▁ side ▁ of ▁ each ▁ square ▁ is ▁ "" , d / ( n - 1 ) ) ; NEW_LINE DEDENT d = 42 ; n = 4 ; NEW_LINE radius ( n , d ) ; NEW_LINE";"Find the side of the squares which are lined in a row , and distance between the centers of first and last square is given | Python program to find side of the squares which are lined in a row and distance between the centers of first and last squares is given ; Driver code"
Python;def findTriangles ( n ) : NEW_LINE INDENT num = n * ( n - 4 ) NEW_LINE print ( num ) NEW_LINE DEDENT / * Driver code * / NEW_LINE n = 6 NEW_LINE findTriangles ( n ) NEW_LINE;"Number of triangles formed by joining vertices of n | Function to find the number of triangles ; print the number of triangles ;  ; Driver code initialize the number of sides of a polygon"
Python;"def diameter ( r ) : NEW_LINE INDENT print ( "" The ▁ length ▁ of ▁ the ▁ longest ▁ chord "" , "" ▁ or ▁ diameter ▁ of ▁ the ▁ circle ▁ is ▁ "" , 2 * r ) NEW_LINE DEDENT r = 4 NEW_LINE diameter ( r ) NEW_LINE";"Find the Diameter or Longest chord of a Circle | Function to find the longest chord ; Get the radius ; Find the diameter"
Python;"def getSlope ( m ) : NEW_LINE INDENT return m ; NEW_LINE DEDENT m = 2 ; NEW_LINE print ( getSlope ( m ) ) ; NEW_LINE";"Slope of the line parallel to the line with the given slope | Function to return the slope of the line which is parallel to the line with the given slope ; Driver code"
Python;def totalTriangles ( h , v ) : NEW_LINE INDENT if ( h == 0 and v == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( h == 0 ) : NEW_LINE INDENT return ( ( v + 1 ) * ( v + 2 ) / 2 ) NEW_LINE DEDENT if ( v == 0 ) : NEW_LINE INDENT return ( h + 1 ) NEW_LINE DEDENT total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) NEW_LINE return total NEW_LINE DEDENT h = 2 NEW_LINE v = 2 NEW_LINE print ( int ( totalTriangles ( h , v ) ) ) NEW_LINE;"Total number of triangles formed when there are H horizontal and V vertical lines | Function to return total triangles ; Only possible triangle is the given triangle ; If only vertical lines are present ; If only horizontal lines are present ; Return total triangles ; Driver code"
Python;import math as mt NEW_LINE def sph ( r , R , h ) : NEW_LINE INDENT if ( r < 0 and R < 0 and h < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = r NEW_LINE V = ( 4 * 3.14 * pow ( r , 3 ) ) / 3 NEW_LINE return V NEW_LINE DEDENT r , R , h = 5 , 8 , 11 NEW_LINE print ( sph ( r , R , h ) ) NEW_LINE;"Largest sphere that can be inscribed in a right circular cylinder inscribed in a frustum | Python3 Program to find the biggest sphere that can be inscribed within a right circular cylinder which in turn is inscribed within a frustum ; Function to find the biggest sphere ; the radii and height cannot be negative ; radius of the sphere ; volume of the sphere ; Driver code"
Python;"def checkOrtho ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : NEW_LINE INDENT if ( x2 - x1 == 0 and x4 - x3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( x2 - x1 == 0 ) : NEW_LINE INDENT m2 = ( y4 - y3 ) / ( x4 - x3 ) NEW_LINE if ( m2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT elif ( x4 - x3 == 0 ) : NEW_LINE INDENT m1 = ( y2 - y1 ) / ( x2 - x1 ) ; NEW_LINE if ( m1 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT m1 = ( y2 - y1 ) / ( x2 - x1 ) NEW_LINE m2 = ( y4 - y3 ) / ( x4 - x3 ) NEW_LINE if ( m1 * m2 == - 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x1 = 0 NEW_LINE y1 = 4 NEW_LINE x2 = 0 NEW_LINE y2 = - 9 NEW_LINE x3 = 2 NEW_LINE y3 = 0 NEW_LINE x4 = - 1 NEW_LINE y4 = 0 NEW_LINE if ( checkOrtho ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT";"Check whether two straight lines are orthogonal or not | Function to check if two straight lines are orthogonal or not ; Both lines have infinite slope ; Only line 1 has infinite slope ; Only line 2 has infinite slope ; Find slopes of the lines ; Check if their product is - 1 ; Driver code"
Python;"def pentdiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = 1.22 * a NEW_LINE return d NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = 6 NEW_LINE print ( pentdiagonal ( a ) ) NEW_LINE DEDENT";"Diagonal of a Regular Pentagon | Function to find the diagonal of a regular pentagon ; Side cannot be negative ; Length of the diagonal ; Driver code"
Python;"from math import sqrt NEW_LINE def hexagonArea ( d ) : NEW_LINE INDENT return ( 3 * sqrt ( 3 ) * pow ( d , 2 ) ) / 8 NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT d = 10 NEW_LINE print ( "" Area ▁ of ▁ hexagon : "" , round ( hexagonArea ( d ) , 3 ) ) NEW_LINE DEDENT";"Area of hexagon with given diagonal length | Python3 program to find the area of Hexagon with given diagonal ; Function to calculate area ; Formula to find area ; Driver ode"
Python;"def Squares ( n , m , a ) : NEW_LINE INDENT return ( ( ( m + a - 1 ) // a ) * ( ( n + a - 1 ) // a ) ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 6 NEW_LINE m = 6 NEW_LINE a = 4 NEW_LINE print ( Squares ( n , m , a ) ) NEW_LINE DEDENT";"Number of squares of side length required to cover an N * M rectangle | function to find number of squares of a * a required to cover n * m rectangle ; Driver code ; function call"
Python;"import math NEW_LINE def octadiagonal ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return a * math . sqrt ( 4 + ( 2 * math . sqrt ( 2 ) ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 4 NEW_LINE print ( octadiagonal ( a ) ) NEW_LINE DEDENT";"Length of the Diagonal of the Octagon | Python3 Program to find the diagonal of the octagon ; Function to find the diagonal of the octagon ; side cannot be negative ; diagonal of the octagon ; Driver code"
Python;"def CalPeri ( ) : NEW_LINE INDENT s = 5 NEW_LINE Perimeter = 10 * s NEW_LINE print ( "" The ▁ Perimeter ▁ of ▁ Decagon ▁ is ▁ : ▁ "" , Perimeter ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT CalPeri ( ) ; NEW_LINE DEDENT";"Program to Calculate the Perimeter of a Decagon | Function for finding the perimeter ; Driver code"
Python;import math NEW_LINE def findEdges ( s1 , s2 , s3 ) : NEW_LINE INDENT a = math . sqrt ( s1 * s2 / s3 ) NEW_LINE b = math . sqrt ( s3 * s1 / s2 ) NEW_LINE c = math . sqrt ( s3 * s2 / s1 ) NEW_LINE sum = a + b + c NEW_LINE return 4 * sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = 65 NEW_LINE s2 = 156 NEW_LINE s3 = 60 NEW_LINE print ( int ( findEdges ( s1 , s2 , s3 ) ) ) NEW_LINE DEDENT;"Sum of lengths of all 12 edges of any rectangular parallelepiped | Python3 program to illustrate the above problem ; function to find the sum of all the edges of parallelepiped ; to calculate the length of one edge ; sum of all the edges of one side ; net sum will be equal to the summation of edges of all the sides ; Driver code ; initialize the area of three faces which has a common vertex"
Python;"def findMaximumPieces ( n ) : NEW_LINE INDENT x = n // 2 NEW_LINE return ( ( x + 1 ) * ( n - x + 1 ) ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 3 NEW_LINE print ( "" Max ▁ number ▁ of ▁ pieces ▁ for ▁ n ▁ = ▁ "" + str ( n ) + "" ▁ is ▁ "" + str ( findMaximumPieces ( 3 ) ) ) NEW_LINE DEDENT";"Maximum number of pieces in N cuts | Function for finding maximum pieces with n cuts . ; to maximize number of pieces x is the horizontal cuts ; Now ( x ) is the horizontal cuts and ( n - x ) is vertical cuts , then maximum number of pieces = ( x + 1 ) * ( n - x + 1 ) ; Driver code ; Taking the maximum number of cuts allowed as 3 ; Finding and printing the max number of pieces"
Python;"def equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x , y , z ) : NEW_LINE INDENT a1 = x2 - x1 NEW_LINE b1 = y2 - y1 NEW_LINE c1 = z2 - z1 NEW_LINE a2 = x3 - x1 NEW_LINE b2 = y3 - y1 NEW_LINE c2 = z3 - z1 NEW_LINE a = b1 * c2 - b2 * c1 NEW_LINE b = a2 * c1 - a1 * c2 NEW_LINE c = a1 * b2 - b1 * a2 NEW_LINE d = ( - a * x1 - b * y1 - c * z1 ) NEW_LINE if ( a * x + b * y + c * z + d == 0 ) : NEW_LINE INDENT print ( "" Coplanar "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Not ▁ Coplanar "" ) NEW_LINE DEDENT DEDENT x1 = 3 NEW_LINE y1 = 2 NEW_LINE z1 = - 5 NEW_LINE x2 = - 1 NEW_LINE y2 = 4 NEW_LINE z2 = - 3 NEW_LINE x3 = - 3 NEW_LINE y3 = 8 NEW_LINE z3 = - 5 NEW_LINE x4 = - 3 NEW_LINE y4 = 2 NEW_LINE z4 = 1 NEW_LINE / * function calling * / NEW_LINE equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x4 , y4 , z4 ) NEW_LINE";"Program to check whether 4 points in a 3 | Function to find equation of plane . ; checking if the 4 th point satisfies the above equation ; Driver Code ;"
Python;"import math NEW_LINE def distance ( a1 , b1 , c1 , a2 , b2 , c2 ) : NEW_LINE INDENT d = ( a1 * a2 + b1 * b2 + c1 * c2 ) NEW_LINE e1 = math . sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) NEW_LINE e2 = math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) NEW_LINE d = d / ( e1 * e2 ) NEW_LINE A = math . degrees ( math . acos ( d ) ) NEW_LINE print ( "" Angle ▁ is "" ) , A , ( "" degree "" ) NEW_LINE DEDENT a1 = 1 NEW_LINE b1 = 1 NEW_LINE c1 = 2 NEW_LINE d1 = 1 NEW_LINE a2 = 2 NEW_LINE b2 = - 1 NEW_LINE c2 = 1 NEW_LINE d2 = - 4 NEW_LINE distance ( a1 , b1 , c1 , a2 , b2 , c2 ) NEW_LINE";"Angle between two Planes in 3D | Python program to find the Angle between two Planes in 3 D . ; Function to find Angle ; Driver Code"
Python;"def mirror_point ( a , b , c , d , x1 , y1 , z1 ) : NEW_LINE INDENT k = ( - a * x1 - b * y1 - c * z1 - d ) / float ( ( a * a + b * b + c * c ) ) NEW_LINE x2 = a * k + x1 NEW_LINE y2 = b * k + y1 NEW_LINE z2 = c * k + z1 NEW_LINE x3 = 2 * x2 - x1 NEW_LINE y3 = 2 * y2 - y1 NEW_LINE z3 = 2 * z2 - z1 NEW_LINE print "" x3 ▁ = "" , x3 , NEW_LINE print "" y3 ▁ = "" , y3 , NEW_LINE print "" z3 ▁ = "" , z3 , NEW_LINE DEDENT a = 1 NEW_LINE b = - 2 NEW_LINE c = 0 NEW_LINE d = 0 NEW_LINE x1 = - 1 NEW_LINE y1 = 3 NEW_LINE z1 = 4 NEW_LINE mirror_point ( a , b , c , d , x1 , y1 , z1 ) NEW_LINE";"Mirror of a point through a 3 D plane | Function to mirror image ; Driver Code ; function call"
Python;"def countRectangles ( radius ) : NEW_LINE INDENT rectangles = 0 NEW_LINE diameter = 2 * radius NEW_LINE diameterSquare = diameter * diameter NEW_LINE for a in range ( 1 , 2 * radius ) : NEW_LINE INDENT for b in range ( 1 , 2 * radius ) : NEW_LINE INDENT diagonalLengthSquare = ( a * a + b * b ) NEW_LINE if ( diagonalLengthSquare <= diameterSquare ) : NEW_LINE INDENT rectangles += 1 NEW_LINE DEDENT DEDENT DEDENT return rectangles NEW_LINE DEDENT radius = 2 NEW_LINE totalRectangles = countRectangles ( radius ) NEW_LINE print ( totalRectangles , "" rectangles ▁ can ▁ be "" , "" cut ▁ from ▁ a ▁ circle ▁ of ▁ Radius "" , radius ) NEW_LINE";"Number of rectangles in a circle of radius R | Function to return the total possible rectangles that can be cut from the circle ; Diameter = 2 * Radius ; Square of diameter which is the square of the maximum length diagonal ; generate all combinations of a and b in the range ( 1 , ( 2 * Radius - 1 ) ) ( Both inclusive ) ; Calculate the Diagonal length of this rectangle ; If this rectangle 's Diagonal  Length is less than the  Diameter, it is a valid  rectangle, thus increment counter ; Radius of the circle"
Python;"def simi_aaa ( a1 , a2 ) : NEW_LINE INDENT a1 = [ float ( i ) for i in a1 ] NEW_LINE a2 = [ float ( i ) for i in a2 ] NEW_LINE a1 . sort ( ) NEW_LINE a2 . sort ( ) NEW_LINE if a1 [ 0 ] == a2 [ 0 ] and a1 [ 1 ] == a2 [ 1 ] and a1 [ 2 ] == a2 [ 2 ] : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def simi_sas ( s1 , s2 , a1 , a2 ) : NEW_LINE INDENT s1 = [ float ( i ) for i in s1 ] NEW_LINE s2 = [ float ( i ) for i in s2 ] NEW_LINE a1 = [ float ( i ) for i in a1 ] NEW_LINE a2 = [ float ( i ) for i in a2 ] NEW_LINE s1 . sort ( ) NEW_LINE s2 . sort ( ) NEW_LINE a1 . sort ( ) NEW_LINE a2 . sort ( ) NEW_LINE if s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] : NEW_LINE INDENT if a1 [ 2 ] == a2 [ 2 ] : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] : NEW_LINE INDENT if a1 [ 0 ] == a2 [ 0 ] : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT if s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] : NEW_LINE INDENT if a1 [ 1 ] == a2 [ 1 ] : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT def simi_sss ( s1 , s2 ) : NEW_LINE INDENT s1 = [ float ( i ) for i in s1 ] NEW_LINE s2 = [ float ( i ) for i in s2 ] NEW_LINE s1 . sort ( ) NEW_LINE s2 . sort ( ) NEW_LINE if ( s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] and s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] and s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT s1 = [ 2 , 3 , 3 ] NEW_LINE s2 = [ 4 , 6 , 6 ] NEW_LINE a1 = [ 80 , 60 , 40 ] NEW_LINE a2 = [ 40 , 60 , 80 ] NEW_LINE aaa = simi_aaa ( a1 , a2 ) NEW_LINE sss = simi_sss ( s1 , s2 ) NEW_LINE sas = simi_sas ( s1 , s2 , a1 , a2 ) NEW_LINE if aaa or sss or sas : NEW_LINE INDENT print "" Triangles ▁ are ▁ similar ▁ by "" , NEW_LINE if aaa : print "" AAA "" , NEW_LINE if sss : print "" SSS "" , NEW_LINE if sas : print "" SAS "" NEW_LINE DEDENT else : print "" Triangles ▁ are ▁ not ▁ similar "" NEW_LINE";"Program to check similarity of given two triangles | Function for AAA similarity ; Check for AAA ; Function for SAS similarity ; angle b / w two smallest sides is largest . ; since we take angle b / w the sides . ; Function for SSS similarity ; Check for SSS ; Driver Code ; function call for AAA similarity ; function call for SSS similarity ; function call for SAS similarity ; Check if triangles are similar or not"
Python;"def center_pentadecagonal_num ( n ) : NEW_LINE INDENT return ( 15 * n * n - 15 * n + 2 ) // 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( n , "" rd ▁ number ▁ : ▁ "" , center_pentadecagonal_num ( n ) ) NEW_LINE n = 10 NEW_LINE print ( n , "" th ▁ number ▁ : ▁ "" , center_pentadecagonal_num ( n ) ) NEW_LINE DEDENT";"Centered Pentadecagonal Number | centered pentadecagonal function ; Formula to calculate nth centered pentadecagonal number ; Driver Code"
Python;"def center_nonadecagon_num ( n ) : NEW_LINE INDENT return ( 19 * n * n - 19 * n + 2 ) // 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 2 NEW_LINE print ( n , "" nd ▁ centered ▁ nonadecagonal ▁ "" + "" number ▁ : ▁ "" , center_nonadecagon_num ( n ) ) NEW_LINE n = 7 NEW_LINE print ( n , "" nd ▁ centered ▁ nonadecagonal ▁ "" + "" number ▁ : ▁ "" , center_nonadecagon_num ( n ) ) NEW_LINE DEDENT";"Centered nonadecagonal number | centered nonadecagonal function ; Formula to calculate nth centered nonadecagonal number & return it into main function . ; Driver Code"
Python;"def hendecagonal_num ( n ) : NEW_LINE INDENT return ( 9 * n * n - 7 * n ) // 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( n , "" rd ▁ Hendecagonal ▁ number ▁ : ▁ "" , hendecagonal_num ( n ) ) NEW_LINE n = 10 NEW_LINE print ( n , "" th ▁ Hendecagonal ▁ number ▁ : ▁ "" , hendecagonal_num ( n ) ) NEW_LINE DEDENT";"Hendecagonal number | Function of Hendecagonal number ; Formula to calculate nth Hendecagonal number & return it into main function . ; Driver Code"
Python;"def cen_octagonalnum ( n ) : NEW_LINE INDENT return ( 4 * n * n - 4 * n + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE print ( n , "" th ▁ Centered "" , "" octagonal ▁ number : ▁ "" , cen_octagonalnum ( n ) ) NEW_LINE n = 11 NEW_LINE print ( n , "" th ▁ Centered "" , "" octagonal ▁ number : ▁ "" , cen_octagonalnum ( n ) ) NEW_LINE DEDENT";"Centered Octagonal Number | Function to find centered octagonal number ; Formula to calculate nth centered octagonal number ; Driver Code"
Python;"def isValid ( arr , i , j , m , c ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT return False NEW_LINE DEDENT lhs = arr [ j ] ; NEW_LINE rhs = m * arr [ i ] + c NEW_LINE return ( lhs == rhs ) NEW_LINE DEDENT def findOrderedPoints ( arr , n , m , c ) : NEW_LINE INDENT counter = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , n ) : NEW_LINE INDENT firstIndex = i NEW_LINE secondIndex = j NEW_LINE if ( isValid ( arr , firstIndex , secondIndex , m , c ) ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE m = 1 NEW_LINE c = 1 NEW_LINE print ( findOrderedPoints ( arr , n , m , c ) ) NEW_LINE";"Number of ordered points pair satisfying line equation | Checks if ( i , j ) is valid , a point ( i , j ) is valid if point ( arr [ i ] , arr [ j ] ) satisfies the equation y = mx + c And i is not equal to j ; check if i equals to j ; Equation LHS = y , and RHS = mx + c ; Returns the number of ordered pairs ( i , j ) for which point ( arr [ i ] , arr [ j ] ) satisfies the equation of the line y = mx + c ; for every possible ( i , j ) check if ( a [ i ] , a [ j ] ) satisfies the equation y = mx + c ; ( firstIndex , secondIndex ) is same as ( i , j ) ; check if ( firstIndex , secondIndex ) is a valid point ; Driver Code ; equation of line is y = mx + c"
Python;"import math NEW_LINE def checkcircle ( r , R , r1 , x1 , y1 ) : NEW_LINE INDENT dis = int ( math . sqrt ( x1 * x1 + y1 * y1 ) ) NEW_LINE return ( dis - r1 >= R and dis + r1 <= r ) NEW_LINE DEDENT r = 8 ; R = 4 ; r1 = 2 ; x1 = 6 ; y1 = 0 NEW_LINE if ( checkcircle ( r , R , r1 , x1 , y1 ) ) : NEW_LINE INDENT print ( "" yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" no "" ) NEW_LINE DEDENT";"Check if a given circle lies completely inside the ring formed by two concentric circles | Python3 code to check if a circle lies in the ring ; Function to check if circle lies in the ring ; distance between center of circle center of concentric circles ( origin ) using Pythagoras theorem ; Condition to check if circle is strictly inside the ring ; Both circle with radius ' r ' and ' R ' have center ( 0 , 0 )"
Python;"import math NEW_LINE def surface_area_octahedron ( side ) : NEW_LINE INDENT return ( 2 * ( math . sqrt ( 3 ) ) * ( side * side ) ) NEW_LINE DEDENT side = 7 NEW_LINE print ( "" Surface ▁ area ▁ of ▁ octahedron ▁ = "" , surface_area_octahedron ( side ) ) NEW_LINE";"Program for Surface Area of Octahedron | Python Program to calculate surface area of Octahedron . ; utility Function ; driver code"
Python;"def nCk ( n , k ) : NEW_LINE INDENT C = [ 0 ] * ( k + 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT j = min ( i , k ) NEW_LINE while ( j > 0 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE j = j - 1 NEW_LINE DEDENT DEDENT return C [ k ] NEW_LINE DEDENT def count_Straightlines ( n , m ) : NEW_LINE INDENT return ( nCk ( n , 2 ) - nCk ( m , 2 ) + 1 ) NEW_LINE DEDENT n = 4 NEW_LINE m = 3 NEW_LINE print ( count_Straightlines ( n , m ) ) ; NEW_LINE";"Count of different straight lines with total n points with m collinear | Returns value of binomial coefficient Code taken from https : goo . gl / vhy4jp ; C [ 0 ] = 1 nC0 is 1 ; Compute next row of pascal triangle using the previous row ; function to calculate number of straight lines can be formed ; Driven code"
Python;"import math NEW_LINE def vol_of_dodecahedron ( side ) : NEW_LINE INDENT return ( ( ( 15 + ( 7 * ( math . sqrt ( 5 ) ) ) ) / 4 ) * ( math . pow ( side , 3 ) ) ) NEW_LINE DEDENT side = 4 NEW_LINE print ( "" Volume ▁ of ▁ dodecahedron ▁ = "" , round ( vol_of_dodecahedron ( side ) , 2 ) ) NEW_LINE";"Calculate Volume of Dodecahedron | Python3 program to calculate Volume of dodecahedron ; utility Function ; Driver Function"
Python;"def overflow ( H , r , h , N , R ) : NEW_LINE INDENT tank_cap = 3.14 * r * r * H NEW_LINE water_vol = 3.14 * r * r * h NEW_LINE balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R NEW_LINE vol = water_vol + balls_vol NEW_LINE if vol > tank_cap : NEW_LINE INDENT print ( "" Overflow "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Not ▁ in ▁ overflow ▁ state "" ) NEW_LINE DEDENT DEDENT H = 10 NEW_LINE r = 5 NEW_LINE h = 5 NEW_LINE N = 2 NEW_LINE R = 2 NEW_LINE overflow ( H , r , h , N , R ) NEW_LINE";"Program to check if water tank overflows when n solid balls are dipped in the water tank | function to find if tak will overflow or not ; cylinder capacity ; volume of water in tank ; volume of n balls ; total volume of water and n dipped balls ; condition to check if tank is in overflow state or not ; giving dimensions ; calling function"
Python;"def volume ( radius , height ) : NEW_LINE INDENT return ( ( 22 / 7 ) * radius * radius * height ) NEW_LINE DEDENT def check_and_print ( required_time , given_time ) : NEW_LINE INDENT if required_time < given_time : NEW_LINE INDENT print ( "" Overflow "" ) NEW_LINE DEDENT elif required_time > given_time : NEW_LINE INDENT print ( "" Underflow "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Filled "" ) NEW_LINE DEDENT DEDENT radius = 5 NEW_LINE height = 10 NEW_LINE rate_of_flow = 10 NEW_LINE given_time = 70.0 NEW_LINE required_time = volume ( radius , height ) / rate_of_flow NEW_LINE check_and_print ( required_time , given_time ) NEW_LINE";"Program to check if tank will overflow , underflow or filled in given time | function to calculate the volume of tank ; function to print overflow / filled / underflow accordingly ; radius of the tank ; height of the tank ; rate of flow of water ; time given ; calculate the required time ; printing the result"
Python;import math as mt NEW_LINE def cal_cos ( n ) : NEW_LINE INDENT accuracy = 0.0001 NEW_LINE x1 , denominator , cosx , cosval = 0 , 0 , 0 , 0 NEW_LINE n = n * ( 3.142 / 180.0 ) NEW_LINE x1 = 1 NEW_LINE cosx = x1 NEW_LINE cosval = mt . cos ( n ) NEW_LINE i = 1 NEW_LINE while ( accuracy <= abs ( cosval - cosx ) ) : NEW_LINE INDENT denominator = 2 * i * ( 2 * i - 1 ) NEW_LINE x1 = - x1 * n * n / denominator NEW_LINE cosx = cosx + x1 NEW_LINE i = i + 1 NEW_LINE DEDENT return cosx NEW_LINE DEDENT def third_side ( a , b , c ) : NEW_LINE INDENT angle = cal_cos ( c ) NEW_LINE return mt . sqrt ( ( a * a ) + ( b * b ) - 2 * a * b * angle ) NEW_LINE DEDENT c = 49 NEW_LINE a , b = 5 , 8 NEW_LINE print ( third_side ( a , b , c ) ) NEW_LINE;"Program to find third side of triangle using law of cosines | Python3 program to find third side of triangle using law of cosines ; Function to calculate cos value of angle c ; Converting degrees to radian ; Maps the sum along the series ; Holds the actual value of sin ( n ) ; Function to find third side ; Driver Code ; function call"
Python;"import math NEW_LINE def fitOrNotFit ( R , r , x , y , rad ) : NEW_LINE INDENT val = math . sqrt ( math . pow ( x , 2 ) + math . pow ( y , 2 ) ) NEW_LINE if ( val + rad <= R and val - rad >= R - r ) : NEW_LINE INDENT print ( "" Fits "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Doesn ' t ▁ Fit "" ) NEW_LINE DEDENT DEDENT R = 8 NEW_LINE r = 4 NEW_LINE x = 5 NEW_LINE y = 3 NEW_LINE rad = 3 NEW_LINE fitOrNotFit ( R , r , x , y , rad ) NEW_LINE";"Check whether given circle resides in boundary maintained by two other circles | Python3 program to check whether circle with given co - ordinates reside within the boundary of outer circle and inner circle ; function to check if given circle fit in boundary or not ; Distance from the center ; Checking the corners of circle ; Radius of outer circle and inner circle respectively ; Co - ordinates and radius of the circle to be checked"
Python;"def lineFromPoints ( P , Q ) : NEW_LINE INDENT a = Q [ 1 ] - P [ 1 ] NEW_LINE b = P [ 0 ] - Q [ 0 ] NEW_LINE c = a * ( P [ 0 ] ) + b * ( P [ 1 ] ) NEW_LINE if ( b < 0 ) : NEW_LINE INDENT print ( "" The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : "" , a , "" x ▁ - ▁ "" , b , "" y ▁ = ▁ "" , c ,   "" "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : ▁ "" , a , "" x ▁ + ▁ "" , b , "" y ▁ = ▁ "" , c ,   "" "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT P = [ 3 , 2 ] NEW_LINE Q = [ 2 , 6 ] NEW_LINE lineFromPoints ( P , Q ) NEW_LINE DEDENT";"Program to find line passing through 2 Points | Function to find the line given two points ; Driver code"
Python;"from math import sqrt NEW_LINE def checkPolygonWithMidpoints ( arr , N , midpoints ) : NEW_LINE INDENT for j in range ( midpoints ) : NEW_LINE INDENT val = 1 NEW_LINE for k in range ( j , N , midpoints ) : NEW_LINE INDENT val &= arr [ k ] NEW_LINE DEDENT if ( val and N // midpoints > 2 ) : NEW_LINE INDENT print ( "" Polygon ▁ possible ▁ with ▁ side ▁ length "" , ( N // midpoints ) ) NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def isPolygonPossible ( arr , N ) : NEW_LINE INDENT limit = sqrt ( N ) NEW_LINE for i in range ( 1 , int ( limit ) + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( checkPolygonWithMidpoints ( arr , N , i ) or checkPolygonWithMidpoints ( arr , N , ( N // i ) ) ) : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT DEDENT print ( "" Not ▁ possiblen "" ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE isPolygonPossible ( arr , N ) NEW_LINE DEDENT";"Regular polygon using only 1 s in a binary numbered circle | Python3 program to find whether a regular polygon is possible in circle with 1 s as vertices ; method returns true if polygon is possible with ' midpoints ' number of midpoints ; loop for getting first vertex of polygon ; loop over array values at ' midpoints ' distance ; and ( & ) all those values , if even one of them is 0 , val will be 0 ; if val is still 1 and ( N / midpoints ) or ( number of vertices ) are more than two ( for a polygon minimum ) print result and return true ; method prints sides in the polygon or print not possible in case of no possible polygon ; limit for iterating over divisors ; If i divides N then i and ( N / i ) will be divisors ; check polygon for both divisors ; Driver code"
Python;def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def getReducedForm ( dy , dx ) : NEW_LINE INDENT g = gcd ( abs ( dy ) , abs ( dx ) ) NEW_LINE sign = ( dy < 0 ) ^ ( dx < 0 ) NEW_LINE if ( sign ) : NEW_LINE INDENT return ( - abs ( dy ) // g , abs ( dx ) // g ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( abs ( dy ) // g , abs ( dx ) // g ) NEW_LINE DEDENT DEDENT def minLinesToCoverPoints ( points , N , xO , yO ) : NEW_LINE INDENT st = dict ( ) NEW_LINE minLines = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT curX = points [ i ] [ 0 ] NEW_LINE curY = points [ i ] [ 1 ] NEW_LINE temp = getReducedForm ( curY - yO , curX - xO ) NEW_LINE if ( temp not in st ) : NEW_LINE INDENT st [ temp ] = 1 NEW_LINE minLines += 1 NEW_LINE DEDENT DEDENT return minLines NEW_LINE DEDENT xO = 1 NEW_LINE yO = 0 NEW_LINE points = [ [ - 1 , 3 ] , [ 4 , 3 ] , [ 2 , 1 ] , [ - 1 , - 2 ] , [ 3 , - 3 ] ] NEW_LINE N = len ( points ) NEW_LINE print ( minLinesToCoverPoints ( points , N , xO , yO ) ) NEW_LINE;"Minimum lines to cover all points | Utility method to get gcd of a and b ; method returns reduced form of dy / dx as a pair ; get sign of result ; method returns minimum number of lines to cover all points where all lines goes through ( xO , yO ) ; set to store slope as a pair ; loop over all points once ; get x and y co - ordinate of current point ; if this slope is not there in set , increase ans by 1 and insert in set ; Driver code"
Python;def squareRoot ( n ) : NEW_LINE INDENT x = n NEW_LINE y = 1 NEW_LINE while ( x - y > e ) : NEW_LINE INDENT x = ( x + y ) / 2 NEW_LINE y = n / x NEW_LINE DEDENT return x NEW_LINE DEDENT def findMaximumHeight ( N ) : NEW_LINE INDENT n = 1 + 8 * N NEW_LINE maxH = ( - 1 + squareRoot ( n ) ) / 2 NEW_LINE return int ( maxH ) NEW_LINE DEDENT N = 12 NEW_LINE print ( findMaximumHeight ( N ) ) NEW_LINE;"Maximum height when coins are arranged in a triangle | Returns the square root of n . Note that the function ; We are using n itself as initial approximation This can definitely be improved ; e = 0.000001 e decides the accuracy level ; Method to find maximum height of arrangement of coins ; calculating portion inside the square root ; Driver code to test above method"
Python;"class Point : NEW_LINE INDENT def __init__ ( self , a , b ) : NEW_LINE INDENT self . x = a NEW_LINE self . y = b NEW_LINE DEDENT DEDENT def gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return a NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def getCount ( p , q ) : NEW_LINE INDENT if p . x == q . x : NEW_LINE INDENT return abs ( p . y - q . y ) - 1 NEW_LINE DEDENT if p . y == q . y : NEW_LINE INDENT return abs ( p . x - q . x ) - 1 NEW_LINE DEDENT return gcd ( abs ( p . x - q . x ) , abs ( p . y - q . y ) ) - 1 NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT p = Point ( 1 , 9 ) NEW_LINE q = Point ( 8 , 16 ) NEW_LINE print ( "" The ▁ number ▁ of ▁ integral ▁ points "" , "" between ▁ ( { } , ▁ { } ) ▁ and ▁ ( { } , ▁ { } ) ▁ is ▁ { } "" . format ( p . x , p . y , q . x , q . y , getCount ( p , q ) ) ) NEW_LINE DEDENT";"Number of Integral Points between Two Points | Class to represent an Integral point on XY plane . ; Utility function to find GCD of two numbers GCD of a and b ; Finds the no . of Integral points between two given points . ; If line joining p and q is parallel to x axis , then count is difference of y values ; If line joining p and q is parallel to y axis , then count is difference of x values ; Driver Code"
Python;"class Point : NEW_LINE INDENT def __init__ ( self , x , y ) : NEW_LINE INDENT self . x = x NEW_LINE self . y = y NEW_LINE DEDENT DEDENT ' NEW_LINE def distSq ( p , q ) : NEW_LINE INDENT return ( p . x - q . x ) * ( p . x - q . x ) + ( p . y - q . y ) * ( p . y - q . y ) NEW_LINE DEDENT def isSquare ( p1 , p2 , p3 , p4 ) : NEW_LINE INDENT if d2 == 0 or d3 == 0 or d4 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT if d2 == d3 and 2 * d2 == d4 and 2 * distSq ( p2 , p4 ) == distSq ( p2 , p3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if d3 == d4 and 2 * d3 == d2 and 2 * distSq ( p3 , p2 ) == distSq ( p3 , p4 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if d2 == d4 and 2 * d2 == d3 and 2 * distSq ( p2 , p3 ) == distSq ( p2 , p4 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT p1 = Point ( 20 , 10 ) NEW_LINE p2 = Point ( 10 , 20 ) NEW_LINE p3 = Point ( 20 , 20 ) NEW_LINE p4 = Point ( 10 , 10 ) NEW_LINE if isSquare ( p1 , p2 , p3 , p4 ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT DEDENT";"How to check if given four points form a square | A Python3 program to check if four given points form a square or not . ; Structure of a point in 2D space ; A utility function to find square of distance from point ' p ' to point 'q ; This function returns true if ( p1 , p2 , p3 , p4 ) form a square , otherwise false ; d2 = distSq ( p1 , p2 ) from p1 to p2 d3 = distSq ( p1 , p3 ) from p1 to p3 d4 = distSq ( p1 , p4 ) from p1 to p4 ; If lengths if ( p1 , p2 ) and ( p1 , p3 ) are same , then following conditions must be met to form a square . 1 ) Square of length of ( p1 , p4 ) is same as twice the square of ( p1 , p2 ) 2 ) Square of length of ( p2 , p3 ) is same as twice the square of ( p2 , p4 ) ; The below two cases are similar to above case ; Driver Code"
Python;"import math NEW_LINE def countDivisors ( n ) : NEW_LINE INDENT divisors = 0 NEW_LINE for i in range ( 1 , math . ceil ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT divisors = divisors + 1 NEW_LINE DEDENT if ( i - ( n / i ) == 1 ) : NEW_LINE INDENT i = i - 1 NEW_LINE DEDENT DEDENT for i in range ( math . ceil ( math . sqrt ( n ) ) + 1 , 1 , - 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT divisors = divisors + 1 NEW_LINE DEDENT DEDENT return divisors NEW_LINE DEDENT def possibleTriplets ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT count = count + countDivisors ( N - i ) NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 10 NEW_LINE print ( possibleTriplets ( N ) ) NEW_LINE DEDENT";"Count triplets such that product of two numbers added with third number is N | Python program for the above approach ; function to find the divisors of the number ( N - i ) ; Stores the resultant count of divisors of ( N - i ) ; Iterate over range [ 1 , sqrt ( N ) ] ; Return the total divisors ; def to find the number of triplets such that A * B - C = N ; Loop to fix the value of C ; Adding the number of divisors in count ; Return count of triplets ; Driver Code Driver Code"
Python;def maxPlanes ( A , B , N ) : NEW_LINE INDENT St = set ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT t = 1 if ( A [ i ] % B [ i ] > 0 ) else 0 NEW_LINE t += ( A [ i ] // B [ i ] ) + t NEW_LINE St . add ( t ) NEW_LINE DEDENT return len ( St ) NEW_LINE DEDENT A = [ 1 , 3 , 5 , 4 , 8 ] NEW_LINE B = [ 1 , 2 , 2 , 1 , 2 ] NEW_LINE N = len ( A ) NEW_LINE print ( maxPlanes ( A , B , N ) ) NEW_LINE;"Maximize count of planes that can be stopped per second with help of given initial position and speed | Function to find maximum number of planes that can be stopped from landing ; Stores the times needed for landing for each plane ; Iterate over the arrays ; Stores the time needed for landing of current plane ; Update the value of t ; Append the t in set St ; Return the answer ; Driver Code"
Python;"def predictTheWinner ( K , N ) : NEW_LINE INDENT if ( N % ( K + 1 ) == 0 ) : NEW_LINE INDENT print ( "" Bob "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Alice "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT K = 7 NEW_LINE N = 50 NEW_LINE predictTheWinner ( K , N ) NEW_LINE DEDENT";"Find the player who will win by choosing a number in range [ 1 , K ] with sum total N | Function to predict the winner ; Driver Code ; Given Input ; Function call"
Python;"def maxRightmostElement ( N , k , arr ) : NEW_LINE INDENT ans = arr [ N - 1 ] NEW_LINE i = N - 2 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT d = min ( arr [ i ] // 2 , k // ( N - 1 - i ) ) NEW_LINE k -= d * ( N - 1 - i ) NEW_LINE ans += d * 2 NEW_LINE i -= 1 NEW_LINE DEDENT print ( ans , end = "" ▁ "" ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 4 NEW_LINE k = 5 NEW_LINE arr = [ 3 , 8 , 1 , 4 ] NEW_LINE maxRightmostElement ( N , k , arr ) NEW_LINE DEDENT";"Maximize the rightmost element of an array in k operations in Linear Time | Function to calculate maximum value of Rightmost element ; Initializing ans to store Maximum valued rightmost element ; Calculating maximum value of Rightmost element ; Printing rightmost element ; Driver Code ; Given Input ; Function Call"
Python;"def smallestMaximum ( N , K ) : NEW_LINE INDENT sum = ( ( N + K - 1 ) // K ) * K NEW_LINE if ( sum % N != 0 ) : NEW_LINE INDENT return ( sum // N ) + 1 NEW_LINE DEDENT else : NEW_LINE INDENT return sum // N NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 4 NEW_LINE K = 3 NEW_LINE print ( smallestMaximum ( N , K ) ) NEW_LINE DEDENT";"Minimize the maximum element in constructed Array with sum divisible by K | Function to find smallest maximum number in an array whose sum is divisible by K . ; Minimum possible sum possible for an array of size N such that its sum is divisible by K ; If sum is not divisible by N ; If sum is divisible by N ; Driver code ."
Python;"def findIfPossible ( N , S , X ) : NEW_LINE INDENT if ( S >= X and S % 2 == X % 2 ) : NEW_LINE INDENT if ( N >= 3 ) : NEW_LINE INDENT return "" Yes "" NEW_LINE DEDENT if ( N == 1 ) : NEW_LINE INDENT if ( S == X ) : NEW_LINE INDENT return "" Yes "" NEW_LINE DEDENT else : NEW_LINE INDENT return "" No "" NEW_LINE DEDENT DEDENT if ( N == 2 ) : NEW_LINE INDENT C = ( S - X ) // 2 NEW_LINE A = C NEW_LINE B = C NEW_LINE A = A + X NEW_LINE if ( ( ( A ^ B ) == X ) ) : NEW_LINE INDENT return "" Yes "" NEW_LINE DEDENT else : NEW_LINE INDENT return "" No "" NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT return "" No "" NEW_LINE DEDENT DEDENT N = 3 NEW_LINE S = 10 NEW_LINE X = 4 NEW_LINE print ( findIfPossible ( N , S , X ) ) NEW_LINE";"Check if it is possible to construct an Array of size N having sum as S and XOR value as X | Function to find if any sequence is possible or not . ; Since , S is greater than equal to X , and either both are odd or even There always exists a sequence ; Only one case possible is S == X or NOT ; Considering the above conditions true , check if XOR of S ^ ( S - X ) is X or not ; Driver Code"
Python;"import sys NEW_LINE def isPossible ( arr , n ) : NEW_LINE INDENT mini = sys . maxsize NEW_LINE for i in range ( n ) : NEW_LINE INDENT mini = min ( mini , arr [ i ] ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] == mini ) : NEW_LINE INDENT continue NEW_LINE DEDENT Max = ( arr [ i ] + 1 ) // 2 - 1 NEW_LINE if ( mini < 0 or mini > Max ) : NEW_LINE INDENT return "" No "" NEW_LINE DEDENT DEDENT return "" Yes "" NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE print ( isPossible ( arr , N ) ) NEW_LINE DEDENT";"Check whether each Array element can be reduced to minimum element by replacing it with remainder with some X | Python 3 program for the above approach ; Function to check if every integer in the array can be reduced to the minimum array element ; Stores the minimum array element ; Find the minimum element ; Traverse the array arr [ ] ; Stores the maximum value in the range ; Check whether mini lies in the range or not ; Otherwise , return Yes ; Driver Code"
Python;def gcd1OfTwoNos ( num1 , num2 ) : NEW_LINE INDENT if ( num1 == 0 ) : NEW_LINE INDENT return num2 NEW_LINE DEDENT if ( num2 == 0 ) : NEW_LINE INDENT return num1 NEW_LINE DEDENT if ( num1 == num2 ) : NEW_LINE INDENT return num1 NEW_LINE DEDENT if ( num1 > num2 ) : NEW_LINE INDENT return gcd1OfTwoNos ( num1 - num2 , num2 ) NEW_LINE DEDENT return gcd1OfTwoNos ( num1 , num2 - num1 ) NEW_LINE DEDENT def Min_sum ( arr , N ) : NEW_LINE INDENT min_sum = 1000000 NEW_LINE maxgcd1 = 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT gcd1 = 1 NEW_LINE if ( i == 0 ) : NEW_LINE INDENT gcd1 = arr [ 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT gcd1 = arr [ i - 1 ] NEW_LINE DEDENT for j in range ( N ) : NEW_LINE INDENT if ( j != i ) : NEW_LINE INDENT gcd1 = gcd1OfTwoNos ( gcd1 , arr [ j ] ) NEW_LINE DEDENT DEDENT c = arr [ i ] NEW_LINE if ( gcd1 > maxgcd1 ) : NEW_LINE INDENT maxgcd1 = gcd1 NEW_LINE DEDENT DEDENT return maxgcd1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 16 , 5 , 10 , 25 ] NEW_LINE N = len ( arr ) NEW_LINE print ( Min_sum ( arr , N ) ) NEW_LINE DEDENT;"Maximum number which can divide all array element after one replacement | Function to return gcd1 of two numbers ; If one of numbers is 0 then gcd1 is other number ; If both are equal then that value is gcd1 ; One is greater ; Function to return minimum sum ; Initialize min_sum with large value ; Initialize variable gcd1 ; Storing value of arr [ i ] in c ; Update maxgcd1 if gcd1 is greater than maxgcd1 ; returning the maximum divisor of all elements ; Driver code"
Python;"from array import * NEW_LINE from math import * NEW_LINE def countOddIntegers ( arr , N ) : NEW_LINE INDENT Fact = [ 0 ] * N NEW_LINE Fact [ 0 ] = 1 NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT Fact [ i ] = i * Fact [ i - 1 ] NEW_LINE DEDENT freq = [ 0 ] * 10 NEW_LINE for i in range ( len ( freq ) ) : NEW_LINE INDENT freq [ i ] = 0 ; NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT freq [ arr [ i ] ] = freq [ arr [ i ] ] + 1 ; NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , 10 , 2 ) : NEW_LINE INDENT if ( freq [ i ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT freq [ i ] = freq [ i ] - 1 ; NEW_LINE for j in range ( 1 , 10 , 1 ) : NEW_LINE INDENT cur_ans = 0 NEW_LINE if ( freq [ j ] == 0 ) : NEW_LINE INDENT continue NEW_LINE DEDENT freq [ j ] = freq [ j ] - 1 ; NEW_LINE cur_ans = Fact [ N - 2 ] NEW_LINE for k in range ( 10 ) : NEW_LINE INDENT cur_ans = cur_ans / Fact [ freq [ k ] ] NEW_LINE DEDENT ans += cur_ans NEW_LINE freq [ j ] = freq [ j ] + 1 ; NEW_LINE DEDENT freq [ i ] = freq [ i ] + 1 ; NEW_LINE DEDENT return ceil ( ans ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A = [ 2 , 3 , 4 , 1 , 2 , 3 ] NEW_LINE N = len ( A ) NEW_LINE print ( countOddIntegers ( A , N ) ) NEW_LINE DEDENT";"Count of distinct N | Python Program for the above approach ; Function to find the count of distinct odd integers with N digits using the given digits in the array arr [ ] ; Stores the factorial of a number Calculate the factorial of all numbers from 1 to N ; Stores the frequency of each digit ; Stores the final answer ; Loop to iterate over all values of Nth digit i and 1 st digit j ; If digit i does not exist in the given array move to next i ; Fixing i as Nth digit ; Stores the answer of a specific value of i and j ; If digit j does not exist move to the next j ; Fixing j as 1 st digit ; Calculate number of ways to arrange remaining N - 2 digits ; Including j back into the set of digits ; Including i back into the set of the digits ; Return Answer ; Driver Code ; Function Call"
Python;def sumOfDigits ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( N ) : NEW_LINE INDENT sum += ( N % 10 ) NEW_LINE N = N // 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def CountPair ( arr , n ) : NEW_LINE INDENT mp = { } NEW_LINE for i in range ( n ) : NEW_LINE INDENT val = arr [ i ] + sumOfDigits ( arr [ i ] ) NEW_LINE if val in mp : NEW_LINE INDENT mp [ val ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ val ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT val = key NEW_LINE times = value NEW_LINE count += ( ( times * ( times - 1 ) ) // 2 ) NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 105 , 96 , 20 , 2 , 87 , 96 ] NEW_LINE N = len ( arr ) NEW_LINE print ( CountPair ( arr , N ) ) NEW_LINE DEDENT;"Count pairs in an array having sum of elements with their respective sum of digits equal | Function to find the sum of digits of the number N ; Stores the sum of digits ; If the number N is greater than 0 ; Return the sum ; Function to find the count of pairs such that arr [ i ] + sumOfDigits ( arr [ i ] ) is equal to ( arr [ j ] + sumOfDigits ( arr [ j ] ) ; Stores the frequency of value of arr [ i ] + sumOfDigits ( arr [ i ] ) ; Traverse the given array ; Find the value ; Increment the frequency ; Stores the total count of pairs ; Traverse the map mp ; Update the count of pairs ; Return the total count of pairs ; Driver Code"
Python;"def build_tree ( b , seg_tree , l , r , vertex ) : NEW_LINE INDENT if ( l == r ) : NEW_LINE INDENT seg_tree [ vertex ] = b [ l ] NEW_LINE return NEW_LINE DEDENT mid = int ( ( l + r ) / 2 ) NEW_LINE build_tree ( b , seg_tree , l , mid , 2 * vertex ) NEW_LINE build_tree ( b , seg_tree , mid + 1 , r , 2 * vertex + 1 ) NEW_LINE seg_tree [ vertex ] = __gcd ( seg_tree [ 2 * vertex ] , seg_tree [ 2 * vertex + 1 ] ) NEW_LINE DEDENT def __gcd ( a , b ) : NEW_LINE INDENT if b == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT else : NEW_LINE INDENT return __gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def range_gcd ( seg_tree , v , tl , tr , l , r ) : NEW_LINE INDENT if ( l > r ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( l == tl and r == tr ) : NEW_LINE INDENT return seg_tree [ v ] NEW_LINE DEDENT tm = int ( ( tl + tr ) / 2 ) NEW_LINE return __gcd ( range_gcd ( seg_tree , 2 * v , tl , tm , l , min ( tm , r ) ) , range_gcd ( seg_tree , 2 * v + 1 , tm + 1 , tr , max ( tm + 1 , l ) , r ) ) NEW_LINE DEDENT def maxSubarrayLen ( arr , n ) : NEW_LINE INDENT seg_tree = [ 0 ] * ( 4 * n + 1 ) NEW_LINE build_tree ( arr , seg_tree , 0 , n - 1 , 1 ) NEW_LINE maxLen = 0 NEW_LINE l , r = 0 , 0 NEW_LINE while ( r < n and l < n ) : NEW_LINE INDENT if ( range_gcd ( seg_tree , 1 , 0 , n - 1 , l , r ) == 1 ) : NEW_LINE INDENT l += 1 NEW_LINE DEDENT maxLen = max ( maxLen , r - l - 1 ) NEW_LINE r += 1 NEW_LINE DEDENT print ( maxLen , end = "" "" ) NEW_LINE DEDENT arr = [ 410 , 52 , 51 , 180 , 222 , 33 , 33 ] NEW_LINE N = len ( arr ) NEW_LINE maxSubarrayLen ( arr , N ) NEW_LINE";"Longest subarray with GCD greater than 1 | Function to build the Segment Tree from the given array to process range queries in log ( N ) time ; Termination Condition ; Find the mid value ; Left and Right Recursive Call ; Update the Segment Tree Node ; Function to return the GCD of the elements of the Array from index l to index r ; Base Case ; Find the middle range ; Find the GCD and return ; Function to print maximum length of the subarray having GCD > one ; Stores the Segment Tree ; Function call to build the Segment tree from array [ ] arr ; Store maximum length of subarray ; Starting and ending pointer of the current window ; Case where the GCD of the current window is 1 ; Update the maximum length ; Print answer ; Driver Code"
Python;from math import log2 NEW_LINE def findAandB ( N ) : NEW_LINE INDENT K = int ( log2 ( N ) ) NEW_LINE B = ( 1 << K ) NEW_LINE A = B ^ N NEW_LINE print ( A , B ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 26 NEW_LINE findAandB ( N ) NEW_LINE DEDENT;"Smallest pair of integers with minimum difference whose Bitwise XOR is N | Python3 program for the above approach ; Function to find the numbers A and B whose Bitwise XOR is N and the difference between them is minimum ; Find the MSB of the N ; Find the value of B ; Find the value of A ; Print the result ; Driver Code"
Python;from math import sqrt NEW_LINE def findValuesOfK ( g ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( g ) ) + 1 , 1 ) : NEW_LINE INDENT if ( g % i == 0 ) : NEW_LINE INDENT if ( i != g // i ) : NEW_LINE INDENT if ( i & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( ( g // i ) & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT elif ( i & 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT print ( count ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT G = 125 NEW_LINE findValuesOfK ( G ) NEW_LINE DEDENT;"Find all possible values of K such that the sum of first N numbers starting from K is G | Python 3 program for the above approach ; Function to find the count the value of K such that sum of the first N numbers from K is G ; Stores the total count of K ; Iterate till square root of g ; If the number is factor of g ; If the second factor is not equal to first factor ; Check if two factors are odd or not ; If second factor is the same as the first factor then check if the first factor is odd or not ; Print the resultant count ; Driver Code"
Python;def Avgdifference ( arr , N , K ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( K ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT min = sum NEW_LINE max = sum NEW_LINE for i in range ( K , N - K + 2 , 1 ) : NEW_LINE INDENT sum += arr [ i ] - arr [ i - K ] NEW_LINE if ( min > sum ) : NEW_LINE INDENT min = sum NEW_LINE DEDENT if ( max < sum ) : NEW_LINE INDENT max = sum NEW_LINE DEDENT DEDENT return ( max - min ) / K NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 8 , 9 , 15 ] NEW_LINE N = len ( arr ) NEW_LINE K = 2 NEW_LINE print ( Avgdifference ( arr , N , K ) ) NEW_LINE DEDENT;"Difference between maximum and minimum average of all K | Function to find the difference between the maximum and minimum subarrays of length K ; Stores the sum of subarray over the range [ 0 , K ] ; Iterate over the range [ 0 , K ] ; Store min and max sum ; Iterate over the range [ K , N - K ] ; Increment sum by arr [ i ] - arr [ i - K ] ; Update max and min moving sum ; Return difference between max and min average ; Driver Code ; Given Input ; Function Call"
Python;"def findSet ( N , K ) : NEW_LINE INDENT a = [ ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( i != K ) : NEW_LINE INDENT a . append ( i ) NEW_LINE DEDENT DEDENT MaxDistinct = ( N - K ) + ( K // 2 ) NEW_LINE a = a [ : : - 1 ] NEW_LINE for i in range ( MaxDistinct ) : NEW_LINE INDENT print ( a [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE K = 3 NEW_LINE findSet ( N , K ) NEW_LINE DEDENT";"Count of distinct integers in range [ 1 , N ] that do not have any subset sum as K | Function to find maximum number of distinct integers in [ 1 , N ] having no subset with sum equal to K ; Declare a vector to store the required numbers ; Store all the numbers in [ 1 , N ] except K ; Store the maximum number of distinct numbers ; Reverse the array ; Print the required numbers ; Driver Code ; Given Input ; Function Call"
Python;"def ExtendedEuclidAlgo ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b , 0 , 1 NEW_LINE DEDENT gcd , x1 , y1 = ExtendedEuclidAlgo ( b % a , a ) NEW_LINE x = y1 - ( b // a ) * x1 NEW_LINE y = x1 NEW_LINE return gcd , x , y NEW_LINE DEDENT def linearCongruence ( A , B , N ) : NEW_LINE INDENT A = A % N NEW_LINE B = B % N NEW_LINE u = 0 NEW_LINE v = 0 NEW_LINE d , u , v = ExtendedEuclidAlgo ( A , N ) NEW_LINE if ( B % d != 0 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE return NEW_LINE DEDENT x0 = ( u * ( B // d ) ) % N NEW_LINE if ( x0 < 0 ) : NEW_LINE INDENT x0 += N NEW_LINE DEDENT for i in range ( d ) : NEW_LINE INDENT print ( ( x0 + i * ( N // d ) ) % N , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT A = 15 NEW_LINE B = 9 NEW_LINE N = 18 NEW_LINE linearCongruence ( A , B , N ) NEW_LINE";"Solve Linear Congruences Ax = B ( mod N ) for values of x in range [ 0 , N | Function to stores the values of x and y and find the value of gcd ( a , b ) ; Base Case ; Store the result of recursive call ; Update x and y using results of recursive call ; Function to give the distinct solutions of ax = b ( mod n ) ; Function Call to find the value of d and u ; No solution exists ; Else , initialize the value of x0 ; Pr all the answers ; Input ; Function Call"
Python;def factorialWithoutMul ( N ) : NEW_LINE INDENT ans = N NEW_LINE i = N - 1 NEW_LINE while ( i > 0 ) : NEW_LINE INDENT sum = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT sum += ans NEW_LINE DEDENT ans = sum NEW_LINE i -= 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE print ( factorialWithoutMul ( N ) ) NEW_LINE DEDENT;"Factorial of a number without using multiplication | Function to calculate factorial of the number without using multiplication operator ; Variable to store the final factorial ; Outer loop ; Inner loop ; Driver code ; Input ; Function calling"
Python;def tripletAndSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n , 1 ) : NEW_LINE INDENT for k in range ( j + 1 , n , 1 ) : NEW_LINE INDENT ans += arr [ i ] & arr [ j ] & arr [ k ] NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 5 , 4 , 7 ] NEW_LINE N = len ( arr ) NEW_LINE tripletAndSum ( arr , N ) NEW_LINE DEDENT;"Sum of Bitwise AND of all unordered triplets of an array | Function to calculate sum of Bitwise AND of all unordered triplets from a given array such that ( i < j < k ) ; Stores the resultant sum of Bitwise AND of all triplets ; Generate all triplets of ( arr [ i ] , arr [ j ] , arr [ k ] ) ; Add Bitwise AND to ans ; Print the result ; Driver Code"
Python;def tripletAndSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for bit in range ( 32 ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] & ( 1 << bit ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT ans += ( 1 << bit ) * cnt * ( cnt - 1 ) * ( cnt - 2 ) // 6 NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 3 , 5 , 4 , 7 ] NEW_LINE N = len ( arr ) NEW_LINE print ( tripletAndSum ( arr , N ) ) NEW_LINE;"Sum of Bitwise AND of all unordered triplets of an array | Function to calculate sum of Bitwise AND of all unordered triplets from a given array such that ( i < j < k ) ; Stores the resultant sum of Bitwise AND of all triplets ; Traverse over all the bits ; Count number of elements with the current bit set ; There are ( cnt ) C ( 3 ) numbers with the current bit set and each triplet contributes 2 ^ bit to the result ; Return the resultant sum ; Driver Code"
Python;"from bisect import bisect_left NEW_LINE def smallestPermutation ( arr , N ) : NEW_LINE INDENT w = [ False for i in range ( 2 * N + 1 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT w [ arr [ i ] ] = True NEW_LINE DEDENT S = set ( ) NEW_LINE for i in range ( 1 , 2 * N + 1 , 1 ) : NEW_LINE INDENT if ( w [ i ] == False ) : NEW_LINE INDENT S . add ( i ) NEW_LINE DEDENT DEDENT found = True NEW_LINE P = [ ] NEW_LINE S = list ( S ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT it = bisect_left ( S , arr [ i ] ) NEW_LINE if ( it == - 1 ) : NEW_LINE INDENT found = False NEW_LINE break NEW_LINE DEDENT P . append ( arr [ i ] ) NEW_LINE P . append ( S [ it ] ) NEW_LINE S . remove ( S [ it ] ) NEW_LINE DEDENT if ( found == False ) : NEW_LINE INDENT print ( "" - 1"" ) NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( 2 * N ) : NEW_LINE INDENT print ( P [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 1 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE smallestPermutation ( arr , N ) NEW_LINE DEDENT";"Lexicographically smallest permutation of length 2 N that can be obtained from an N | Python3 program for the above approach ; Function to find the lexicographically smallest permutation of length 2 * N satisfying the given conditions ; Stores if i - th element is placed at odd position or not ; Traverse the array ; Mark arr [ i ] true ; Stores all the elements not placed at odd positions ; Iterate in the range [ 1 , 2 * N ] ; If w [ i ] is not marked ; Stores whether it is possible to obtain the required permutation or not ; Stores the permutation ; Traverse the array arr [ ] ; Finds the iterator of the smallest number greater than the arr [ i ] ; If it is S . end ( ) ; Mark found false ; Push arr [ i ] and * it into the array ; Erase the current element from the Set ; If found is not marked ; Otherwise , ; Print the permutation ; Driver Code ; Given Input ; Function call"
Python;def maximumSubsequenceSum ( A , N ) : NEW_LINE INDENT ans = 0 NEW_LINE mp = { } NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] - i in mp ) : NEW_LINE INDENT mp [ A [ i ] - i ] += A [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT mp [ A [ i ] - i ] = A [ i ] NEW_LINE DEDENT ans = max ( ans , mp [ A [ i ] - i ] ) NEW_LINE DEDENT print ( ans ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 10 , 7 , 1 , 9 , 10 , 1 ] NEW_LINE N = len ( A ) NEW_LINE maximumSubsequenceSum ( A , N ) NEW_LINE DEDENT;"Maximum sum of a subsequence having difference between their indices equal to the difference between their values | Function to find the maximum sum of a subsequence having difference between indices equal to difference in their values ; Stores the maximum sum ; Stores the value for each A [ i ] - i ; Traverse the array ; Update the value in map ; Update the answer ; Finally , print the answer ; Driver Code ; Given Input ; Function Call"
Python;"import math NEW_LINE def nearestPerfectSquare ( arr , N ) : NEW_LINE INDENT for i in range ( 0 , N ) : NEW_LINE INDENT sr = math . floor ( math . sqrt ( arr [ i ] ) ) NEW_LINE a = sr * sr NEW_LINE b = ( sr + 1 ) * ( sr + 1 ) NEW_LINE if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) : NEW_LINE print ( a , end = "" ▁ "" ) NEW_LINE else : NEW_LINE print ( b , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT arr = [ 5 , 2 , 7 , 13 ] NEW_LINE N = len ( arr ) NEW_LINE nearestPerfectSquare ( arr , N ) NEW_LINE";"Find the nearest perfect square for each element of the array | Function to find the nearest perfect square for every element in the given array import the math module ; Traverse the array ; Calculate square root of current element ; Calculate perfect square ; Find the nearest ; Driver Code"
Python;prime = [ True ] * 100001 NEW_LINE def SieveOfEratosthenes ( n ) : NEW_LINE INDENT global prime NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if p * p > n : NEW_LINE INDENT break NEW_LINE DEDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * p , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def NumberofSets ( N ) : NEW_LINE INDENT SieveOfEratosthenes ( N ) NEW_LINE if ( N == 2 ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT elif ( N == 3 ) : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( N // 2 , N + 1 ) : NEW_LINE INDENT if ( prime [ i ] ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 9 NEW_LINE NumberofSets ( N ) NEW_LINE DEDENT;"Count of sets possible using integers from a range [ 2 , N ] using given operations that are in Equivalence Relation | Python3 program for the above approach ; Sieve of Eratosthenes to find primes less than or equal to N ; Function to find number of Sets ; Handle Base Case ; Set which contains less than or equal to N / 2 ; Number greater than N / 2 and are prime increment it by 1 ; If the number is prime Increment answer by 1 ; Driver Code ; Input ; Function Call"
Python;def floorDifference ( A , N , X ) : NEW_LINE INDENT totalSum = 0 NEW_LINE perElementSum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT totalSum += A [ i ] NEW_LINE perElementSum += A [ i ] // X NEW_LINE DEDENT totalFloorSum = totalSum // X NEW_LINE return abs ( totalFloorSum - perElementSum ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE X = 4 NEW_LINE N = len ( A ) NEW_LINE print ( floorDifference ( A , N , X ) ) NEW_LINE DEDENT;"Absolute difference between floor of Array sum divided by X and floor sum of every Array element when divided by X | Function to find absolute difference between the two sum values ; Variable to store total sum ; Variable to store sum of A [ i ] / X ; Traverse the array ; Update totalSum ; Update perElementSum ; Floor of total sum divided by X ; Return the absolute difference ; Driver Code ; Input ; Size of Array ; Function call to find absolute difference between the two sum values"
Python;"def val ( c ) : NEW_LINE INDENT if ( c >= '0' and c <= '9' ) : NEW_LINE INDENT return ord ( c ) - 48 NEW_LINE DEDENT else : NEW_LINE INDENT return ord ( c ) - 65 + 10 NEW_LINE DEDENT DEDENT def toDeci ( strr , base ) : NEW_LINE INDENT lenn = len ( strr ) NEW_LINE power = 1 NEW_LINE num = 0 NEW_LINE for i in range ( lenn - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( val ( strr [ i ] ) >= base ) : NEW_LINE INDENT print ( "" Invalid ▁ Number "" ) NEW_LINE return - 1 NEW_LINE DEDENT num += val ( strr [ i ] ) * power NEW_LINE power = power * base NEW_LINE DEDENT return num NEW_LINE DEDENT def reVal ( num ) : NEW_LINE INDENT if ( num >= 0 and num <= 9 ) : NEW_LINE INDENT return chr ( num + 48 ) NEW_LINE DEDENT else : NEW_LINE INDENT return chr ( num - 10 + 65 ) NEW_LINE DEDENT DEDENT def fromDeci ( base , inputNum ) : NEW_LINE INDENT res = "" "" NEW_LINE while ( inputNum > 0 ) : NEW_LINE INDENT res += reVal ( inputNum % base ) NEW_LINE inputNum //= base NEW_LINE DEDENT res = res [ : : - 1 ] NEW_LINE return res NEW_LINE DEDENT def convertBase ( s , a , b ) : NEW_LINE INDENT num = toDeci ( s , a ) NEW_LINE ans = fromDeci ( b , num ) NEW_LINE print ( ans ) NEW_LINE DEDENT s = ""10B "" NEW_LINE a = 16 NEW_LINE b = 10 NEW_LINE convertBase ( s , a , b ) NEW_LINE";"Convert a number from base A to base B | Function to return ASCII value of a character ; Function to convert a number from given base to decimal number ; Stores the length of the string ; Initialize power of base ; Initialize result ; Decimal equivalent is strr [ len - 1 ] * 1 + strr [ len - 2 ] * base + strr [ len - 3 ] * ( base ^ 2 ) + ... ; A digit in input number must be less than number 's base ; Update num ; Update power ; Function to return equivalent character of a given value ; Function to convert a given decimal number to a given base ; Store the result ; Repeatedly divide inputNum by base and take remainder ; Update res ; Update inputNum ; Reverse the result ; Function to convert a given number from a base to another base ; Convert the number from base A to decimal ; Convert the number from decimal to base B ; Prthe result ; Given input ; Function Call"
Python;"def fact ( N ) : NEW_LINE INDENT if ( N == 1 or N == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return N * fact ( N - 1 ) NEW_LINE DEDENT def prefixFactorialArray ( arr , N ) : NEW_LINE INDENT for i in range ( 1 , N ) : NEW_LINE INDENT arr [ i ] += arr [ i - 1 ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT arr [ i ] = fact ( arr [ i ] ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE prefixFactorialArray ( arr , N ) NEW_LINE DEDENT";"Prefix Factorials of a Prefix Sum Array | Function to find the factorial of a number N ; Base Case ; Find the factorial recursively ; Function to find the prefix factorial array ; Find the prefix sum array ; Find the factorials of each array element ; Print the resultant array ; Driver Code"
Python;def findAverage ( N ) : NEW_LINE INDENT avg = ( ( 6 * N * N * N * N ) + ( 15 * N * N * N ) + ( 10 * N * N ) - 1 ) / 30 NEW_LINE return avg NEW_LINE DEDENT N = 3 NEW_LINE print ( round ( findAverage ( N ) , 4 ) ) NEW_LINE;"Mean of fourth powers of first N natural numbers | Function to find the average of the fourth power of first N natural numbers ; Store the resultant average calculated using formula ; Return the average ; Driver Code"
Python;"def removeEveryKth ( l , k ) : NEW_LINE INDENT for i in range ( 0 , len ( l ) ) : NEW_LINE INDENT if i % k == 0 : NEW_LINE INDENT l [ i ] = 0 NEW_LINE DEDENT DEDENT arr = [ 0 ] NEW_LINE for i in range ( 1 , len ( l ) ) : NEW_LINE INDENT if l [ i ] != 0 : NEW_LINE INDENT arr . append ( l [ i ] ) NEW_LINE DEDENT DEDENT return arr NEW_LINE DEDENT def printArray ( l ) : NEW_LINE INDENT for i in range ( 1 , len ( l ) ) : NEW_LINE INDENT print ( l [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def printSequence ( n , k ) : NEW_LINE INDENT l = [ int ( i ) for i in range ( 0 , n + 1 ) ] NEW_LINE x = 1 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT p = l [ x ] + l [ x + 1 ] NEW_LINE l = removeEveryKth ( l , p ) NEW_LINE x += 1 NEW_LINE DEDENT printArray ( l ) NEW_LINE DEDENT N = 8 NEW_LINE K = 2 NEW_LINE printSequence ( N , K ) NEW_LINE";"Modify array by removing ( arr [ i ] + arr [ i + 1 ] ) th element exactly K times | Function to modify array by removing every K - th element from the array ; Check if current element is the k - th element ; Stores the elements after removing every kth element ; Append the current element if it is not k - th element ; Return the new array after removing every k - th element ; Function to print the array ; Traverse the array l [ ] ; Function to print the array after performing the given operations exactly k times ; Store first N natural numbers ; Iterate over the range [ 0 , k - 1 ] ; Store sums of the two consecutive terms ; Remove every p - th element from the array ; Increment x by 1 for the next iteration ; Print the resultant array ; Given arrays ; Function Call"
Python;def makeEqual ( arr , n ) : NEW_LINE INDENT fre0 = [ 0 ] * 33 NEW_LINE fre1 = [ 0 ] * 33 NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE for j in range ( 33 ) : NEW_LINE INDENT if ( x & 1 ) : NEW_LINE INDENT fre1 [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT fre0 [ j ] += 1 NEW_LINE DEDENT x = x >> 1 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 33 ) : NEW_LINE INDENT ans += min ( fre0 [ i ] , fre1 [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE print ( makeEqual ( arr , N ) ) NEW_LINE DEDENT;"Minimum number of bits of array elements required to be flipped to make all array elements equal | Function to count minimum number of bits required to be flipped to make all array elements equal ; Stores the count of unset bits ; Stores the count of set bits ; Traverse the array ; Traverse the bit of arr [ i ] ; If current bit is set ; Increment fre1 [ j ] ; Otherwise ; Increment fre0 [ j ] ; Right shift x by 1 ; Stores the count of total moves ; Traverse the range [ 0 , 32 ] ; Update the value of ans ; Return the minimum number of flips required ; Driver Code"
Python;def summ ( arr , N , K ) : NEW_LINE INDENT sum = 4 NEW_LINE v = [ i for i in arr ] NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if ( v [ i ] % K == 0 ) : NEW_LINE INDENT x = v [ i ] // K NEW_LINE for j in range ( K ) : NEW_LINE INDENT v . append ( x ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT for i in range ( len ( v ) ) : NEW_LINE INDENT sum = sum + v [ i ] NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 6 , 8 , 2 ] NEW_LINE K = 2 NEW_LINE N = len ( arr ) NEW_LINE print ( summ ( arr , N , K ) ) NEW_LINE DEDENT;"Sum of array elements possible by appending arr [ i ] / K to the end of the array K times for array elements divisible by K | Function to calculate sum of array elements after adding arr [ i ] / K to the end of the array if arr [ i ] is divisible by K ; Stores the sum of the array ; Traverse the array arr [ ] ; Traverse the vector ; If v [ i ] is divisible by K ; Iterate over the range [ 0 , K ] ; Update v ; Otherwise ; Traverse the vector v ; Return the sum of the updated array ; Driver Code"
Python;"def check ( arr , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT if ( sum == 0 ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , - 1 , 3 , - 2 , - 1 ] NEW_LINE N = len ( arr ) NEW_LINE check ( arr , N ) NEW_LINE DEDENT";"Check if sum of arr [ i ] / j for all possible pairs ( i , j ) in an array is 0 or not | Function to check if sum of all values of ( arr [ i ] / j ) for all 0 < i <= j < ( N - 1 ) is 0 or not ; Stores the required sum ; Traverse the array ; If the sum is equal to 0 ; Otherwise ; Driver Code"
Python;def expectedValue ( P , a , b , N ) : NEW_LINE INDENT expValue = P + ( N * 0.5 * ( a + b ) ) NEW_LINE print ( int ( expValue ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT P = 3000 NEW_LINE a = 20 NEW_LINE b = 10 NEW_LINE N = 30 NEW_LINE expectedValue ( P , a , b , N ) NEW_LINE DEDENT;"Program to calculate expected increase in price P after N consecutive days | Function to find the increased value of P after N days ; Expected value of the number P after N days ; Print the expected value ; Driver Code"
Python;import sys NEW_LINE def startingPoint ( A , N ) : NEW_LINE INDENT sum = 0 NEW_LINE startingindex = 0 NEW_LINE min = sys . maxsize NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT sum += A [ i ] NEW_LINE if ( sum < min ) : NEW_LINE INDENT min = sum NEW_LINE startingindex = i + 1 NEW_LINE DEDENT DEDENT if ( sum < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return startingindex % N NEW_LINE DEDENT arr = [ 3 , - 6 , 7 , - 4 , - 4 , 6 , - 1 ] NEW_LINE N = len ( arr ) NEW_LINE print ( startingPoint ( arr , N ) ) NEW_LINE;"Find the index in a circular array from which prefix sum is always non | Function to find the starting index of the given circular array prefix sum array is non negative ; Stores the sum of the array ; Stores the starting index ; Stores the minimum prefix sum of A [ 0. . i ] ; Traverse the array ; Update the value of sum ; If sum is less than minimum ; Update the min as the value of prefix sum ; Update starting index ; Otherwise no such index is possible ; Driver code"
Python;import math NEW_LINE def nearestPow ( x , y ) : NEW_LINE INDENT if y == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT k = int ( math . log ( x , y ) ) NEW_LINE if abs ( y ** k - x ) < abs ( y ** ( k + 1 ) - x ) : NEW_LINE INDENT return y ** k NEW_LINE DEDENT return y ** ( k + 1 ) NEW_LINE DEDENT def replacebyNearestPower ( arr ) : NEW_LINE INDENT prev = arr [ - 1 ] NEW_LINE lastNext = arr [ 0 ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE if i == len ( arr ) - 1 : NEW_LINE INDENT next = lastNext NEW_LINE DEDENT else : NEW_LINE INDENT next = arr [ ( i + 1 ) % len ( arr ) ] NEW_LINE DEDENT prevPow = nearestPow ( arr [ i ] , prev ) NEW_LINE nextPow = nearestPow ( arr [ i ] , next ) NEW_LINE if abs ( arr [ i ] - prevPow ) < abs ( arr [ i ] - nextPow ) : NEW_LINE INDENT arr [ i ] = prevPow NEW_LINE DEDENT else : NEW_LINE INDENT arr [ i ] = nextPow NEW_LINE DEDENT prev = temp NEW_LINE DEDENT print ( arr ) NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 1 , 2 ] NEW_LINE replacebyNearestPower ( arr ) NEW_LINE;"Modify array by replacing elements with the nearest power of its previous or next element | Python3 program for the above approach ; Function to calculate the power of y which is nearest to x ; Base Case ; Stores the logarithmic value of x with base y ; Function to replace each array element by the nearest power of its previous or next element ; Stores the previous and next element ; Traverse the array ; Calculate nearest power for previous and next elements ; Replacing the array values ; Print the updated array ; Given array"
Python;"def makeSumX ( arr , X , S , i ) : NEW_LINE INDENT if i == len ( arr ) : NEW_LINE INDENT return S == X NEW_LINE DEDENT a = str ( arr [ i ] ) NEW_LINE l = int ( a [ : - 1 ] ) NEW_LINE r = int ( a [ 1 : ] ) NEW_LINE x = makeSumX ( arr , X , S + l , i + 1 ) NEW_LINE y = makeSumX ( arr , X , S + r , i + 1 ) NEW_LINE return x | y NEW_LINE DEDENT def Check ( arr , X ) : NEW_LINE INDENT if ( makeSumX ( arr , X , 0 , 0 ) ) : NEW_LINE print ( "" Yes "" ) NEW_LINE else : NEW_LINE print ( "" No "" ) NEW_LINE DEDENT arr = [ 545 , 433 , 654 , 23 ] NEW_LINE X = 134 NEW_LINE Check ( arr , X ) NEW_LINE";"Check if sum of array can be made equal to X by removing either the first or last digits of every array element | Utility Function to check if the sum of the array elements can be made equal to X by removing either the first or last digits of every array element ; Base Case ; Convert arr [ i ] to string ; Remove last digit ; Remove first digit ; Recursive function call ; Function to check if sum of given array can be made equal to X or not ; Driver Code ; Function Call"
Python;from math import log NEW_LINE def isPower ( m , y ) : NEW_LINE INDENT res1 = log ( y ) // log ( m ) NEW_LINE res2 = log ( y ) // log ( m ) NEW_LINE return ( res1 == res2 ) NEW_LINE DEDENT def numSub ( arr , n , m ) : NEW_LINE INDENT ans = 0 NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( isPower ( m , arr [ i ] ) ) : NEW_LINE INDENT cnt += 1 NEW_LINE ans += ( cnt * ( cnt - 1 ) ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT cnt = 0 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 1 , 3 ] NEW_LINE m = 3 NEW_LINE n = len ( arr ) NEW_LINE print ( numSub ( arr , n , m ) ) NEW_LINE DEDENT;"Count subarrays having product equal to the power of a given Prime Number | Python 3 program for the above approach ; Function to check if y is a power of m or not ; Calculate log y base m and store it in a variable with integer datatype ; Calculate log y base m and store it in a variable with double datatype ; If res1 and res2 are equal , return True . Otherwise , return false ; Function to count the number of subarrays having product of elements equal to a power of m , where m is a prime number ; Stores the count of subarrays required ; Stores current sequence of consecutive array elements which are a multiple of m ; Traverse the array ; If arr [ i ] is a power of M ; Increment cnt ; Update ans ; Update cnt ; Return the count of subarrays ; Driver Code ; Input"
Python;"import math NEW_LINE def cntPairs ( arr , N ) : NEW_LINE INDENT res = 0 NEW_LINE bit = [ 0 ] * 32 NEW_LINE for i in range ( N ) : NEW_LINE INDENT pos = ( int ) ( math . log2 ( arr [ i ] ) ) NEW_LINE bit [ pos ] += 1 NEW_LINE DEDENT for i in range ( 32 ) : NEW_LINE INDENT res += ( bit [ i ] * ( bit [ i ] - 1 ) ) // 2 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE N = len ( arr ) NEW_LINE print ( cntPairs ( arr , N ) ) NEW_LINE DEDENT";"Count pairs whose Bitwise AND exceeds Bitwise XOR from a given array | Python3 program to implement the above approach ; Function to count pairs that satisfy the above condition ; Stores the count of pairs ; Stores the count of array elements having same positions of MSB ; Traverse the array ; Stores the index of MSB of array elements ; Calculate number of pairs ; Driver Code ; Given Input ; Function call to count pairs satisfying the given condition"
Python;def minimumMEX ( arr , N , K ) : NEW_LINE INDENT s = set ( ) NEW_LINE for i in range ( 1 , N + 2 , 1 ) : NEW_LINE INDENT s . add ( i ) NEW_LINE DEDENT for i in range ( K ) : NEW_LINE INDENT s . remove ( arr [ i ] ) NEW_LINE DEDENT mex = list ( s ) [ 0 ] NEW_LINE for i in range ( K , N , 1 ) : NEW_LINE INDENT s . remove ( arr [ i ] ) NEW_LINE s . add ( arr [ i - K ] ) NEW_LINE firstElem = list ( s ) [ 0 ] NEW_LINE mex = min ( mex , firstElem ) NEW_LINE DEDENT print ( mex ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] NEW_LINE K = 3 NEW_LINE N = len ( arr ) NEW_LINE minimumMEX ( arr , N , K ) NEW_LINE DEDENT;"Minimum MEX from all subarrays of length K | Function to return minimum MEX from all K - length subarrays ; Stores element from [ 1 , N + 1 ] which are not present in subarray ; Store number 1 to N + 1 in set s ; Find the MEX of K - length subarray starting from index 0 ; Find the MEX of all subarrays of length K by erasing arr [ i ] and inserting arr [ i - K ] ; Store first element of set ; Updating the mex ; Print minimum MEX of all K length subarray ; Driver Code"
Python;"def smallerNumbers ( arr , N ) : NEW_LINE INDENT hash = [ 0 ] * 100000 NEW_LINE for i in range ( N ) : NEW_LINE INDENT hash [ arr [ i ] ] += 1 NEW_LINE DEDENT sum = 0 NEW_LINE for i in range ( 1 , 100000 ) : NEW_LINE INDENT hash [ i ] += hash [ i - 1 ] NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT print ( ""0"" ) NEW_LINE continue NEW_LINE DEDENT print ( hash [ arr [ i ] - 1 ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 3 , 4 , 1 , 1 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE smallerNumbers ( arr , N ) NEW_LINE DEDENT";"Count smaller elements present in the array for each array element | Function to count for each array element , the number of elements that are smaller than that element ; Stores the frequencies of array elements ; Traverse the array ; Update frequency of arr [ i ] ; Initialize sum with 0 ; Compute prefix sum of the array hash [ ] ; Traverse the array arr [ ] ; If current element is 0 ; Print the resultant count ; Driver Code"
Python;"def truncMod ( a , n ) : NEW_LINE INDENT q = a // n NEW_LINE return a - n * q NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 9 NEW_LINE b = 4 NEW_LINE print ( a , "" % "" , b , "" = "" , truncMod ( a , b ) ) NEW_LINE a = - 9 NEW_LINE b = 4 NEW_LINE print ( a , "" % "" , b , "" = "" , truncMod ( a , b ) ) NEW_LINE a = 9 NEW_LINE b = - 4 NEW_LINE print ( a , "" % "" , b , "" = "" , truncMod ( a , b ) ) NEW_LINE a = - 9 NEW_LINE b = - 4 NEW_LINE print ( a , "" % "" , b , "" = "" , truncMod ( a , b ) ) NEW_LINE DEDENT";"Modulo Operations in Programming With Negative Results | Function to calculate and return the remainder of a % n ; ( a / n ) implicitly gives the truncated result ; Driver Code ; Modulo of two positive numbers ; Modulo of a negative number by a positive number ; Modulo of a positive number by a negative number ; Modulo of two negative numbers"
Python;"import sys NEW_LINE def average ( arr , N ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT return sum // N * 1.0 - 1 NEW_LINE DEDENT def mean ( arr , N ) : NEW_LINE INDENT avg = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT avg += ( arr [ i ] - avg ) / ( i + 1 ) NEW_LINE DEDENT return round ( avg , 7 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2147483647 , 1 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE print ( "" Average ▁ by ▁ Standard ▁ method : ▁ "" , "" { : . 10f } "" . format ( - 1.0 * average ( arr , N ) ) ) NEW_LINE print ( "" Average ▁ by ▁ Efficient ▁ method : ▁ "" , "" { : . 10f } "" . format ( mean ( arr , N ) ) ) NEW_LINE DEDENT";"Program for average of an array without running into overflow | Python3 program for the above approach ; Function to calculate average of an array using standard method ; Stores the sum of array ; Find the sum of the array ; Return the average ; Function to calculate average of an array using efficient method ; Store the average of the array ; Traverse the array arr [ ] ; Update avg ; Return avg ; Driver Code ; Input ; Function call"
Python;"from collections import defaultdict NEW_LINE def countPairs ( arr , N ) : NEW_LINE INDENT count = 0 NEW_LINE mp = defaultdict ( int ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT val = 1.0 * arr [ i ] NEW_LINE idx = 1.0 * ( i + 1 ) NEW_LINE count += mp [ val / idx ] NEW_LINE mp [ val / idx ] += 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 3 , 5 , 6 , 5 ] NEW_LINE N = len ( arr ) NEW_LINE countPairs ( arr , N ) NEW_LINE DEDENT";"Count number of pairs ( i , j ) from an array such that arr [ i ] * j = arr [ j ] * i | Python3 program for the above approach ; Function to count pairs from an array satisfying given conditions ; Stores the total count of pairs ; Stores count of a [ i ] / i ; Traverse the array ; Updating count ; Update frequency in the Map ; Print count of pairs ; Driver Code ; Given array ; Size of the array ; Function call to count pairs satisfying given conditions"
Python;"def add_edge ( u , v ) : NEW_LINE INDENT global adj NEW_LINE adj [ u ] . append ( v ) NEW_LINE adj [ v ] . append ( u ) NEW_LINE DEDENT def dfs ( u , par = - 1 ) : NEW_LINE INDENT global adj , parent NEW_LINE parent [ u ] = par NEW_LINE for child in adj [ u ] : NEW_LINE INDENT if ( child != par ) : NEW_LINE INDENT dfs ( child , u ) NEW_LINE DEDENT DEDENT DEDENT def countSmallerAncestors ( n ) : NEW_LINE INDENT global parent , adj NEW_LINE dfs ( 1 ) NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT node = i NEW_LINE cnt = 0 NEW_LINE while ( parent [ node ] != - 1 ) : NEW_LINE INDENT if ( parent [ node ] < i ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT node = parent [ node ] NEW_LINE DEDENT print ( cnt , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 6 NEW_LINE adj = [ [ ] for i in range ( 10 ** 5 ) ] NEW_LINE parent = [ 0 ] * ( 10 ** 5 ) NEW_LINE add_edge ( 1 , 5 ) NEW_LINE add_edge ( 1 , 4 ) NEW_LINE add_edge ( 4 , 6 ) NEW_LINE add_edge ( 5 , 3 ) NEW_LINE add_edge ( 5 , 2 ) NEW_LINE countSmallerAncestors ( N ) NEW_LINE DEDENT";"Count ancestors with smaller value for each node of a Binary Tree | Function to add an edge between nodes u and v ; Function to perform the DFS Traversal and store parent of each node ; Store the immediate parent ; Traverse the children of the current node ; Recursively call for function dfs for the child node ; Function to count the number of ancestors with values smaller than that of the current node ; Perform the DFS Traversal ; Traverse all the nodes ; Store the number of ancestors smaller than node ; Loop until parent [ node ] != - 1 ; If the condition satisfies , increment cnt by 1 ; Print the required result for the current node ; Driver Code ; Tree Formation"
Python;"def countSubsequences ( A ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for el in A : NEW_LINE INDENT if ( el % 2 == 1 ) : NEW_LINE INDENT odd += 1 NEW_LINE DEDENT else : NEW_LINE INDENT even += 1 NEW_LINE DEDENT DEDENT if ( odd == 0 ) : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 << len ( A ) - 1 ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT A = [ 1 , 3 , 4 ] NEW_LINE countSubsequences ( A ) NEW_LINE DEDENT";"Count subsequences having odd Bitwise XOR values from an array | Function to count the subsequences having odd bitwise XOR value ; Stores count of odd elements ; Stores count of even elements ; Traverse the array A [ ] ; If el is odd ; If count of odd elements is 0 ; Driver Code ; Given array A [ ] ; Function call to count subsequences having odd bitwise XOR value"
Python;"def maxModProdSubarr ( arr , n , M ) : NEW_LINE INDENT ans = 0 NEW_LINE length = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT product = 1 NEW_LINE for j in range ( i , n , 1 ) : NEW_LINE INDENT product = ( product * arr [ i ] ) % M NEW_LINE if ( product > ans ) : NEW_LINE INDENT ans = product NEW_LINE if ( length > j - i + 1 ) : NEW_LINE INDENT length = j - i + 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( "" Maximum ▁ subarray ▁ product ▁ is "" , ans ) NEW_LINE print ( "" Minimum ▁ length ▁ of ▁ the ▁ maximum ▁ product ▁ subarray ▁ is "" , length ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 4 , 2 ] NEW_LINE N = len ( arr ) NEW_LINE M = 5 NEW_LINE maxModProdSubarr ( arr , N , M ) NEW_LINE DEDENT";"Maximum subarray product modulo M | Function to find maximum subarray product modulo M and minimum length of the subarray ; Stores maximum subarray product modulo M and minimum length of the subarray ; Stores the minimum length of subarray having maximum product ; Traverse the array ; Stores the product of a subarray ; Calculate Subarray whose start index is i ; Multiply product by arr [ i ] ; If product greater than ans ; Update ans ; Update length ; Print maximum subarray product mod M ; Print minimum length of subarray having maximum product ; Drivers Code"
Python;"from copy import deepcopy NEW_LINE import math NEW_LINE def coprime ( a , b ) : NEW_LINE INDENT return ( math . gcd ( a , b ) ) == 1 NEW_LINE DEDENT def numOfPairs ( arr , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( coprime ( int ( arr [ i ] ) , int ( arr [ j ] ) ) ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT def noOfCoPrimePairs ( N , d1 , d2 ) : NEW_LINE INDENT l = [ ] NEW_LINE l . append ( str ( d1 ) ) NEW_LINE l . append ( str ( d2 ) ) NEW_LINE l . sort ( ) NEW_LINE if int ( N ) < int ( l [ 1 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT total = temp2 = deepcopy ( l ) NEW_LINE flag = 0 NEW_LINE temp3 = [ ] NEW_LINE while len ( l [ 0 ] ) < 10 : NEW_LINE INDENT for i in range ( len ( l ) ) : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT if int ( l [ i ] + temp2 [ j ] ) > int ( N ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT total . append ( l [ i ] + temp2 [ j ] ) NEW_LINE temp3 . append ( l [ i ] + temp2 [ j ] ) NEW_LINE DEDENT if flag == 1 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if flag == 1 : NEW_LINE INDENT break NEW_LINE DEDENT l = deepcopy ( temp3 ) NEW_LINE temp3 = [ ] NEW_LINE DEDENT lenOfTotal = len ( total ) NEW_LINE ans = numOfPairs ( total , lenOfTotal ) NEW_LINE print ( ans ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT N = 30 NEW_LINE d1 = 2 NEW_LINE d2 = 3 NEW_LINE noOfCoPrimePairs ( N , d1 , d2 ) NEW_LINE DEDENT";"Number of co | Python3 program for the above approach ; Function to check whether given integers are co - prime or not ; Utility function to count number of co - prime pairs ; Traverse the array ; If co - prime ; Increment count ; Return count ; Function to count number of co - prime pairs ; Stores digits in string form ; Sort the list ; Keep two copies of list l ; Generate 2 digit numbers using d1 and d2 ; If current number does not exceed N ; Stores length of list ; Stores number of co - prime pairs ; Print number of co - prime pairs ; Driver Code ; Given value of N , d1 , d2 ; Function call to count number of co - prime pairs"
Python;"def tile_placing ( grid , N ) : NEW_LINE INDENT dp = [ 0 ] * ( N + 5 ) ; NEW_LINE orig_cost = 0 ; NEW_LINE for i in range ( 2 ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT orig_cost += grid [ i ] [ j ] ; NEW_LINE DEDENT DEDENT dp [ 0 ] = 0 ; NEW_LINE dp [ 1 ] = abs ( grid [ 0 ] [ 0 ] - grid [ 1 ] [ 0 ] ) ; NEW_LINE for i in range ( 2 , N + 1 ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i - 1 ] + abs ( grid [ 0 ] [ i - 1 ] - grid [ 1 ] [ i - 1 ] ) , dp [ i - 2 ] + abs ( grid [ 0 ] [ i - 2 ] - grid [ 0 ] [ i - 1 ] ) + abs ( grid [ 1 ] [ i - 2 ] - grid [ 1 ] [ i - 1 ] ) ) ; NEW_LINE DEDENT print ( orig_cost - dp [ N ] , end = "" "" ) ; NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT M = [ [ 7 , 5 , 1 , 3 ] , [ 8 , 6 , 0 , 2 ] ] ; NEW_LINE N = len ( M [ 0 ] ) ; NEW_LINE tile_placing ( M , N ) ; NEW_LINE DEDENT";"Minimize cost of placing tiles of dimensions 2 * 1 over a Matrix | Function to find the minimum cost in placing N tiles in a grid M [ ] [ ] ; Stores the minimum profit after placing i tiles ; Traverse the grid [ ] [ ] ; Update the orig_cost ; Traverse over the range [ 2 , N ] ; Place tiles horizentally or vertically ; Print the answer ; Driver Code"
Python;def findSplit ( arr , N ) : NEW_LINE INDENT for l in range ( 1 , N - 3 , 1 ) : NEW_LINE INDENT for r in range ( l + 2 , N - 1 , 1 ) : NEW_LINE INDENT lsum = 0 NEW_LINE rsum = 0 NEW_LINE msum = 0 NEW_LINE for i in range ( 0 , l , 1 ) : NEW_LINE INDENT lsum += arr [ i ] NEW_LINE DEDENT for i in range ( l + 1 , r , 1 ) : NEW_LINE INDENT msum += arr [ i ] NEW_LINE DEDENT for i in range ( r + 1 , N , 1 ) : NEW_LINE INDENT rsum += arr [ i ] NEW_LINE DEDENT if ( lsum == rsum and rsum == msum ) : NEW_LINE INDENT print ( l , r ) NEW_LINE return NEW_LINE DEDENT DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 5 , 12 , 7 , 19 , 4 , 3 ] NEW_LINE N = len ( arr ) NEW_LINE findSplit ( arr , N ) NEW_LINE DEDENT;"Print indices of pair of array elements required to be removed to split array into 3 equal sum subarrays | Function to check if array can be split into three equal sum subarrays by removing two elements ; Stores sum of all three subarrays ; Sum of left subarray ; Sum of middle subarray ; Sum of right subarray ; Check if sum of subarrays are equal ; Print the possible pair ; If no pair exists , print - 1 ; Driver code ; Given array ; Size of the array"
Python;import math NEW_LINE def solve ( A , n , Q , q ) : NEW_LINE INDENT one = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( A [ i ] == 1 ) : NEW_LINE INDENT one += 1 NEW_LINE DEDENT DEDENT glows = 0 NEW_LINE count = 0 NEW_LINE if ( one >= int ( math . ceil ( n / 2 ) ) ) : NEW_LINE INDENT glows = 1 NEW_LINE DEDENT for i in range ( 0 , q ) : NEW_LINE INDENT prev = glows NEW_LINE if ( A [ Q [ i ] - 1 ] == 1 ) : NEW_LINE INDENT one -= 1 NEW_LINE DEDENT if ( A [ Q [ i ] - 1 ] == 0 ) : NEW_LINE INDENT one += 1 NEW_LINE DEDENT A [ Q [ i ] - 1 ] ^= 1 NEW_LINE if ( one >= int ( math . ceil ( n / 2.0 ) ) ) : NEW_LINE INDENT glows = 1 NEW_LINE DEDENT else : NEW_LINE INDENT glows = 0 NEW_LINE DEDENT if ( prev != glows ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 3 NEW_LINE arr = [ 1 , 1 , 0 ] NEW_LINE q = 3 NEW_LINE Q = [ 3 , 2 , 1 ] NEW_LINE print ( solve ( arr , n , Q , q ) ) NEW_LINE;"Count the number of times a Bulb switches its state | Python program for the above approach ; Function to find the number of times a bulb switches its state ; count of 1 's ; Traverse the array ; update the array ; update the status of bulb ; Traverse the array Q [ ] ; stores previous state of the bulb ; Toggle the switch and update the count of 1 's ; if the bulb switches state ; Return count ; Input ; Queries ; Function call to find number of times the bulb toggles"
Python;def sumOfDigits ( N ) : NEW_LINE INDENT sum = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT sum += N % 10 NEW_LINE N //= 10 NEW_LINE DEDENT return sum NEW_LINE DEDENT def elementsHavingDigitSumK ( arr , N , K ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( sumOfDigits ( arr [ i ] ) == K ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT print ( count ) NEW_LINE DEDENT arr = [ 23 , 54 , 87 , 29 , 92 , 62 ] NEW_LINE K = 11 NEW_LINE N = len ( arr ) NEW_LINE elementsHavingDigitSumK ( arr , N , K ) NEW_LINE;"Count array elements having sum of digits equal to K | Function to calculate the sum of digits of the number N ; Stores the sum of digits ; Return the sum ; Function to count array elements ; Store the count of array elements having sum of digits K ; Traverse the array ; If sum of digits is equal to K ; Increment the count ; Prthe count ; Given array ; Given value of K ; Size of the array ; Function call to count array elements having sum of digits equal to K"
Python;"def isOperand ( x ) : NEW_LINE INDENT return ( ( x >= ' a ' and x <= ' z ' ) or ( x >= ' A ' and x <= ' Z ' ) ) NEW_LINE DEDENT def getInfix ( exp ) : NEW_LINE INDENT s = [ ] NEW_LINE for i in exp : NEW_LINE INDENT if ( isOperand ( i ) ) : NEW_LINE INDENT s . insert ( 0 , i ) NEW_LINE DEDENT else : NEW_LINE INDENT op1 = s [ 0 ] NEW_LINE s . pop ( 0 ) NEW_LINE op2 = s [ 0 ] NEW_LINE s . pop ( 0 ) NEW_LINE s . insert ( 0 , "" ( "" + op2 + i + op1 + "" ) "" ) NEW_LINE DEDENT DEDENT return s [ 0 ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT exp = "" ab * c + "" NEW_LINE print ( getInfix ( exp . strip ( ) ) ) NEW_LINE DEDENT";"Postfix to Infix | Python3 program to find infix for a given postfix . ; Get Infix for a given postfix expression ; Push operands ; We assume that input is a valid postfix and expect an operator . ; There must be a single element in stack now which is the required infix . ; Driver Code"
Python;"class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def updatetree ( root ) : NEW_LINE INDENT if ( not root ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( root . left == None and root . right == None ) : NEW_LINE INDENT return root . data NEW_LINE DEDENT leftsum = updatetree ( root . left ) NEW_LINE rightsum = updatetree ( root . right ) NEW_LINE root . data += leftsum NEW_LINE return root . data + rightsum NEW_LINE DEDENT def inorder ( node ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return NEW_LINE DEDENT inorder ( node . left ) NEW_LINE print ( node . data , end = "" ▁ "" ) NEW_LINE inorder ( node . right ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . right . right = newNode ( 6 ) NEW_LINE updatetree ( root ) NEW_LINE print ( "" Inorder ▁ traversal ▁ of ▁ the ▁ modified ▁ tree ▁ is "" ) NEW_LINE inorder ( root ) NEW_LINE DEDENT";"Change a Binary Tree so that every node stores sum of all nodes in left subtree | Python3 program to store sum of nodes in left subtree in every node Binary Tree Node utility that allocates a new Node with the given key ; Construct to create a new node ; Function to modify a Binary Tree so that every node stores sum of values in its left child including its own value ; Base cases ; Update left and right subtrees ; Add leftsum to current node ; Return sum of values under root ; Utility function to do inorder traversal ; Driver Code ; Let us con below tree 1 / \ 2 3 / \ \ 4 5 6"
Python;"def calculateSpan ( price , n , S ) : NEW_LINE INDENT S [ 0 ] = 1 NEW_LINE for i in range ( 1 , n , 1 ) : NEW_LINE INDENT S [ i ] = 1 NEW_LINE j = i - 1 NEW_LINE while ( j >= 0 ) and ( price [ i ] >= price [ j ] ) : NEW_LINE INDENT S [ i ] += 1 NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT price = [ 10 , 4 , 5 , 90 , 120 , 80 ] NEW_LINE n = len ( price ) NEW_LINE S = [ None ] * n NEW_LINE calculateSpan ( price , n , S ) NEW_LINE printArray ( S , n ) NEW_LINE";"The Stock Span Problem | Fills list S [ ] with span values ; Span value of first day is always 1 ; Calculate span value of remaining days by linearly checking previous days ; Initialize span value ; Traverse left while the next element on left is smaller than price [ i ] ; A utility function to print elements of array ; Driver program to test above function ; Fill the span values in list S [ ] ; print the calculated span values"
Python;"def calculateSpan ( price , S ) : NEW_LINE INDENT n = len ( price ) NEW_LINE st = [ ] NEW_LINE st . append ( 0 ) NEW_LINE S [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( len ( st ) > 0 and price [ st [ - 1 ] ] <= price [ i ] ) : NEW_LINE INDENT st . pop ( ) NEW_LINE DEDENT S [ i ] = i + 1 if len ( st ) <= 0 else ( i - st [ - 1 ] ) NEW_LINE st . append ( i ) NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT price = [ 10 , 4 , 5 , 90 , 120 , 80 ] NEW_LINE S = [ 0 for i in range ( len ( price ) + 1 ) ] NEW_LINE calculateSpan ( price , S ) NEW_LINE printArray ( S , len ( price ) ) NEW_LINE";"The Stock Span Problem | A stack based efficient method to calculate s ; Create a stack and push index of fist element to it ; Span value of first element is always 1 ; Calculate span values for rest of the elements ; Pop elements from stack whlie stack is not empty and top of stack is smaller than price [ i ] ; If stack becomes empty , then price [ i ] is greater than all elements on left of it , i . e . price [ 0 ] , price [ 1 ] , . . price [ i - 1 ] . Else the price [ i ] is greater than elements after top of stack ; Push this element to stack ; A utility function to print elements of array ; Driver program to test above function ; Fill the span values in array S [ ] ; Print the calculated span values"
Python;def calculateSpan ( A , n , ans ) : NEW_LINE INDENT ans [ 0 ] = 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT counter = 1 NEW_LINE while ( ( i - counter ) >= 0 and A [ i ] >= A [ i - counter ] ) : NEW_LINE INDENT counter += ans [ i - counter ] NEW_LINE DEDENT ans [ i ] = counter NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT price = [ 10 , 4 , 5 , 90 , 120 , 80 ] NEW_LINE n = len ( price ) NEW_LINE S = [ 0 ] * ( n ) NEW_LINE calculateSpan ( price , n , S ) NEW_LINE printArray ( S , n ) NEW_LINE;"The Stock Span Problem | An efficient method to calculate stock span values implementing the same idea without using stack ; Span value of first element is always 1 ; Calculate span values for rest of the elements ; A utility function to print elements of array ; Driver code ; Fill the span values in array S [ ] ; Print the calculated span values"
Python;"def printNGE ( arr ) : NEW_LINE INDENT for i in range ( 0 , len ( arr ) , 1 ) : NEW_LINE INDENT next = - 1 NEW_LINE for j in range ( i + 1 , len ( arr ) , 1 ) : NEW_LINE INDENT if arr [ i ] < arr [ j ] : NEW_LINE INDENT next = arr [ j ] NEW_LINE break NEW_LINE DEDENT DEDENT print ( str ( arr [ i ] ) + "" ▁ - - ▁ "" + str ( next ) ) NEW_LINE DEDENT DEDENT arr = [ 11 , 13 , 21 , 3 ] NEW_LINE printNGE ( arr ) NEW_LINE";"Next Greater Element | Function to print element and NGE pair for all elements of list ; Driver program to test above function"
Python;"class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def mirror ( node ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return NEW_LINE DEDENT else : NEW_LINE INDENT temp = node NEW_LINE mirror ( node . left ) NEW_LINE mirror ( node . right ) NEW_LINE temp = node . left NEW_LINE node . left = node . right NEW_LINE node . right = temp NEW_LINE DEDENT DEDENT def inOrder ( node ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return NEW_LINE DEDENT inOrder ( node . left ) NEW_LINE print ( node . data , end = "" ▁ "" ) NEW_LINE inOrder ( node . right ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE print ( "" Inorder ▁ traversal ▁ of ▁ the "" , "" constructed ▁ tree ▁ is "" ) NEW_LINE inOrder ( root ) NEW_LINE mirror ( root ) NEW_LINE print ( "" Inorder traversal of "" , ▁ "" the mirror treeis   "" ) NEW_LINE inOrder ( root ) NEW_LINE DEDENT";"Convert a Binary Tree into its Mirror Tree | Utility function to create a new tree node ; Change a tree so that the roles of the left and right pointers are swapped at every node . So the tree ... 4 / \ 2 5 / \ 1 3 is changed to ... 4 / \ 5 2 / \ 3 1 ; do the subtrees ; swap the pointers in this node ; Helper function to print Inorder traversal . ; Driver code ; Print inorder traversal of the input tree ; Convert tree to its mirror ; Print inorder traversal of the mirror tree"
Python;def nextGreaterInLeft ( a ) : NEW_LINE INDENT left_index = [ 0 ] * len ( a ) NEW_LINE s = [ ] NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT while len ( s ) != 0 and a [ i ] >= a [ s [ - 1 ] ] : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT if len ( s ) != 0 : NEW_LINE INDENT left_index [ i ] = s [ - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT left_index [ i ] = 0 NEW_LINE DEDENT s . append ( i ) NEW_LINE DEDENT return left_index NEW_LINE DEDENT def nextGreaterInRight ( a ) : NEW_LINE INDENT right_index = [ 0 ] * len ( a ) NEW_LINE s = [ ] NEW_LINE for i in range ( len ( a ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT while len ( s ) != 0 and a [ i ] >= a [ s [ - 1 ] ] : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT if len ( s ) != 0 : NEW_LINE INDENT right_index [ i ] = s [ - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT right_index [ i ] = 0 NEW_LINE DEDENT s . append ( i ) NEW_LINE DEDENT return right_index NEW_LINE DEDENT def LRProduct ( arr ) : NEW_LINE INDENT left = nextGreaterInLeft ( arr ) NEW_LINE right = nextGreaterInRight ( arr ) NEW_LINE ans = - 1 NEW_LINE for i in range ( 1 , len ( left ) - 1 ) : NEW_LINE INDENT if left [ i ] == 0 or right [ i ] == 0 : NEW_LINE INDENT ans = max ( ans , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = ( left [ i ] + 1 ) * ( right [ i ] + 1 ) NEW_LINE ans = max ( ans , temp ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 5 , 4 , 3 , 4 , 5 ] NEW_LINE print ( LRProduct ( arr ) ) NEW_LINE;"Maximum product of indexes of next greater on left and right | Method to find the next greater value in left side ; Checking if current element is greater than top ; Pop the element till we can 't  get the larger value then  the current value ; Else push the element in the stack ; Method to find the next greater value in right ; Checking if current element is greater than top ; Pop the element till we can 't  get the larger value then  the current value ; Else push the element in the stack ; For each element storing the index of just greater element in left side ; For each element storing the index of just greater element in right side ; Finding the max index product ; Driver Code"
Python;"N = 8 NEW_LINE MATRIX = [ [ 0 , 0 , 1 , 0 ] , [ 0 , 0 , 1 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 1 , 0 ] ] NEW_LINE def knows ( a , b ) : NEW_LINE INDENT return MATRIX [ a ] [ b ] NEW_LINE DEDENT def findCelebrity ( n ) : NEW_LINE INDENT indegree = [ 0 for x in range ( n ) ] NEW_LINE outdegree = [ 0 for x in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT x = knows ( i , j ) NEW_LINE outdegree [ i ] += x NEW_LINE indegree [ j ] += x NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( indegree [ i ] == n - 1 and outdegree [ i ] == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE id_ = findCelebrity ( n ) NEW_LINE if id_ == - 1 : NEW_LINE INDENT print ( "" No ▁ celebrity "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Celebrity ▁ ID "" , id_ ) NEW_LINE DEDENT DEDENT";"The Celebrity Problem | Max ; Person with 2 is celebrity ; Returns - 1 if celebrity is not present . If present , returns id ( value from 0 to n - 1 ) ; The graph needs not be constructed as the edges can be found by using knows function degree array ; ; Query for all edges ; Set the degrees ; Find a person with indegree n - 1 and out degree 0 ; Driver code"
Python;"N = 8 NEW_LINE MATRIX = [ [ 0 , 0 , 1 , 0 ] , [ 0 , 0 , 1 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 1 , 0 ] ] NEW_LINE def knows ( a , b ) : NEW_LINE INDENT return MATRIX [ a ] [ b ] NEW_LINE DEDENT def findPotentialCelebrity ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT id_ = findPotentialCelebrity ( n - 1 ) NEW_LINE if ( id_ == - 1 ) : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT elif knows ( id_ , n - 1 ) : NEW_LINE INDENT return n - 1 NEW_LINE DEDENT elif knows ( n - 1 , id_ ) : NEW_LINE INDENT return id_ NEW_LINE DEDENT return - 1 NEW_LINE DEDENT def Celebrity ( n ) : NEW_LINE INDENT id_ = findPotentialCelebrity ( n ) NEW_LINE if ( id_ == - 1 ) : NEW_LINE INDENT return id_ NEW_LINE DEDENT else : NEW_LINE INDENT c1 = 0 NEW_LINE c2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i != id_ ) : NEW_LINE INDENT c1 += knows ( id_ , i ) NEW_LINE c2 += knows ( i , id_ ) NEW_LINE DEDENT DEDENT if ( c1 == 0 and c2 == n - 1 ) : NEW_LINE INDENT return id_ NEW_LINE DEDENT return - 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE id_ = Celebrity ( n ) NEW_LINE if id_ == - 1 : NEW_LINE INDENT print ( "" No ▁ celebrity "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Celebrity ▁ ID "" , id_ ) NEW_LINE DEDENT DEDENT";"The Celebrity Problem | Max ; Person with 2 is celebrity ; Returns - 1 if a potential celebrity is not present . If present , returns id ( value from 0 to n - 1 ) . ; Base case ; Find the celebrity with n - 1 persons ; If there are no celebrities ; if the id knows the nth person then the id cannot be a celebrity , but nth person could be on ; if the id knows the nth person then the id cannot be a celebrity , but nth person could be one ; If there is no celebrity ; Returns - 1 if celebrity is not present . If present , returns id ( value from 0 to n - 1 ) . a wrapper over findCelebrity ; Find the celebrity ; Check if the celebrity found is really the celebrity ; Check the id is really the celebrity ; If the person is known to everyone . ; Driver code"
Python;"class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def mirror ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE while ( len ( q ) ) : NEW_LINE INDENT curr = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE curr . left , curr . right = curr . right , curr . left NEW_LINE if ( curr . left ) : NEW_LINE INDENT q . append ( curr . left ) NEW_LINE DEDENT if ( curr . right ) : NEW_LINE INDENT q . append ( curr . right ) NEW_LINE DEDENT DEDENT DEDENT def inOrder ( node ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return NEW_LINE DEDENT inOrder ( node . left ) NEW_LINE print ( node . data , end = "" ▁ "" ) NEW_LINE inOrder ( node . right ) NEW_LINE DEDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE print ( "" Inorder ▁ traversal ▁ of ▁ the ▁ constructed ▁ tree ▁ is "" ) NEW_LINE inOrder ( root ) NEW_LINE mirror ( root ) NEW_LINE print ( "" Inorder traversal of the mirror tree is "" ) NEW_LINE inOrder ( root ) NEW_LINE";"Convert a Binary Tree into its Mirror Tree | A binary tree node has data , pointer to left child and a pointer to right child Helper function that allocates a new node with the given data and None left and right pointers ; Change a tree so that the roles of the left and right pointers are swapped at every node . So the tree ... 4 / \ 2 5 / \ 1 3 is changed to ... 4 / \ 5 2 / \ 3 1 ; Do BFS . While doing BFS , keep swapping left and right children ; pop top node from queue ; swap left child with right child ; append left and right children ; Helper function to print Inorder traversal . ; Driver code ; Print inorder traversal of the input tree ; Convert tree to its mirror ; Print inorder traversal of the mirror tree"
Python;"class Stack : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . items = [ ] NEW_LINE DEDENT def isEmpty ( self ) : NEW_LINE INDENT return self . items == [ ] NEW_LINE DEDENT def push ( self , item ) : NEW_LINE INDENT self . items . append ( item ) NEW_LINE DEDENT def pop ( self ) : NEW_LINE INDENT return self . items . pop ( ) NEW_LINE DEDENT def peek ( self ) : NEW_LINE INDENT return self . items [ len ( self . items ) - 1 ] NEW_LINE DEDENT def size ( self ) : NEW_LINE INDENT return len ( self . items ) NEW_LINE DEDENT DEDENT def deleteMid ( st , n , curr ) : NEW_LINE INDENT if ( st . isEmpty ( ) or curr == n ) : NEW_LINE INDENT return NEW_LINE DEDENT x = st . peek ( ) NEW_LINE st . pop ( ) NEW_LINE deleteMid ( st , n , curr + 1 ) NEW_LINE if ( curr != int ( n / 2 ) ) : NEW_LINE INDENT st . push ( x ) NEW_LINE DEDENT DEDENT st = Stack ( ) NEW_LINE st . push ( '1' ) NEW_LINE st . push ( '2' ) NEW_LINE st . push ( '3' ) NEW_LINE st . push ( '4' ) NEW_LINE st . push ( '5' ) NEW_LINE st . push ( '6' ) NEW_LINE st . push ( '7' ) NEW_LINE deleteMid ( st , st . size ( ) , 0 ) NEW_LINE while ( st . isEmpty ( ) == False ) : NEW_LINE INDENT p = st . peek ( ) NEW_LINE st . pop ( ) NEW_LINE print ( str ( p ) + "" ▁ "" , end = "" "" ) NEW_LINE DEDENT";"Delete middle element of a stack | Deletes middle of stack of size n . Curr is current item number ; If stack is empty or all items are traversed ; Remove current item ; Remove other items ; Put all items back except middle ; Driver function to test above functions ; push elements into the stack ; Printing stack after deletion of middle ."
Python;"def sortStack ( input ) : NEW_LINE INDENT tmpStack = [ ] NEW_LINE while ( len ( input ) > 0 ) : NEW_LINE INDENT tmp = input [ - 1 ] NEW_LINE input . pop ( ) NEW_LINE while ( len ( tmpStack ) > 0 and tmpStack [ - 1 ] < tmp ) : NEW_LINE INDENT input . append ( tmpStack [ - 1 ] ) NEW_LINE tmpStack . pop ( ) NEW_LINE DEDENT tmpStack . append ( tmp ) NEW_LINE DEDENT return tmpStack NEW_LINE DEDENT def sortArrayUsingStacks ( arr , n ) : NEW_LINE INDENT input = [ ] NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT input . append ( arr [ i ] ) NEW_LINE i = i + 1 NEW_LINE DEDENT tmpStack = sortStack ( input ) NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT arr [ i ] = tmpStack [ - 1 ] NEW_LINE tmpStack . pop ( ) NEW_LINE i = i + 1 NEW_LINE DEDENT return arr NEW_LINE DEDENT arr = [ 10 , 5 , 15 , 45 ] NEW_LINE n = len ( arr ) NEW_LINE arr = sortArrayUsingStacks ( arr , n ) NEW_LINE i = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE i = i + 1 NEW_LINE DEDENT";"Sorting array using Stacks | This function return the sorted stack ; pop out the first element ; while temporary stack is not empty and top of stack is smaller than temp ; pop from temporary stack and append it to the input stack ; append temp in tempory of stack ; append array elements to stack ; Sort the temporary stack ; Put stack elements in arrp [ ] ; Driver code"
Python;"class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def push ( head_ref , node ) : NEW_LINE INDENT node . right = ( head_ref ) NEW_LINE node . left = None NEW_LINE if ( ( head_ref ) != None ) : NEW_LINE INDENT ( head_ref ) . left = node NEW_LINE DEDENT ( head_ref ) = node NEW_LINE DEDENT def printList ( node ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < len ( node ) ) : NEW_LINE INDENT print ( node [ i ] . data , end = "" ▁ "" ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT def spiralLevelOrder ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE stk = [ ] NEW_LINE level = 0 NEW_LINE while ( len ( q ) ) : NEW_LINE INDENT nodeCount = len ( q ) NEW_LINE if ( level & 1 ) : NEW_LINE INDENT while ( nodeCount > 0 ) : NEW_LINE INDENT node = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE stk . append ( node ) NEW_LINE if ( node . left != None ) : NEW_LINE INDENT q . append ( node . left ) NEW_LINE DEDENT if ( node . right != None ) : NEW_LINE INDENT q . append ( node . right ) NEW_LINE DEDENT nodeCount -= 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT while ( nodeCount > 0 ) : NEW_LINE INDENT node = q [ - 1 ] NEW_LINE q . pop ( - 1 ) NEW_LINE stk . append ( node ) NEW_LINE if ( node . right != None ) : NEW_LINE INDENT q . insert ( 0 , node . right ) NEW_LINE DEDENT if ( node . left != None ) : NEW_LINE INDENT q . insert ( 0 , node . left ) NEW_LINE DEDENT nodeCount -= 1 NEW_LINE DEDENT DEDENT level += 1 NEW_LINE DEDENT head = [ ] NEW_LINE while ( len ( stk ) ) : NEW_LINE INDENT head . append ( stk [ 0 ] ) NEW_LINE stk . pop ( 0 ) NEW_LINE DEDENT print ( "" Created ▁ DLL ▁ is : "" ) NEW_LINE printList ( head ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 4 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . right . left = newNode ( 6 ) NEW_LINE root . right . right = newNode ( 7 ) NEW_LINE root . left . left . left = newNode ( 8 ) NEW_LINE root . left . left . right = newNode ( 9 ) NEW_LINE root . left . right . left = newNode ( 10 ) NEW_LINE root . left . right . right = newNode ( 11 ) NEW_LINE root . right . left . right = newNode ( 13 ) NEW_LINE root . right . right . left = newNode ( 14 ) NEW_LINE spiralLevelOrder ( root ) NEW_LINE DEDENT";"Convert a Binary Tree into Doubly Linked List in spiral fashion | Binary tree node ; Given a reference to the head of a list and a node , inserts the node on the front of the list . ; Make right of given node as head and left as None ; change left of head node to given node ; move the head to point to the given node ; Function to prints contents of DLL ; Function to prcorner node at each level ; Base Case ; Create an empty deque for doing spiral level order traversal and enqueue root ; create a stack to store Binary Tree nodes to insert into DLL later ; nodeCount indicates number of Nodes at current level . ; Dequeue all Nodes of current level and Enqueue all Nodes of next level odd level ; dequeue node from front & push it to stack ; insert its left and right children in the back of the deque ; even level ; dequeue node from the back & push it to stack ; inserts its right and left children in the front of the deque ; head pointer for DLL ; pop all nodes from stack and push them in the beginning of the list ; Driver Code ; Let us create Binary Tree as shown in above example ; root . right . left . left = newNode ( 12 ) ; root . right . right . right = newNode ( 15 )"
Python;"def reverserWords ( string ) : NEW_LINE INDENT st = list ( ) NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if string [ i ] != "" ▁ "" : NEW_LINE INDENT st . append ( string [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT while len ( st ) > 0 : NEW_LINE INDENT print ( st [ - 1 ] , end = "" "" ) NEW_LINE st . pop ( ) NEW_LINE DEDENT print ( end = "" ▁ "" ) NEW_LINE DEDENT DEDENT while len ( st ) > 0 : NEW_LINE INDENT print ( st [ - 1 ] , end = "" "" ) NEW_LINE st . pop ( ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT string = "" Geeks ▁ for ▁ Geeks "" NEW_LINE reverserWords ( string ) NEW_LINE DEDENT";"Reverse individual words | reverses individual words of a string ; Traverse given string and push all characters to stack until we see a space . ; When we see a space , we print contents of stack . ; Since there may not be space after last word . ; Driver Code"
Python;"from typing import List NEW_LINE MAXN = 100005 NEW_LINE def makeNext ( arr : List [ int ] , n : int , nextBig : List [ int ] ) -> None : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT nextBig [ i ] = i NEW_LINE while len ( s ) and s [ - 1 ] [ 0 ] < arr [ i ] : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT if len ( s ) : NEW_LINE INDENT nextBig [ i ] = s [ - 1 ] [ 1 ] NEW_LINE DEDENT s . append ( ( arr [ i ] , i ) ) NEW_LINE DEDENT DEDENT def makePrev ( arr : List [ int ] , n : int , prevBig : List [ int ] ) -> None : NEW_LINE INDENT s = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT prevBig [ i ] = - 1 NEW_LINE while ( len ( s ) and s [ - 1 ] [ 0 ] < arr [ i ] ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT if ( len ( s ) ) : NEW_LINE INDENT prevBig [ i ] = s [ - 1 ] [ 1 ] NEW_LINE DEDENT s . append ( ( arr [ i ] , i ) ) NEW_LINE DEDENT DEDENT def wrapper ( arr : List [ int ] , n : int ) -> int : NEW_LINE INDENT nextBig = [ 0 ] * MAXN NEW_LINE prevBig = [ 0 ] * MAXN NEW_LINE maxi = [ 0 ] * MAXN NEW_LINE ans = 0 NEW_LINE makePrev ( arr , n , prevBig ) NEW_LINE makeNext ( arr , n , nextBig ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( nextBig [ i ] != i ) : NEW_LINE INDENT maxi [ nextBig [ i ] - i ] = max ( maxi [ nextBig [ i ] - i ] , i - prevBig [ i ] ) NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT ans += maxi [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 3 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( wrapper ( arr , n ) ) NEW_LINE DEDENT";"Count subarrays where second highest lie before highest | Python3 program to count number of distinct instance where second highest number lie before highest number in all subarrays . ; Finding the next greater element of the array . ; Finding the previous greater element of the array . ; Wrapper Function ; Finding previous largest element ; Finding next largest element ; Driver Code"
Python;"def TowerOfHanoi ( n , from_rod , to_rod , aux_rod ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT print ( "" Move ▁ disk ▁ 1 ▁ from ▁ rod "" , from_rod , "" to ▁ rod "" , to_rod ) NEW_LINE return NEW_LINE DEDENT TowerOfHanoi ( n - 1 , from_rod , aux_rod , to_rod ) NEW_LINE print ( "" Move ▁ disk "" , n , "" from ▁ rod "" , from_rod , "" to ▁ rod "" , to_rod ) NEW_LINE TowerOfHanoi ( n - 1 , aux_rod , to_rod , from_rod ) NEW_LINE DEDENT n = 4 NEW_LINE TowerOfHanoi ( n , ' A ' , ' C ' , ' B ' ) NEW_LINE";"Program for Tower of Hanoi | Recursive Python function to solve tower of hanoi ; Number of disks ; A , C , B are the name of rods"
Python;"INT_MIN = - 1000000 NEW_LINE def printMaxOfMin ( arr , n ) : NEW_LINE INDENT for k in range ( 1 , n + 1 ) : NEW_LINE INDENT maxOfMin = INT_MIN ; NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE for j in range ( k ) : NEW_LINE INDENT if ( arr [ i + j ] < min ) : NEW_LINE INDENT min = arr [ i + j ] NEW_LINE DEDENT DEDENT if ( min > maxOfMin ) : NEW_LINE INDENT maxOfMin = min NEW_LINE DEDENT DEDENT print ( maxOfMin , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT arr = [ 10 , 20 , 30 , 50 , 10 , 70 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE printMaxOfMin ( arr , n ) NEW_LINE";"Find maximum of minimum for every window size in a given array | A naive method to find maximum of minimum of all windows of different sizes ; Consider all windows of different sizes starting from size 1 ; Initialize max of min for current window size k ; Traverse through all windows of current size k ; Find minimum of current window ; Update maxOfMin if required ; Print max of min for current window size ; Driver Code"
Python;"def printMaxOfMin ( arr , n ) : NEW_LINE INDENT s = [ ] NEW_LINE left = [ - 1 ] * ( n + 1 ) NEW_LINE right = [ n ] * ( n + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( len ( s ) != 0 and arr [ s [ - 1 ] ] >= arr [ i ] ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT if ( len ( s ) != 0 ) : NEW_LINE INDENT left [ i ] = s [ - 1 ] NEW_LINE DEDENT s . append ( i ) NEW_LINE DEDENT while ( len ( s ) != 0 ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( len ( s ) != 0 and arr [ s [ - 1 ] ] >= arr [ i ] ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT if ( len ( s ) != 0 ) : NEW_LINE INDENT right [ i ] = s [ - 1 ] NEW_LINE DEDENT s . append ( i ) NEW_LINE DEDENT ans = [ 0 ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT ans [ i ] = 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT Len = right [ i ] - left [ i ] - 1 NEW_LINE ans [ Len ] = max ( ans [ Len ] , arr [ i ] ) NEW_LINE DEDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT ans [ i ] = max ( ans [ i ] , ans [ i + 1 ] ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( ans [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 20 , 30 , 50 , 10 , 70 , 30 ] NEW_LINE n = len ( arr ) NEW_LINE printMaxOfMin ( arr , n ) NEW_LINE DEDENT";"Find maximum of minimum for every window size in a given array | An efficient Python3 program to find maximum of all minimums of windows of different sizes ; Used to find previous and next smaller ; Initialize elements of left [ ] and right [ ] ; Fill elements of left [ ] using logic discussed on www . geeksforgeeks . org / next - greater - element https : ; Empty the stack as stack is going to be used for right [ ] ; Fill elements of right [ ] using same logic ; Create and initialize answer array ; Fill answer array by comparing minimums of all . Lengths computed using left [ ] and right [ ] ; Length of the interval ; arr [ i ] is a possible answer for this Length ' Len ' interval , check if arr [ i ] is more than max for 'Len   ; Some entries in ans [ ] may not be filled yet . Fill them by taking values from right side of ans [ ] ; Print the result ; Driver Code"
Python;"def findMaxLen ( string ) : NEW_LINE INDENT n = len ( string ) NEW_LINE stk = [ ] NEW_LINE stk . append ( - 1 ) NEW_LINE result = 0 NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT if string [ i ] == ' ( ' : NEW_LINE INDENT stk . append ( i ) NEW_LINE DEDENT else : NEW_LINE INDENT if len ( stk ) != 0 : NEW_LINE stk . pop ( ) NEW_LINE if len ( stk ) != 0 : NEW_LINE INDENT result = max ( result , i - stk [ len ( stk ) - 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stk . append ( i ) NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT string = "" ( ( ( ) ( ) "" NEW_LINE print findMaxLen ( string ) NEW_LINE string = "" ( ) ( ( ) ) ) ) ) "" NEW_LINE print findMaxLen ( string ) NEW_LINE";"Length of the longest valid substring | method to get length of the longest valid ; Create a stack and push - 1 as initial index to it . ; Initialize result ; Traverse all characters of given string ; If opening bracket , push index of it ; If closing bracket ; Pop the previous opening bracket 's index ; Check if this length formed with base of current valid substring is more than max so far ; If stack is empty . push current index as base for next valid substring ( if any ) ; Driver code ; Function call ; Function call"
Python;def dfs ( tree , visit , ans , node ) : NEW_LINE INDENT num = 0 NEW_LINE temp = 0 NEW_LINE visit [ node ] = 1 NEW_LINE for i in range ( len ( tree [ node ] ) ) : NEW_LINE INDENT if ( visit [ tree [ node ] [ i ] ] == 0 ) : NEW_LINE INDENT temp = dfs ( tree , visit , ans , tree [ node ] [ i ] ) NEW_LINE if ( temp % 2 ) : NEW_LINE INDENT num += temp NEW_LINE DEDENT else : NEW_LINE INDENT ans [ 0 ] += 1 NEW_LINE DEDENT DEDENT DEDENT return num + 1 NEW_LINE DEDENT def minEdge ( tree , n ) : NEW_LINE INDENT visit = [ 0 ] * ( n + 2 ) NEW_LINE ans = [ 0 ] NEW_LINE dfs ( tree , visit , ans , 1 ) NEW_LINE return ans [ 0 ] NEW_LINE DEDENT N = 12 NEW_LINE n = 10 NEW_LINE tree = [ [ ] for i in range ( n + 2 ) ] NEW_LINE tree [ 1 ] . append ( 3 ) NEW_LINE tree [ 3 ] . append ( 1 ) NEW_LINE tree [ 1 ] . append ( 6 ) NEW_LINE tree [ 6 ] . append ( 1 ) NEW_LINE tree [ 1 ] . append ( 2 ) NEW_LINE tree [ 2 ] . append ( 1 ) NEW_LINE tree [ 3 ] . append ( 4 ) NEW_LINE tree [ 4 ] . append ( 3 ) NEW_LINE tree [ 6 ] . append ( 8 ) NEW_LINE tree [ 8 ] . append ( 6 ) NEW_LINE tree [ 2 ] . append ( 7 ) NEW_LINE tree [ 7 ] . append ( 2 ) NEW_LINE tree [ 2 ] . append ( 5 ) NEW_LINE tree [ 5 ] . append ( 2 ) NEW_LINE tree [ 4 ] . append ( 9 ) NEW_LINE tree [ 9 ] . append ( 4 ) NEW_LINE tree [ 4 ] . append ( 10 ) NEW_LINE tree [ 10 ] . append ( 4 ) NEW_LINE print ( minEdge ( tree , n ) ) NEW_LINE;"Convert a tree to forest of even nodes | Return the number of nodes of subtree having node as a root . ; Mark node as visited . ; Traverse the adjacency list to find non - visited node . ; Finding number of nodes of the subtree of a subtree . ; If nodes are even , increment number of edges to removed . Else leave the node as child of subtree . ; Return the maximum number of edge to remove to make forest . ; Driver Code"
Python;"def findMaxLen ( s ) : NEW_LINE INDENT if ( len ( s ) <= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT curMax = 0 NEW_LINE longest = [ 0 ] * ( len ( s ) ) NEW_LINE for i in range ( 1 , len ( s ) ) : NEW_LINE INDENT if ( ( s [ i ] == ' ) ' and i - longest [ i - 1 ] - 1 >= 0 and s [ i - longest [ i - 1 ] - 1 ] == ' ( ' ) ) : NEW_LINE INDENT longest [ i ] = longest [ i - 1 ] + 2 NEW_LINE if ( i - longest [ i - 1 ] - 2 >= 0 ) : NEW_LINE INDENT longest [ i ] += ( longest [ i - longest [ i - 1 ] - 2 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT longest [ i ] += 0 NEW_LINE DEDENT curMax = max ( longest [ i ] , curMax ) NEW_LINE DEDENT DEDENT return curMax NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Str = "" ( ( ( ) ( ) "" NEW_LINE print ( findMaxLen ( Str ) ) NEW_LINE Str = "" ( ) ( ( ) ) ) ) ) "" NEW_LINE print ( findMaxLen ( Str ) ) NEW_LINE DEDENT";"Length of the longest valid substring | Python3 program to find length of the longest valid substring ; Initialize curMax to zero ; Iterate over the string starting from second index ; Driver Code ; Function call ; Function call"
Python;"def solve ( s , n ) : NEW_LINE INDENT left = 0 NEW_LINE right = 0 NEW_LINE maxlength = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT right += 1 NEW_LINE DEDENT if ( left == right ) : NEW_LINE INDENT maxlength = max ( maxlength , 2 * right ) NEW_LINE DEDENT elif ( right > left ) : NEW_LINE INDENT left = right = 0 NEW_LINE DEDENT DEDENT left = right = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT left += 1 NEW_LINE DEDENT else : NEW_LINE INDENT right += 1 NEW_LINE DEDENT if ( left == right ) : NEW_LINE INDENT maxlength = max ( maxlength , 2 * left ) NEW_LINE DEDENT elif ( left > right ) : NEW_LINE INDENT left = right = 0 NEW_LINE DEDENT DEDENT return maxlength NEW_LINE DEDENT print ( solve ( "" ( ( ( ) ( ) ( ) ( ) ( ( ( ( ) ) "" , 16 ) ) NEW_LINE";"Length of the longest valid substring | Function to return the length of the longest valid substring ; Variables for left and right counter . maxlength to store the maximum length found so far ; Iterating the string from left to right ; If "" ( "" is encountered , then left counter is incremented else right counter is incremented ; Whenever left is equal to right , it signifies that the subsequence is valid and ; Reseting the counters when the subsequence becomes invalid ; Iterating the string from right to left ; If "" ( "" is encountered , then left counter is incremented else right counter is incremented ; Whenever left is equal to right , it signifies that the subsequence is valid and ; Reseting the counters when the subsequence becomes invalid ; Function call"
Python;"def checkRedundancy ( Str ) : NEW_LINE INDENT st = [ ] NEW_LINE for ch in Str : NEW_LINE INDENT if ( ch == ' ) ' ) : NEW_LINE INDENT top = st [ - 1 ] NEW_LINE st . pop ( ) NEW_LINE flag = True NEW_LINE while ( top != ' ( ' ) : NEW_LINE INDENT if ( top == ' + ' or top == ' - ' or top == ' * ' or top == ' / ' ) : NEW_LINE INDENT flag = False NEW_LINE DEDENT top = st [ - 1 ] NEW_LINE st . pop ( ) NEW_LINE DEDENT if ( flag == True ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT st . append ( ch ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def findRedundant ( Str ) : NEW_LINE INDENT ans = checkRedundancy ( Str ) NEW_LINE if ( ans == True ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Str = "" ( ( a + b ) ) "" NEW_LINE findRedundant ( Str ) NEW_LINE Str = "" ( a + ( b ) / c ) "" NEW_LINE findRedundant ( Str ) NEW_LINE Str = "" ( a + b * ( c - d ) ) "" NEW_LINE findRedundant ( Str ) NEW_LINE DEDENT";"Expression contains redundant bracket or not | Function to check redundant brackets in a balanced expression ; create a stack of characters ; Iterate through the given expression ; if current character is close parenthesis ')   ; If immediate pop have open parenthesis ' ( ' duplicate brackets found ; Check for operators in expression ; Fetch top element of stack ; If operators not found ; append open parenthesis ' ( ' , ; operators and operands to stack ; Function to check redundant brackets ; Driver code"
Python;"MAX_CHAR = 26 ; NEW_LINE def adjSign ( s , i ) : NEW_LINE INDENT if ( i == 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( s [ i - 1 ] == ' - ' ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def eval ( s , v , add ) : NEW_LINE INDENT stk = [ ] NEW_LINE stk . append ( True ) ; NEW_LINE i = 0 ; NEW_LINE while ( i < len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == ' + ' or s [ i ] == ' - ' ) : NEW_LINE i += 1 NEW_LINE continue ; NEW_LINE if ( s [ i ] == ' ( ' ) : NEW_LINE if ( adjSign ( s , i ) ) : NEW_LINE INDENT stk . append ( stk [ - 1 ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT stk . append ( not stk [ - 1 ] ) ; NEW_LINE DEDENT elif ( s [ i ] == ' ) ' ) : NEW_LINE stk . pop ( ) ; NEW_LINE else : NEW_LINE if ( stk [ - 1 ] ) : NEW_LINE INDENT v [ ord ( s [ i ] ) - ord ( ' a ' ) ] += ( 1 if add else - 1 ) if adjSign ( s , i ) else ( - 1 if add else 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT v [ ord ( s [ i ] ) - ord ( ' a ' ) ] += ( - 1 if add else 1 ) if adjSign ( s , i ) else ( 1 if add else - 1 ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT DEDENT def areSame ( expr1 , expr2 ) : NEW_LINE INDENT v = [ 0 for i in range ( MAX_CHAR ) ] ; NEW_LINE eval ( expr1 , v , True ) ; NEW_LINE eval ( expr2 , v , False ) ; NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( v [ i ] != 0 ) : NEW_LINE return False ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT expr1 = "" - ( a + b + c ) "" NEW_LINE expr2 = "" - a - b - c "" ; NEW_LINE if ( areSame ( expr1 , expr2 ) ) : NEW_LINE INDENT print ( "" Yes "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) ; NEW_LINE DEDENT DEDENT";"Check if two expressions with brackets are same | Python3 program to check if two expressions evaluate to same . ; Return local sign of the operand . For example , in the expr a - b - ( c ) , local signs of the operands are + a , - b , + c ; Evaluate expressions into the count vector of the 26 alphabets . If add is True , then add count to the count vector of the alphabets , else remove count from the count vector . ; stack stores the global sign for operands . ; + means True global sign is positive initially ; global sign for the bracket is pushed to the stack ; global sign is popped out which was pushed in for the last bracket ; global sign is positive ( we use different values in two calls of functions so that we finally check if all vector elements are 0. ; global sign is negative here ; Returns True if expr1 and expr2 represent same expressions ; Create a vector for all operands and initialize the vector as 0. ; Put signs of all operands in expr1 ; Subtract signs of operands in expr2 ; If expressions are same , vector must be 0. ; Driver Code"
Python;"from collections import deque NEW_LINE def getIndex ( s , i ) : NEW_LINE INDENT if s [ i ] != ' [ ' : NEW_LINE INDENT return - 1 NEW_LINE DEDENT d = deque ( ) NEW_LINE for k in range ( i , len ( s ) ) : NEW_LINE INDENT if s [ k ] == ' [ ' : NEW_LINE INDENT d . append ( s [ i ] ) NEW_LINE DEDENT elif s [ k ] == ' ] ' : NEW_LINE INDENT d . popleft ( ) NEW_LINE DEDENT if not d : NEW_LINE INDENT return k NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def test ( s , i ) : NEW_LINE INDENT matching_index = getIndex ( s , i ) NEW_LINE print ( s + "" , ▁ "" + str ( i ) + "" : ▁ "" + str ( matching_index ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT test ( "" [ ABC [ 23 ] ] [89 ] "" , 0 ) NEW_LINE test ( "" [ ABC [ 23 ] ] [89 ] "" , 4 ) NEW_LINE test ( "" [ ABC [ 23 ] ] [89 ] "" , 9 ) NEW_LINE test ( "" [ ABC [ 23 ] ] [89 ] "" , 1 ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT main ( ) NEW_LINE DEDENT";"Find index of closing bracket for a given opening bracket in an expression | Python program to find index of closing bracket for a given opening bracket . ; Function to find index of closing bracket for given opening bracket . ; If input is invalid . ; Create a deque to use it as a stack . ; Traverse through all elements starting from i . ; Push all starting brackets ; Pop a starting bracket for every closing bracket ; If deque becomes empty ; test function ; Driver code to test above method . ; should be 8 ; should be 7 ; should be 12 ; No matching bracket ; execution"
Python;"class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def convertTree ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT convertTree ( root . left ) NEW_LINE convertTree ( root . right ) NEW_LINE if ( root . left != None and root . right != None ) : NEW_LINE INDENT root . data = ( ( root . left . data ) & ( root . right . data ) ) NEW_LINE DEDENT DEDENT def printInorder ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT printInorder ( root . left ) NEW_LINE print ( root . data , end = "" ▁ "" ) NEW_LINE printInorder ( root . right ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 0 ) NEW_LINE root . left = newNode ( 1 ) NEW_LINE root . right = newNode ( 0 ) NEW_LINE root . left . left = newNode ( 0 ) NEW_LINE root . left . right = newNode ( 1 ) NEW_LINE root . right . left = newNode ( 1 ) NEW_LINE root . right . right = newNode ( 1 ) NEW_LINE print ( "" Inorder ▁ traversal ▁ before ▁ conversion "" , end = "" ▁ "" ) NEW_LINE printInorder ( root ) NEW_LINE convertTree ( root ) NEW_LINE print ( "" Inorder traversal after conversion "" , ▁ end ▁ = ▁ ""   "" ) NEW_LINE printInorder ( root ) NEW_LINE DEDENT";"Convert a given Binary tree to a tree that holds Logical AND property | Program to convert an aribitary binary tree to a tree that holds children sum property Helper function that allocates a new node with the given data and None left and right poers . ; Construct to create a new node ; Convert the given tree to a tree where each node is logical AND of its children The main idea is to do Postorder traversal ; first recur on left child ; then recur on right child ; first recur on left child ; then print the data of node ; now recur on right child ; Driver Code ; Create following Binary Tree 1 / \ 1 0 / \ / \ 0 1 1 1"
Python;"def findDuplicateparenthesis ( string ) : NEW_LINE INDENT Stack = [ ] NEW_LINE for ch in string : NEW_LINE INDENT if ch == ' ) ' : NEW_LINE INDENT top = Stack . pop ( ) NEW_LINE elementsInside = 0 NEW_LINE while top != ' ( ' : NEW_LINE INDENT elementsInside += 1 NEW_LINE top = Stack . pop ( ) NEW_LINE DEDENT if elementsInside < 1 : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT Stack . append ( ch ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT string = "" ( ( ( a + ( b ) ) + ( c + d ) ) ) "" NEW_LINE if findDuplicateparenthesis ( string ) == True : NEW_LINE INDENT print ( "" Duplicate ▁ Found "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No ▁ Duplicates ▁ Found "" ) NEW_LINE DEDENT DEDENT";"Find if an expression has duplicate parenthesis or not | Function to find duplicate parenthesis in a balanced expression ; create a stack of characters ; Iterate through the given expression ; if current character is close parenthesis ' ) ' ; pop character from the stack ; stores the number of characters between a closing and opening parenthesis if this count is less than or equal to 1 then the brackets are redundant else not ; push open parenthesis ' ( ' , operators and operands to stack ; No duplicates found ; Driver Code ; input balanced expression"
Python;"def nextGreater ( arr , n , next , order ) : NEW_LINE INDENT S = [ ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT while ( S != [ ] and ( arr [ S [ len ( S ) - 1 ] ] <= arr [ i ] if ( order == ' G ' ) else arr [ S [ len ( S ) - 1 ] ] >= arr [ i ] ) ) : NEW_LINE INDENT S . pop ( ) NEW_LINE DEDENT if ( S != [ ] ) : NEW_LINE INDENT next [ i ] = S [ len ( S ) - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT next [ i ] = - 1 NEW_LINE DEDENT S . append ( i ) NEW_LINE DEDENT DEDENT def nextSmallerOfNextGreater ( arr , n ) : NEW_LINE INDENT NG = [ None ] * n NEW_LINE RS = [ None ] * n NEW_LINE nextGreater ( arr , n , NG , ' G ' ) NEW_LINE nextGreater ( arr , n , RS , ' S ' ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( NG [ i ] != - 1 and RS [ NG [ i ] ] != - 1 ) : NEW_LINE INDENT print ( arr [ RS [ NG [ i ] ] ] , end = "" ▁ "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" - 1"" , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 5 , 1 , 9 , 2 , 5 , 1 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE nextSmallerOfNextGreater ( arr , n ) NEW_LINE DEDENT";"Find next Smaller of next Greater in an array | function find Next greater element ; create empty stack ; Traverse all array elements in reverse order order == ' G ' we compute next greater elements of every element order == ' S ' we compute right smaller element of every element ; Keep removing top element from S while the top element is smaller then or equal to arr [ i ] ( if Key is G ) element is greater then or equal to arr [ i ] ( if order is S ) ; store the next greater element of current element ; If all elements in S were smaller than arr [ i ] ; Push this element ; Function to find Right smaller element of next greater element ; stores indexes of next greater elements ; stores indexes of right smaller elements ; Find next greater element Here G indicate next greater element ; Find right smaller element using same function nextGreater ( ) Here S indicate right smaller elements ; If NG [ i ] = = - 1 then there is no smaller element on right side . We can find Right smaller of next greater by arr [ RS [ NG [ i ] ] ] ; Driver program"
Python;"class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def convert_expression ( expression , i ) : NEW_LINE INDENT if i >= len ( expression ) : NEW_LINE INDENT return None NEW_LINE DEDENT root = Node ( expression [ i ] ) NEW_LINE i += 1 NEW_LINE if ( i < len ( expression ) and expression [ i ] == "" ? "" ) : NEW_LINE INDENT root . left = convert_expression ( expression , i + 1 ) NEW_LINE DEDENT elif i < len ( expression ) : NEW_LINE INDENT root . right = convert_expression ( expression , i + 1 ) NEW_LINE DEDENT return root NEW_LINE DEDENT def print_tree ( root ) : NEW_LINE INDENT if not root : NEW_LINE INDENT return NEW_LINE DEDENT print ( root . data , end = ' ▁ ' ) NEW_LINE print_tree ( root . left ) NEW_LINE print_tree ( root . right ) NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT string_expression = "" a ? b ? c : d : e "" NEW_LINE root_node = convert_expression ( string_expression , 0 ) NEW_LINE print_tree ( root_node ) NEW_LINE DEDENT";"Convert Ternary Expression to a Binary Tree | Class to define a node structure of the tree ; Function to convert ternary expression to a Binary tree It returns the root node of the tree ; Base case ; Create a new node object for the expression at ith index ; Move ahead in str ; if current character of ternary expression is ' ? ' then we add next character as a left child of current node ; else we have to add it as a right child of current node expression [ 0 ] = = ':   ; Function to print the tree in a pre - order traversal pattern ; Driver Code"
Python;def countNumber ( n ) : NEW_LINE INDENT result = 0 NEW_LINE s = [ ] NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( i <= n ) : NEW_LINE INDENT s . append ( i ) NEW_LINE result += 1 NEW_LINE DEDENT while len ( s ) != 0 : NEW_LINE INDENT tp = s [ - 1 ] NEW_LINE s . pop ( ) NEW_LINE for j in range ( tp % 10 , 10 ) : NEW_LINE INDENT x = tp * 10 + j NEW_LINE if ( x <= n ) : NEW_LINE INDENT s . append ( x ) NEW_LINE result += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 15 NEW_LINE print ( countNumber ( n ) ) NEW_LINE DEDENT;"Count natural numbers whose all permutation are greater than that number | Return the count of the number having all permutation greater than or equal to the number . ; Pushing 1 to 9 because all number from 1 to 9 have this property . ; take a number from stack and add a digit smaller than last digit of it . ; Driver Code"
Python;"def removeConsecutiveSame ( v ) : NEW_LINE INDENT n = len ( v ) NEW_LINE i = 0 NEW_LINE while ( i < n - 1 ) : NEW_LINE INDENT if ( ( i + 1 ) < len ( v ) ) and ( v [ i ] == v [ i + 1 ] ) : NEW_LINE INDENT v = v [ : i ] NEW_LINE v = v [ : i ] NEW_LINE if ( i > 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT n = n - 2 NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return len ( v [ : i - 1 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT v = [ "" tom "" , "" jerry "" , "" jerry "" , "" tom "" ] NEW_LINE print ( removeConsecutiveSame ( v ) ) NEW_LINE DEDENT";"Delete consecutive same words in a sequence | Function to find the size of manipulated sequence ; Start traversing the sequence ; Compare the current string with next one Erase both if equal ; Erase function delete the element and also shifts other element that 's why   i is not updated  ; Update i , as to check from previous element again ; Reduce sequence size ; Increment i , if not equal ; Return modified size ; Driver Code"
Python;"def removeConsecutiveSame ( v ) : NEW_LINE INDENT st = [ ] NEW_LINE for i in range ( len ( v ) ) : NEW_LINE INDENT if ( len ( st ) == 0 ) : NEW_LINE INDENT st . append ( v [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT Str = st [ - 1 ] NEW_LINE if ( Str == v [ i ] ) : NEW_LINE INDENT st . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT st . append ( v [ i ] ) NEW_LINE DEDENT DEDENT DEDENT return len ( st ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT V = [ "" ab "" , "" aa "" , "" aa "" , "" bcd "" , "" ab "" ] NEW_LINE print ( removeConsecutiveSame ( V ) ) NEW_LINE DEDENT";"Delete consecutive same words in a sequence | Function to find the size of manipulated sequence ; Start traversing the sequence ; Push the current string if the stack is empty ; compare the current string with stack top if equal , pop the top ; Otherwise push the current string ; Return stack size ; Driver code"
Python;"def decode ( Str ) : NEW_LINE INDENT integerstack = [ ] NEW_LINE stringstack = [ ] NEW_LINE temp = "" "" NEW_LINE result = "" "" NEW_LINE i = 0 NEW_LINE while i < len ( Str ) : NEW_LINE INDENT count = 0 NEW_LINE if ( Str [ i ] >= '0' and Str [ i ] <= '9' ) : NEW_LINE INDENT while ( Str [ i ] >= '0' and Str [ i ] <= '9' ) : NEW_LINE INDENT count = count * 10 + ord ( Str [ i ] ) - ord ( '0' ) NEW_LINE i += 1 NEW_LINE DEDENT i -= 1 NEW_LINE integerstack . append ( count ) NEW_LINE DEDENT elif ( Str [ i ] == ' ] ' ) : NEW_LINE INDENT temp = "" "" NEW_LINE count = 0 NEW_LINE if ( len ( integerstack ) != 0 ) : NEW_LINE INDENT count = integerstack [ - 1 ] NEW_LINE integerstack . pop ( ) NEW_LINE DEDENT while ( len ( stringstack ) != 0 and stringstack [ - 1 ] != ' [ ' ) : NEW_LINE INDENT temp = stringstack [ - 1 ] + temp NEW_LINE stringstack . pop ( ) NEW_LINE DEDENT if ( len ( stringstack ) != 0 and stringstack [ - 1 ] == ' [ ' ) : NEW_LINE INDENT stringstack . pop ( ) NEW_LINE DEDENT for j in range ( count ) : NEW_LINE INDENT result = result + temp NEW_LINE DEDENT for j in range ( len ( result ) ) : NEW_LINE INDENT stringstack . append ( result [ j ] ) NEW_LINE DEDENT result = "" "" NEW_LINE DEDENT elif ( Str [ i ] == ' [ ' ) : NEW_LINE INDENT if ( Str [ i - 1 ] >= '0' and Str [ i - 1 ] <= '9' ) : NEW_LINE INDENT stringstack . append ( Str [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stringstack . append ( Str [ i ] ) NEW_LINE integerstack . append ( 1 ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT stringstack . append ( Str [ i ] ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT while len ( stringstack ) != 0 : NEW_LINE INDENT result = stringstack [ - 1 ] + result NEW_LINE stringstack . pop ( ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT Str = ""3 [ b2 [ ca ] ] "" NEW_LINE print ( decode ( Str ) ) NEW_LINE DEDENT";"Decode a string recursively encoded as count followed by substring | Returns decoded string for ' str ' ; Traversing the string ; If number , convert it into number and push it into integerstack . ; If closing bracket ' ] ' , pop elemment until ' [ ' opening bracket is not found in the character stack . ; Repeating the popped string ' temo ' count number of times . ; Push it in the character stack . ; If ' [ ' opening bracket , push it into character stack . ; Pop all the elmenet , make a string and return . ; Driven code"
Python;"class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def printAncestors ( root , key ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT st = [ ] NEW_LINE while ( 1 ) : NEW_LINE INDENT while ( root and root . data != key ) : NEW_LINE INDENT st . append ( root ) NEW_LINE root = root . left NEW_LINE DEDENT if ( root and root . data == key ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( st [ - 1 ] . right == None ) : NEW_LINE INDENT root = st [ - 1 ] NEW_LINE st . pop ( ) NEW_LINE while ( len ( st ) != 0 and st [ - 1 ] . right == root ) : NEW_LINE INDENT root = st [ - 1 ] NEW_LINE st . pop ( ) NEW_LINE DEDENT DEDENT root = None if len ( st ) == 0 else st [ - 1 ] . right NEW_LINE DEDENT while ( len ( st ) != 0 ) : NEW_LINE INDENT print ( st [ - 1 ] . data , end = "" ▁ "" ) NEW_LINE st . pop ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 7 ) NEW_LINE root . left . left = newNode ( 3 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . right . left = newNode ( 8 ) NEW_LINE root . right . right = newNode ( 9 ) NEW_LINE root . left . left . left = newNode ( 4 ) NEW_LINE root . left . right . right = newNode ( 6 ) NEW_LINE root . right . right . left = newNode ( 10 ) NEW_LINE key = 6 NEW_LINE printAncestors ( root , key ) NEW_LINE DEDENT";"Iterative method to find ancestors of a given binary tree | A class to create a new tree node ; Iterative Function to print all ancestors of a given key ; Create a stack to hold ancestors ; Traverse the complete tree in postorder way till we find the key ; Traverse the left side . While traversing , push the nodes into the stack so that their right subtrees can be traversed later ; push current node ; move to next node ; If the node whose ancestors are to be printed is found , then break the while loop . ; Check if right sub - tree exists for the node at top If not then pop that node because we don 't need   this node any more.  ; If the popped node is right child of top , then remove the top as well . Left child of the top must have processed before . ; if stack is not empty then simply set the root as right child of top and start traversing right sub - tree . ; If stack is not empty , print contents of stack Here assumption is that the key is there in tree ; Driver code ; Let us construct a binary tree"
Python;class StackWithMax : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . mainStack = [ ] NEW_LINE self . trackStack = [ ] NEW_LINE DEDENT def push ( self , x ) : NEW_LINE INDENT self . mainStack . append ( x ) NEW_LINE if ( len ( self . mainStack ) == 1 ) : NEW_LINE INDENT self . trackStack . append ( x ) NEW_LINE return NEW_LINE DEDENT if ( x > self . trackStack [ - 1 ] ) : NEW_LINE INDENT self . trackStack . append ( x ) NEW_LINE DEDENT else : NEW_LINE INDENT self . trackStack . append ( self . trackStack [ - 1 ] ) NEW_LINE DEDENT DEDENT def getMax ( self ) : NEW_LINE INDENT return self . trackStack [ - 1 ] NEW_LINE DEDENT def pop ( self ) : NEW_LINE INDENT self . mainStack . pop ( ) NEW_LINE self . trackStack . pop ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = StackWithMax ( ) NEW_LINE s . push ( 20 ) NEW_LINE print ( s . getMax ( ) ) NEW_LINE s . push ( 10 ) NEW_LINE print ( s . getMax ( ) ) NEW_LINE s . push ( 50 ) NEW_LINE print ( s . getMax ( ) ) NEW_LINE DEDENT;"Tracking current Maximum Element in a Stack | Python3 program to keep track of maximum element in a stack ; main stack ; tack to keep track of max element ; If current element is greater than the top element of track stack , append the current element to track stack otherwise append the element at top of track stack again into it . ; Driver Code"
Python;"st = [ ] ; NEW_LINE def push_digits ( number ) : NEW_LINE INDENT while ( number != 0 ) : NEW_LINE INDENT st . append ( number % 10 ) ; NEW_LINE number = int ( number / 10 ) ; NEW_LINE DEDENT DEDENT def reverse_number ( number ) : NEW_LINE INDENT push_digits ( number ) ; NEW_LINE reverse = 0 ; NEW_LINE i = 1 ; NEW_LINE while ( len ( st ) > 0 ) : NEW_LINE INDENT reverse = reverse + ( st [ len ( st ) - 1 ] * i ) ; NEW_LINE st . pop ( ) ; NEW_LINE i = i * 10 ; NEW_LINE DEDENT return reverse ; NEW_LINE DEDENT number = 39997 ; NEW_LINE print ( reverse_number ( number ) ) ; NEW_LINE";"Reverse a number using stack | Stack to maintain order of digits ; Function to push digits into stack ; Function to reverse the number ; Function call to push number 's   digits to stack ; Popping the digits and forming the reversed number ; Return the reversed number formed ; Driver Code ; Function call to reverse number"
Python;"class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . right = None NEW_LINE self . left = None NEW_LINE DEDENT DEDENT def flipBinaryTree ( root ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return root NEW_LINE DEDENT if ( root . left is None and root . right is None ) : NEW_LINE INDENT return root NEW_LINE DEDENT flippedRoot = flipBinaryTree ( root . left ) NEW_LINE root . left . left = root . right NEW_LINE root . left . right = root NEW_LINE root . left = root . right = None NEW_LINE return flippedRoot NEW_LINE DEDENT def printLevelOrder ( root ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return NEW_LINE DEDENT from Queue import Queue NEW_LINE q = Queue ( ) NEW_LINE q . put ( root ) NEW_LINE while ( True ) : NEW_LINE INDENT nodeCount = q . qsize ( ) NEW_LINE if nodeCount == 0 : NEW_LINE INDENT break NEW_LINE DEDENT while nodeCount > 0 : NEW_LINE INDENT node = q . get ( ) NEW_LINE print node . data , NEW_LINE if node . left is not None : NEW_LINE INDENT q . put ( node . left ) NEW_LINE DEDENT if node . right is not None : NEW_LINE INDENT q . put ( node . right ) NEW_LINE DEDENT nodeCount -= 1 NEW_LINE DEDENT print NEW_LINE DEDENT DEDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . right . left = Node ( 4 ) NEW_LINE root . right . right = Node ( 5 ) NEW_LINE print "" Level ▁ order ▁ traversal ▁ of ▁ given ▁ tree "" NEW_LINE printLevelOrder ( root ) NEW_LINE root = flipBinaryTree ( root ) NEW_LINE print   "" NEW_LINE Level order traversal of the flipped tree "" NEW_LINE printLevelOrder ( root ) NEW_LINE";"Flip Binary Tree | A binary tree node ; method to flip the binary tree ; Recursively call the same method ; Rearranging main root Node after returning from recursive call ; Iterative method to do the level order traversal line by line ; Base Case ; Create an empty queue for level order traversal ; Enqueue root and initialize height ; nodeCount ( queue size ) indicates number of nodes at current level ; Dequeue all nodes of current level and Enqueue all nodes of next level ; Driver code"
Python;"def pairWiseConsecutive ( s ) : NEW_LINE INDENT aux = [ ] NEW_LINE while ( len ( s ) != 0 ) : NEW_LINE INDENT aux . append ( s [ - 1 ] ) NEW_LINE s . pop ( ) NEW_LINE DEDENT result = True NEW_LINE while ( len ( aux ) > 1 ) : NEW_LINE INDENT x = aux [ - 1 ] NEW_LINE aux . pop ( ) NEW_LINE y = aux [ - 1 ] NEW_LINE aux . pop ( ) NEW_LINE if ( abs ( x - y ) != 1 ) : NEW_LINE INDENT result = False NEW_LINE DEDENT s . append ( x ) NEW_LINE s . append ( y ) NEW_LINE DEDENT if ( len ( aux ) == 1 ) : NEW_LINE INDENT s . append ( aux [ - 1 ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = [ ] NEW_LINE s . append ( 4 ) NEW_LINE s . append ( 5 ) NEW_LINE s . append ( - 2 ) NEW_LINE s . append ( - 3 ) NEW_LINE s . append ( 11 ) NEW_LINE s . append ( 10 ) NEW_LINE s . append ( 5 ) NEW_LINE s . append ( 6 ) NEW_LINE s . append ( 20 ) NEW_LINE if ( pairWiseConsecutive ( s ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT print ( "" Stack ▁ content ▁ ( from ▁ top ) "" , "" after ▁ function ▁ call "" ) NEW_LINE while ( len ( s ) != 0 ) : NEW_LINE INDENT print ( s [ - 1 ] , end = "" ▁ "" ) NEW_LINE s . pop ( ) NEW_LINE DEDENT DEDENT";"Check if stack elements are pairwise consecutive | Function to check if elements are pairwise consecutive in stack ; Transfer elements of s to aux . ; Traverse aux and see if elements are pairwise consecutive or not . We also need to make sure that original content is retained . ; Fetch current top two elements of aux and check if they are consecutive . ; append the elements to original stack . ; Driver Code"
Python;"def simplify ( Str ) : NEW_LINE INDENT Len = len ( Str ) NEW_LINE res = [ None ] * Len NEW_LINE index = 0 NEW_LINE i = 0 NEW_LINE s = [ ] NEW_LINE s . append ( 0 ) NEW_LINE while ( i < Len ) : NEW_LINE INDENT if ( Str [ i ] == ' + ' ) : NEW_LINE INDENT if ( s [ - 1 ] == 1 ) : NEW_LINE INDENT res [ index ] = ' - ' NEW_LINE index += 1 NEW_LINE DEDENT if ( s [ - 1 ] == 0 ) : NEW_LINE INDENT res [ index ] = ' + ' NEW_LINE index += 1 NEW_LINE DEDENT DEDENT elif ( Str [ i ] == ' - ' ) : NEW_LINE INDENT if ( s [ - 1 ] == 1 ) : NEW_LINE INDENT res [ index ] = ' + ' NEW_LINE index += 1 NEW_LINE DEDENT elif ( s [ - 1 ] == 0 ) : NEW_LINE INDENT res [ index ] = ' - ' NEW_LINE index += 1 NEW_LINE DEDENT DEDENT elif ( Str [ i ] == ' ( ' and i > 0 ) : NEW_LINE INDENT if ( Str [ i - 1 ] == ' - ' ) : NEW_LINE INDENT x = 0 if ( s [ - 1 ] == 1 ) else 1 NEW_LINE s . append ( x ) NEW_LINE DEDENT elif ( Str [ i - 1 ] == ' + ' ) : NEW_LINE INDENT s . append ( s [ - 1 ] ) NEW_LINE DEDENT DEDENT elif ( Str [ i ] == ' ) ' ) : NEW_LINE INDENT s . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT res [ index ] = Str [ i ] NEW_LINE index += 1 NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = "" a - ( b + c ) "" NEW_LINE s2 = "" a - ( b - c - ( d + e ) ) - f "" NEW_LINE r1 = simplify ( s1 ) NEW_LINE for i in r1 : NEW_LINE INDENT if i != None : NEW_LINE INDENT print ( i , end = "" ▁ "" ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( ) NEW_LINE r2 = simplify ( s2 ) NEW_LINE for i in r2 : NEW_LINE INDENT if i != None : NEW_LINE INDENT print ( i , end = "" ▁ "" ) NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT";"Remove brackets from an algebraic string containing + and | Function to simplify the String ; resultant String of max Length equal to Length of input String ; create empty stack ; If top is 1 , flip the operator ; If top is 0 , append the same operator ; x is opposite to the top of stack ; append value equal to top of the stack ; If closing parentheses pop the stack once ; copy the character to the result ; Driver Code"
Python;"BOUND = 4 NEW_LINE top = - 1 ; NEW_LINE a = [ ] NEW_LINE length = 0 ; NEW_LINE def create_new ( ) : NEW_LINE INDENT global length ; NEW_LINE new_a = [ 0 for i in range ( length + BOUND ) ] ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT new_a [ i ] = a [ i ] ; NEW_LINE DEDENT length += BOUND ; NEW_LINE return new_a NEW_LINE DEDENT def push ( element ) : NEW_LINE INDENT global top , a NEW_LINE if ( top == length - 1 ) : NEW_LINE INDENT a = create_new ( ) ; NEW_LINE DEDENT top += 1 NEW_LINE a [ top ] = element ; NEW_LINE return a ; NEW_LINE DEDENT def pop ( ) : NEW_LINE INDENT global top NEW_LINE top -= 1 ; NEW_LINE DEDENT def display ( ) : NEW_LINE INDENT global top NEW_LINE if ( top == - 1 ) : NEW_LINE INDENT print ( "" Stack ▁ is ▁ Empty "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Stack : ▁ "" , end = ' ' ) NEW_LINE for i in range ( top + 1 ) : NEW_LINE INDENT print ( a [ i ] , end = ' ▁ ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = create_new ( ) ; NEW_LINE push ( 1 ) ; NEW_LINE push ( 2 ) ; NEW_LINE push ( 3 ) ; NEW_LINE push ( 4 ) ; NEW_LINE display ( ) ; NEW_LINE push ( 5 ) ; NEW_LINE push ( 6 ) ; NEW_LINE display ( ) ; NEW_LINE push ( 7 ) ; NEW_LINE push ( 8 ) ; NEW_LINE display ( ) ; NEW_LINE push ( 9 ) ; NEW_LINE display ( ) ; NEW_LINE DEDENT";"Growable array based stack | constant amount at which stack is increased ; top of the stack ; length of stack ; function to create new stack ; allocate memory for new stack ; copying the content of old stack ; re - sizing the length ; function to push new element ; if stack is full , create new one ; insert element at top of the stack ; function to pop an element ; function to display ; if top is - 1 , that means stack is empty ; Driver Code ; creating initial stack ; pushing element to top of stack ; pushing more element when stack is full ; pushing more element so that stack can grow"
Python;"def constructBlanceArray ( BOP , BCP , str , n ) : NEW_LINE INDENT stk = [ ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == ' ( ' ) : NEW_LINE INDENT stk . append ( i ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( len ( stk ) != 0 ) : NEW_LINE INDENT BCP [ i ] = 1 ; NEW_LINE BOP [ stk [ - 1 ] ] = 1 ; NEW_LINE stk . pop ( ) ; NEW_LINE DEDENT else : NEW_LINE INDENT BCP [ i ] = 0 ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT BCP [ i ] += BCP [ i - 1 ] ; NEW_LINE BOP [ i ] += BOP [ i - 1 ] ; NEW_LINE DEDENT DEDENT def query ( BOP , BCP , s , e ) : NEW_LINE INDENT if ( BOP [ s - 1 ] == BOP [ s ] ) : NEW_LINE INDENT return ( BCP [ e ] - BOP [ s ] ) * 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( BCP [ e ] - BOP [ s ] + 1 ) * 2 ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT string = "" ( ) ) ( ( ) ) ( ( ) ) ( "" ; NEW_LINE n = len ( string ) NEW_LINE BCP = [ 0 for i in range ( n + 1 ) ] ; NEW_LINE BOP = [ 0 for i in range ( n + 1 ) ] ; NEW_LINE constructBlanceArray ( BOP , BCP , string , n ) ; NEW_LINE startIndex = 5 NEW_LINE endIndex = 11 ; NEW_LINE print ( "" Maximum ▁ Length ▁ Correct ▁ "" + "" Bracket ▁ Subsequence ▁ between ▁ "" + str ( startIndex ) + "" ▁ and ▁ "" + str ( endIndex ) + "" ▁ = ▁ "" + str ( query ( BOP , BCP , startIndex , endIndex ) ) ) ; NEW_LINE startIndex = 4 ; NEW_LINE endIndex = 5 ; NEW_LINE print ( "" Maximum ▁ Length ▁ Correct ▁ "" + "" Bracket ▁ Subsequence ▁ between ▁ "" + str ( startIndex ) + "" ▁ and ▁ "" + str ( endIndex ) + "" ▁ = ▁ "" + str ( query ( BOP , BCP , startIndex , endIndex ) ) ) NEW_LINE startIndex = 1 ; NEW_LINE endIndex = 5 ; NEW_LINE print ( "" Maximum ▁ Length ▁ Correct ▁ "" + "" Bracket ▁ Subsequence ▁ between ▁ "" + str ( startIndex ) + "" ▁ and ▁ "" + str ( endIndex ) + "" ▁ = ▁ "" + str ( query ( BOP , BCP , startIndex , endIndex ) ) ) ; NEW_LINE DEDENT";"Range Queries for Longest Correct Bracket Subsequence Set | 2 | Function for precomputation ; Create a stack and push - 1 as initial index to it . ; Traverse all characters of given String ; If opening bracket , push index of it ; If closing bracket , i . e . , str [ i ] = ')  ; If closing bracket , i . e . , str [ i ] = ' ) ' && stack is not empty then mark both "" open ▁ & ▁ close "" bracket indexs as 1 . Pop the previous opening bracket 's index ; If stack is empty . ; Function return output of each query in O ( 1 ) ; Driver code"
Python;"def heapify ( arr , n , i ) : NEW_LINE INDENT largest = i NEW_LINE l = 2 * i + 1 NEW_LINE r = 2 * i + 2 NEW_LINE if l < n and arr [ largest ] < arr [ l ] : NEW_LINE INDENT largest = l NEW_LINE DEDENT if r < n and arr [ largest ] < arr [ r ] : NEW_LINE INDENT largest = r NEW_LINE DEDENT if largest != i : NEW_LINE INDENT arr [ i ] , arr [ largest ] = arr [ largest ] , arr [ i ] NEW_LINE heapify ( arr , n , largest ) NEW_LINE DEDENT DEDENT def heapSort ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE for i in range ( n // 2 - 1 , - 1 , - 1 ) : NEW_LINE INDENT heapify ( arr , n , i ) NEW_LINE DEDENT for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT arr [ i ] , arr [ 0 ] = arr [ 0 ] , arr [ i ] NEW_LINE heapify ( arr , i , 0 ) NEW_LINE DEDENT DEDENT arr = [ 12 , 11 , 13 , 5 , 6 , 7 ] NEW_LINE heapSort ( arr ) NEW_LINE n = len ( arr ) NEW_LINE print ( "" Sorted ▁ array ▁ is "" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( "" % d "" % arr [ i ] ) , NEW_LINE DEDENT";"HeapSort | To heapify subtree rooted at index i . n is size of heap ; Initialize largest as root ; left = 2 * i + 1 ; right = 2 * i + 2 ; See if left child of root exists and is greater than root ; See if right child of root exists and is greater than root ; Change root , if needed ; Heapify the root . ; The main function to sort an array of given size ; Build a maxheap . ; One by one extract elements ; swap ; call max heapify on the reduced heap ; Driver code"
Python;"def buildMaxHeap ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if arr [ i ] > arr [ int ( ( i - 1 ) / 2 ) ] : NEW_LINE INDENT j = i NEW_LINE while arr [ j ] > arr [ int ( ( j - 1 ) / 2 ) ] : NEW_LINE INDENT ( arr [ j ] , arr [ int ( ( j - 1 ) / 2 ) ] ) = ( arr [ int ( ( j - 1 ) / 2 ) ] , arr [ j ] ) NEW_LINE j = int ( ( j - 1 ) / 2 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def heapSort ( arr , n ) : NEW_LINE INDENT buildMaxHeap ( arr , n ) NEW_LINE for i in range ( n - 1 , 0 , - 1 ) : NEW_LINE INDENT arr [ 0 ] , arr [ i ] = arr [ i ] , arr [ 0 ] NEW_LINE j , index = 0 , 0 NEW_LINE while True : NEW_LINE INDENT index = 2 * j + 1 NEW_LINE if ( index < ( i - 1 ) and arr [ index ] < arr [ index + 1 ] ) : NEW_LINE INDENT index += 1 NEW_LINE DEDENT if index < i and arr [ j ] < arr [ index ] : NEW_LINE INDENT arr [ j ] , arr [ index ] = arr [ index ] , arr [ j ] NEW_LINE DEDENT j = index NEW_LINE if index >= i : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 10 , 20 , 15 , 17 , 9 , 21 ] NEW_LINE n = len ( arr ) NEW_LINE print ( "" Given ▁ array : ▁ "" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT print ( ) NEW_LINE heapSort ( arr , n ) NEW_LINE print ( "" Sorted ▁ array : ▁ "" ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT";"Iterative HeapSort | function build Max Heap where value of each child is always smaller than value of their parent ; if child is bigger than parent ; swap child and parent until parent is smaller ; swap value of first indexed with last indexed ; maintaining heap property after each swapping ; if left child is smaller than right child point index variable to right child ; if parent is smaller than child then swapping parent with child having higher value ; Driver Code"
Python;"from collections import deque NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . data = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def flipBinaryTree ( root ) : NEW_LINE INDENT curr = root NEW_LINE next = None NEW_LINE temp = None NEW_LINE prev = None NEW_LINE while ( curr ) : NEW_LINE INDENT next = curr . left NEW_LINE curr . left = temp NEW_LINE temp = curr . right NEW_LINE curr . right = prev NEW_LINE prev = curr NEW_LINE curr = next NEW_LINE DEDENT return prev NEW_LINE DEDENT def printLevelOrder ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return NEW_LINE DEDENT q = deque ( ) NEW_LINE q . append ( root ) NEW_LINE while ( 1 ) : NEW_LINE INDENT nodeCount = len ( q ) NEW_LINE if ( nodeCount == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT while ( nodeCount > 0 ) : NEW_LINE INDENT node = q . popleft ( ) NEW_LINE print ( node . data , end = "" ▁ "" ) NEW_LINE if ( node . left != None ) : NEW_LINE INDENT q . append ( node . left ) NEW_LINE DEDENT if ( node . right != None ) : NEW_LINE INDENT q . append ( node . right ) NEW_LINE DEDENT nodeCount -= 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . right . left = Node ( 4 ) NEW_LINE root . right . right = Node ( 5 ) NEW_LINE print ( "" Level ▁ order ▁ traversal ▁ of ▁ given ▁ tree "" ) NEW_LINE printLevelOrder ( root ) NEW_LINE root = flipBinaryTree ( root ) NEW_LINE print ( "" Level order traversal of the flipped "" ▁ "" tree "" ) NEW_LINE printLevelOrder ( root ) NEW_LINE DEDENT";"Flip Binary Tree | Python3 program to flip a binary tree ; A binary tree node structure ; method to flip the binary tree ; Initialization of pointers ; Iterate through all left nodes ; Swapping nodes now , need temp to keep the previous right child Making prev ' s ▁ right ▁ as ▁ curr ' s left child ; Storing curr 's right child ; Making prev as curr 's right  child ; Iterative method to do level order traversal line by line ; Base Case ; Create an empty queue for level order traversal ; Enqueue Root and initialize height ; nodeCount ( queue size ) indicates number of nodes at current level . ; Dequeue all nodes of current level and Enqueue all nodes of next level ; Driver code"
Python;"class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def IsFoldable ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return True NEW_LINE DEDENT return IsFoldableUtil ( root . left , root . right ) NEW_LINE DEDENT def IsFoldableUtil ( n1 , n2 ) : NEW_LINE INDENT if n1 == None and n2 == None : NEW_LINE INDENT return True NEW_LINE DEDENT if n1 == None or n2 == None : NEW_LINE INDENT return False NEW_LINE DEDENT d1 = IsFoldableUtil ( n1 . left , n2 . right ) NEW_LINE d2 = IsFoldableUtil ( n1 . right , n2 . left ) NEW_LINE return d1 and d2 NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . right = newNode ( 4 ) NEW_LINE root . right . left = newNode ( 5 ) NEW_LINE if IsFoldable ( root ) : NEW_LINE INDENT print ( "" Tree ▁ is ▁ foldable "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Tree ▁ is ▁ not ▁ foldable "" ) NEW_LINE DEDENT DEDENT";"Foldable Binary Trees | Utility function to create a new tree node ; Returns true if the given tree can be folded ; A utility function that checks if trees with roots as n1 and n2 are mirror of each other ; If both left and right subtrees are NULL , then return true ; If one of the trees is NULL and other is not , then return false ; Otherwise check if left and right subtrees are mirrors of their counterparts ; Driver code ; The constructed binary tree is 1 / \ 2 3 \ / 4 5"
Python;"def isSumProperty ( node ) : NEW_LINE INDENT left_data = 0 NEW_LINE right_data = 0 NEW_LINE if ( node == None or ( node . left == None and node . right == None ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( node . left != None ) : NEW_LINE INDENT left_data = node . left . data NEW_LINE DEDENT if ( node . right != None ) : NEW_LINE INDENT right_data = node . right . data NEW_LINE DEDENT if ( ( node . data == left_data + right_data ) and isSumProperty ( node . left ) and isSumProperty ( node . right ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT DEDENT class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 10 ) NEW_LINE root . left = newNode ( 8 ) NEW_LINE root . right = newNode ( 2 ) NEW_LINE root . left . left = newNode ( 3 ) NEW_LINE root . left . right = newNode ( 5 ) NEW_LINE root . right . right = newNode ( 2 ) NEW_LINE if ( isSumProperty ( root ) ) : NEW_LINE INDENT print ( "" The ▁ given ▁ tree ▁ satisfies ▁ the "" , "" children ▁ sum ▁ property ▁ "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" The ▁ given ▁ tree ▁ does ▁ not ▁ satisfy "" , "" the ▁ children ▁ sum ▁ property ▁ "" ) NEW_LINE DEDENT DEDENT";"Check for Children Sum Property in a Binary Tree | returns 1 if children sum property holds for the given node and both of its children ; left_data is left child data and right_data is for right child data ; If node is None or it 's a leaf   node then return true  ; If left child is not present then 0 is used as data of left child ; If right child is not present then 0 is used as data of right child ; if the node and both of its children satisfy the property return 1 else 0 ; Helper class that allocates a new node with the given data and None left and right pointers . ; Driver Code"
Python;"def isHeap ( arr , i , n ) : NEW_LINE INDENT if i >= int ( ( n - 2 ) / 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 1 , n ) and isHeap ( arr , 2 * i + 2 , n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ] NEW_LINE n = len ( arr ) - 1 NEW_LINE if isHeap ( arr , 0 , n ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT";"How to check if a given array represents a Binary Heap ? | Returns true if arr [ i . . n - 1 ] represents a max - heap ; If a leaf node ; If an internal node and is greater than its children , and same is recursively true for the children ; Driver Code"
Python;"def isHeap ( arr , n ) : NEW_LINE INDENT for i in range ( int ( ( n - 2 ) / 2 ) + 1 ) : NEW_LINE INDENT if arr [ 2 * i + 1 ] > arr [ i ] : NEW_LINE INDENT return False NEW_LINE DEDENT if ( 2 * i + 2 < n and arr [ 2 * i + 2 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE if isHeap ( arr , n ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT DEDENT";"How to check if a given array represents a Binary Heap ? | Returns true if arr [ i . . n - 1 ] represents a max - heap ; Start from root and go till the last internal node ; If left child is greater , return false ; If right child is greater , return false ; Driver Code"
Python;"import heapq NEW_LINE def minCost ( arr , n ) : NEW_LINE INDENT heapq . heapify ( arr ) NEW_LINE res = 0 NEW_LINE while ( len ( arr ) > 1 ) : NEW_LINE INDENT first = heapq . heappop ( arr ) NEW_LINE second = heapq . heappop ( arr ) NEW_LINE res += first + second NEW_LINE heapq . heappush ( arr , first + second ) NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT lengths = [ 4 , 3 , 2 , 6 ] NEW_LINE size = len ( lengths ) NEW_LINE print ( "" Total ▁ cost ▁ for ▁ connecting ▁ ropes ▁ is ▁ "" + str ( minCost ( lengths , size ) ) ) NEW_LINE DEDENT";"Connect n ropes with minimum cost | Python3 program to connect n ropes with minimum cost ; Create a priority queue out of the given list ; Initializ result ; While size of priority queue is more than 1 ; Extract shortest two ropes from arr ; Connect the ropes : update result and insert the new rope to arr ; Driver code"
Python;"def generate_derangement ( N ) : NEW_LINE INDENT S = [ i for i in range ( N + 1 ) ] NEW_LINE PQ = [ ] NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT PQ . append ( S [ i ] ) NEW_LINE DEDENT D = [ 0 ] * ( N + 1 ) NEW_LINE PQ . sort ( ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT PQ . sort ( ) NEW_LINE d = PQ [ 0 ] NEW_LINE del PQ [ 0 ] NEW_LINE if ( d != S [ i ] ) or ( i == N ) : NEW_LINE INDENT D [ i ] = d NEW_LINE DEDENT else : NEW_LINE INDENT PQ . sort ( ) NEW_LINE D [ i ] = PQ [ 0 ] NEW_LINE del PQ [ 0 ] NEW_LINE PQ . append ( d ) NEW_LINE DEDENT DEDENT if D [ N ] == S [ N ] : NEW_LINE INDENT t = D [ N - 1 ] NEW_LINE D [ N - 1 ] = D [ N ] NEW_LINE D [ N ] = t NEW_LINE DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( D [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT generate_derangement ( 10 ) NEW_LINE";"Smallest Derangement of Sequence | Python3 program to generate smallest derangement using priority queue . ; Generate Sequence and insert into a priority queue . ; Generate Least Derangement ; Print Derangement ; Driver code"
Python;"def generate_derangement ( N ) : NEW_LINE INDENT S = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT S [ i ] = i NEW_LINE DEDENT D = [ 0 ] * ( N + 1 ) NEW_LINE for i in range ( 1 , N + 1 , 2 ) : NEW_LINE INDENT if i == N : NEW_LINE INDENT D [ N ] = S [ N - 1 ] NEW_LINE D [ N - 1 ] = S [ N ] NEW_LINE DEDENT else : NEW_LINE INDENT D [ i ] = i + 1 NEW_LINE D [ i + 1 ] = i NEW_LINE DEDENT DEDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT print ( D [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT generate_derangement ( 10 ) NEW_LINE DEDENT";"Smallest Derangement of Sequence | Efficient Python3 program to find smallest derangement . ; Generate Sequence S ; Generate Derangement ; Only if i is odd Swap S [ N - 1 ] and S [ N ] ; Print Derangement ; Driver Code"
Python;"def printLargest ( seq , N ) : NEW_LINE INDENT res = [ 0 ] * N NEW_LINE pq = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT pq . append ( seq [ i ] ) NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT pq . sort ( ) NEW_LINE pq . reverse ( ) NEW_LINE d = pq [ 0 ] NEW_LINE del pq [ 0 ] NEW_LINE if ( d != seq [ i ] or i == N - 1 ) : NEW_LINE INDENT res [ i ] = d NEW_LINE DEDENT else : NEW_LINE INDENT res [ i ] = pq [ 0 ] NEW_LINE del pq [ 0 ] NEW_LINE pq . append ( d ) NEW_LINE DEDENT DEDENT if ( res [ N - 1 ] == seq [ N - 1 ] ) : NEW_LINE INDENT res [ N - 1 ] = res [ N - 2 ] NEW_LINE res [ N - 2 ] = seq [ N - 1 ] NEW_LINE DEDENT print ( "" Largest ▁ Derangement "" ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT print ( res [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT seq = [ 92 , 3 , 52 , 13 , 2 , 31 , 1 ] NEW_LINE n = len ( seq ) NEW_LINE printLargest ( seq , n ) NEW_LINE";"Largest Derangement of a Sequence | Python3 program to find the largest derangement ; Stores result ; Insert all elements into a priority queue ; Fill Up res [ ] from left to right ; New Element poped equals the element in original sequence . Get the next largest element ; If given sequence is in descending order then we need to swap last two elements again ; Driver code"
Python;"def Profit ( costPrice , sellingPrice ) : NEW_LINE INDENT profit = ( sellingPrice - costPrice ) NEW_LINE return profit NEW_LINE DEDENT def Loss ( costPrice , sellingPrice ) : NEW_LINE INDENT Loss = ( costPrice - sellingPrice ) NEW_LINE return Loss NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT costPrice , sellingPrice = 1500 , 2000 NEW_LINE if sellingPrice == costPrice : NEW_LINE INDENT print ( "" No ▁ profit ▁ nor ▁ Loss "" ) NEW_LINE DEDENT elif sellingPrice > costPrice : NEW_LINE INDENT print ( Profit ( costPrice , sellingPrice ) , "" Profit "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( Loss ( costPrice , sellingPrice ) , "" Loss "" ) NEW_LINE DEDENT DEDENT";"Program to calculate Profit Or Loss | Function to calculate Profit . ; Function to calculate Loss . ; Driver code"
Python;import math NEW_LINE def nextPerfectSquare ( N ) : NEW_LINE INDENT nextN = math . floor ( math . sqrt ( N ) ) + 1 NEW_LINE return nextN * nextN NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 35 NEW_LINE print ( nextPerfectSquare ( N ) ) NEW_LINE DEDENT;"Find the Next perfect square greater than a given number | Python3 implementation of above approach ; Function to find the next perfect square ; Driver Code"
Python;"import math NEW_LINE def printSubstrings ( n ) : NEW_LINE INDENT s = int ( math . log10 ( n ) ) ; NEW_LINE d = ( math . pow ( 10 , s ) ) ; NEW_LINE k = d ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT while ( d > 0 ) : NEW_LINE INDENT print ( int ( n // d ) ) ; NEW_LINE d = int ( d / 10 ) ; NEW_LINE DEDENT n = int ( n % k ) ; NEW_LINE k = int ( k // 10 ) ; NEW_LINE d = k ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 123 ; NEW_LINE printSubstrings ( n ) ; NEW_LINE DEDENT";"Print all substring of a number without any conversion | Python3 implementation of above approach ; Function to print the substrings of a number ; Calculate the total number of digits ; 0.5 has been added because of it will return double value like 99.556 ; Print all the numbers from starting position ; Update the no . ; Update the no . of digits ; Driver code"
Python;"MOD = 1000000007 ; NEW_LINE def powerLL ( x , n ) : NEW_LINE INDENT result = 1 ; NEW_LINE while ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT result = result * x % MOD ; NEW_LINE DEDENT n = int ( n / 2 ) ; NEW_LINE x = x * x % MOD ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT def powerStrings ( sa , sb ) : NEW_LINE INDENT a = 0 ; NEW_LINE b = 0 ; NEW_LINE for i in range ( len ( sa ) ) : NEW_LINE INDENT a = ( a * 10 + ( ord ( sa [ i ] ) - ord ( '0' ) ) ) % MOD ; NEW_LINE DEDENT for i in range ( len ( sb ) ) : NEW_LINE INDENT b = ( b * 10 + ( ord ( sb [ i ] ) - ord ( '0' ) ) ) % ( MOD - 1 ) ; NEW_LINE DEDENT return powerLL ( a , b ) ; NEW_LINE DEDENT sa = ""2"" ; NEW_LINE sb = ""3"" ; NEW_LINE print ( powerStrings ( sa , sb ) ) ; NEW_LINE";"Modulo power for large numbers represented as strings | Python3 program to find ( a ^ b ) % MOD where a and b may be very large and represented as strings . ; Returns modulo exponentiation for two numbers represented as long long int . It is used by powerStrings ( ) . Its complexity is log ( n ) ; Returns modulo exponentiation for two numbers represented as strings . It is used by powerStrings ( ) ; We convert strings to number ; calculating a % MOD ; calculating b % ( MOD - 1 ) ; Now a and b are long long int . We calculate a ^ b using modulo exponentiation ; As numbers are very large that is it may contains upto 10 ^ 6 digits . So , we use string ."
Python;"def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( n and ( not ( n & ( n - 1 ) ) ) ) NEW_LINE DEDENT def previousPowerOfTwo ( n ) : NEW_LINE INDENT while ( n & n - 1 ) : NEW_LINE INDENT n = n & n - 1 NEW_LINE DEDENT return n NEW_LINE DEDENT def checkSum ( n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT elif ( isPowerOfTwo ( n ) ) : NEW_LINE INDENT print ( n // 2 , n // 2 ) NEW_LINE return True NEW_LINE DEDENT else : NEW_LINE INDENT x = previousPowerOfTwo ( n ) NEW_LINE y = n - x ; NEW_LINE if ( isPowerOfTwo ( y ) ) : NEW_LINE INDENT print ( x , y ) NEW_LINE return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT n1 = 20 NEW_LINE if ( checkSum ( n1 ) ) : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT n2 = 11 NEW_LINE if ( checkSum ( n2 ) ) : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Check if a number can be expressed as 2 ^ x + 2 ^ y | Utility function to check if a number is power of 2 or not ; Utility function to determine the value of previous power of 2 ; function to check if n can be expressed as 2 ^ x + 2 ^ y or not ; if value of n is 0 or 1 it can not be expressed as 2 ^ x + 2 ^ y ; if n is power of two then it can be expressed as sum of 2 ^ x + 2 ^ y ; if the remainder after subtracting previous power of 2 is also a power of 2 then it can be expressed as 2 ^ x + 2 ^ y ; driver code"
Python;"import math NEW_LINE def complement ( num ) : NEW_LINE INDENT i = 0 ; NEW_LINE len = 0 ; NEW_LINE comp = 0 ; NEW_LINE temp = num ; NEW_LINE while ( 1 ) : NEW_LINE INDENT len += 1 ; NEW_LINE num = int ( num / 10 ) ; NEW_LINE if ( abs ( num ) == 0 ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT num = temp ; NEW_LINE comp = math . pow ( 10 , len ) - num ; NEW_LINE return int ( comp ) ; NEW_LINE DEDENT print ( complement ( 25 ) ) ; NEW_LINE print ( complement ( 456 ) ) ; NEW_LINE";"10 's Complement of a decimal number | Python3 program to find 10 's complement ; Function to find 10 's complement ; Calculating total digits in num ; restore num ; calculate 10 's complement ; Driver code"
Python;def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 and b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE if ( gcd ( a , b ) ) : NEW_LINE INDENT print ( ' GCD ▁ of ' , a , ' and ' , b , ' is ' , gcd ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' not ▁ found ' ) NEW_LINE DEDENT;"Program to find HCF ( Highest Common Factor ) of 2 Numbers | Recursive function to return gcd of a and b ; Everything divides 0 ; base case ; a is greater ; Driver program to test above function"
Python;"def countOddSum ( a , n ) : NEW_LINE INDENT c_odd = 0 ; NEW_LINE result = 0 ; NEW_LINE odd = False ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 1 ) : NEW_LINE INDENT if ( odd == True ) : NEW_LINE INDENT odd = False ; NEW_LINE DEDENT else : NEW_LINE INDENT odd = True ; NEW_LINE DEDENT DEDENT if ( odd ) : NEW_LINE INDENT c_odd += 1 ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT result += c_odd ; NEW_LINE if ( a [ i ] % 2 == 1 ) : NEW_LINE INDENT c_odd = ( n - i - c_odd ) ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT ar = [ 5 , 4 , 4 , 5 , 1 , 3 ] ; NEW_LINE n = len ( ar ) ; NEW_LINE print ( "" The ▁ Number ▁ of ▁ Subarrays "" + "" with ▁ odd ▁ sum ▁ is ▁ "" , countOddSum ( ar , n ) ) ; NEW_LINE DEDENT";"Number of sub arrays with odd sum | Function to find number of subarrays with odd sum ; ' odd ' stores number of odd numbers upto ith index ' c _ odd ' stores number of odd sum subarrays starting at ith index ' Result ' stores the number of odd sum subarrays ; First find number of odd sum subarrays starting at 0 th index ; Find number of odd sum subarrays starting at ith index add to result ; Driver code"
Python;def findNthRoot ( x , n ) : NEW_LINE INDENT x = float ( x ) NEW_LINE n = int ( n ) NEW_LINE if ( x >= 0 and x <= 1 ) : NEW_LINE INDENT low = x NEW_LINE high = 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = 1 NEW_LINE high = x NEW_LINE DEDENT epsilon = 0.00000001 NEW_LINE guess = ( low + high ) / 2 NEW_LINE while abs ( guess ** n - x ) >= epsilon : NEW_LINE INDENT if guess ** n > x : NEW_LINE INDENT high = guess NEW_LINE DEDENT else : NEW_LINE INDENT low = guess NEW_LINE DEDENT guess = ( low + high ) / 2 NEW_LINE DEDENT print ( guess ) NEW_LINE DEDENT x = 5 NEW_LINE n = 2 NEW_LINE findNthRoot ( x , n ) NEW_LINE;"Calculating n | Python Program to find n - th real root of x ; Initialize boundary values ; used for taking approximations of the answer ; Do binary search ; Driver code"
Python;"def calculateSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for row in range ( n ) : NEW_LINE INDENT sum = sum + ( 1 << row ) NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 10 NEW_LINE print ( "" Sum ▁ of ▁ all ▁ elements : "" , calculateSum ( n ) ) NEW_LINE";"Sum of all elements up to Nth row in a Pascal triangle | Function to find sum of all elements upto nth row . ; Initialize sum with 0 ; Loop to calculate power of 2 upto n and add them ; Driver code"
Python;"def findAllSequence ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return ( pow ( 2 , N / 2 + 1 ) + pow ( 2 , N / 2 ) - 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( pow ( 2 , ( N + 1 ) / 2 ) + pow ( 2 , ( N + 1 ) / 2 ) - 2 ) ; NEW_LINE DEDENT DEDENT N = 2 ; NEW_LINE print ( int ( findAllSequence ( N ) ) ) ; NEW_LINE";"Number of sequences which has HEAD at alternate positions to the right of the first HEAD | function to calculate total sequences possible ; Value of N is even ; Value of N is odd ; Driver code"
Python;N = 1000000 NEW_LINE phi = [ 0 for i in range ( N + 5 ) ] NEW_LINE def computeTotient ( ) : NEW_LINE INDENT for i in range ( 1 , N + 1 ) : NEW_LINE INDENT phi [ i ] = i NEW_LINE DEDENT for p in range ( 2 , N + 1 ) : NEW_LINE INDENT if ( phi [ p ] == p ) : NEW_LINE INDENT phi [ p ] = p - 1 NEW_LINE for i in range ( 2 * p , N + 1 , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] // p ) * ( p - 1 ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def calculate ( x , k , mod ) : NEW_LINE INDENT arr = [ 0 for i in range ( N ) ] NEW_LINE count = 0 NEW_LINE while ( mod > 1 ) : NEW_LINE INDENT arr [ count ] = mod NEW_LINE count += 1 NEW_LINE mod = phi [ mod ] NEW_LINE DEDENT result = 1 NEW_LINE loop = count + 1 NEW_LINE arr [ count ] = 1 NEW_LINE for i in range ( min ( k , loop ) , - 1 , - 1 ) : NEW_LINE INDENT result = power ( x , result , arr [ i ] ) NEW_LINE DEDENT return result NEW_LINE DEDENT computeTotient ( ) NEW_LINE x = 3 NEW_LINE k = 2 NEW_LINE m = 3 NEW_LINE print ( calculate ( x , k , m ) ) NEW_LINE;"Compute power of power k times % m | Python3 program to compute x ^ x ^ x ^ x . . % m ; Create an array to store phi or totient values ; Function to calculate Euler Totient values ; indicates not evaluated yet and initializes for product formula . ; Compute other Phi values ; If phi [ p ] is not computed already , then number p is prime ; Phi of a prime number p is always equal to p - 1. ; Update phi values of all multiples of p ; Add contribution of p to its multiple i by multiplying with ( 1 - 1 / p ) ; Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; x = x % p Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 y = y / 2 ; Function to calculate ( x ^ x ^ x ^ x ... k times ) % m ; to store different mod values ; run loop in reverse to calculate result ; compute euler totient function values ; Calling function to compute answer"
Python;"def countOnes ( n ) : NEW_LINE INDENT count = 1 ; NEW_LINE rem = 1 ; NEW_LINE while ( rem != 0 ) : NEW_LINE INDENT rem = ( rem * 10 + 1 ) % n ; NEW_LINE count = count + 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT n = 13 ; NEW_LINE print ( countOnes ( n ) ) ; NEW_LINE";"Number of ones in the smallest repunit | Function to find number of 1 s in smallest repunit multiple of the number ; to store number of 1 s in smallest repunit multiple of the number . ; initialize rem with 1 ; run loop until rem becomes zero ; rem * 10 + 1 here represents the repunit modulo n ; when remainder becomes 0 return count ; Driver Code ; Calling function"
Python;"def largestNum ( a , b ) : NEW_LINE INDENT return a * ( bool ) ( a // b ) + b * ( bool ) ( b // a ) ; NEW_LINE DEDENT a = 22 ; NEW_LINE b = 1231 ; NEW_LINE print ( largestNum ( a , b ) ) ; NEW_LINE";"Largest of two distinct numbers without using any conditional statements or operators | Function to find the largest number ; Driver Code"
Python;"import math NEW_LINE def numberOfmeet ( a , b ) : NEW_LINE INDENT ans = 0 ; NEW_LINE if ( a > b ) : NEW_LINE INDENT ans = a - b ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = b - a ; NEW_LINE DEDENT if ( a < 0 ) : NEW_LINE INDENT a = a * ( - 1 ) ; NEW_LINE DEDENT if ( b < 0 ) : NEW_LINE INDENT b = b * ( - 1 ) ; NEW_LINE DEDENT return int ( ans / math . gcd ( a , b ) ) ; NEW_LINE DEDENT a = 1 ; NEW_LINE b = - 1 ; NEW_LINE print ( numberOfmeet ( a , b ) ) ; NEW_LINE";"Number of Distinct Meeting Points on a Circular Road | Python3 Program to find number of distinct point of meet on a circular road ; Returns the number of distinct meeting points . ; Find the relative speed . ; convert the negative value to positive . ; Driver Code"
Python;"from math import sqrt NEW_LINE MAX = 1005 NEW_LINE def SieveOfEratosthenes ( primes ) : NEW_LINE INDENT prime = [ True for i in range ( MAX ) ] NEW_LINE for p in range ( 2 , int ( sqrt ( MAX ) ) + 1 , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT for p in range ( 2 , MAX , 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT primes . append ( p ) NEW_LINE DEDENT DEDENT return primes NEW_LINE DEDENT def minimumSquareFreeDivisors ( N ) : NEW_LINE INDENT prime = [ ] NEW_LINE primes = [ ] NEW_LINE primes = SieveOfEratosthenes ( prime ) NEW_LINE max_count = 0 NEW_LINE i = 0 NEW_LINE while ( len ( primes ) and primes [ i ] * primes [ i ] <= N ) : NEW_LINE INDENT if ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp = 0 NEW_LINE while ( N % primes [ i ] == 0 ) : NEW_LINE INDENT tmp += 1 NEW_LINE N /= primes [ i ] NEW_LINE DEDENT max_count = max ( max_count , tmp ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT if ( max_count == 0 ) : NEW_LINE INDENT max_count = 1 NEW_LINE DEDENT return max_count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 24 NEW_LINE print ( "" Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is "" , minimumSquareFreeDivisors ( N ) ) NEW_LINE N = 6 NEW_LINE print ( "" Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is "" , minimumSquareFreeDivisors ( N ) ) NEW_LINE DEDENT";"Minimum number of Square Free Divisors | Python 3 Program to find the minimum number of square free divisors ; Initializing MAX with SQRT ( 10 ^ 6 ) ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Print all prime numbers ; This function returns the minimum number of Square Free divisors ; Precomputing Prime Factors ; holds max of max power of all prime factors ; holds the max power of current prime factor ; If number itself is prime , it will be included as answer and thus minimum required answer is 1 ; Driver Code"
Python;"import math NEW_LINE def findMaxGCD ( arr , n , k ) : NEW_LINE INDENT high = max ( arr ) NEW_LINE divisors = [ 0 ] * ( high + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 1 , int ( math . sqrt ( arr [ i ] ) ) + 1 ) : NEW_LINE INDENT if ( arr [ i ] % j == 0 ) : NEW_LINE INDENT divisors [ j ] += 1 NEW_LINE if ( j != arr [ i ] // j ) : NEW_LINE INDENT divisors [ arr [ i ] // j ] += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( high , 0 , - 1 ) : NEW_LINE INDENT if ( divisors [ i ] >= k ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 8 , 8 , 12 ] NEW_LINE k = 3 NEW_LINE n = len ( arr ) NEW_LINE print ( findMaxGCD ( arr , n , k ) ) NEW_LINE DEDENT";"Subsequence of size k with maximum possible GCD | Python 3 program to find subsequence of size k with maximum possible GCD . ; function to find GCD of sub sequence of size k with max GCD in the array ; Computing highest element ; Array to store the count of divisors i . e . Potential GCDs ; Iterating over every element ; Calculating all the divisors ; Divisor found ; Incrementing count for divisor ; Element / divisor is also a divisor Checking if both divisors are not same ; Checking the highest potential GCD ; If this divisor can divide at least k numbers , it is a GCD of at least one sub sequence of size k ; Driver code ; Array in which sub sequence with size k with max GCD is to be found"
Python;"def determinantOfMatrix ( mat ) : NEW_LINE INDENT ans = ( mat [ 0 ] [ 0 ] * ( mat [ 1 ] [ 1 ] * mat [ 2 ] [ 2 ] - mat [ 2 ] [ 1 ] * mat [ 1 ] [ 2 ] ) - mat [ 0 ] [ 1 ] * ( mat [ 1 ] [ 0 ] * mat [ 2 ] [ 2 ] - mat [ 1 ] [ 2 ] * mat [ 2 ] [ 0 ] ) + mat [ 0 ] [ 2 ] * ( mat [ 1 ] [ 0 ] * mat [ 2 ] [ 1 ] - mat [ 1 ] [ 1 ] * mat [ 2 ] [ 0 ] ) ) NEW_LINE return ans NEW_LINE DEDENT def findSolution ( coeff ) : NEW_LINE INDENT d = [ [ coeff [ 0 ] [ 0 ] , coeff [ 0 ] [ 1 ] , coeff [ 0 ] [ 2 ] ] , [ coeff [ 1 ] [ 0 ] , coeff [ 1 ] [ 1 ] , coeff [ 1 ] [ 2 ] ] , [ coeff [ 2 ] [ 0 ] , coeff [ 2 ] [ 1 ] , coeff [ 2 ] [ 2 ] ] ] NEW_LINE d1 = [ [ coeff [ 0 ] [ 3 ] , coeff [ 0 ] [ 1 ] , coeff [ 0 ] [ 2 ] ] , [ coeff [ 1 ] [ 3 ] , coeff [ 1 ] [ 1 ] , coeff [ 1 ] [ 2 ] ] , [ coeff [ 2 ] [ 3 ] , coeff [ 2 ] [ 1 ] , coeff [ 2 ] [ 2 ] ] ] NEW_LINE d2 = [ [ coeff [ 0 ] [ 0 ] , coeff [ 0 ] [ 3 ] , coeff [ 0 ] [ 2 ] ] , [ coeff [ 1 ] [ 0 ] , coeff [ 1 ] [ 3 ] , coeff [ 1 ] [ 2 ] ] , [ coeff [ 2 ] [ 0 ] , coeff [ 2 ] [ 3 ] , coeff [ 2 ] [ 2 ] ] ] NEW_LINE d3 = [ [ coeff [ 0 ] [ 0 ] , coeff [ 0 ] [ 1 ] , coeff [ 0 ] [ 3 ] ] , [ coeff [ 1 ] [ 0 ] , coeff [ 1 ] [ 1 ] , coeff [ 1 ] [ 3 ] ] , [ coeff [ 2 ] [ 0 ] , coeff [ 2 ] [ 1 ] , coeff [ 2 ] [ 3 ] ] ] NEW_LINE D = determinantOfMatrix ( d ) NEW_LINE D1 = determinantOfMatrix ( d1 ) NEW_LINE D2 = determinantOfMatrix ( d2 ) NEW_LINE D3 = determinantOfMatrix ( d3 ) NEW_LINE print ( "" D ▁ is ▁ : ▁ "" , D ) NEW_LINE print ( "" D1 ▁ is ▁ : ▁ "" , D1 ) NEW_LINE print ( "" D2 ▁ is ▁ : ▁ "" , D2 ) NEW_LINE print ( "" D3 ▁ is ▁ : ▁ "" , D3 ) NEW_LINE if ( D != 0 ) : NEW_LINE INDENT x = D1 / D NEW_LINE y = D2 / D NEW_LINE z = D3 / D NEW_LINE print ( "" Value ▁ of ▁ x ▁ is ▁ : ▁ "" , x ) NEW_LINE print ( "" Value ▁ of ▁ y ▁ is ▁ : ▁ "" , y ) NEW_LINE print ( "" Value ▁ of ▁ z ▁ is ▁ : ▁ "" , z ) NEW_LINE DEDENT else : NEW_LINE INDENT if ( D1 == 0 and D2 == 0 and D3 == 0 ) : NEW_LINE INDENT print ( "" Infinite ▁ solutions "" ) NEW_LINE DEDENT elif ( D1 != 0 or D2 != 0 or D3 != 0 ) : NEW_LINE INDENT print ( "" No ▁ solutions "" ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT coeff = [ [ 2 , - 1 , 3 , 9 ] , [ 1 , 1 , 1 , 6 ] , [ 1 , - 1 , 1 , 2 ] ] NEW_LINE findSolution ( coeff ) NEW_LINE DEDENT";"System of Linear Equations in three variables using Cramer 's Rule | This functions finds the determinant of Matrix ; This function finds the solution of system of linear equations using cramer 's rule ; Matrix d using coeff as given in cramer 's rule ; Matrix d1 using coeff as given in cramer 's rule ; Matrix d2 using coeff as given in cramer 's rule ; Matrix d3 using coeff as given in cramer 's rule ; Calculating Determinant of Matrices d , d1 , d2 , d3 ; Case 1 ; Coeff have a unique solution . Apply Cramer 's Rule ; calculating z using cramer 's rule ; Case 2 ; Driver Code ; storing coefficients of linear equations in coeff matrix"
Python;"import math NEW_LINE def printGreater ( x , y ) : NEW_LINE INDENT X = y * math . log ( x ) ; NEW_LINE Y = x * math . log ( y ) ; NEW_LINE if ( abs ( X - Y ) < 1e-9 ) : NEW_LINE INDENT print ( "" Equal "" ) ; NEW_LINE DEDENT elif ( X > Y ) : NEW_LINE INDENT print ( x , "" ^ "" , y ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( y , "" ^ "" , x ) ; NEW_LINE DEDENT DEDENT x = 5 ; NEW_LINE y = 8 ; NEW_LINE printGreater ( x , y ) ; NEW_LINE";"Find larger of x ^ y and y ^ x | Python3 program to print greater of x ^ y and y ^ x ; Driver Code"
Python;def sumOfSeries ( n ) : NEW_LINE INDENT return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 NEW_LINE DEDENT n = 4 NEW_LINE print sumOfSeries ( n ) NEW_LINE;"n | Function to print nth term of series ; Driver code"
Python;"def mulmod ( a , b , mod ) : NEW_LINE INDENT a = a % mod NEW_LINE while ( b > 0 ) : NEW_LINE INDENT if ( b % 2 == 1 ) : NEW_LINE INDENT res = ( res + a ) % mod NEW_LINE DEDENT a = ( a * 2 ) % mod NEW_LINE b //= 2 NEW_LINE DEDENT return res % mod NEW_LINE DEDENT def findProduct ( N ) : NEW_LINE INDENT product = 1 ; fact = 1 NEW_LINE MOD = 1e9 + 7 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT fact = mulmod ( fact , i , MOD ) NEW_LINE product = mulmod ( product , fact , MOD ) NEW_LINE if not product : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return int ( product ) NEW_LINE DEDENT N = 3 NEW_LINE print ( findProduct ( N ) ) NEW_LINE N = 5 NEW_LINE print ( findProduct ( N ) ) NEW_LINE";"Product of first N factorials | To compute ( a * b ) % MOD ; res = 0 Initialize result ; If b is odd , add ' a ' to result ; Multiply ' a ' with 2 ; Divide b by 2 ; Return result ; This function computes factorials and product by using above function i . e . modular multiplication ; Initialize product and fact with 1 ; ith factorial ; product of first i factorials ; If at any iteration , product becomes divisible by MOD , simply return 0 ; Driver Code to Test above functions"
Python;"import math NEW_LINE def divSum ( n ) : NEW_LINE INDENT sum = 1 ; NEW_LINE i = 2 ; NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT sum = ( sum + i + math . floor ( n / i ) ) ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT def areEquivalent ( num1 , num2 ) : NEW_LINE INDENT return divSum ( num1 ) == divSum ( num2 ) ; NEW_LINE DEDENT num1 = 559 ; NEW_LINE num2 = 703 ; NEW_LINE if ( areEquivalent ( num1 , num2 ) == True ) : NEW_LINE INDENT print ( "" Equivalent "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Not ▁ Equivalent "" ) ; NEW_LINE DEDENT";"Check if sum of divisors of two numbers are same | Python3 program to find if two numbers are equivalent or not ; Function to calculate sum of all proper divisors num -- > given natural number ; To store sum of divisors ; Find all divisors and add them ; Function to check if both numbers are equivalent or not ; Driver code"
Python;"def dodecahedral_num ( n ) : NEW_LINE INDENT return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) // 2 NEW_LINE DEDENT n = 5 NEW_LINE print ( "" % sth ▁ Dodecahedral ▁ number ▁ : "" % n , dodecahedral_num ( n ) ) NEW_LINE";"Dodecahedral number | Function to calculate dodecahedral number ; Formula to calculate nth dodecahedral number ; Driver Code ; print result"
Python;"import math NEW_LINE def bit ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( x ) : NEW_LINE INDENT x /= 2 NEW_LINE ans = ans + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def check ( d , x ) : NEW_LINE INDENT if ( bit ( x / d ) <= bit ( d ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False ; NEW_LINE DEDENT def bs ( n ) : NEW_LINE INDENT l = 1 NEW_LINE r = int ( math . sqrt ( n ) ) NEW_LINE while ( l < r ) : NEW_LINE INDENT m = int ( ( l + r ) / 2 ) NEW_LINE if ( check ( m , n ) ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if ( check ( l , n ) == False ) : NEW_LINE INDENT return math . floor ( l + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return math . floor ( l ) NEW_LINE DEDENT DEDENT def countDivisor ( n ) : NEW_LINE INDENT return n - bs ( n ) + 1 NEW_LINE DEDENT n = 5 NEW_LINE print ( countDivisor ( n ) ) NEW_LINE";"Count of divisors having more set bits than quotient on dividing N | Python3 Program to find number of Divisors which on integer division produce quotient having less set bit than divisor ; Return the count of set bit . ; check if q and d have same number of set bit . ; Binary Search to find the point at which number of set in q is less than or equal to d . ; while left index is less than right index ; finding the middle . ; check if q and d have same number of set it or not . ; Driver Code"
Python;"def everMeet ( x1 , x2 , v1 , v2 ) : NEW_LINE INDENT if ( x1 < x2 and v1 <= v2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( x1 > x2 and v1 >= v2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( x1 < x2 ) : NEW_LINE INDENT x1 , x2 = x2 , x1 ; NEW_LINE v1 , v2 = v2 , v1 ; NEW_LINE DEDENT while ( x1 >= x2 ) : NEW_LINE INDENT if ( x1 == x2 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT x1 = x1 + v1 ; NEW_LINE x2 = x2 + v2 ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT x1 = 5 ; NEW_LINE v1 = 8 ; NEW_LINE x2 = 4 ; NEW_LINE v2 = 7 ; NEW_LINE if ( everMeet ( x1 , x2 , v1 , v2 ) ) : NEW_LINE INDENT print ( "" Yes "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) ; NEW_LINE DEDENT";"Check if two people starting from different points ever meet | Python3 program to find if two people starting from different positions ever meet or not . ; If speed of a person at a position before other person is smaller , then return false . ; Making sure that x1 is greater ; Until one person crosses other ; first person taking one jump in each iteration ; second person taking one jump in each iteration ; Driver code"
Python;"def check ( k , d0 , d1 ) : NEW_LINE INDENT s = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ) NEW_LINE a = ( k - 3 ) % 4 NEW_LINE if ( a == 0 ) : NEW_LINE INDENT x = 0 NEW_LINE DEDENT elif ( a == 1 ) : NEW_LINE INDENT x = ( 2 * ( d0 + d1 ) ) % 10 NEW_LINE DEDENT elif ( a == 2 ) : NEW_LINE INDENT x = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ) NEW_LINE DEDENT elif ( a == 3 ) : NEW_LINE INDENT x = ( ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ) NEW_LINE DEDENT sum = d0 + d1 + ( ( k - 3 ) // 4 ) * s + x NEW_LINE if ( sum % 3 == 0 ) : NEW_LINE INDENT return "" YES "" NEW_LINE DEDENT else : NEW_LINE INDENT return "" NO "" NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT k = 13 NEW_LINE d0 = 8 NEW_LINE d1 = 1 NEW_LINE print ( check ( k , d0 , d1 ) ) NEW_LINE k = 5 NEW_LINE d0 = 3 NEW_LINE d1 = 4 NEW_LINE print ( check ( k , d0 , d1 ) ) NEW_LINE DEDENT";"Divisibility by 3 where each digit is the sum of all prefix digits modulo 10 | Function to check the divisibility ; Cycle ; no of residual terms ; if no of residue term = 0 ; if no of residue term = 1 ; if no of residue term = 2 ; if no of residue term = 3 ; sum of all digits ; divisibility check ; Driver code"
Python;"import math NEW_LINE a = 4 ; NEW_LINE b = 3 ; NEW_LINE val = ( a / b ) + ( ( a % b ) != 0 ) ; NEW_LINE print ( "" The ▁ ceiling ▁ value ▁ of ▁ 4/3 ▁ is "" , math . floor ( val ) ) ; NEW_LINE a = 6 ; NEW_LINE b = 3 ; NEW_LINE val = int ( ( a / b ) + ( ( a % b ) != 0 ) ) ; NEW_LINE print ( "" The ▁ ceiling ▁ value ▁ of ▁ 6/3 ▁ is "" , val ) ; NEW_LINE";"Find ceil of a / b without using ceil ( ) function | Python3 program to find ceil ( a / b ) without using ceil ( ) function ; taking input 1 ; example of perfect division taking input 2"
Python;def printCollatz ( n ) : NEW_LINE INDENT while n != 1 : NEW_LINE INDENT print ( n , end = ' ▁ ' ) NEW_LINE if n & 1 : NEW_LINE INDENT n = 3 * n + 1 NEW_LINE DEDENT else : NEW_LINE INDENT n = n // 2 NEW_LINE DEDENT DEDENT print ( n ) NEW_LINE DEDENT printCollatz ( 6 ) NEW_LINE;"Program to print Collatz Sequence | Python 3 program to print Collatz sequence ; We simply follow steps while we do not reach 1 ; If n is odd ; If even ; Print 1 at the end ; Driver code"
Python;"def block ( x ) : NEW_LINE INDENT v = [ ] NEW_LINE print ( "" Blocks ▁ for ▁ % d ▁ : ▁ "" % x , end = "" "" ) NEW_LINE while ( x > 0 ) : NEW_LINE INDENT v . append ( int ( x % 2 ) ) NEW_LINE x = int ( x / 2 ) NEW_LINE DEDENT for i in range ( 0 , len ( v ) ) : NEW_LINE INDENT if ( v [ i ] == 1 ) : NEW_LINE INDENT print ( i , end = "" "" ) NEW_LINE if ( i != len ( v ) - 1 ) : NEW_LINE INDENT print ( "" , ▁ "" , end = "" "" ) NEW_LINE DEDENT DEDENT DEDENT print ( "" "" ) NEW_LINE DEDENT block ( 71307 ) NEW_LINE block ( 1213 ) NEW_LINE block ( 29 ) NEW_LINE block ( 100 ) NEW_LINE";"Powers of 2 to required sum | Python3 program to find the blocks for given number . ; Converting the decimal number into its binary equivalent . ; Displaying the output when the bit is '1' in binary equivalent of number . ; Driver Code"
Python;"import math NEW_LINE def findNumberOfDigits ( n , base ) : NEW_LINE INDENT dig = ( math . floor ( math . log ( n ) / math . log ( base ) ) + 1 ) NEW_LINE print ( "" The ▁ Number ▁ of ▁ digits ▁ of "" . format ( n , base , dig ) ) DEDENT n = 1446 NEW_LINE base = 7 NEW_LINE findNumberOfDigits ( n , base ) NEW_LINE";"Given a number N in decimal base , find number of its digits in any base ( base b ) | Python3 program to Find Number of digits in base b . ; function to print number of digits ; Calculating log using base changing property and then taking it floor and then adding 1. ; printing output ; taking inputs ; calling the method"
Python;"def isValidNesbitt ( a , b , c ) : NEW_LINE INDENT A = a / ( b + c ) ; NEW_LINE B = b / ( a + c ) ; NEW_LINE C = c / ( a + b ) ; NEW_LINE inequality = A + B + C ; NEW_LINE return ( inequality >= 1.5 ) ; NEW_LINE DEDENT a = 1.0 ; NEW_LINE b = 2.0 ; NEW_LINE c = 3.0 ; NEW_LINE if ( isValidNesbitt ( a , b , c ) ) : NEW_LINE INDENT print ( "" Nesbitt ' s ▁ inequality ▁ satisfied . "" , "" ▁ for ▁ real ▁ numbers ▁ "" , a , "" , ▁ "" , b , "" , ▁ "" , c ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Not ▁ satisfied "" ) ; NEW_LINE DEDENT";"Nesbitt 's Inequality | Python3 code to verify Nesbitt 's Inequality ; 3 parts of the inequality sum ; Driver Code"
Python;"def printCubeFree ( n ) : NEW_LINE INDENT cubFree = [ 1 ] * ( n + 1 ) ; NEW_LINE i = 2 ; NEW_LINE while ( i * i * i <= n ) : NEW_LINE INDENT if ( cubFree [ i ] == 1 ) : NEW_LINE INDENT multiple = 1 ; NEW_LINE while ( i * i * i * multiple <= n ) : NEW_LINE INDENT cubFree [ i * i * i * multiple ] = 0 ; NEW_LINE multiple += 1 ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( cubFree [ i ] == 1 ) : NEW_LINE INDENT print ( i , end = "" ▁ "" ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT printCubeFree ( 20 ) ; NEW_LINE DEDENT";"Cube Free Numbers smaller than n | Efficient Python3 Program to print all cube free numbers smaller than or equal to n . ; Initialize all numbers as not cube free ; Traverse through all possible cube roots ; If i itself is cube free ; Mark all multiples of i as not cube free ; Print all cube free numbers ; Driver Code"
Python;"def heapify ( arr , n , i ) : NEW_LINE INDENT smallest = i NEW_LINE l = 2 * i + 1 NEW_LINE r = 2 * i + 2 NEW_LINE if l < n and arr [ l ] < arr [ smallest ] : NEW_LINE INDENT smallest = l NEW_LINE DEDENT if r < n and arr [ r ] < arr [ smallest ] : NEW_LINE INDENT smallest = r NEW_LINE DEDENT if smallest != i : NEW_LINE INDENT ( arr [ i ] , arr [ smallest ] ) = ( arr [ smallest ] , arr [ i ] ) NEW_LINE heapify ( arr , n , smallest ) NEW_LINE DEDENT DEDENT def heapSort ( arr , n ) : NEW_LINE INDENT for i in range ( int ( n / 2 ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT heapify ( arr , n , i ) NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT arr [ 0 ] , arr [ i ] = arr [ i ] , arr [ 0 ] NEW_LINE heapify ( arr , i , 0 ) NEW_LINE DEDENT DEDENT def printArray ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = "" ▁ "" ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 6 , 3 , 2 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE heapSort ( arr , n ) NEW_LINE print ( "" Sorted ▁ array ▁ is ▁ "" ) NEW_LINE printArray ( arr , n ) NEW_LINE DEDENT";"Heap Sort for decreasing order using min heap | To heapify a subtree rooted with node i which is an index in arr [ ] . n is size of heap ; Initialize smalles as root ; left = 2 * i + 1 ; right = 2 * i + 2 ; If left child is smaller than root ; If right child is smaller than smallest so far ; If smallest is not root ; Recursively heapify the affected sub - tree ; main function to do heap sort ; Build heap ( rearrange array ) ; One by one extract an element from heap ; Move current root to end ; call max heapify on the reduced heap ; A utility function to print array of size n ; Driver Code"
Python;"import math NEW_LINE def isTriangular ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT c = ( - 2 * num ) ; NEW_LINE b = 1 ; NEW_LINE a = 1 ; NEW_LINE d = ( b * b ) - ( 4 * a * c ) ; NEW_LINE if ( d < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT root1 = ( - b + math . sqrt ( d ) ) // ( 2 * a ) ; NEW_LINE root2 = ( - b - math . sqrt ( d ) ) // ( 2 * a ) ; NEW_LINE if ( root1 > 0 and math . floor ( root1 ) == root1 ) : NEW_LINE INDENT return root1 ; NEW_LINE DEDENT if ( root2 > 0 and math . floor ( root2 ) == root2 ) : NEW_LINE INDENT return root2 ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT def isPerfectSquare ( x ) : NEW_LINE INDENT sr = math . sqrt ( x ) ; NEW_LINE if ( ( sr - math . floor ( sr ) ) == 0 ) : NEW_LINE INDENT return math . floor ( sr ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT DEDENT def findS ( s ) : NEW_LINE INDENT sr = isPerfectSquare ( s ) ; NEW_LINE if ( sr == - 1 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return int ( isTriangular ( sr ) ) ; NEW_LINE DEDENT s = 9 ; NEW_LINE n = findS ( s ) ; NEW_LINE if ( n == - 1 ) : NEW_LINE INDENT print ( "" - 1"" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( n ) ; NEW_LINE DEDENT";"Squared triangular number ( Sum of cubes ) | Python3 program to check if a given number is sum of cubes of natural numbers . ; Returns root of n ( n + 1 ) / 2 = num if num is triangular ( or integerroot exists ) . Else returns - 1. ; Considering the equation n * ( n + 1 ) / 2 = num . The equation is : a ( n ^ 2 ) + bn + c = 0 ""; ; Find roots of equation ; checking if root1 is natural ; checking if root2 is natural ; Returns square root of x if it is perfect square . Else returns - 1. ; Find floating point value of square root of x . ; If square root is an integer ; Function to find if the given number is sum of the cubes of first n natural numbers ; Driver code"
Python;"def trickyCase ( s , index ) : NEW_LINE INDENT index1 = - 1 ; NEW_LINE for i in range ( index - 1 , - 1 , - 1 ) : NEW_LINE INDENT digit = s [ i ] - '0' ; NEW_LINE if ( digit != 8 ) : NEW_LINE INDENT index1 = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( index1 == - 1 ) : NEW_LINE INDENT return 2 * pow ( 10 , len ( s ) ) ; NEW_LINE DEDENT num = 0 ; NEW_LINE for i in range ( index1 ) : NEW_LINE INDENT num = num * 10 + ( s [ i ] - '0' ) ; NEW_LINE DEDENT if ( s [ index1 ] % 2 == 0 ) : NEW_LINE INDENT num = num * 10 + ( s [ index1 ] - '0' + 2 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT num = num * 10 + ( s [ index1 ] - '0' + 1 ) ; NEW_LINE DEDENT for i in range ( index1 + 1 , len ( s ) ) : NEW_LINE INDENT num = num * 10 ; NEW_LINE DEDENT return num ; NEW_LINE DEDENT def smallestNumber ( n ) : NEW_LINE INDENT num = 0 ; NEW_LINE s = "" "" ; NEW_LINE duplicate = n ; NEW_LINE while ( n ) : NEW_LINE INDENT s = chr ( n % 10 + 48 ) + s ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT index = - 1 ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT digit = ord ( s [ i ] ) - ord ( '0' ) ; NEW_LINE if ( digit & 1 ) : NEW_LINE INDENT index = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( index == - 1 ) : NEW_LINE INDENT return duplicate ; NEW_LINE DEDENT if ( s [ index ] == '9' ) : NEW_LINE INDENT num = trickyCase ( s , index ) ; NEW_LINE return num ; NEW_LINE DEDENT for i in range ( index ) : NEW_LINE INDENT num = num * 10 + ord ( s [ i ] ) - ord ( '0' ) ; NEW_LINE DEDENT num = num * 10 + ( ord ( s [ index ] ) - ord ( '0' ) + 1 ) ; NEW_LINE for i in range ( index + 1 , len ( s ) ) : NEW_LINE INDENT num = num * 10 ; NEW_LINE DEDENT return num ; NEW_LINE DEDENT N = 2397 ; NEW_LINE print ( smallestNumber ( N ) ) ; NEW_LINE";"Smallest even digits number not less than N | Function to return the answer when the first odd digit is 9 ; traverse towwars the left to find the non - 8 digit ; index digit ; if digit is not 8 , then break ; if on the left side of the '9' , no 8 is found then we return by adding a 2 and 0 's ; till non - 8 digit add all numbers ; if non - 8 is even or odd than add the next even . ; add 0 to right of 9 ; function to return the smallest number with all digits even ; convert the number to string to perform operations ; find out the first odd number ; if no odd numbers are there , than n is the answer ; if the odd number is 9 , than tricky case handles it ; add all digits till first odd ; increase the odd digit by 1 ; add 0 to the right of the odd number ; Driver Code"
Python;"def findNth ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE curr = 19 ; NEW_LINE while ( True ) : NEW_LINE INDENT sum = 0 ; NEW_LINE x = curr ; NEW_LINE while ( x > 0 ) : NEW_LINE INDENT sum = sum + x % 10 ; NEW_LINE x = int ( x / 10 ) ; NEW_LINE DEDENT if ( sum == 10 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( count == n ) : NEW_LINE INDENT return curr ; NEW_LINE DEDENT curr += 9 ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT print ( findNth ( 5 ) ) ; NEW_LINE";"n | Python3 program to find n - th number with sum of digits as 10. ; Find sum of digits in current no . ; If sum is 10 , we increment count ; If count becomes n , we return current number . ; Driver Code"
Python;def findSum ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT sm = sm + i * j NEW_LINE DEDENT DEDENT return sm NEW_LINE DEDENT n = 5 NEW_LINE print ( findSum ( n ) ) NEW_LINE;"Sum of pairwise products | Simple Python3 program to find sum of given series . ; Driver Code"
Python;def findSum ( n ) : NEW_LINE INDENT multiTerms = n * ( n + 1 ) // 2 NEW_LINE sm = multiTerms NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT multiTerms = multiTerms - ( i - 1 ) NEW_LINE sm = sm + multiTerms * i NEW_LINE DEDENT return sm NEW_LINE DEDENT n = 5 NEW_LINE print ( findSum ( n ) ) NEW_LINE;"Sum of pairwise products | Efficient Python3 program to find sum of given series . ; Sum of multiples of 1 is 1 * ( 1 + 2 + . . ) ; Adding sum of multiples of numbers other than 1 , starting from 2. ; Subtract previous number from current multiple . ; For example , for 2 , we get sum as ( 2 + 3 + 4 + ... . ) * 2 ; Driver code"
Python;"from math import sqrt NEW_LINE def isPrime ( n : int ) -> bool : NEW_LINE INDENT if n < 2 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def lemoine ( n : int ) -> None : NEW_LINE INDENT pr = dict ( ) NEW_LINE for q in range ( 1 , n // 2 + 1 ) : NEW_LINE INDENT p = n - 2 * q NEW_LINE if isPrime ( p ) and isPrime ( q ) : NEW_LINE INDENT if p not in pr : NEW_LINE INDENT pr [ p ] = q NEW_LINE DEDENT DEDENT DEDENT DEDENT ' NEW_LINE INDENT for it in pr : NEW_LINE INDENT print ( "" % d ▁ = ▁ % d ▁ + ▁ ( 2 ▁ * ▁ % d ) "" % ( n , it , pr [ it ] ) ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 39 NEW_LINE print ( n , "" can ▁ be ▁ expressed ▁ as ▁ "" ) NEW_LINE lemoine ( n ) NEW_LINE DEDENT";"Lemoine 's Conjecture | Python code to verify Lemoine 's Conjecture for any odd number >= 7 ; Function to check if a number is prime or not ; Representing n as p + ( 2 * q ) to satisfy lemoine 's conjecture ; Declaring a map to hold pairs ( p , q ) ; Finding various values of p for each q to satisfy n = p + ( 2 * q ) ; After finding a pair that satisfies the equation , check if both p and q are prime or not ; If both p and q are prime , store them in the map ; Displaying all pairs ( p , q ) that satisfy lemoine ' s ▁ conjecture ▁ for ▁ the ▁ number ▁ ' n ; Driver Code ; Function calling"
Python;"def totalSumDivisibleByNum ( digit , number ) : NEW_LINE INDENT firstnum = pow ( 10 , digit - 1 ) NEW_LINE lastnum = pow ( 10 , digit ) NEW_LINE firstnum = ( firstnum - firstnum % number ) + number NEW_LINE lastnum = ( lastnum - lastnum % number ) NEW_LINE count = ( ( lastnum - firstnum ) / number + 1 ) NEW_LINE return int ( ( ( lastnum + firstnum ) * count ) / 2 ) NEW_LINE DEDENT digit = 3 ; num = 7 NEW_LINE print ( totalSumDivisibleByNum ( digit , num ) ) NEW_LINE";"Sum of n digit numbers divisible by a given number | find the Sum of having n digit and divisible by the number ; compute the first and last term ; first number which is divisible by given number ; last number which is divisible by given number ; total divisible number ; return the total sum ; Driver code"
Python;"def Nth_of_AP ( a , d , N ) : NEW_LINE INDENT return ( a + ( N - 1 ) * d ) NEW_LINE DEDENT a = 2 NEW_LINE d = 1 NEW_LINE N = 5 NEW_LINE print ( "" The ▁ "" , N , "" th ▁ term ▁ of ▁ the ▁ series ▁ is ▁ : ▁ "" , Nth_of_AP ( a , d , N ) ) NEW_LINE";"Program for N | Python 3 Program to find nth term of Arithmetic progression ; using formula to find the Nth term t ( n ) = a ( 1 ) + ( n - 1 ) * d ; starting number ; Common difference ; N th term to be find ; Display the output"
Python;"def checkFibinnary ( n ) : NEW_LINE INDENT prev_last = 0 NEW_LINE while ( n ) : NEW_LINE INDENT if ( ( n & 1 ) and prev_last ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev_last = n & 1 NEW_LINE n >>= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 10 NEW_LINE if ( checkFibinnary ( n ) ) : NEW_LINE INDENT print ( "" YES "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT";"Fibbinary Numbers ( No consecutive 1 s in binary ) | function to check if binary representation of an integer has consecutive 1 s ; stores the previous last bit initially as 0 ; if current last bit and previous last bit is 1 ; stores the last bit ; right shift the number ; Driver code"
Python;def sumOfSeries ( n ) : NEW_LINE INDENT return ( int ) ( 0.6172 * ( pow ( 10 , n ) - 1 ) - 0.55 * n ) NEW_LINE DEDENT n = 2 NEW_LINE print ( sumOfSeries ( n ) ) NEW_LINE;"Sum of the series 5 + 55 + 555 + . . up to n terms | function which return the the sum of series ; Driver Code"
Python;def Nonagonal ( n ) : NEW_LINE INDENT return int ( n * ( 7 * n - 5 ) / 2 ) NEW_LINE DEDENT n = 10 NEW_LINE print ( Nonagonal ( n ) ) NEW_LINE;"Nonagonal number | Function to find nth nonagonal number . ; Formula to find nth nonagonal number . ; Driver function ."
Python;"import math NEW_LINE def divisibleBy20 ( num ) : NEW_LINE INDENT lastTwoDigits = int ( num [ - 2 : ] ) NEW_LINE return ( ( lastTwoDigits % 5 == 0 and lastTwoDigits % 4 == 0 ) ) NEW_LINE DEDENT num = ""63284689320"" NEW_LINE if ( divisibleBy20 ( num ) == True ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Check if a large number is divisible by 20 | Python3 program to check if a large number is divisible by 20. ; Get number with last two digits ; Check if the number formed by last two digits is divisible by 5 and 4. ; driver code"
Python;"import math NEW_LINE def isDvisibleBy12 ( num ) : NEW_LINE INDENT if ( len ( num ) >= 3 ) : NEW_LINE INDENT d1 = int ( num [ len ( num ) - 1 ] ) ; NEW_LINE if ( d1 % 2 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT d2 = int ( num [ len ( num ) - 2 ] ) NEW_LINE sum = 0 NEW_LINE for i in range ( 0 , len ( num ) ) : NEW_LINE INDENT sum += int ( num [ i ] ) NEW_LINE DEDENT return ( sum % 3 == 0 and ( d2 * 10 + d1 ) % 4 == 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT number = int ( num ) NEW_LINE return ( number % 12 == 0 ) NEW_LINE DEDENT DEDENT num = ""12244824607284961224"" NEW_LINE if ( isDvisibleBy12 ( num ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Divisibility by 12 for a large number | Python Program to check if number is divisible by 12 ; if number greater then 3 ; find last digit ; no is odd ; find second last digit ; find sum of all digits ; f number is less then r equal to 100 ; driver function"
Python;import math NEW_LINE def check ( n ) : NEW_LINE INDENT d = int ( math . sqrt ( n ) ) NEW_LINE if ( d * d == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def largestNonPerfectSquareNumber ( a , n ) : NEW_LINE INDENT maxi = - 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( check ( a [ i ] ) == False ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT a = [ 16 , 20 , 25 , 2 , 3 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestNonPerfectSquareNumber ( a , n ) ) NEW_LINE;"Largest number that is not a perfect square | python program to find the largest non perfect square number among n numbers ; takes the sqrt of the number ; checks if it is a perfect square number ; function to find the largest non perfect square number ; stores the maximum of all non perfect square numbers ; traverse for all elements in the array ; store the maximum if not a perfect square ; driver code ; function call"
Python;def printAP ( a , d , n ) : NEW_LINE INDENT curr_term NEW_LINE DEDENT curr_term = a NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE DEDENT print ( curr_term , end = ' ▁ ' ) NEW_LINE INDENT curr_term = curr_term + d NEW_LINE DEDENT a = 2 NEW_LINE d = 1 NEW_LINE n = 5 NEW_LINE printAP ( a , d , n ) NEW_LINE;"Program to print Arithmetic Progression series | Python 3 Program to print an arithmetic progression series ; Printing AP by simply adding d to previous term . ; starting number ; Common difference ; N th term to be find"
Python;def countZeros ( a , n ) : NEW_LINE INDENT count2 = 0 NEW_LINE count5 = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT while ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT a [ i ] = a [ i ] // 2 NEW_LINE count2 = count2 + 1 NEW_LINE DEDENT while ( a [ i ] % 5 == 0 ) : NEW_LINE INDENT a [ i ] = a [ i ] // 5 NEW_LINE count5 = count5 + 1 NEW_LINE DEDENT DEDENT if ( count2 < count5 ) : NEW_LINE INDENT return count2 NEW_LINE DEDENT else : NEW_LINE INDENT return count5 NEW_LINE DEDENT DEDENT a = [ 10 , 100 , 20 , 30 , 50 , 90 , 12 , 80 ] NEW_LINE n = len ( a ) NEW_LINE print ( countZeros ( a , n ) ) NEW_LINE;"Count number of trailing zeros in product of array | Returns count of zeros in product of array ; count number of 2 s in each element ; count number of 5 s in each element ; return the minimum ; Driven Program"
Python;def squareSum ( n ) : NEW_LINE INDENT return int ( 2 * n * ( n + 1 ) * ( 2 * n + 1 ) / 3 ) NEW_LINE DEDENT ans = squareSum ( 8 ) NEW_LINE print ( ans ) NEW_LINE;"Sum of square of first n even numbers | Efficient Python3 code to find sum of square of first n even numbers ; driver code"
Python;import math NEW_LINE pwr = [ 0 ] * 10 NEW_LINE def isMunchhausen ( n ) : NEW_LINE INDENT sm = 0 NEW_LINE temp = n NEW_LINE while ( temp ) : NEW_LINE INDENT sm = sm + pwr [ ( temp % 10 ) ] NEW_LINE temp = temp // 10 NEW_LINE DEDENT return ( sm == n ) NEW_LINE DEDENT def printMunchhausenNumbers ( n ) : NEW_LINE INDENT for i in range ( 0 , 10 ) : NEW_LINE INDENT pwr [ i ] = math . pow ( ( float ) ( i ) , ( float ) ( i ) ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( isMunchhausen ( i ) ) : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT DEDENT n = 10000 NEW_LINE printMunchhausenNumbers ( n ) NEW_LINE;"MÃ ¼ nchhausen Number | Python 3 code for MA14nchhausen Number ; pwr [ i ] is going to store i raised to power i . ; Function to check out whether the number is MA14nchhausen Number or not ; Precompute i raised to power i for every i ; The input here is fixed i . e . it will check up to n ; check the integer for MA14nchhausen Number , if yes then print out the number ; Driver Code"
Python;"def kthdigit ( a , b , k ) : NEW_LINE INDENT p = a ** b NEW_LINE count = 0 NEW_LINE while ( p > 0 and count < k ) : NEW_LINE INDENT rem = p % 10 NEW_LINE count = count + 1 NEW_LINE if ( count == k ) : NEW_LINE INDENT return rem NEW_LINE DEDENT p = p / 10 ; NEW_LINE DEDENT DEDENT a = 5 NEW_LINE b = 2 NEW_LINE k = 1 NEW_LINE ans = kthdigit ( a , b , k ) NEW_LINE print ( ans ) NEW_LINE";"K | Python3 code to compute k - th digit in a ^ b ; computin a ^ b in python ; getting last digit ; increasing count by 1 ; if current number is required digit ; remove last digit ; driver code"
Python;import math NEW_LINE def digSum ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if n % 9 == 0 : NEW_LINE INDENT return 9 NEW_LINE DEDENT else : NEW_LINE INDENT return ( n % 9 ) NEW_LINE DEDENT DEDENT def PowDigSum ( n , x ) : NEW_LINE INDENT sum = digSum ( n ) NEW_LINE rem = x % 6 NEW_LINE if ( ( sum == 3 or sum == 6 ) and x > 1 ) : NEW_LINE INDENT return 9 NEW_LINE DEDENT elif ( x == 1 ) : NEW_LINE INDENT return sum NEW_LINE DEDENT elif ( x == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif ( rem == 0 ) : NEW_LINE INDENT return digSum ( math . pow ( sum , 6 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return digSum ( math . pow ( sum , rem ) ) NEW_LINE DEDENT DEDENT n = 33333 NEW_LINE x = 332654 NEW_LINE print ( PowDigSum ( n , x ) ) NEW_LINE;"Recursive sum of digit in n ^ x , where n and x are very large | Python3 Code for Sum of digit of n ^ x ; function to get sum of digits of a number ; function to return sum ; Find sum of digits in n ; Find remainder of exponent ; Driver method"
Python;def maxArea ( A ) : NEW_LINE INDENT l = 0 NEW_LINE r = len ( A ) - 1 NEW_LINE area = 0 NEW_LINE while l < r : NEW_LINE INDENT area = max ( area , min ( A [ l ] , A [ r ] ) * ( r - l ) ) NEW_LINE if A [ l ] < A [ r ] : NEW_LINE INDENT l += 1 NEW_LINE DEDENT else : NEW_LINE INDENT r -= 1 NEW_LINE DEDENT DEDENT return area NEW_LINE DEDENT a = [ 1 , 5 , 4 , 3 ] NEW_LINE b = [ 3 , 1 , 2 , 4 , 5 ] NEW_LINE print ( maxArea ( a ) ) NEW_LINE print ( maxArea ( b ) ) NEW_LINE;"Container with Most Water | Python3 code for Max Water Container ; Calculating the max area ; Driver code"
Python;"import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n < 2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i * i NEW_LINE DEDENT return True NEW_LINE DEDENT def mobius ( n ) : NEW_LINE INDENT p = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE p = p + 1 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT n = int ( n / i ) NEW_LINE p = p + 1 NEW_LINE if ( n % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT i = i + 2 NEW_LINE DEDENT if ( p % 2 == 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT N = 17 NEW_LINE print ( "" Mobius defs M ( N ) at N = { } is : { } "" . format ( N , mobius ( N ) ) ) ; NEW_LINE print ( "" Mobius defs M ( N ) at N = 25 is : { } "" . format ( mobius ( 25 ) ) ) ; NEW_LINE print ( "" Mobius defs M ( N ) at N = 6 is : { } "" . format ( mobius ( 6 ) ) ) ; NEW_LINE";"Program for Mobius Function | Python Program to evaluate Mobius def M ( N ) = 1 if N = 1 M ( N ) = 0 if any prime factor of N is contained twice M ( N ) = ( - 1 ) ^ ( no of distinctprime factors ) ; def to check if n is prime or not ; Handling 2 separately ; If 2 ^ 2 also divides N ; Check for all other prime factors ; If i divides n ; If i ^ 2 also divides N ; Driver Code"
Python;def factorial ( start , end ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( start , end + 1 ) : NEW_LINE INDENT res *= i NEW_LINE DEDENT return res NEW_LINE DEDENT def sumofsquare ( n ) : NEW_LINE INDENT return int ( factorial ( n + 1 , 2 * n ) / factorial ( 1 , n ) ) NEW_LINE DEDENT n = 4 NEW_LINE print ( sumofsquare ( n ) ) NEW_LINE;"Sum of squares of binomial coefficients | function to return product of number from start to end . ; Return the sum of square of binomial coefficient ; Driven Program"
Python;"PHI = 1.6180339 NEW_LINE f = [ 0 , 1 , 1 , 2 , 3 , 5 ] NEW_LINE def fib ( n ) : NEW_LINE INDENT if n < 6 : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT t = 5 NEW_LINE fn = 5 NEW_LINE while t < n : NEW_LINE INDENT fn = round ( fn * PHI ) NEW_LINE t += 1 NEW_LINE DEDENT return fn NEW_LINE DEDENT n = 9 NEW_LINE print ( n , "" th ▁ Fibonacci ▁ Number ▁ = "" , fib ( n ) ) NEW_LINE";"Find nth Fibonacci number using Golden ratio | Approximate value of golden ratio ; Fibonacci numbers upto n = 5 ; Function to find nth Fibonacci number ; Fibonacci numbers for n < 6 ; Else start counting from 5 th term ; driver code"
Python;"def func ( x , y ) : NEW_LINE INDENT return ( x + y + x * y ) NEW_LINE DEDENT def euler ( x0 , y , h , x ) : NEW_LINE INDENT temp = - 0 NEW_LINE while x0 < x : NEW_LINE INDENT temp = y NEW_LINE y = y + h * func ( x0 , y ) NEW_LINE x0 = x0 + h NEW_LINE DEDENT print ( "" Approximate ▁ solution ▁ at ▁ x ▁ = ▁ "" , x , "" ▁ is ▁ "" , "" % .6f "" % y ) NEW_LINE DEDENT x0 = 0 NEW_LINE y0 = 1 NEW_LINE h = 0.025 NEW_LINE x = 0.1 NEW_LINE euler ( x0 , y0 , h , x ) NEW_LINE";"Euler Method for solving differential equation | Consider a differential equation dy / dx = ( x + y + xy ) ; Function for euler formula ; Iterating till the point at which we need approximation ; Printing approximation ; Initial Values ; Value of x at which we need approximation"
Python;"def solution ( a , b , n ) : NEW_LINE INDENT i = 0 NEW_LINE while i * a <= n : NEW_LINE INDENT if ( n - ( i * a ) ) % b == 0 : NEW_LINE INDENT print ( "" x ▁ = ▁ "" , i , "" , ▁ y ▁ = ▁ "" , int ( ( n - ( i * a ) ) / b ) ) NEW_LINE return 0 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT print ( "" No ▁ solution "" ) NEW_LINE DEDENT a = 2 NEW_LINE b = 3 NEW_LINE n = 7 NEW_LINE solution ( a , b , n ) NEW_LINE";"Find x and y satisfying ax + by = n | function to find the solution ; traverse for all possible values ; check if it is satisfying the equation ; driver program to test the above function"
Python;"import math NEW_LINE def binomialCoeffSum ( n ) : NEW_LINE INDENT return ( 1 << n ) ; NEW_LINE DEDENT n = 4 NEW_LINE print ( binomialCoeffSum ( n ) ) NEW_LINE";"Sum of Binomial coefficients | Python Program to find the sum of Binomial Coefficient . ; Returns value of Binomial Coefficient Sum ; Driver program to test above function"
Python;"def precisionCompute ( x , y , n ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT print ( "" Infinite "" ) ; NEW_LINE return ; NEW_LINE DEDENT if x == 0 : NEW_LINE INDENT print ( 0 ) ; NEW_LINE return ; NEW_LINE DEDENT if n <= 0 : NEW_LINE INDENT print ( x / y ) ; NEW_LINE return ; NEW_LINE DEDENT if ( ( ( x > 0 ) and ( y < 0 ) ) or ( ( x < 0 ) and ( y > 0 ) ) ) : NEW_LINE INDENT print ( "" - "" , end = "" "" ) ; NEW_LINE if x < 0 : NEW_LINE INDENT x = - x ; NEW_LINE DEDENT if y < 0 : NEW_LINE INDENT y = - y ; NEW_LINE DEDENT DEDENT d = x / y ; NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT print ( d ) ; NEW_LINE x = x - ( y * d ) ; NEW_LINE if x == 0 : NEW_LINE INDENT break ; NEW_LINE DEDENT x = x * 10 ; NEW_LINE d = x / y ; NEW_LINE if ( i == 0 ) : NEW_LINE INDENT print ( "" . "" , end = "" "" ) ; NEW_LINE DEDENT DEDENT DEDENT x = 22 ; NEW_LINE y = 7 ; NEW_LINE n = 15 ; NEW_LINE precisionCompute ( x , y , n ) ; NEW_LINE";"Program to compute division upto n decimal places | Python3 program to compute division upto n decimal places . ; Base cases ; Since n <= 0 , don 't  compute after the decimal ; Handling negative numbers ; Integral division ; Now one by print digits after dot using school division method . ; Driver Code"
Python;"def quadrant ( x , y ) : NEW_LINE INDENT if ( x > 0 and y > 0 ) : NEW_LINE INDENT print ( "" lies ▁ in ▁ First ▁ quadrant "" ) NEW_LINE DEDENT elif ( x < 0 and y > 0 ) : NEW_LINE INDENT print ( "" lies ▁ in ▁ Second ▁ quadrant "" ) NEW_LINE DEDENT elif ( x < 0 and y < 0 ) : NEW_LINE INDENT print ( "" lies ▁ in ▁ Third ▁ quadrant "" ) NEW_LINE DEDENT elif ( x > 0 and y < 0 ) : NEW_LINE INDENT print ( "" lies ▁ in ▁ Fourth ▁ quadrant "" ) NEW_LINE DEDENT elif ( x == 0 and y > 0 ) : NEW_LINE INDENT print ( "" lies ▁ at ▁ positive ▁ y ▁ axis "" ) NEW_LINE DEDENT elif ( x == 0 and y < 0 ) : NEW_LINE INDENT print ( "" lies ▁ at ▁ negative ▁ y ▁ axis "" ) NEW_LINE DEDENT elif ( y == 0 and x < 0 ) : NEW_LINE INDENT print ( "" lies ▁ at ▁ negative ▁ x ▁ axis "" ) NEW_LINE DEDENT elif ( y == 0 and x > 0 ) : NEW_LINE INDENT print ( "" lies ▁ at ▁ positive ▁ x ▁ axis "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" lies ▁ at ▁ origin "" ) NEW_LINE DEDENT DEDENT x = 1 NEW_LINE y = 1 NEW_LINE quadrant ( x , y ) NEW_LINE";"Program to determine the quadrant of the cartesian plane | Function to check quadrant ; Driver code ; Function Calling"
Python;"def checkDigits ( n ) : NEW_LINE INDENT while ( n ) : NEW_LINE INDENT dig = n % 10 NEW_LINE if ( dig != 2 and dig != 3 and dig != 5 and dig != 7 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT n = n / 10 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def prime ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def isFullPrime ( n ) : NEW_LINE INDENT return ( checkDigits ( n ) and prime ( n ) ) NEW_LINE DEDENT n = 53 NEW_LINE if ( isFullPrime ( n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Check if a number is Full Prime | function to check digits ; check all digits are prime or not ; check if digits are prime or not ; To check if n is prime or not ; check for all factors ; To check if n is Full Prime ; The order is important here for efficiency . ; Driver code"
Python;"def getResult ( st ) : NEW_LINE INDENT sum = 0 NEW_LINE length = len ( st ) NEW_LINE for i in st : NEW_LINE INDENT sum = sum + int ( i ) ** length NEW_LINE DEDENT number = int ( st ) NEW_LINE if ( number == sum ) : NEW_LINE INDENT return "" true "" NEW_LINE DEDENT else : NEW_LINE INDENT return "" false "" NEW_LINE DEDENT DEDENT st = ""153"" NEW_LINE print ( getResult ( st ) ) NEW_LINE";"Narcissistic number | Python program for checking of Narcissistic number ; Traversing through the string ; Converting character to int ; Converting string to integer ; Comparing number and sum ; Driver Code taking input as string"
Python;"def nthSHN ( n , dp ) : NEW_LINE INDENT if ( n == 1 or n == 2 ) : NEW_LINE INDENT dp [ n ] = 1 NEW_LINE return dp [ n ] NEW_LINE DEDENT if ( dp [ n ] != - 1 ) : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n NEW_LINE return dp [ n ] NEW_LINE DEDENT n = 6 ; NEW_LINE dp = [ - 1 for i in range ( 500 ) ] NEW_LINE print ( nthSHN ( n , dp ) ) NEW_LINE";"SchrÃ ¶ derâ €“ Hipparchus number | A memoization based optimized Python3 program to find n - th SchrAderaHipparchus number ; Driven Program"
Python;"def evensum ( n ) : NEW_LINE INDENT curr = 2 NEW_LINE sum = 0 NEW_LINE i = 1 NEW_LINE while i <= n : NEW_LINE INDENT sum += curr NEW_LINE curr += 2 NEW_LINE i = i + 1 NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 20 NEW_LINE print ( "" sum ▁ of ▁ first ▁ "" , n , "" even ▁ number ▁ is : ▁ "" , evensum ( n ) ) NEW_LINE";"Sum of first n even numbers | function to find sum of first n even numbers ; sum of first n even numbers ; next even number ; required sum ; Driver Code"
Python;"def evensum ( n ) : NEW_LINE INDENT return n * ( n + 1 ) NEW_LINE DEDENT n = 20 NEW_LINE print ( "" sum ▁ of ▁ first "" , n , "" even ▁ number ▁ is : ▁ "" , evensum ( n ) ) NEW_LINE";"Sum of first n even numbers | function to find sum of first n even numbers ; required sum ; Driver Code"
Python;"def kmphTOmph ( kmph ) : NEW_LINE INDENT mph = 0.6214 * kmph NEW_LINE return mph NEW_LINE DEDENT def mphTOkmph ( mph ) : NEW_LINE INDENT kmph = ( float ) ( mph * 1.60934 ) NEW_LINE return kmph NEW_LINE DEDENT / * Driver code to check the above function * / NEW_LINE kmph = 150 NEW_LINE mph = 100 NEW_LINE print "" speed ▁ in ▁ miles ▁ / ▁ hr ▁ is ▁ "" , kmphTOmph ( kmph ) NEW_LINE print "" speed ▁ in ▁ km ▁ / ▁ hr ▁ is ▁ "" , mphTOkmph ( mph ) NEW_LINE";"Program to Convert Km / hr to miles / hr and vice versa | Function to convert kmph to mph ; Function to convert mph to kmph ;"
Python;"from collections import defaultdict NEW_LINE def subsequences ( a , n , r ) : NEW_LINE INDENT left = defaultdict ( lambda : 0 ) NEW_LINE right = defaultdict ( lambda : 0 ) NEW_LINE ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT c1 , c2 = 0 , 0 NEW_LINE if a [ i ] % r == 0 : NEW_LINE INDENT c1 = left [ a [ i ] // r ] NEW_LINE DEDENT right [ a [ i ] ] -= 1 NEW_LINE c2 = right [ a [ i ] * r ] NEW_LINE ans += c1 * c2 NEW_LINE left [ a [ i ] ] += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = [ 1 , 2 , 6 , 2 , 3 , 6 , 9 , 18 , 3 , 9 ] NEW_LINE n = len ( a ) NEW_LINE r = 3 NEW_LINE print ( subsequences ( a , n , r ) ) NEW_LINE DEDENT";"Number of GP ( Geometric Progression ) subsequences of size 3 | Python3 program to count GP subsequences of size 3. ; Returns count of G . P . subsequences with length 3 and common ratio r ; hashing to maintain left and right array elements to the main count ; stores the answer ; traverse through the elements ; traverse through all elements and find out the number of elements as k1 * k2 ; keep the count of left and right elements left is a [ i ] / r and right a [ i ] * r ; if the current element is divisible by k , count elements in left hash . ; decrease the count in right hash ; number of right elements ; calculate the answer ; left count of a [ i ] ; Returns answer ; Driver Code"
Python;"def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def findNumber ( arr , n ) : NEW_LINE INDENT ans = arr [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT ans = gcd ( ans , arr [ i ] ) NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] == ans ) : NEW_LINE INDENT return ans NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 2 , 4 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( findNumber ( arr , n ) ) NEW_LINE";"Find element in array that divides all array elements | Returns GCD of two numbers ; Function to return the desired number if exists ; Find GCD of array ; Check if GCD is present in array ; Driver Code"
Python;"primes = [ ] ; NEW_LINE def SieveofEratosthenes ( n ) : NEW_LINE INDENT visited = [ False ] * ( n + 2 ) ; NEW_LINE for i in range ( 2 , n + 2 ) : NEW_LINE INDENT if ( visited [ i ] == False ) : NEW_LINE INDENT for j in range ( i * i , n + 2 , i ) : NEW_LINE INDENT visited [ j ] = True ; NEW_LINE DEDENT primes . append ( i ) ; NEW_LINE DEDENT DEDENT DEDENT def specialPrimeNumbers ( n , k ) : NEW_LINE INDENT SieveofEratosthenes ( n ) ; NEW_LINE count = 0 ; NEW_LINE for i in range ( len ( primes ) ) : NEW_LINE INDENT for j in range ( i - 1 ) : NEW_LINE INDENT if ( primes [ j ] + primes [ j + 1 ] + 1 == primes [ i ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( count == k ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT n = 27 ; NEW_LINE k = 2 ; NEW_LINE if ( specialPrimeNumbers ( n , k ) ) : NEW_LINE INDENT print ( "" YES "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) ; NEW_LINE DEDENT";"Special prime numbers | Python3 program to check whether there exist at least k or not in range [ 2. . n ] ; Generating all the prime numbers from 2 to n . ; If a prime number is Special prime number , then we increments the value of k . ; If at least k Special prime numbers are present , then we return 1. else we return 0 from outside of the outer loop . ; Driver Code"
Python;"import math NEW_LINE def factorize ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( ( n % 2 > 0 ) == False ) : NEW_LINE INDENT n >>= 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT print ( 2 , count ) ; NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n = int ( n / i ) ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT print ( i , count ) ; NEW_LINE DEDENT i += 2 ; NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( n , 1 ) ; NEW_LINE DEDENT DEDENT n = 1000000000000000000 ; NEW_LINE factorize ( n ) ; NEW_LINE";"Prime factors of a big number | Python3 program to print prime factors and their powers . ; Function to calculate all the prime factors and count of every prime factor ; count the number of times 2 divides ; equivalent to n = n / 2 ; ; if 2 divides it ; check for all the possible numbers that can divide it ; if n at the end is a prime number . ; Driver Code"
Python;"def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return __gcd ( b % a , a ) NEW_LINE DEDENT def minimumMoves ( A , N ) : NEW_LINE INDENT one = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( A [ i ] == 1 ) : NEW_LINE INDENT one += 1 NEW_LINE DEDENT DEDENT if ( one != 0 ) : NEW_LINE INDENT return N - one NEW_LINE DEDENT minimum = + 2147483647 NEW_LINE for i in range ( N ) : NEW_LINE INDENT g = A [ i ] NEW_LINE for j in range ( i + 1 , N ) : NEW_LINE INDENT g = __gcd ( A [ j ] , g ) NEW_LINE if ( g == 1 ) : NEW_LINE INDENT minimum = min ( minimum , j - i ) NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( minimum == + 2147483647 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return N + minimum - 1 ; NEW_LINE DEDENT DEDENT A = [ 2 , 4 , 3 , 9 ] NEW_LINE N = len ( A ) NEW_LINE print ( minimumMoves ( A , N ) ) NEW_LINE";"Minimum gcd operations to make all array elements one | __gcd function ; Function to count number of moves . ; Counting Number of ones . ; If there is a one ; Find smallest subarray with GCD equals to one . ; to calculate GCD ; Not Possible ; Final answer ; Driver program"
Python;"import math NEW_LINE def series ( n , d ) : NEW_LINE INDENT if d == 0 : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( ""0"" , end = ' ▁ ' ) NEW_LINE DEDENT return 1 NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT i = 1 NEW_LINE while i <= n : NEW_LINE INDENT print ( "" % .5f "" % ( ( math . pow ( - 1 , i ) * d ) ) , end = ' ▁ ' ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT m = n NEW_LINE r = ( m / ( m - 1 ) ) NEW_LINE g = ( float ) ( d * float ( math . sqrt ( r ) ) ) NEW_LINE print ( ""0 ▁ "" , end = ' ▁ ' ) NEW_LINE i = 1 NEW_LINE while i < n : NEW_LINE INDENT print ( "" % .5f "" % ( math . pow ( - 1 , i ) * g ) , end = ' ▁ ' ) NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT print ( "" "" ) NEW_LINE DEDENT n = 3 NEW_LINE d = 3 NEW_LINE series ( n , d ) NEW_LINE";"Given N and Standard Deviation , find N elements | Python program to find n elements ; function to print series of n elements ; if S . D . is 0 then print all elements as 0. ; print n 0 's ; if S . D . is even ; print - SD , + SD , - SD , + SD ; if odd ; if odd convert n to a float integer ; print one element to be 0 ; print ( n - 1 ) elements as xi derived from the formula ; driver code to test the above function"
Python;"def countDigitOne ( n ) : NEW_LINE INDENT countr = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT str1 = str ( i ) ; NEW_LINE countr += str1 . count ( ""1"" ) ; NEW_LINE DEDENT return countr ; NEW_LINE DEDENT n = 13 ; NEW_LINE print ( countDigitOne ( n ) ) ; NEW_LINE n = 131 ; NEW_LINE print ( countDigitOne ( n ) ) ; NEW_LINE n = 159 ; NEW_LINE print ( countDigitOne ( n ) ) ; NEW_LINE";"Total no of 1 's in numbers | Python3 code to count the frequency of 1 in numbers less than or equal to the given number . ; Driver Code"
Python;"N = 1000000007 ; NEW_LINE def exponentiation ( bas , exp ) : NEW_LINE INDENT t = 1 ; NEW_LINE while ( exp > 0 ) : NEW_LINE INDENT if ( exp % 2 != 0 ) : NEW_LINE INDENT t = ( t * bas ) % N ; NEW_LINE DEDENT bas = ( bas * bas ) % N ; NEW_LINE exp = int ( exp / 2 ) ; NEW_LINE DEDENT return t % N ; NEW_LINE DEDENT bas = 5 ; NEW_LINE exp = 100000 ; NEW_LINE modulo = exponentiation ( bas , exp ) ; NEW_LINE print ( modulo ) ; NEW_LINE";"Exponential Squaring ( Fast Modulo Multiplication ) | prime modulo value ; for cases where exponent is not an even value ; Driver Code"
Python;import math NEW_LINE def gcdOfFactorial ( m , n ) : NEW_LINE INDENT return math . factorial ( min ( m , n ) ) NEW_LINE DEDENT m = 5 NEW_LINE n = 9 NEW_LINE print ( gcdOfFactorial ( m , n ) ) NEW_LINE;"GCD of factorials of two numbers | Python code to find GCD of factorials of two numbers . ; Driver code"
Python;"def recDigSum ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT if n % 9 == 0 : NEW_LINE INDENT return 9 NEW_LINE DEDENT else : NEW_LINE INDENT return n % 9 NEW_LINE DEDENT DEDENT DEDENT def check ( n ) : NEW_LINE INDENT n = recDigSum ( n ) NEW_LINE if n == 2 or n == 3 or n == 5 or n == 7 : NEW_LINE INDENT print "" Yes "" NEW_LINE DEDENT else : NEW_LINE INDENT print "" No "" NEW_LINE DEDENT DEDENT n = 5602 NEW_LINE check ( n ) NEW_LINE";"Recursive sum of digits of a number is prime or not | Function for recursive digit sum ; function to check if prime or not the single digit ; calls function which returns sum till single digit ; checking prime ; driver code"
Python;import math NEW_LINE def findNumber ( n ) : NEW_LINE INDENT x = int ( math . floor ( ( - 1 + math . sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ) NEW_LINE base = ( x * ( x + 1 ) ) / 2 + 1 NEW_LINE return n - base + 1 NEW_LINE DEDENT n = 55 NEW_LINE print ( findNumber ( n ) ) NEW_LINE;"Find n | Python program to find the value at n - th place in the given sequence ; Definition of findNumber function ; Finding x from equation n = x ( x + 1 ) / 2 + 1 ; Base of current block ; Value of n - th element ; Driver code"
Python;def weightedMean ( n ) : NEW_LINE INDENT return ( 2 * n + 1 ) / 3 NEW_LINE DEDENT n = 10 NEW_LINE print ( int ( weightedMean ( n ) ) ) NEW_LINE;"Program for weighted mean of natural numbers . | Returns weighted mean assuming for numbers 1 , 2 , . . n and weights 1 , 2 , . . n ; Driver program to test the function ."
Python;"import math NEW_LINE def calculate ( a , b , n , m ) : NEW_LINE INDENT mul = 1 NEW_LINE for i in range ( m ) : NEW_LINE INDENT if ( b [ i ] != 0 ) : NEW_LINE INDENT mul = mul * b [ i ] NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT x = math . floor ( a [ i ] / mul ) NEW_LINE print ( x , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT a = [ 5 , 100 , 8 ] NEW_LINE b = [ 2 , 3 ] NEW_LINE n = len ( a ) NEW_LINE m = len ( b ) NEW_LINE calculate ( a , b , n , m ) NEW_LINE";"Divide every element of one array by other array elements | Python3 program to find quotient of arrayelements ; Function to calculate the quotient of every element of the array ; Calculate the product of all elements ; To calculate the quotient of every array element ; Driver code"
Python;import sys NEW_LINE def findPowerOfP ( n , p ) : NEW_LINE INDENT count = 0 NEW_LINE r = p NEW_LINE while ( r <= n ) : NEW_LINE INDENT count += ( n // r ) NEW_LINE r = r * p NEW_LINE DEDENT return count NEW_LINE DEDENT def primeFactorsofK ( k ) : NEW_LINE INDENT ans = [ ] NEW_LINE i = 2 NEW_LINE while k != 1 : NEW_LINE INDENT if k % i == 0 : NEW_LINE INDENT count = 0 NEW_LINE while k % i == 0 : NEW_LINE INDENT k = k // i NEW_LINE count += 1 NEW_LINE DEDENT ans . append ( [ i , count ] ) NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def largestPowerOfK ( n , k ) : NEW_LINE INDENT vec = primeFactorsofK ( k ) NEW_LINE ans = sys . maxsize NEW_LINE for i in range ( len ( vec ) ) : NEW_LINE INDENT ans = min ( ans , findPowerOfP ( n , vec [ i ] [ 0 ] ) // vec [ i ] [ 1 ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT print ( largestPowerOfK ( 7 , 2 ) ) NEW_LINE print ( largestPowerOfK ( 10 , 9 ) ) NEW_LINE;"Largest power of k in n ! ( factorial ) where k may not be prime | Python3 program to find the largest power of k that divides n ! ; To find the power of a prime p in factorial N ; calculating floor ( n / r ) and adding to the count ; increasing the power of p from 1 to 2 to 3 and so on ; returns all the prime factors of k ; vector to store all the prime factors along with their number of occurrence in factorization of k ; Returns largest power of k that divides n ! ; calculating minimum power of all the prime factors of k ; Driver code"
Python;"def bomb_required ( n ) : NEW_LINE INDENT print ( n + n // 2 ) NEW_LINE for i in range ( 2 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = "" ▁ "" ) NEW_LINE DEDENT for i in range ( 1 , n + 1 , 2 ) : NEW_LINE INDENT print ( i , end = "" ▁ "" ) NEW_LINE DEDENT for i in range ( 2 , n , 2 ) : NEW_LINE INDENT print ( i , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT bomb_required ( 3 ) NEW_LINE";"Minimum number of bombs | function to print where to shoot ; no . of bombs required ; bomb all the even positions ; bomb all the odd positions ; bomb all the even positions again ; Driver Code"
Python;"def lcm_fun ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT return lcm_fun ( b , a % b ) ; NEW_LINE DEDENT def digitLCM ( n ) : NEW_LINE INDENT lcm = 1 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT lcm = int ( ( n % 10 * lcm ) / lcm_fun ( n % 10 , lcm ) ) ; NEW_LINE if ( lcm == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT n = int ( n / 10 ) ; NEW_LINE DEDENT return lcm ; NEW_LINE DEDENT n = 397 ; NEW_LINE print ( digitLCM ( n ) ) ; NEW_LINE";"LCM of digits of a given number | define lcm function ; If at any point LCM become 0. return it ; Driver code"
Python;"import random NEW_LINE import math NEW_LINE e = 2.71828 ; NEW_LINE def roundNo ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT return ( num - 0.5 ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( num + 0.5 ) ; NEW_LINE DEDENT DEDENT def printBestCandidate ( candidate , n ) : NEW_LINE INDENT sample_size = roundNo ( n / e ) ; NEW_LINE print ( "" Sample size is "" , math . floor ( sample_size ) ) ; NEW_LINE best = 0 ; NEW_LINE for i in range ( 1 , int ( sample_size ) ) : NEW_LINE INDENT if ( candidate [ i ] > candidate [ best ] ) : NEW_LINE INDENT best = i ; NEW_LINE DEDENT DEDENT for i in range ( int ( sample_size ) , n ) : NEW_LINE INDENT if ( candidate [ i ] >= candidate [ best ] ) : NEW_LINE INDENT best = i ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( best >= int ( sample_size ) ) : NEW_LINE INDENT print ( "" Best candidate found is "" , math . floor ( best + 1 ) , "" with ▁ talent "" , math . floor ( candidate [ best ] ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Couldn ' t ▁ find ▁ a ▁ best ▁ candidate "" ) ; NEW_LINE DEDENT DEDENT n = 8 ; NEW_LINE candidate = [ 0 ] * ( n ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT candidate [ i ] = 1 + random . randint ( 1 , 8 ) ; NEW_LINE DEDENT print ( "" Candidate ▁ : ▁ "" , end = "" "" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( ( i + 1 ) , end = "" ▁ "" ) ; NEW_LINE DEDENT print ( "" Talents : "" , ▁ end ▁ = ▁ "" "" ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( candidate [ i ] , end = "" ▁ "" ) ; NEW_LINE DEDENT printBestCandidate ( candidate , n ) ; NEW_LINE";"Secretary Problem ( A Optimal Stopping Problem ) | Python3 Program to test 1 / e law for Secretary Problem ; To find closest integer of num . ; Finds best candidate using n / e rule . candidate [ ] represents talents of n candidates . ; Calculating sample size for benchmarking . ; Finding best candidate in sample size ; Finding the first best candidate that is better than benchmark set . ; Driver code ; n = 8 candidates and candidate array contains talents of n candidate where the largest number means highest talented candidate . ; generating random numbers between 1 to 8 for talent of candidate"
Python;"def sumDigitSquare ( n ) : NEW_LINE INDENT sq = 0 NEW_LINE while ( n ) : NEW_LINE INDENT digit = n % 10 NEW_LINE sq = sq + digit * digit NEW_LINE n = n // 10 NEW_LINE DEDENT return sq NEW_LINE DEDENT def isHappy ( n ) : NEW_LINE INDENT while ( 1 ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT n = sumDigitSquare ( n ) NEW_LINE if ( n == 4 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT n = 23 NEW_LINE if ( isHappy ( n ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Happy Numbers | Returns sum of squares of digits of a number n . For example for n = 12 it returns 1 + 4 = 5 ; Returns true if n is Happy number else returns false . ; Keep replacing n with sum of squares of digits until we either reach 1 or we end up in a cycle ; Number is Happy if we reach 1 ; Replace n with sum of squares of digits ; Number is not Happy if we reach 4 ; Driver code"
Python;def findSumSubsets ( n ) : NEW_LINE INDENT return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) NEW_LINE DEDENT n = 3 NEW_LINE print ( findSumSubsets ( n ) ) NEW_LINE;"Sum of all subsets of a set formed by first n natural numbers | Python program to find sum of all subsets of a set . ; sum of subsets is ( n * ( n + 1 ) / 2 ) * pow ( 2 , n - 1 ) ; Driver code"
Python;import math as m NEW_LINE def findMin ( a , n ) : NEW_LINE INDENT _sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE x = m . exp ( _sum / n ) NEW_LINE return int ( x + 1 ) NEW_LINE DEDENT a = [ 3 , 2 , 1 , 4 ] NEW_LINE n = len ( a ) NEW_LINE print ( findMin ( a , n ) ) NEW_LINE;"Minimum element whose n | Python3 program to find minimum element whose n - th power is greater than product of an array of size n ; function to find the minimum element ; loop to traverse and store the sum of log ; calculates the elements according to formula . ; returns the minimal element ; initialised array ; computes the size of array ; prints out the minimal element"
Python;"import math NEW_LINE def countdigits ( N ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( N ) : NEW_LINE INDENT count = count + 1 ; NEW_LINE N = int ( math . floor ( N / 10 ) ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def cyclic ( N ) : NEW_LINE INDENT num = N ; NEW_LINE n = countdigits ( N ) ; NEW_LINE while ( 1 ) : NEW_LINE INDENT print ( int ( num ) ) ; NEW_LINE rem = num % 10 ; NEW_LINE div = math . floor ( num / 10 ) ; NEW_LINE num = ( ( math . pow ( 10 , n - 1 ) ) * rem + div ) ; NEW_LINE if ( num == N ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT DEDENT N = 5674 ; NEW_LINE cyclic ( N ) ; NEW_LINE";"Generate all cyclic permutations of a number | Python3 Program to generate all cyclic permutations of number ; Function to count the total number of digits in a number . ; Function to generate all cyclic permutations of a number ; Following three lines generates a circular permutation of a number . ; If all the permutations are checked and we obtain original number exit from loop . ; Driver Code"
Python;"import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while i * i <= n : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def checkCircular ( N ) : NEW_LINE INDENT count = 0 NEW_LINE temp = N NEW_LINE while ( temp > 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE temp = temp / 10 NEW_LINE DEDENT num = N ; NEW_LINE while ( isPrime ( num ) ) : NEW_LINE INDENT rem = num % 10 NEW_LINE div = num / 10 NEW_LINE num = ( int ) ( ( math . pow ( 10 , count - 1 ) ) * rem ) + div NEW_LINE if ( num == N ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT N = 1193 ; NEW_LINE if ( checkCircular ( N ) ) : NEW_LINE INDENT print "" Yes "" NEW_LINE DEDENT else : NEW_LINE INDENT print "" No "" NEW_LINE DEDENT";"Check whether a number is circular prime or not | Python Program to check if a number is circular prime or not . ; Function to check if a number is prime or not . ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function to check if the number is circular prime or not . ; Count digits . ; Following three lines generate the next circular permutation of a number . We move last digit to first position . ; If all the permutations are checked and we obtain original number exit from loop . ; Driver Program"
Python;"def sackRace ( p1 , s1 , p2 , s2 ) : NEW_LINE INDENT return ( ( s1 > s2 and ( p2 - p1 ) % ( s1 - s2 ) == 0 ) or ( s2 > s1 and ( p1 - p2 ) % ( s2 - s1 ) == 0 ) ) NEW_LINE DEDENT p1 = 4 NEW_LINE s1 = 4 NEW_LINE p2 = 8 NEW_LINE s2 = 2 NEW_LINE if ( sackRace ( p1 , s1 , p2 , s2 ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No "" ) NEW_LINE DEDENT";"Find if two people ever meet after same number of jumps | function to find if any one of them can overtake the other ; Since starting points are always different , they will meet if following conditions are met . ( 1 ) Speeds are not same ( 2 ) Difference between speeds divide the total distance between initial points . ; driver program"
Python;"import math NEW_LINE def solve ( n ) : NEW_LINE INDENT a = float ( n / 2 ) ; NEW_LINE if ( n % 2 != 0 ) : NEW_LINE INDENT print ( ( math . ceil ( a ) - 1 ) , ( math . floor ( a ) + 1 ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( a % 2 == 0 ) : NEW_LINE INDENT print ( ( math . ceil ( a ) - 1 ) , ( math . floor ( a ) + 1 ) ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ( math . ceil ( a ) - 2 ) , ( math . floor ( a ) + 2 ) ) ; NEW_LINE DEDENT DEDENT DEDENT n = 34 ; NEW_LINE solve ( n ) ; NEW_LINE";"Largest proper fraction with sum of numerator and denominator equal to a given number | Python3 program to find the largest fraction a / b such that a + b is equal to given number and a < b . ; Calculate N / 2 ; ; Check if N is odd or even ; If N is odd answer will be ceil ( n / 2 ) - 1 and floor ( n / 2 ) + 1 ; If N is even check if N / 2 i . e a is even or odd ; If N / 2 is even apply the previous formula ; If N / 2 is odd answer will be ceil ( N / 2 ) - 2 and floor ( N / 2 ) + 2 ; Driver Code"
Python;"P = 1 NEW_LINE R = 1 NEW_LINE T = 1 NEW_LINE SI = ( P * R * T ) / 100 NEW_LINE print ( "" simple ▁ interest ▁ is "" , SI ) NEW_LINE";"Program to find simple interest | We can change values here for different inputs ; Calculates simple interest ; Print the resultant value of SI"
Python;"def countDigits ( a , b ) : NEW_LINE INDENT count = 0 NEW_LINE p = abs ( a * b ) NEW_LINE if ( p == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT ' NEW_LINE INDENT while ( p > 0 ) : NEW_LINE INDENT count = count + 1 NEW_LINE p = p // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT a = 33 NEW_LINE b = - 24 NEW_LINE print ( "" Number ▁ of ▁ digits ▁ = ▁ "" , countDigits ( a , b ) ) NEW_LINE";"Number of digits in the product of two numbers | function to count number of digits in the product of two numbers ; absolute value of the product of two numbers ; if product is 0 ; count number of digits in the product 'p ; required count of digits ; Driver program to test above"
Python;"import math NEW_LINE def multiple ( a , b , x ) : NEW_LINE INDENT if ( b < 0 ) : NEW_LINE INDENT if ( a == 1 and x == 1 ) : NEW_LINE INDENT print ( ""1"" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ""0"" ) ; NEW_LINE DEDENT DEDENT mul = int ( pow ( a , b ) ) ; NEW_LINE ans = int ( mul / x ) ; NEW_LINE ans1 = x * ans ; NEW_LINE ans2 = x * ( ans + 1 ) ; NEW_LINE if ( ( mul - ans1 ) <= ( ans2 - mul ) ) : NEW_LINE INDENT print ( ans1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( ans2 ) ; NEW_LINE DEDENT DEDENT a = 349 ; NEW_LINE b = 1 ; NEW_LINE x = 4 ; NEW_LINE multiple ( a , b , x ) ; NEW_LINE";"Find multiple of x closest to or a ^ b ( a raised to power b ) | Python3 Program to find closest multiple of x to a ^ b ; function to find closest multiple of x to a ^ b ; calculate a ^ b / x ; Answer is either ( ans * x ) or ( ans + 1 ) * x ; Printing nearest answer ; Driver Code"
Python;def maxSum ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return int ( ( n * ( n - 1 ) / 2 ) - 1 + n / 2 ) NEW_LINE DEDENT DEDENT n = 3 NEW_LINE print ( maxSum ( n ) ) NEW_LINE;"Maximum sum of difference of adjacent elements | To find max sum of permutation ; Base case ; Otherwise max sum will be ( n * ( n - 1 ) / 2 ) - 1 + n / 2 ; Driver program to test maxSum ( )"
Python;"import sys NEW_LINE from math import floor NEW_LINE INT_MAX = 2147483647 NEW_LINE def compute_average ( a , b ) : NEW_LINE INDENT return floor ( ( a + b ) / 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = INT_MAX NEW_LINE b = - INT_MAX - 1 NEW_LINE print ( "" Actual ▁ average ▁ : ▁ "" , INT_MAX ) NEW_LINE print ( "" Computed ▁ average ▁ : ▁ "" , compute_average ( a , b ) ) NEW_LINE DEDENT";"Compute average of two numbers without overflow | Python 3 code to compute average of two numbers ; Function to compute average of two numbers ; Driver code ; Assigning maximum integer value ; Average of two equal numbers is the same number ; Function to get the average of 2 numbers"
Python;def minNum ( arr , n ) : NEW_LINE INDENT odd = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 ) : NEW_LINE INDENT odd = not odd NEW_LINE DEDENT DEDENT if ( odd ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print minNum ( arr , n ) NEW_LINE;"Add minimum number to an array so that the sum becomes even | Function to find out minimum number ; Count odd number of terms in array ; Driver code"
Python;"def checkJumbled ( num ) : NEW_LINE INDENT if ( num / 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT while ( num != 0 ) : NEW_LINE INDENT if ( num / 10 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT digit1 = num % 10 NEW_LINE digit2 = ( num / 10 ) % 10 NEW_LINE if ( abs ( digit2 - digit1 ) > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT num = num / 10 NEW_LINE DEDENT return True NEW_LINE DEDENT num = - 1234 NEW_LINE if ( checkJumbled ( abs ( num ) ) ) : NEW_LINE INDENT print "" True ▁ "" NEW_LINE DEDENT else : NEW_LINE INDENT print "" False "" NEW_LINE DEDENT num = - 1247 NEW_LINE if ( checkJumbled ( abs ( num ) ) ) : NEW_LINE INDENT print "" True ▁ "" NEW_LINE DEDENT else : NEW_LINE INDENT print "" False "" NEW_LINE DEDENT";"Check if a number is jumbled or not | Function to check if a number is jumbled or not ; Single digit number ; Checking every digit through a loop ; All digits were checked ; Digit at index i ; Digit at index i - 1 ; If difference is greater than 1 ; Number checked ; - 1234 to be checked ; - 1247 to be checked"
Python;def msbPos ( n ) : NEW_LINE INDENT pos = 0 NEW_LINE while n != 0 : NEW_LINE INDENT pos += 1 NEW_LINE n = n >> 1 NEW_LINE DEDENT return pos NEW_LINE DEDENT def josephify ( n ) : NEW_LINE INDENT position = msbPos ( n ) NEW_LINE DEDENT ' NEW_LINE INDENT j = 1 << ( position - 1 ) NEW_LINE n = n ^ j NEW_LINE n = n << 1 NEW_LINE n = n | 1 NEW_LINE return n NEW_LINE DEDENT n = 41 NEW_LINE print ( josephify ( n ) ) NEW_LINE;"Josephus Problem Using Bit Magic | Function to find the position of the Most Significant Bit ; keeps shifting bits to the right until we are left with 0 ; Function to return at which place Josephus should sit to avoid being killed ; Getting the position of the Most Significant Bit ( MSB ) . The leftmost '1' . If the number is '41' then its binary is '101001' . So msbPos ( 41 ) = 6 ; ' j ' stores the number with which to XOR the number ' n ' . Since we need '100000' We will do 1 << 6 - 1 to get '100000 ; Toggling the Most Significant Bit . Changing the leftmost '1' to '0' . 101001 ^ 100000 = 001001 ( 9 ) ; Left - shifting once to add an extra '0' to the right end of the binary number 001001 = 010010 ( 18 ) ; Toggling the '0' at the end to '1' which is essentially the same as putting the MSB at the rightmost place . 010010 | 1 = 010011 ( 19 ) ; Driver Code"
Python;"def countXorPair ( arr , n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countXorPair ( arr , n ) ) NEW_LINE DEDENT";"Count pairs with Odd XOR | A function will return number of pair whose XOR is odd ; To store count of XOR pair ; If XOR is odd increase count ; Return count ; Driver Code"
Python;"import math ; NEW_LINE def powmod ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT x = ( x * x ) % p ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def discreteLogarithm ( a , b , m ) : NEW_LINE INDENT n = int ( math . sqrt ( m ) + 1 ) ; NEW_LINE value = [ 0 ] * m ; NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT value [ powmod ( a , i * n , m ) ] = i ; NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT cur = ( powmod ( a , j , m ) * b ) % m ; NEW_LINE if ( value [ cur ] ) : NEW_LINE INDENT ans = value [ cur ] * n - j ; NEW_LINE if ( ans < m ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT DEDENT DEDENT return - 1 ; NEW_LINE DEDENT a = 2 ; NEW_LINE b = 3 ; NEW_LINE m = 5 ; NEW_LINE print ( discreteLogarithm ( a , b , m ) ) ; NEW_LINE a = 3 ; NEW_LINE b = 7 ; NEW_LINE m = 11 ; NEW_LINE print ( discreteLogarithm ( a , b , m ) ) ; NEW_LINE";"Discrete logarithm ( Find an integer k such that a ^ k is congruent modulo b ) | Python3 program to calculate discrete logarithm ; Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; x = x % p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 ; y = y / 2 ; Function to calculate k for given a , b , m ; Store all values of a ^ ( n * i ) of LHS ; Calculate ( a ^ j ) * b and check for collision ; If collision occurs i . e . , LHS = RHS ; Check whether ans lies below m or not ; Driver code"
Python;"import math ; NEW_LINE def discreteLogarithm ( a , b , m ) : NEW_LINE INDENT n = int ( math . sqrt ( m ) + 1 ) ; NEW_LINE an = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT an = ( an * a ) % m ; NEW_LINE DEDENT value = [ 0 ] * m ; NEW_LINE cur = an ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( value [ cur ] == 0 ) : NEW_LINE INDENT value [ cur ] = i ; NEW_LINE DEDENT cur = ( cur * an ) % m ; NEW_LINE DEDENT cur = b ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( value [ cur ] > 0 ) : NEW_LINE INDENT ans = value [ cur ] * n - i ; NEW_LINE if ( ans < m ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT DEDENT cur = ( cur * a ) % m ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT a = 2 ; NEW_LINE b = 3 ; NEW_LINE m = 5 ; NEW_LINE print ( discreteLogarithm ( a , b , m ) ) ; NEW_LINE a = 3 ; NEW_LINE b = 7 ; NEW_LINE m = 11 ; NEW_LINE print ( discreteLogarithm ( a , b , m ) ) ; NEW_LINE";"Discrete logarithm ( Find an integer k such that a ^ k is congruent modulo b ) | Python3 program to calculate discrete logarithm ; Calculate a ^ n ; Store all values of a ^ ( n * i ) of LHS ; Calculate ( a ^ j ) * b and check for collision ; Driver code"
Python;"def nthprimedigitsnumber ( number ) : NEW_LINE INDENT num = "" "" ; NEW_LINE while ( number > 0 ) : NEW_LINE INDENT rem = number % 4 ; NEW_LINE if ( rem == 1 ) : NEW_LINE INDENT num += '2' ; NEW_LINE DEDENT if ( rem == 2 ) : NEW_LINE INDENT num += '3' ; NEW_LINE DEDENT if ( rem == 3 ) : NEW_LINE INDENT num += '5' ; NEW_LINE DEDENT if ( rem == 0 ) : NEW_LINE INDENT num += '7' ; NEW_LINE DEDENT if ( number % 4 == 0 ) : NEW_LINE INDENT number = number - 1 NEW_LINE DEDENT number = number // 4 ; NEW_LINE DEDENT return num [ : : - 1 ] ; NEW_LINE DEDENT number = 21 ; NEW_LINE print ( nthprimedigitsnumber ( 10 ) ) ; NEW_LINE print ( nthprimedigitsnumber ( number ) ) ; NEW_LINE";"Finding n | Python3 program to find n - th number with prime digits 2 , 3 and 7 ; remainder for check element position ; if number is 1 st position in tree ; if number is 2 nd position in tree ; if number is 3 rd position in tree ; if number is 4 th position in tree ; Driver code"
Python;import math NEW_LINE def countPairs ( N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 1 , int ( math . pow ( N , 1 / 3 ) + 1 ) ) : NEW_LINE INDENT cb = i * i * i NEW_LINE diff = N - cb NEW_LINE cbrtDiff = int ( math . pow ( diff , 1 / 3 ) ) NEW_LINE if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT for i in range ( 1 , 11 ) : NEW_LINE INDENT print ( ' For ▁ n ▁ = ▁ ' , i , ' , ▁ ' , countPairs ( i ) , ' ▁ pair ▁ exists ' ) NEW_LINE DEDENT;"Count pairs ( a , b ) whose sum of cubes is N ( a ^ 3 + b ^ 3 = N ) | Python 3 program to count pairs whose sum cubes is N ; Function to count the pairs satisfying a ^ 3 + b ^ 3 = N ; Check for each number 1 to cbrt ( N ) ; Store cube of a number ; Subtract the cube from given N ; Check if the difference is also a perfect cube ; If yes , then increment count ; Return count ; Loop to Count no . of pairs satisfying a ^ 3 + b ^ 3 = i for N = 1 to 10"
Python;"def primeFactors ( num ) : NEW_LINE INDENT ans = dict ( ) NEW_LINE i = 2 NEW_LINE while ( i * i <= num ) : NEW_LINE INDENT while ( num % i == 0 ) : NEW_LINE INDENT num //= i ; NEW_LINE if i not in ans : NEW_LINE ans [ i ] = 0 NEW_LINE ans [ i ] += 1 NEW_LINE DEDENT DEDENT if ( num > 1 ) : NEW_LINE if num not in ans : NEW_LINE INDENT ans [ num ] = 0 NEW_LINE DEDENT ans [ num ] += 1 NEW_LINE return ans ; NEW_LINE DEDENT def legendre ( factor , num ) : NEW_LINE INDENT count = 0 NEW_LINE fac2 = factor ; NEW_LINE while ( num >= factor ) : NEW_LINE INDENT count += num // factor ; NEW_LINE factor *= fac2 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def possible ( factors , num ) : NEW_LINE INDENT for it in factors . keys ( ) : NEW_LINE INDENT if ( legendre ( it , num ) < factors [ it ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT def search ( start , end , factors ) : NEW_LINE INDENT mid = ( start + end ) // 2 ; NEW_LINE if ( not possible ( factors , mid ) ) : NEW_LINE INDENT return search ( mid + 1 , end , factors ) ; NEW_LINE DEDENT if ( start == mid ) : NEW_LINE INDENT return mid ; NEW_LINE DEDENT return search ( start , mid , factors ) ; NEW_LINE DEDENT def findFact ( num ) : NEW_LINE INDENT factors = primeFactors ( num ) ; NEW_LINE return search ( 1 , num , factors ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( findFact ( 6 ) ) NEW_LINE print ( findFact ( 997587429953 ) ) NEW_LINE DEDENT";"Smallest number S such that N is a factor of S factorial or S ! | Calculate prime factors for a given number ; Container for prime factors ; Iterate from 2 to i ^ 2 finding all factors ; If we still have a remainder it is also a prime factor ; Calculate occurrence of an element in factorial of a number ; Iterate through prime factors ; Check if factorial contains less occurrences of prime factor ; Function to binary search 1 to N ; Prime factors are not in the factorial Increase the lowerbound ; We have reached smallest occurrence ; Smaller factorial satisfying requirements may exist , decrease upperbound ; Calculate prime factors and search ; Driver function"
Python;"def printEqualModNumbers ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE d = arr [ n - 1 ] - arr [ 0 ] ; NEW_LINE if ( d == 0 ) : NEW_LINE INDENT print ( "" Infinite ▁ solution "" ) NEW_LINE return NEW_LINE DEDENT v = [ ] ; NEW_LINE i = 1 ; NEW_LINE while ( i * i <= d ) : NEW_LINE INDENT if ( d % i == 0 ) : NEW_LINE INDENT v . append ( i ) ; NEW_LINE if ( i != d / i ) : NEW_LINE INDENT v . append ( d / i ) ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT for i in range ( len ( v ) ) : NEW_LINE INDENT temp = arr [ 0 ] % v [ i ] ; NEW_LINE j = 1 ; NEW_LINE while ( j < n ) : NEW_LINE INDENT if ( arr [ j ] % v [ i ] != temp ) : NEW_LINE INDENT break ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT if ( j == n ) : NEW_LINE INDENT print ( v [ i ] , end = "" ▁ "" ) ; NEW_LINE DEDENT DEDENT DEDENT arr = [ 38 , 6 , 34 ] ; NEW_LINE printEqualModNumbers ( arr , len ( arr ) ) ; NEW_LINE";"Finding ' k ' such that its modulus with each array element is same | Prints all k such that arr [ i ] % k is same for all i ; sort the numbers ; max difference will be the difference between first and last element of sorted array ; Case when all the array elements are same ; Find all divisors of d and store in a vector v [ ] ; check for each v [ i ] if its modulus with each array element is same or not ; checking for each array element if its modulus with k is equal to k or not ; if check is true print v [ i ] ; Driver Code"
Python;import math NEW_LINE def FirstDigit ( arr , n ) : NEW_LINE INDENT S = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT S = S + math . log10 ( arr [ i ] * 1.0 ) NEW_LINE DEDENT fract_S = S - math . floor ( S ) NEW_LINE ans = math . pow ( 10 , fract_S ) NEW_LINE return ans NEW_LINE DEDENT arr = [ 5 , 8 , 3 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( ( int ) ( FirstDigit ( arr , n ) ) ) NEW_LINE;"First digit in product of an array of numbers | Python implementation of finding first digit of product of n numbers ; Returns the first digit of product of elements of arr [ ] ; stores the logarithm of product of elements of arr [ ] ; fractional ( s ) = s - floor ( s ) ; ans = 10 ^ fract_s ; Driver function"
Python;def countDigit ( n ) : NEW_LINE INDENT temp = n NEW_LINE count = 0 NEW_LINE while temp != 0 : NEW_LINE INDENT d = temp % 10 NEW_LINE temp //= 10 NEW_LINE if d > 0 and n % d == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT n = 1012 NEW_LINE print ( countDigit ( n ) ) NEW_LINE;"Find count of digits in a number that divide the number | Return the number of digits that divides the number . ; Fetching each digit of the number ; Checking if digit is greater than 0 and can divides n . ; Driven Code"
Python;"def makeOdd ( n ) : NEW_LINE INDENT if ( n % 2 != 0 ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT resul = 1 ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 ; NEW_LINE resul = resul * 2 ; NEW_LINE DEDENT return resul ; NEW_LINE DEDENT n = 36 ; NEW_LINE print ( makeOdd ( n ) ) ; NEW_LINE";"Minimum positive integer to divide a number such that the result is an odd | Function to find the value ; Return 1 if already odd ; Check how many times it is divided by 2 ; Driver code"
Python;"def closestMultiple ( n , x ) : NEW_LINE INDENT if x > n : NEW_LINE INDENT return x ; NEW_LINE DEDENT z = ( int ) ( x / 2 ) ; NEW_LINE n = n + z ; NEW_LINE n = n - ( n % x ) ; NEW_LINE return n ; NEW_LINE DEDENT n = 56287 ; NEW_LINE x = 27 ; NEW_LINE print ( closestMultiple ( n , x ) ) ; NEW_LINE";"Multiple of x closest to n | Function to calculate the smallest multiple ; Driver Code"
Python;"def cbrt ( n ) : NEW_LINE INDENT return ( int ) ( n ** ( 1. / 3 ) ) NEW_LINE DEDENT def printCubes ( a , b ) : NEW_LINE INDENT acrt = cbrt ( a ) NEW_LINE bcrt = cbrt ( b ) NEW_LINE for i in range ( acrt , bcrt + 1 ) : NEW_LINE INDENT if ( i * i * i >= a and i * i * i <= b ) : NEW_LINE INDENT print ( i * i * i , "" ▁ "" , end = "" "" ) NEW_LINE DEDENT DEDENT DEDENT a = 24 NEW_LINE b = 576 NEW_LINE print ( "" Perfect ▁ cubes ▁ in ▁ given ▁ range : "" ) NEW_LINE printCubes ( a , b ) NEW_LINE";"Perfect cubes in a range | Python3 code for Efficient method to print cubes between a and b ; An efficient solution to print perfect cubes between a and b ; Find cube root of both a and b ; Print cubes between acrt and bcrt ; Driver code"
Python;def number0f2s ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 == 2 ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT def numberOf2sinRange ( n ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT count = count + number0f2s ( i ) NEW_LINE DEDENT return count NEW_LINE DEDENT print ( numberOf2sinRange ( 22 ) ) NEW_LINE print ( numberOf2sinRange ( 100 ) ) NEW_LINE;"Number of occurrences of 2 as a digit in numbers from 0 to n | Counts the number of '2' digits in a single number ; Counts the number of '2' digits between 0 and n ; Initialize result ; Count 2 's in every number  from 2 to n ; Driver code"
Python;def minToggle ( arr , n ) : NEW_LINE INDENT zero = [ 0 for i in range ( n + 1 + 1 ) ] NEW_LINE zero [ 0 ] = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( arr [ i - 1 ] == 0 ) : NEW_LINE INDENT zero [ i ] = zero [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT zero [ i ] = zero [ i - 1 ] NEW_LINE DEDENT DEDENT ans = n NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 0 , 1 , 1 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minToggle ( arr , n ) ) NEW_LINE;"Minimum toggles to partition a binary array so that it has first 0 s then 1 s | Function to calculate minimum toggling required by using Dynamic programming ; Fill entries in zero [ ] such that zero [ i ] stores count of zeroes to the left of i ( exl ; If zero found update zero [ ] array ; Finding the minimum toggle required from every index ( 0 to n - 1 ) ; Driver Program"
Python;"def check ( st ) : NEW_LINE INDENT n = len ( st ) NEW_LINE if ( ( ( int ) ( st [ n - 1 ] ) % 2 ) != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT digitSum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT digitSum = digitSum + ( int ) ( st [ i ] ) NEW_LINE DEDENT return ( digitSum % 3 == 0 ) NEW_LINE DEDENT st = ""1332"" NEW_LINE if ( check ( st ) ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" No ▁ "" ) NEW_LINE DEDENT";"Check if a large number is divisible by 6 or not | Function to find that number is divisible by 6 or not ; Return false if number is not divisible by 2. ; Compute sum of digits ; Check if sum of digits is divisible by 3 ; Driver code"
Python;def checkRecursive ( num , rem_num , next_int , n , ans = 0 ) : NEW_LINE INDENT if ( rem_num == 0 ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT r = int ( num ** ( 1 / n ) ) NEW_LINE for i in range ( next_int + 1 , r + 1 ) : NEW_LINE INDENT a = rem_num - int ( i ** n ) NEW_LINE if a >= 0 : NEW_LINE INDENT ans += checkRecursive ( num , rem_num - int ( i ** n ) , i , n , 0 ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT def check ( x , n ) : NEW_LINE INDENT return checkRecursive ( x , x , 0 , n ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( check ( 10 , 2 ) ) NEW_LINE DEDENT;"Find ways an Integer can be expressed as sum of n | Python 3 program to find number of ways to express a number as sum of n - th powers of numbers . ; Wrapper over checkRecursive ( ) ; Driver Code"
Python;"import math ; NEW_LINE def reverseNum ( n ) : NEW_LINE INDENT rev = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT rem = n % 10 ; NEW_LINE rev = ( rev * 10 ) + rem ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT return rev ; NEW_LINE DEDENT def isPalindrom ( num ) : NEW_LINE INDENT return num == reverseNum ( num ) ; NEW_LINE DEDENT def nthPalindrome ( n , k ) : NEW_LINE INDENT num = math . pow ( 10 , k - 1 ) ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( isPalindrom ( num ) ) : NEW_LINE INDENT n -= 1 ; NEW_LINE DEDENT if ( not n ) : NEW_LINE INDENT break ; NEW_LINE DEDENT num += 1 ; NEW_LINE DEDENT return int ( num ) ; NEW_LINE DEDENT n = 6 ; NEW_LINE k = 5 ; NEW_LINE print ( n , "" th ▁ palindrome ▁ of "" , k , "" digit ▁ = "" , nthPalindrome ( n , k ) ) ; NEW_LINE n = 10 ; NEW_LINE k = 6 ; NEW_LINE print ( n , "" th ▁ palindrome ▁ of "" , k , "" digit ▁ = "" , nthPalindrome ( n , k ) ) ; NEW_LINE";"N 'th palindrome of K digits | A naive approach of Python3 program of finding nth palindrome of k digit ; Utility function to reverse the number n ; Boolean Function to check for palindromic number ; Function for finding nth palindrome of k digits ; Get the smallest k digit number ; check the number is palindrom or not ; if n 'th palindrome found  break the loop ; Increment number for checking next palindrome ; Driver code"
Python;"def nthPalindrome ( n , k ) : NEW_LINE INDENT if ( k & 1 ) : NEW_LINE INDENT temp = k // 2 NEW_LINE DEDENT else : NEW_LINE INDENT temp = k // 2 - 1 NEW_LINE DEDENT palindrome = 10 ** temp NEW_LINE palindrome = palindrome + n - 1 NEW_LINE print ( palindrome , end = "" "" ) NEW_LINE if ( k & 1 ) : NEW_LINE INDENT palindrome = palindrome // 10 NEW_LINE DEDENT while ( palindrome ) : NEW_LINE INDENT print ( palindrome % 10 , end = "" "" ) NEW_LINE palindrome = palindrome // 10 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE k = 5 NEW_LINE print ( n , "" th ▁ palindrome ▁ of "" , k , "" ▁ digit ▁ = ▁ "" , end = "" ▁ "" ) NEW_LINE nthPalindrome ( n , k ) NEW_LINE print ( ) NEW_LINE n = 10 NEW_LINE k = 6 NEW_LINE print ( n , "" th ▁ palindrome ▁ of "" , k , "" digit ▁ = ▁ "" , end = "" ▁ "" ) NEW_LINE nthPalindrome ( n , k ) NEW_LINE DEDENT";"N 'th palindrome of K digits | Python3 program of finding nth palindrome of k digit ; Determine the first half digits ; Print the first half digits of palindrome ; If k is odd , truncate the last digit ; print the last half digits of palindrome ; Driver code"
Python;"import sys NEW_LINE def findMax ( n , a , b , k , m ) : NEW_LINE INDENT arr = [ 0 ] * n NEW_LINE for i in range ( m ) : NEW_LINE INDENT lowerbound = a [ i ] NEW_LINE upperbound = b [ i ] NEW_LINE for j in range ( lowerbound , upperbound + 1 ) : NEW_LINE arr [ j ] += k [ i ] NEW_LINE res = - sys . maxsize - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT res = max ( res , arr [ i ] ) NEW_LINE return res NEW_LINE DEDENT DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 5 NEW_LINE a = [ 0 , 1 , 2 ] NEW_LINE b = [ 1 , 4 , 3 ] NEW_LINE k = [ 100 , 100 , 100 ] NEW_LINE m = len ( a ) NEW_LINE print ( "" Maximum ▁ value ▁ after ▁ ' m ' ▁ operations ▁ is ▁ "" , findMax ( n , a , b , k , m ) ) NEW_LINE DEDENT";"Maximum value in an array after m range increment operations | Python3 progrma of simple approach to find maximum value after m range increments . ; Function to find the maximum element after m operations ; Start performing m operations ; Store lower and upper index i . e . range ; Add ' k [ i ] ' value at this operation to whole range ; Find maximum value after all operations and return ; Driver code ; Number of values ; Value of k to be added at each operation"
Python;"MAX = 100001 NEW_LINE phi = [ 0 ] * MAX NEW_LINE result = [ 0 ] * MAX NEW_LINE def computeTotient ( ) : NEW_LINE INDENT phi [ 1 ] = 1 NEW_LINE for i in range ( 2 , MAX ) : NEW_LINE INDENT if not phi [ i ] : NEW_LINE INDENT phi [ i ] = i - 1 NEW_LINE for j in range ( i << 1 , MAX , i ) : NEW_LINE INDENT if not phi [ j ] : NEW_LINE INDENT phi [ j ] = j NEW_LINE DEDENT phi [ j ] = ( ( phi [ j ] // i ) * ( i - 1 ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT def sumOfGcdPairs ( ) : NEW_LINE INDENT computeTotient ( ) NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT for j in range ( 2 , MAX ) : NEW_LINE INDENT if i * j >= MAX : NEW_LINE INDENT break NEW_LINE DEDENT result [ i * j ] += i * phi [ j ] NEW_LINE DEDENT DEDENT for i in range ( 2 , MAX ) : NEW_LINE INDENT result [ i ] += result [ i - 1 ] NEW_LINE DEDENT DEDENT sumOfGcdPairs ( ) NEW_LINE N = 4 NEW_LINE print ( "" Summation ▁ of "" , N , "" = "" , result [ N ] ) NEW_LINE N = 12 NEW_LINE print ( "" Summation ▁ of "" , N , "" = "" , result [ N ] ) NEW_LINE N = 5000 NEW_LINE print ( "" Summation ▁ of "" , N , "" = "" , result [ N ] ) NEW_LINE";"Summation of GCD of all the pairs up to N | Python approach of finding sum of GCD of all pairs ; phi [ i ] stores euler totient function for i result [ j ] stores result for value j ; Precomputation of phi [ ] numbers . Refer below link for details : https : goo . gl / LUqdtY ; Refer https : goo . gl / LUqdtY ; Precomputes result for all numbers till MAX ; Precompute all phi value ; Iterate throght all the divisors of i . ; Add summation of previous calculated sum ; Function to calculate sum of all the GCD pairs"
Python;"N = 3 NEW_LINE def solve ( v ) : NEW_LINE INDENT res = [ ] NEW_LINE all3 = v [ 0 ] + v [ 1 ] + v [ 2 ] NEW_LINE res . append ( all3 - v [ 1 ] * 2 ) NEW_LINE res . append ( all3 - v [ 2 ] * 2 ) NEW_LINE res . append ( all3 - v [ 0 ] * 2 ) NEW_LINE return res NEW_LINE DEDENT def findVertex ( xmid , ymid ) : NEW_LINE INDENT V1 = solve ( xmid ) NEW_LINE V2 = solve ( ymid ) NEW_LINE for i in range ( 0 , 3 ) : NEW_LINE INDENT print ( V1 [ i ] , end = "" ▁ "" ) NEW_LINE print ( V2 [ i ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT xmid = [ 5 , 4 , 5 ] NEW_LINE ymid = [ 3 , 4 , 5 ] NEW_LINE findVertex ( xmid , ymid ) NEW_LINE DEDENT";"Find coordinates of the triangle given midpoint of each side | Python3 program to find coordinate of the triangle given midpoint of each side ; Return after solving the equations and finding the vertices coordinate . ; Finding sum of all three coordinate . ; Solving the equation . ; Finds vertices of a triangles from given middle vertices . ; Find X coordinates of vertices . ; Find Y coordinates of vertices . ; Output the solution . ; Driver code"
Python;"def nthElement ( a , b , n ) : NEW_LINE INDENT seq = [ ] ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT seq . append ( a * i ) ; NEW_LINE DEDENT seq . sort ( ) ; NEW_LINE i = 1 ; NEW_LINE k = n ; NEW_LINE while ( i <= n and k > 0 ) : NEW_LINE INDENT try : NEW_LINE INDENT z = seq . index ( b * i ) ; NEW_LINE DEDENT except ValueError : NEW_LINE INDENT seq . append ( b * i ) ; NEW_LINE seq . sort ( ) ; NEW_LINE k -= 1 ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT return seq [ n - 1 ] ; NEW_LINE DEDENT a = 3 ; NEW_LINE b = 5 ; NEW_LINE n = 5 ; NEW_LINE print ( nthElement ( a , b , n ) ) ; NEW_LINE";"N | Return the n - th number in the sorted list of multiples of two numbers . ; Generating first n multiple of a . ; Sorting the sequence . ; Generating and storing first n multiple of b and storing if not present in the sequence . ; If not present in the sequence ; Storing in the sequence . ; Driver Code"
Python;def gcd ( a , b ) : NEW_LINE INDENT return gcd ( b , a % b ) if b > 0 else a NEW_LINE DEDENT def countGCD ( L , R , g ) : NEW_LINE INDENT L = ( L + g - 1 ) // g NEW_LINE R = R // g NEW_LINE ans = 0 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT for j in range ( L , R + 1 ) : NEW_LINE INDENT if ( gcd ( i , j ) == 1 ) : NEW_LINE INDENT ans = ans + 1 NEW_LINE DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT L = 1 NEW_LINE R = 11 NEW_LINE g = 5 NEW_LINE print ( countGCD ( L , R , g ) ) NEW_LINE;"Count pairs of natural numbers with GCD equal to given number | Return the GCD of two numbers . ; Return the count of pairs having GCD equal to g . ; Setting the value of L , R . ; For each possible pair check if GCD is 1. ; Driver code"
Python;dig = [ 1 , 1 , 2 , 6 , 4 , 2 , 2 , 4 , 2 , 8 ] NEW_LINE def lastNon0Digit ( n ) : NEW_LINE INDENT if ( n < 10 ) : NEW_LINE INDENT return dig [ n ] NEW_LINE DEDENT if ( ( ( n // 10 ) % 10 ) % 2 == 0 ) : NEW_LINE INDENT return ( 6 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 NEW_LINE DEDENT else : NEW_LINE INDENT return ( 4 * lastNon0Digit ( n // 5 ) * dig [ n % 10 ] ) % 10 NEW_LINE DEDENT return 0 NEW_LINE DEDENT n = 14 NEW_LINE print ( lastNon0Digit ( n ) ) NEW_LINE;"Last non | Initialize values of last non - zero digit of numbers from 0 to 9 ; Check whether tens ( or second last ) digit is odd or even If n = 375 , So n / 10 = 37 and ( n / 10 ) % 10 = 7 Applying formula for even and odd cases . ; driver code"
Python;def gcd ( a , b ) : NEW_LINE INDENT if ( ( a % b ) == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b , a % b ) NEW_LINE DEDENT def firstFactorialDivisibleNumber ( x ) : NEW_LINE INDENT new_x = x NEW_LINE for i in range ( 1 , x ) : NEW_LINE INDENT new_x /= gcd ( i , new_x ) NEW_LINE if ( new_x == 1 ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT return i NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x = 16 NEW_LINE print ( firstFactorialDivisibleNumber ( x ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT;"Find the first natural number whose factorial is divisible by x | GCD function to compute the greatest divisor among a and b ; Returns first number whose factorial divides x . ; i = 1 Result ; Remove common factors ; We found first i . ; Driver code"
Python;"def sieve ( prime , n ) : NEW_LINE INDENT p = 2 NEW_LINE while p * p <= n : NEW_LINE INDENT if ( prime [ p ] == False ) : NEW_LINE INDENT for i in range ( p * 2 , n , p ) : NEW_LINE INDENT prime [ i ] = True NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def maxDigitInPrimes ( L , R ) : NEW_LINE INDENT prime = [ 0 ] * ( R + 1 ) NEW_LINE sieve ( prime , R ) NEW_LINE freq = [ 0 ] * 10 NEW_LINE for i in range ( L , R + 1 ) : NEW_LINE INDENT if ( not prime [ i ] ) : NEW_LINE INDENT while ( p ) : NEW_LINE INDENT freq [ p % 10 ] += 1 NEW_LINE p //= 10 NEW_LINE DEDENT DEDENT DEDENT max = freq [ 0 ] NEW_LINE ans = 0 NEW_LINE for j in range ( 1 , 10 ) : NEW_LINE INDENT if ( max <= freq [ j ] ) : NEW_LINE INDENT max = freq [ j ] NEW_LINE ans = j NEW_LINE DEDENT DEDENT if max == 0 NEW_LINE return - 1 NEW_LINE return ans NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT L = 1 NEW_LINE R = 20 NEW_LINE print ( maxDigitInPrimes ( L , R ) ) NEW_LINE DEDENT";"Find the highest occurring digit in prime numbers in a range | Sieve of Eratosthenes ; Returns maximum occurring digits in primes from l to r . ; Finding the prime number up to R . ; Initialise frequency of all digit to 0. ; For all number between L to R , check if prime or not . If prime , incrementing the frequency of digits present in the prime number . ; p = i If i is prime ; Finding digit with highest frequency . ; Driver Code"
Python;"arr = [ True ] * ( 1001 ) NEW_LINE def simpleSieve ( ) : NEW_LINE INDENT k = 0 NEW_LINE for p in range ( 2 , 1001 ) : NEW_LINE INDENT if ( p * p > 1001 ) : NEW_LINE INDENT break NEW_LINE DEDENT if ( arr [ p ] ) : NEW_LINE INDENT for k in range ( p , 1001 , k + p ) : NEW_LINE INDENT arr [ k ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def find_sphene ( N ) : NEW_LINE INDENT arr1 = [ 0 ] * ( 8 ) NEW_LINE count = 0 NEW_LINE j = 0 NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT if ( N % i == 0 and count < 8 ) : NEW_LINE INDENT count += 1 NEW_LINE arr1 [ j ] = i NEW_LINE j += 1 NEW_LINE DEDENT DEDENT if ( count == 8 and ( arr [ arr1 [ 1 ] ] and arr [ arr1 [ 2 ] ] and arr [ arr1 [ 3 ] ] ) ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 60 NEW_LINE simpleSieve ( ) NEW_LINE ans = find_sphene ( n ) NEW_LINE if ( ans == 1 ) : NEW_LINE INDENT print ( "" Yes "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" NO "" ) NEW_LINE DEDENT DEDENT";"Sphenic Number | Create a global array of size 1001 ; ; This functions finds all primes smaller than ' limit ' using simple sieve of eratosthenes . ; Initialize all entries of it as True . A value in mark [ p ] will finally be False if ' p ' is Not a prime , else True . ; One by one traverse all numbers so that their multiples can be marked as composite . ; If p is not changed , then it is a prime ; Update all multiples of p ; To store the 8 divisors ; To count the number of divisor ; Finally check if there re 8 divisor and all the numbers are distinct prime no return 1 else return 0 ) ; ; Driver code"
Python;"from math import sqrt NEW_LINE def gcd ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b NEW_LINE DEDENT return gcd ( b % a , a ) NEW_LINE DEDENT def commDiv ( a , b ) : NEW_LINE INDENT n = gcd ( a , b ) NEW_LINE result = 0 NEW_LINE for i in range ( 1 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n / i == i : NEW_LINE INDENT result += 1 NEW_LINE DEDENT else : NEW_LINE INDENT result += 2 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT a = 12 NEW_LINE b = 24 ; NEW_LINE print ( commDiv ( a , b ) ) NEW_LINE DEDENT";"Common Divisors of Two Numbers | Python implementation of program ; Function to calculate gcd of two numbers ; Function to calculate all common divisors of two given numbers a , b -- > input integer numbers ; find GCD of a , b ; Count divisors of n ; if i is a factor of n ; check if divisors are equal ; Driver program to run the case"
Python;"def spellsCount ( num ) : NEW_LINE INDENT n = len ( num ) ; NEW_LINE result = 1 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n ) : NEW_LINE INDENT count = 1 ; NEW_LINE while ( i < n - 1 and num [ i + 1 ] == num [ i ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE i += 1 ; NEW_LINE DEDENT result = result * int ( pow ( 2 , count - 1 ) ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT num = ""11112"" ; NEW_LINE print ( spellsCount ( num ) ) ; NEW_LINE";"Count ways to spell a number with repeated digits | Function to calculate all possible spells of a number with repeated digits num -- > string which is favourite number ; final count of total possible spells ; iterate through complete number ; count contiguous frequency of particular digit num [ i ] ; Compute 2 ^ ( count - 1 ) and multiply with result ; Driver Code"
Python;"def numSquareSum ( n ) : NEW_LINE INDENT squareSum = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT squareSum += ( n % 10 ) * ( n % 10 ) ; NEW_LINE n = int ( n / 10 ) ; NEW_LINE DEDENT return squareSum ; NEW_LINE DEDENT def isHappynumber ( n ) : NEW_LINE INDENT slow = n ; NEW_LINE fast = n ; NEW_LINE while ( True ) : NEW_LINE INDENT slow = numSquareSum ( slow ) ; NEW_LINE fast = numSquareSum ( numSquareSum ( fast ) ) ; NEW_LINE if ( slow != fast ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT else : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT return ( slow == 1 ) ; NEW_LINE DEDENT n = 13 ; NEW_LINE if ( isHappynumber ( n ) ) : NEW_LINE INDENT print ( n , "" is ▁ a ▁ Happy ▁ number "" ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , "" is ▁ not ▁ a ▁ Happy ▁ number "" ) ; NEW_LINE DEDENT";"Happy Number | Utility method to return sum of square of digit of n ; method return true if n is Happy number ; initialize slow and fast by n ; move slow number by one iteration ; move fast number by two iteration ; if both number meet at 1 , then return true ; Driver Code"
Python;"allPrimes = [ ] ; NEW_LINE def sieve ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT i = p * 2 ; NEW_LINE while ( i <= n ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE i += p ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT allPrimes . append ( p ) ; NEW_LINE DEDENT DEDENT DEDENT def factorialDivisors ( n ) : NEW_LINE INDENT result = 1 ; NEW_LINE for i in range ( len ( allPrimes ) ) : NEW_LINE INDENT p = allPrimes [ i ] ; NEW_LINE exp = 0 ; NEW_LINE while ( p <= n ) : NEW_LINE INDENT exp = exp + int ( n / p ) ; NEW_LINE p = p * allPrimes [ i ] ; NEW_LINE DEDENT result = result * ( exp + 1 ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT print ( factorialDivisors ( 6 ) ) ; NEW_LINE";"Count Divisors of Factorial | allPrimes [ ] stores all prime numbers less than or equal to n . ; Fills above vector allPrimes [ ] for a given n ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is not a prime , else true . ; Loop to update prime [ ] ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Store primes in the vector allPrimes ; Function to find all result of factorial number ; Initialize result ; find exponents of all primes which divides n and less than n ; Current divisor ; Find the highest power ( stored in exp ) ' ▁ ▁ of ▁ allPrimes [ i ] ▁ that ▁ divides ▁ n ▁ using ▁ ▁ Legendre ' s formula . ; Multiply exponents of all primes less than n ; return total divisors ; Driver Code"
Python;def nonFibonacci ( n ) : NEW_LINE INDENT prevPrev = 1 NEW_LINE prev = 2 NEW_LINE curr = 3 NEW_LINE while n > 0 : NEW_LINE INDENT prevPrev = prev NEW_LINE prev = curr NEW_LINE curr = prevPrev + prev NEW_LINE n = n - ( curr - prev - 1 ) NEW_LINE DEDENT n = n + ( curr - prev - 1 ) NEW_LINE return prev + n NEW_LINE DEDENT print ( nonFibonacci ( 5 ) ) NEW_LINE;"Non Fibonacci Numbers | Returns n 'th Non-Fibonacci number ; curr is to keep track of current fibonacci number , prev is previous , prevPrev is previous of previous . ; While count of non - fibonacci numbers doesn 't become  negative or zero ; Simple Fibonacci number logic ; ( curr - prev - 1 ) is count of non - Fibonacci numbers between curr and prev . ; n might be negative now . Make sure it becomes positive by removing last added gap . ; Now add the positive n to previous Fibonacci number to find the n 'th non-fibonacci. ; Driver code"
Python;"def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT k = 0 NEW_LINE while ( ( ( a b ) & 1 ) == 0 ) : NEW_LINE INDENT a = a >> 1 NEW_LINE b = b >> 1 NEW_LINE k = k + 1 NEW_LINE DEDENT while ( ( a & 1 ) == 0 ) : NEW_LINE INDENT a = a >> 1 NEW_LINE DEDENT while ( b != 0 ) : NEW_LINE INDENT while ( ( b & 1 ) == 0 ) : NEW_LINE INDENT b = b >> 1 NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT temp = a NEW_LINE a = b NEW_LINE b = temp NEW_LINE DEDENT b = ( b - a ) NEW_LINE DEDENT return ( a << k ) NEW_LINE DEDENT a = 34 NEW_LINE b = 17 NEW_LINE print ( "" Gcd ▁ of ▁ given ▁ numbers ▁ is ▁ "" , gcd ( a , b ) ) NEW_LINE";"Stein 's Algorithm for finding GCD | Function to implement Stein 's Algorithm ; GCD ( 0 , b ) == b ; GCD ( a , 0 ) == a , GCD ( 0 , 0 ) == 0 ; Finding K , where K is the greatest power of 2 that divides both a and b . ; Dividing a by 2 until a becomes odd ; From here on , ' a ' is always odd . ; If b is even , remove all factor of 2 in b ; Now a and b are both odd . Swap if necessary so a <= b , then set b = b - a ( which is even ) . ; restore common factors of 2 ; Driver code"
Python;"def findNDigitNumsUtil ( n , out , index , evenSum , oddSum ) : NEW_LINE INDENT if ( index > n ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( index == n ) : NEW_LINE INDENT if ( abs ( evenSum - oddSum ) == 1 ) : NEW_LINE INDENT out [ index ] = ' ' NEW_LINE out = ' ' . join ( out ) NEW_LINE print ( out , end = "" ▁ "" ) NEW_LINE DEDENT return NEW_LINE DEDENT if ( index & 1 ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT out [ index ] = chr ( i + ord ( '0' ) ) NEW_LINE findNDigitNumsUtil ( n , out , index + 1 , evenSum , oddSum + i ) NEW_LINE DEDENT for i in range ( 10 ) : NEW_LINE INDENT out [ index ] = chr ( i + ord ( '0' ) ) NEW_LINE findNDigitNumsUtil ( n , out , index + 1 , evenSum + i , oddSum ) NEW_LINE DEDENT DEDENT DEDENT def findNDigitNums ( n ) : NEW_LINE INDENT out = [ 0 ] * ( n + 1 ) NEW_LINE index = 0 NEW_LINE evenSum = 0 NEW_LINE oddSum = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT out [ index ] = chr ( i + ord ( '0' ) ) NEW_LINE findNDigitNumsUtil ( n , out , index + 1 , evenSum + i , oddSum ) NEW_LINE DEDENT DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 3 NEW_LINE findNDigitNums ( n ) NEW_LINE DEDENT";"Print all n | n -- > value of input out -- > output array index -- > index of next digit to be filled in output array evenSum , oddSum -- > sum of even and odd digits so far ; Base case ; If number becomes n - digit ; if absolute difference between sum of even and odd digits is 1 , print the number ; If current index is odd , then add it to odd sum and recurse ; else : else add to even sum and recurse ; This is mainly a wrapper over findNDigitNumsUtil . It explicitly handles leading digit and calls findNDigitNumsUtil ( ) for remaining indexes . ; output array to store n - digit numbers ; Initialize number index considered so far ; Initialize even and odd sums ; Explicitly handle first digit and call recursive function findNDigitNumsUtil for remaining indexes . Note that the first digit is considered to be present in even position . ; Driver Code"
Python;"one = [ "" "" , "" one ▁ "" , "" two ▁ "" , "" three ▁ "" , "" four ▁ "" , "" five ▁ "" , "" six ▁ "" , "" seven ▁ "" , "" eight ▁ "" , "" nine ▁ "" , "" ten ▁ "" , "" eleven ▁ "" , "" twelve ▁ "" , "" thirteen ▁ "" , "" fourteen ▁ "" , "" fifteen ▁ "" , "" sixteen ▁ "" , "" seventeen ▁ "" , "" eighteen ▁ "" , "" nineteen ▁ "" ] ; NEW_LINE ten = [ "" "" , "" "" , "" twenty ▁ "" , "" thirty ▁ "" , "" forty ▁ "" , "" fifty ▁ "" , "" sixty ▁ "" , "" seventy ▁ "" , "" eighty ▁ "" , "" ninety ▁ "" ] ; NEW_LINE def numToWords ( n , s ) : NEW_LINE INDENT str = "" "" ; NEW_LINE if ( n > 19 ) : NEW_LINE INDENT str += ten [ n // 10 ] + one [ n % 10 ] ; NEW_LINE DEDENT else : NEW_LINE INDENT str += one [ n ] ; NEW_LINE DEDENT if ( n ) : NEW_LINE INDENT str += s ; NEW_LINE DEDENT return str ; NEW_LINE DEDENT def convertToWords ( n ) : NEW_LINE INDENT out = "" "" ; NEW_LINE out += numToWords ( ( n // 10000000 ) , "" crore ▁ "" ) ; NEW_LINE out += numToWords ( ( ( n // 100000 ) % 100 ) , "" lakh ▁ "" ) ; NEW_LINE out += numToWords ( ( ( n // 1000 ) % 100 ) , "" thousand ▁ "" ) ; NEW_LINE out += numToWords ( ( ( n // 100 ) % 10 ) , "" hundred ▁ "" ) ; NEW_LINE if ( n > 100 and n % 100 ) : NEW_LINE INDENT out += "" and ▁ "" ; NEW_LINE DEDENT out += numToWords ( ( n % 100 ) , "" "" ) ; NEW_LINE return out ; NEW_LINE DEDENT n = 438237764 ; NEW_LINE print ( convertToWords ( n ) ) ; NEW_LINE";"Program to convert a given number to words | Set 2 | strings at index 0 is not used , it is to make array indexing simple ; strings at index 0 and 1 are not used , they is to make array indexing simple ; n is 1 - or 2 - digit number ; if n is more than 19 , divide it ; if n is non - zero ; Function to print a given number in words ; stores word representation of given number n ; handles digits at ten millions and hundred millions places ( if any ) ; handles digits at hundred thousands and one millions places ( if any ) ; handles digits at thousands and tens thousands places ( if any ) ; handles digit at hundreds places ( if any ) ; handles digits at ones and tens places ( if any ) ; long handles upto 9 digit no change to unsigned long long int to handle more digit number ; convert given number in words"
Python;"def countEvenSum ( arr , n ) : NEW_LINE INDENT res = 0 NEW_LINE s = 0 NEW_LINE for i in reversed ( range ( n ) ) : NEW_LINE INDENT if arr [ i ] % 2 == 1 : NEW_LINE INDENT s = n - i - 1 - s NEW_LINE DEDENT else : NEW_LINE INDENT s = s + 1 NEW_LINE DEDENT res = res + s NEW_LINE DEDENT return res NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT arr = [ 1 , 2 , 2 , 3 , 4 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( "" The ▁ Number ▁ of ▁ Subarrays ▁ with ▁ even "" "" ▁ sum ▁ is "" , countEvenSum ( arr , n ) ) NEW_LINE DEDENT";"Find number of subarrays with even sum | Python 3 program to count number of sub - arrays with even sum using an efficient algorithm Time Complexity - O ( N ) Space Complexity - O ( 1 ) ; result may be large enough not to fit in int ; ; to keep track of subarrays with even sum starting from index i ; if a [ i ] is odd then all subarrays starting from index i + 1 which was odd becomes even when a [ i ] gets added to it . ; if a [ i ] is even then all subarrays starting from index i + 1 which was even remains even and one extra a [ i ] even subarray gets added to it . ; Driver code"
Python;"from math import gcd NEW_LINE def isPossible ( a , b , c ) : NEW_LINE INDENT return ( c % gcd ( a , b ) == 0 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 3 NEW_LINE b = 6 NEW_LINE c = 9 NEW_LINE if ( isPossible ( a , b , c ) ) : NEW_LINE INDENT print ( "" Possible "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Not ▁ Possible "" ) NEW_LINE DEDENT a = 3 NEW_LINE b = 6 NEW_LINE c = 8 NEW_LINE if ( isPossible ( a , b , c ) ) : NEW_LINE INDENT print ( "" Possible "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Not ▁ Possible "" ) NEW_LINE DEDENT a = 2 NEW_LINE b = 5 NEW_LINE c = 1 NEW_LINE if ( isPossible ( a , b , c ) ) : NEW_LINE INDENT print ( "" Possible "" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( "" Not ▁ Possible "" ) NEW_LINE DEDENT DEDENT";"Linear Diophantine Equations | Python 3 program to check for solutions of diophantine equations ; This function checks if integral solutions are possible ; Driver Code ; First example ; Second example ; Third example"
Python;"import math NEW_LINE def farey ( n ) : NEW_LINE INDENT x1 = 0 ; NEW_LINE y1 = 1 ; NEW_LINE x2 = 1 ; NEW_LINE y2 = n ; NEW_LINE print ( x1 , end = "" "" ) NEW_LINE print ( "" / "" , end = "" "" ) NEW_LINE print ( y1 , x2 , end = "" "" ) NEW_LINE print ( "" / "" , end = "" "" ) NEW_LINE print ( y2 , end = "" ▁ "" ) ; NEW_LINE x = 0 ; NEW_LINE y = 0 ; NEW_LINE while ( y != 1.0 ) : NEW_LINE INDENT x = math . floor ( ( y1 + n ) / y2 ) * x2 - x1 ; NEW_LINE y = math . floor ( ( y1 + n ) / y2 ) * y2 - y1 ; NEW_LINE print ( x , end = "" "" ) NEW_LINE print ( "" / "" , end = "" "" ) NEW_LINE print ( y , end = "" ▁ "" ) ; NEW_LINE x1 = x2 ; NEW_LINE x2 = x ; NEW_LINE y1 = y2 ; NEW_LINE y2 = y ; NEW_LINE DEDENT DEDENT n = 7 ; NEW_LINE print ( "" Farey ▁ Sequence ▁ of ▁ order "" , n , "" is "" ) ; NEW_LINE farey ( n ) ; NEW_LINE";"Farey Sequence | Efficient Python3 program to print Farey Sequence of order n ; Optimized function to print Farey sequence of order n ; We know first two terms are 0 / 1 and 1 / n ; For next terms to be evaluated ; Using recurrence relation to find the next term ; Print next term ; Update x1 , y1 , x2 and y2 for next iteration ; Driver Code"
Python;"def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT return ( gcd ( b , a % b ) ) NEW_LINE DEDENT def findSmallest ( a , b ) : NEW_LINE INDENT lcm = ( a * b ) / gcd ( a , b ) NEW_LINE print ( "" x ▁ = "" , lcm / a ,   "" y =   "" , lcm / b ) NEW_LINE DEDENT a = 25 NEW_LINE b = 35 NEW_LINE findSmallest ( a , b ) NEW_LINE";"Find smallest values of x and y such that ax | To find GCD using Eculcid 's algorithm ; Prints smallest values of x and y that satisfy "" ax ▁ - ▁ by ▁ = ▁ 0"" ; Find LCM ; Driver code"
Python;"def power ( x , y , p ) : NEW_LINE INDENT while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT x = ( x * x ) % p ; NEW_LINE DEDENT return res NEW_LINE DEDENT def modInverse ( a , p ) : NEW_LINE INDENT return power ( a , p - 2 , p ) NEW_LINE DEDENT def modFact ( n , p ) : NEW_LINE INDENT if ( p <= n ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT res = ( p - 1 ) NEW_LINE for i in range ( n + 1 , p ) : NEW_LINE INDENT res = ( res * modInverse ( i , p ) ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT n = 25 NEW_LINE p = 29 NEW_LINE print ( modFact ( n , p ) ) NEW_LINE";"Compute n ! under modulo p | Utility function to do modular exponentiation . It returns ( x ^ y ) % p ; res = 1 ; Initialize result x = x % p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 ; y = y / 2 ; Function to find modular inverse of a under modulo p using Fermat 's method. Assumption: p is prime ; Returns n ! % p using Wilson 's Theorem ; n ! % p is 0 if n >= p ; Initialize result as ( p - 1 ) ! which is - 1 or ( p - 1 ) ; Multiply modulo inverse of all numbers from ( n + 1 ) to p ; Driver code"
Python;"def countWays ( n ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT for k in range ( j , n ) : NEW_LINE INDENT for l in range ( k , n ) : NEW_LINE INDENT if ( i + j + k + l == n ) : NEW_LINE INDENT counter += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return counter NEW_LINE DEDENT if __name__ == "" _ _ main _ _ "" : NEW_LINE INDENT n = 8 NEW_LINE print ( countWays ( n ) ) NEW_LINE DEDENT";"Count number of ways to divide a number in 4 parts | Returns count of ways ; Generate all possible quadruplet and increment counter when sum of a quadruplet is equal to n ; Driver Code"
Python;def pairAndSum ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( ( i + 1 ) , n ) : NEW_LINE INDENT ans = ans + arr [ i ] & arr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 5 , 10 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairAndSum ( arr , n ) ) NEW_LINE;"Sum of Bitwise And of all pairs in a given array | Returns value of "" arr [ 0 ] ▁ & ▁ arr [ 1 ] ▁ + ▁ arr [ 0 ] ▁ & ▁ arr [ 2 ] ▁ + ▁ . . . ▁ arr [ i ] ▁ & ▁ arr [ j ] ▁ + ▁ . . . . . ▁ arr [ n - 2 ] ▁ & ▁ arr [ n - 1 ] "" ; Consider all pairs ( arr [ i ] , arr [ j ) such that i < j ; Driver program to test above function"
Python;def pairAndSum ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , 32 ) : NEW_LINE INDENT k = 0 NEW_LINE for j in range ( 0 , n ) : NEW_LINE INDENT if ( ( arr [ j ] & ( 1 << i ) ) ) : NEW_LINE INDENT k = k + 1 NEW_LINE DEDENT DEDENT ans = ans + ( 1 << i ) * ( k * ( k - 1 ) // 2 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 5 , 10 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairAndSum ( arr , n ) ) NEW_LINE;"Sum of Bitwise And of all pairs in a given array | Returns value of "" arr [ 0 ] ▁ & ▁ arr [ 1 ] ▁ + ▁ arr [ 0 ] ▁ & ▁ arr [ 2 ] ▁ + ▁ . . . ▁ arr [ i ] ▁ & ▁ arr [ j ] ▁ + ▁ . . . . . ▁ arr [ n - 2 ] ▁ & ▁ arr [ n - 1 ] "" ; Traverse over all bits ; Count number of elements with i 'th bit set  Initialize the count ; There are k set bits , means k ( k - 1 ) / 2 pairs . Every pair adds 2 ^ i to the answer . Therefore , we add ""2 ^ i ▁ * ▁ [ k * ( k - 1 ) / 2 ] "" to the answer . ; Driver program to test above function"
Python;"def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT print ( "" true "" ) if isPrime ( 11 ) else print ( "" false "" ) NEW_LINE print ( "" true "" ) if isPrime ( 14 ) else print ( "" false "" ) NEW_LINE";"Primality Test | Set 1 ( Introduction and School Method ) | A school method based Python3 program to check if a number is prime ; Corner case ; Check from 2 to n - 1 ; Driver Program to test above function"
Python;"def computeTotient ( n ) : NEW_LINE INDENT phi = [ ] NEW_LINE for i in range ( n + 2 ) : NEW_LINE INDENT phi . append ( 0 ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( phi [ p ] == p ) : NEW_LINE INDENT phi [ p ] = p - 1 NEW_LINE for i in range ( 2 * p , n + 1 , p ) : NEW_LINE INDENT phi [ i ] = ( phi [ i ] // p ) * ( p - 1 ) NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( "" Totient ▁ of ▁ "" , i , "" ▁ is ▁ "" , phi [ i ] ) NEW_LINE DEDENT DEDENT n = 12 NEW_LINE computeTotient ( n ) NEW_LINE";"Euler 's Totient function for all numbers smaller than or equal to n | Computes and prints totient of all numbers smaller than or equal to n . ; Create and initialize an array to store phi or totient values ; Compute other Phi values ; If phi [ p ] is not computed already , then number p is prime ; Phi of a prime number p is always equal to p - 1. ; Update phi values of all multiples of p ; Add contribution of p to its multiple i by multiplying with ( 1 - 1 / p ) ; Print precomputed phi values ; Driver code"
Python;"import math NEW_LINE def Euler_totient_function ( n ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT c = 0 NEW_LINE if n % i == 0 : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE n //= i NEW_LINE DEDENT DEDENT if ( c > 0 ) : NEW_LINE INDENT power = math . pow ( i , c - 1 ) NEW_LINE m = math . pow ( i , c - 1 ) * ( i - 1 ) NEW_LINE result *= m NEW_LINE DEDENT DEDENT if ( n > 1 ) : NEW_LINE INDENT result *= ( n - 1 ) NEW_LINE DEDENT return int ( result ) NEW_LINE DEDENT for i in range ( 1 , 13 ) : NEW_LINE INDENT print ( "" Euler _ totient _ function ( "" , i , "" ) : ▁ "" , end = "" "" ) NEW_LINE print ( Euler_totient_function ( i ) ) NEW_LINE DEDENT";"Euler 's Totient function for all numbers smaller than or equal to n | python program for the above approach ; Driver code"
Python;"import math NEW_LINE def isPower ( n ) : NEW_LINE INDENT p = 0 NEW_LINE if ( n <= 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT for i in range ( 2 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT p = math . log2 ( n ) / math . log2 ( i ) NEW_LINE if ( ( math . ceil ( p ) == math . floor ( p ) ) and p > 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT DEDENT return 0 NEW_LINE DEDENT for i in range ( 2 , 100 ) : NEW_LINE INDENT if isPower ( i ) : NEW_LINE INDENT print ( i , end = "" ▁ "" ) NEW_LINE DEDENT DEDENT";"Check if a number can be expressed as x ^ y ( x raised to power y ) | Python3 program to check if a given number can be expressed as power ; Returns true if n can be written as x ^ y ; Driver code"
Python;"def sumBetweenTwoKth ( arr , n , k1 , k2 ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE result = 0 NEW_LINE for i in range ( k1 , k2 - 1 ) : NEW_LINE INDENT result += arr [ i ] NEW_LINE DEDENT return result NEW_LINE DEDENT arr = [ 20 , 8 , 22 , 4 , 12 , 10 , 14 ] NEW_LINE k1 = 3 ; k2 = 6 NEW_LINE n = len ( arr ) NEW_LINE print ( sumBetweenTwoKth ( arr , n , k1 , k2 ) ) NEW_LINE";"Sum of all elements between k1 ' th ▁ and ▁ k2' th smallest elements | Returns sum between two kth smallest element of array ; Sort the given array ; Below code is equivalent to ; Driver code"
Python;"def countSquares ( n ) : NEW_LINE INDENT return ( ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( "" Count ▁ of ▁ squares ▁ is ▁ "" , countSquares ( n ) ) NEW_LINE";"Puzzle | Program to find number of squares in a chessboard | Function to return count of squares ; ; better way to write n * ( n + 1 ) * ( 2 n + 1 ) / 6 ; Driver code"
Python;"def nthMagicNo ( n ) : NEW_LINE INDENT pow = 1 NEW_LINE answer = 0 NEW_LINE while ( n ) : NEW_LINE INDENT pow = pow * 5 NEW_LINE if ( n & 1 ) : NEW_LINE INDENT answer += pow NEW_LINE DEDENT DEDENT return answer NEW_LINE DEDENT n = 5 NEW_LINE print ( "" nth ▁ magic ▁ number ▁ is "" , nthMagicNo ( n ) ) NEW_LINE";"Find nth Magic Number | Function to find nth magic number ; Go through every bit of n ; If last bit of n is set ; proceed to next bit n >>= 1 or n = n / 2 ; Driver program to test above function"
Python;"def countOfMultiples ( n ) : NEW_LINE INDENT return ( int ( n / 3 ) + int ( n / 5 ) - int ( n / 15 ) ) ; NEW_LINE DEDENT print ( countOfMultiples ( 6 ) ) NEW_LINE print ( countOfMultiples ( 16 ) ) NEW_LINE";"Given a number n , count all multiples of 3 and / or 5 in set { 1 , 2 , 3 , ... n } | python program to find count of multiples of 3 and 5 in { 1 , 2 , 3 , . . n } ; Add multiples of 3 and 5. Since common multiples are counted twice in n / 3 + n / 15 , subtract common multiples ; Driver program to test above function"
Python;def gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 ) : NEW_LINE INDENT return b NEW_LINE DEDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT a = 98 NEW_LINE b = 56 NEW_LINE if ( gcd ( a , b ) ) : NEW_LINE INDENT print ( ' GCD ▁ of ' , a , ' and ' , b , ' is ' , gcd ( a , b ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' not ▁ found ' ) NEW_LINE DEDENT;"Program to find GCD or HCF of two numbers | Recursive function to return gcd of a and b ; Everything divides 0 ; base case ; a is greater ; Driver program to test above function"
Python;def XorSum ( A , B , N , M ) : NEW_LINE INDENT ans1 = 0 NEW_LINE ans2 = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans1 = ans1 ^ A [ i ] NEW_LINE DEDENT for i in range ( M ) : NEW_LINE INDENT ans2 = ans2 ^ B [ i ] NEW_LINE DEDENT return ( ans1 & ans2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 3 , 5 ] NEW_LINE B = [ 2 , 3 ] NEW_LINE N = len ( A ) NEW_LINE M = len ( B ) NEW_LINE print ( XorSum ( A , B , N , M ) ) NEW_LINE DEDENT;"Find XOR sum of Bitwise AND of all pairs from given two Arrays | Function to calculate the XOR sum of all ANDS of all pairs on A [ ] and B [ ] ; variable to store xor sums of first array and second array respectively . ; Xor sum of first array ; Xor sum of second array ; required answer ; Driver code ; Input ; Function call"
Python;"class TreeNode : NEW_LINE INDENT def __init__ ( self , val = 0 , left = None , right = None ) : NEW_LINE INDENT self . val = val NEW_LINE self . left = left NEW_LINE self . right = right NEW_LINE DEDENT DEDENT def uniqueLevels ( root ) : NEW_LINE INDENT uniqueLevels = 0 NEW_LINE que = [ root ] NEW_LINE while len ( que ) : NEW_LINE INDENT length = len ( que ) NEW_LINE prefix_XOR = 0 ; NEW_LINE prefix_OR = 0 NEW_LINE flag = True NEW_LINE while length : NEW_LINE INDENT temp = que . pop ( 0 ) NEW_LINE prefix_OR |= temp . val NEW_LINE prefix_XOR ^= temp . val NEW_LINE if prefix_XOR != prefix_OR : NEW_LINE INDENT flag = False NEW_LINE DEDENT if temp . left : NEW_LINE INDENT que . append ( temp . left ) NEW_LINE DEDENT if temp . right : NEW_LINE INDENT que . append ( temp . right ) NEW_LINE DEDENT length -= 1 NEW_LINE DEDENT if flag : NEW_LINE INDENT uniqueLevels += 1 NEW_LINE DEDENT DEDENT print ( uniqueLevels ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = TreeNode ( 5 ) NEW_LINE root . left = TreeNode ( 6 ) NEW_LINE root . right = TreeNode ( 9 ) NEW_LINE root . left . left = TreeNode ( 1 ) NEW_LINE root . left . right = TreeNode ( 4 ) NEW_LINE root . right . right = TreeNode ( 7 ) NEW_LINE uniqueLevels ( root ) NEW_LINE DEDENT";"Count levels in a Binary Tree consisting of node values having set bits at different positions | Structure of a node in the binary tree ; Function to find total unique levels ; Stores count of levels , where the set bits of all the nodes are at different positions ; Store nodes at each level of the tree using BFS ; Performing level order traversal ; Stores count of nodes at current level ; Stores prefix XOR of all the nodes at current level ; Stores prefix OR of all the nodes at current level ; Check if set bit of all the nodes at current level is at different positions or not ; Traverse nodes at current level ; Stores front element of the que ; Update prefix_OR ; Update prefix_XOR ; If left subtree not NULL ; If right subtree not NULL ; If bitwise AND is zero ; Driver Code ; Function Call"
Python;n = 7 NEW_LINE def minheapify ( a , index ) : NEW_LINE INDENT small = index NEW_LINE l = 2 * index + 1 NEW_LINE r = 2 * index + 2 NEW_LINE if ( l < n and a [ l ] < a [ small ] ) : NEW_LINE INDENT small = l NEW_LINE DEDENT if ( r < n and a [ r ] < a [ small ] ) : NEW_LINE INDENT small = r NEW_LINE DEDENT if ( small != index ) : NEW_LINE INDENT ( a [ small ] , a [ index ] ) = ( a [ index ] , a [ small ] ) NEW_LINE minheapify ( a , small ) NEW_LINE DEDENT DEDENT i = 0 NEW_LINE k1 = 3 NEW_LINE k2 = 6 NEW_LINE a = [ 20 , 8 , 22 , 4 , 12 , 10 , 14 ] NEW_LINE ans = 0 NEW_LINE for i in range ( ( n // 2 ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT minheapify ( a , i ) NEW_LINE DEDENT k1 -= 1 NEW_LINE k2 -= 1 NEW_LINE for i in range ( 0 , k1 + 1 ) : NEW_LINE INDENT a [ 0 ] = a [ n - 1 ] NEW_LINE n -= 1 NEW_LINE minheapify ( a , 0 ) NEW_LINE DEDENT for i in range ( k1 + 1 , k2 ) : NEW_LINE INDENT ans += a [ 0 ] NEW_LINE a [ 0 ] = a [ n - 1 ] NEW_LINE n -= 1 NEW_LINE minheapify ( a , 0 ) NEW_LINE DEDENT print ( ans ) NEW_LINE;"Sum of all elements between k1 ' th ▁ and ▁ k2' th smallest elements | Python 3 implementation of above approach ; Driver Code ; decreasing value by 1 because we want min heapifying k times and it starts from 0 so we have to decrease it 1 time ; Step 1 : Do extract minimum k1 times ( This step takes O ( K1 Log n ) time ) ; Step 2 : Do extract minimum k2 k1 1 times and sum all extracted elements . ( This step takes O ( ( K2 k1 ) * Log n ) time )"
Python;def ConstructList ( Q ) : NEW_LINE INDENT xor = 0 NEW_LINE ans = [ ] NEW_LINE for i in range ( len ( Q ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( Q [ i ] [ 0 ] == 0 ) : NEW_LINE INDENT ans . append ( Q [ i ] [ 1 ] ^ xor ) NEW_LINE DEDENT else : NEW_LINE INDENT xor ^= Q [ i ] [ 1 ] NEW_LINE DEDENT DEDENT ans . append ( xor ) NEW_LINE ans . sort ( ) NEW_LINE return ans NEW_LINE DEDENT Q = [ [ 0 , 6 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 4 ] , [ 1 , 5 ] ] NEW_LINE print ( ConstructList ( Q ) ) NEW_LINE;"Construct a List using the given Q XOR queries | Function to return required list after performing all the queries ; Store cumulative Bitwise XOR ; Initialize final list to return ; Perform each query ; The initial value of 0 ; Sort the list ; Return final list ; Given Queries ; Function call"
Python;"def build_num ( bit ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( 32 ) : NEW_LINE INDENT if ( bit [ i ] > 0 ) : NEW_LINE INDENT ans += ( 1 << i ) ; NEW_LINE DEDENT DEDENT return ans ; NEW_LINE DEDENT def maximumOR ( arr , n , k ) : NEW_LINE INDENT bit = [ 0 ] * 32 ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT for j in range ( 32 ) : NEW_LINE INDENT if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) : NEW_LINE INDENT bit [ j ] += 1 ; NEW_LINE DEDENT DEDENT DEDENT max_or = build_num ( bit ) ; NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT for j in range ( 32 ) : NEW_LINE INDENT if ( ( arr [ i - k ] & ( 1 << j ) ) > 0 ) : NEW_LINE INDENT bit [ j ] -= 1 ; NEW_LINE DEDENT DEDENT for j in range ( 32 ) : NEW_LINE INDENT if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) : NEW_LINE INDENT bit [ j ] += 1 ; NEW_LINE DEDENT DEDENT max_or = max ( build_num ( bit ) , max_or ) ; NEW_LINE DEDENT return max_or ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 5 , 3 , 6 , 11 , 13 ] ; NEW_LINE k = 3 ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maximumOR ( arr , n , k ) ) ; NEW_LINE DEDENT";"Bitwise operations on Subarrays of size K | Function to convert bit array to decimal number ; Function to find maximum values of each bitwise OR operation on element of subarray of size K ; Maintain an integer array bit of size 32 all initialized to 0 ; Create a sliding window of size k ; Function call ; Perform operation for removed element ; Perform operation for added_element ; Taking maximum value ; Return the result ; Driver Code ; Given array arr ; Given subarray size K ; Function call"
Python;class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def Solve ( root , xr , max_xor ) : NEW_LINE INDENT xr = xr ^ root . data NEW_LINE if ( root . left == None and root . right == None ) : NEW_LINE INDENT max_xor [ 0 ] = max ( max_xor [ 0 ] , xr ) NEW_LINE DEDENT if root . left != None : NEW_LINE INDENT Solve ( root . left , xr , max_xor ) NEW_LINE DEDENT if root . right != None : NEW_LINE INDENT Solve ( root . right , xr , max_xor ) NEW_LINE DEDENT return NEW_LINE DEDENT def findMaxXor ( root ) : NEW_LINE INDENT xr , max_xor = 0 , [ 0 ] NEW_LINE Solve ( root , xr , max_xor ) NEW_LINE return max_xor [ 0 ] NEW_LINE DEDENT root = Node ( 2 ) NEW_LINE root . left = Node ( 1 ) NEW_LINE root . right = Node ( 4 ) NEW_LINE root . left . left = Node ( 10 ) NEW_LINE root . left . right = Node ( 8 ) NEW_LINE root . right . left = Node ( 5 ) NEW_LINE root . right . right = Node ( 10 ) NEW_LINE print ( findMaxXor ( root ) ) NEW_LINE;"Maximum XOR path of a Binary Tree | Binary tree node ; Function to create a new node ; Function calculate the value of max - xor ; Updating the xor value with the xor of the path from root to the node ; Check if node is leaf node ; Check if the left node exist in the tree ; Check if the right node exist in the tree ; Function to find the required count ; Recursively traverse the tree and compute the max_xor ; Return the result ; Create the binary tree"
Python;"def constructXORArray ( A , n , K ) : NEW_LINE INDENT B = [ 0 ] * n ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT B [ i ] = A [ i ] ^ K ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT print ( B [ i ] , end = "" ▁ "" ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 2 , 4 , 1 , 3 , 5 ] ; NEW_LINE K = 5 ; NEW_LINE n = len ( A ) ; NEW_LINE constructXORArray ( A , n , K ) ; NEW_LINE B = [ 4 , 75 , 45 , 42 ] ; NEW_LINE K = 2 ; NEW_LINE n = len ( B ) ; NEW_LINE constructXORArray ( B , n , K ) ; NEW_LINE DEDENT";"XOR of every element of an Array with a given number K | Function to construct new array ; Traverse the array and compute XOR with K ; Print new array ; Driver code"
Python;def find_and ( arr ) : NEW_LINE INDENT ans = arr [ 0 ] NEW_LINE for i in range ( 1 , len ( arr ) ) : NEW_LINE INDENT ans = ans & arr [ i ] NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 3 , 5 , 9 , 11 ] NEW_LINE print ( find_and ( arr ) ) NEW_LINE DEDENT;"Bitwise AND of all the elements of array | Function to calculate bitwise AND ; Initialise ans variable is arr [ 0 ] ; Traverse the array compute AND ; Return ans ; Driver Code ; Function Call to find AND"
C#;"using System ; using System . Collections . Generic ; class GFG { static int maxPresum ( List < int > a , List < int > b ) { int X = Math . Max ( a [ 0 ] , 0 ) ; for ( int i = 1 ; i < a . Count ; i ++ ) { a [ i ] += a [ i - 1 ] ; X = Math . Max ( X , a [ i ] ) ; } int Y = Math . Max ( b [ 0 ] , 0 ) ; for ( int i = 1 ; i < b . Count ; i ++ ) { b [ i ] += b [ i - 1 ] ; Y = Math . Max ( Y , b [ i ] ) ; } return X + Y ; } static void Main ( ) { List < int > A = new List < int > ( new int [ ] { 2 , - 1 , 4 , - 5 } ) ; List < int > B = new List < int > ( new int [ ] { 4 , - 3 , 12 , 4 , - 3 } ) ; Console . WriteLine ( maxPresum ( A , B ) ) ; } }";"Maximum Prefix Sum possible by merging two given arrays | C # Program to implement the above approach ; Stores the maximum prefix sum of the array A [ ] ; Traverse the array A [ ] ; Stores the maximum prefix sum of the array B [ ] ; Traverse the array B [ ] ; Driver code"
C#;"using System ; class GFG { static bool sumOfTwoCubes ( int n ) { int lo = 1 , hi = ( int ) Math . Pow ( n , ( 1.0 / 3.0 ) ) ; while ( lo <= hi ) { int curr = ( lo * lo * lo + hi * hi * hi ) ; if ( curr == n ) return true ; if ( curr < n ) lo ++ ; else hi -- ; } return false ; } public static void Main ( String [ ] args ) { int N = 28 ; if ( sumOfTwoCubes ( N ) ) { Console . Write ( "" True "" ) ; } else { Console . Write ( "" False "" ) ; } } }";"Check if a number can be represented as sum of two positive perfect cubes | C # program for the above approach ; Function to check if N can be represented as sum of two perfect cubes or not ; if it is same return true ; ; if the curr smaller than n increment the lo ; if the curr is greater than curr decrement the hi ; Driver Code ; Function call to check if N can be represented as sum of two perfect cubes or not"
C#;"using System ; using System . Collections . Generic ; class GFG { static int [ ] sieve = new int [ 10000000 ] ; static void sieveOfPrimes ( ) { for ( int i = 0 ; i < 10000000 ; i ++ ) { sieve [ i ] = 1 ; } int N = 1000000 ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( sieve [ i ] == 0 ) continue ; for ( int j = i * i ; j <= N ; j += i ) sieve [ j ] = 0 ; } } static void getArray ( int [ ] arr , int N ) { int [ ] A = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { A [ i ] = 0 ; } List < int > v = new List < int > ( ) ; sieveOfPrimes ( ) ; for ( int i = 2 ; i <= 1000000 ; i ++ ) if ( sieve [ i ] != 0 ) v . Add ( i ) ; int j = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int ind = arr [ i ] ; if ( A [ i ] != 0 ) continue ; else if ( A [ ind ] != 0 ) A [ i ] = A [ ind ] ; else { int prime = v [ j ++ ] ; A [ i ] = prime ; A [ ind ] = A [ i ] ; } } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( A [ i ] + "" ▁ "" ) ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 4 , 1 , 2 , 3 , 4 } ; int N = arr . Length ; getArray ( arr , N ) ; } }";"Generate an N | C # Program to implement the above approach ; Function to generate all prime numbers upto 10 ^ 6 ; Initialize sieve [ ] as 1 ; Iterate over the range [ 2 , N ] ; If current element is non - prime ; Make all multiples of i as 0 ; Function to construct an array A [ ] satisfying the given conditions ; Stores the resultant array ; Stores all prime numbers ; Sieve of Erastosthenes ; Append the integer i if it is a prime ; Indicates current position in list of prime numbers ; Traverse the array arr [ ] ; If already filled with another prime number ; If A [ i ] is not filled but A [ ind ] is filled ; Store A [ i ] = A [ ind ] ; If none of them were filled ; To make sure A [ i ] does not affect other values , store next prime number ; Print the resultant array ; Driver Code ; Function Call"
C#;"using System ; class GFG { static long findNthNumber ( long N ) { long result = 0 ; long p = 1 ; while ( N > 0 ) { result += ( p * ( N % 9 ) ) ; N = N / 9 ; p = p * 10 ; } return result ; } static void Main ( ) { int N = 9 ; Console . Write ( findNthNumber ( N ) ) ; } }";"Nth natural number after removing all numbers consisting of the digit 9 | C # implementation of above approach ; Function to find Nth number in base 9 ; Stores the Nth number ; Iterate while N is greater than 0 ; Update result ; Divide N by 9 ; Multiply p by 10 ; Return result ; Driver code"
C#;"using System ; public class GFG { static int check ( int A , int B ) { if ( A == B ) { return 1 ; } int dig1 = ( int ) Math . Floor ( Math . Log10 ( A ) + 1 ) ; int dig2 = ( int ) Math . Floor ( Math . Log10 ( B ) + 1 ) ; if ( dig1 != dig2 ) { return 0 ; } int temp = A ; while ( true ) { int power = ( int ) Math . Pow ( 10 , dig1 - 1 ) ; int firstdigit = A / power ; A = A - firstdigit * power ; A = A * 10 + firstdigit ; if ( A == B ) { return 1 ; } if ( A == temp ) { return 0 ; } } } public static void Main ( String [ ] args ) { int A = 967 , B = 679 ; if ( check ( A , B ) == 1 ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Check if an integer is rotation of another given integer | C # implementation of the approach ; Function to check if the integer A is a rotation of the integer B ; Stores the count of digits in A ; Stores the count of digits in B ; If dig1 not equal to dig2 ; Stores position of first digit ; Stores the first digit ; Rotate the digits of the integer ; If A is equal to B ; If A is equal to the initial value of integer A ; Driver Code"
C#;"using System ; class GFG { static void sameProductQuadruples ( int [ ] nums , int N ) { int [ ] umap = new int [ 10000 ] ; int res = 0 ; for ( int i = 0 ; i < N ; ++ i ) { for ( int j = i + 1 ; j < N ; ++ j ) { int prod = nums [ i ] * nums [ j ] ; res += 8 * umap [ prod ] ; ++ umap [ prod ] ; } } Console . Write ( res ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 4 , 6 } ; int N = arr . Length ; sameProductQuadruples ( arr , N ) ; } }";"Count of quadruples with product of a pair equal to the product of the remaining pair | C # program to implement the above approach ; Function to count the number of unique quadruples from an array that satisfies the given condition ; Hashmap to store the product of pairs ; Store the count of required quadruples ; Traverse the array arr [ ] and generate all possible pairs ; Store their product ; Pair ( a , b ) can be used to generate 8 unique permutations with another pair ( c , d ) ; Increment um [ prod ] by 1 ; Print the result ; Driver Code"
C#;"using System ; public class GFG { public static int MOD = 1000000007 ; static int power ( int x , int y , int p ) { p = MOD ; int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } static void totalWays ( int N , int M ) { int X = N / 2 ; int S = ( X * ( X + 1 ) ) % MOD ; Console . WriteLine ( power ( S , M , MOD ) ) ; } static public void Main ( ) { int N = 5 , M = 2 ; totalWays ( N , M ) ; } }";"Count ways to place M objects in distinct partitions of N boxes | C # implementation of the above Approach ; Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; Initialize Result ; Update x if x >= MOD to avoid multiplication overflow ; If y is odd , multiply x with result ; y = y / 2 ; Change x to x ^ 2 ; Utility function to find the Total Number of Ways ; Number of Even Indexed Boxes ; Number of partitions of Even Indexed Boxes ; Number of ways to distribute objects ; Driver Code ; N = number of boxes M = number of distinct objects ; Function call to get Total Number of Ways"
C#;"using System ; class GFG { static void isCycleExists ( int [ ] arr , int N ) { for ( int i = 1 ; i < N ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { Console . WriteLine ( "" Yes "" ) ; return ; } } Console . WriteLine ( "" No "" ) ; } public static void Main ( ) { int [ ] arr = { 1 , 3 , 2 , 4 , 5 } ; int N = arr . Length ; isCycleExists ( arr , N ) ; } }";"Check if a graph constructed from an array based on given conditions consists of a cycle or not | C # program for the above approach ; Function to check if the graph constructed from given array contains a cycle or not ; Traverse the array ; If arr [ i ] is less than arr [ i - 1 ] and arr [ i ] ; Driver Code ; Given array ; Size of the array"
C#;"using System ; class GFG { static void getMax ( int [ ] arr , int N , int K ) { for ( int i = 1 ; i < N ; i ++ ) { int cur_val = arr [ i ] ; while ( K >= i ) { if ( cur_val > 0 ) { arr [ 0 ] = arr [ 0 ] + 1 ; cur_val = cur_val - 1 ; K = K - i ; } else break ; } } Console . Write ( arr [ 0 ] ) ; } static void Main ( ) { int [ ] arr = { 1 , 0 , 3 , 2 } ; int N = arr . Length ; int K = 5 ; getMax ( arr , N , K ) ; } }";"Maximize first array element by performing given operations at most K times | C # program for the above approach ; Function to maximize the first array element ; Traverse the array ; Initialize cur_val to a [ i ] ; If all operations are not over yet ; If current value is greater than zero ; Incrementing first element of array by 1 ; Decrementing current value of array by 1 ; Decrementing number of operations by i ; If current value is zero , then break ; Print first array element ; Driver code ; Given array ; Size of the array ; Given K ; Prints the maximum possible value of the first array element"
C#;"using System ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int DistinctValues ( int [ ] arr , int N ) { int max_value = Int32 . MinValue ; for ( int i = 0 ; i < N ; ++ i ) { max_value = Math . Max ( max_value , arr [ i ] ) ; } int GCDArr = arr [ 0 ] ; for ( int i = 1 ; i < N ; ++ i ) { GCDArr = gcd ( GCDArr , arr [ i ] ) ; } int answer = ( max_value / GCDArr ) + 1 ; return answer ; } static void Main ( ) { int [ ] arr = { 4 , 12 , 16 , 24 } ; int N = arr . Length ; Console . WriteLine ( DistinctValues ( arr , N ) ) ; } }";"Count Non | C # program of the above approach ; Function to find the gcd of the two numbers ; Function to find distinct elements in the array by repeatidely inserting the absolute difference of all possible pairs ; Stores largest element of the array ; Traverse the array , arr [ ] ; Update max_value ; Stores GCD of array ; Traverse the array , arr [ ] ; Update GCDArr ; Stores distinct elements in the array by repeatidely inserting absolute difference of all possible pairs ; Driver code ; Given array arr [ ]"
C#;"using System ; class GFG { public static int minSwaps ( int [ , ] b ) { int n = b . GetLength ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( ( b [ 0 , 0 ] ^ b [ 0 , j ] ^ b [ i , 0 ] ^ b [ i , j ] ) == 1 ) { return - 1 ; } } } int rowSum = 0 ; int colSum = 0 ; int rowSwap = 0 ; int colSwap = 0 ; for ( int i = 0 ; i < n ; i ++ ) { rowSum += b [ i , 0 ] ; colSum += b [ 0 , i ] ; int cond1 = 0 ; int cond2 = 0 ; if ( b [ i , 0 ] == i % 2 ) cond1 = 1 ; if ( b [ 0 , i ] == i % 2 ) cond2 = 1 ; rowSwap += cond1 ; colSwap += cond2 ; } if ( rowSum != n / 2 && rowSum != ( n + 1 ) / 2 ) return - 1 ; if ( colSum != n / 2 && colSum != ( n + 1 ) / 2 ) return - 1 ; if ( n % 2 == 1 ) { if ( ( colSwap % 2 ) == 1 ) colSwap = n - colSwap ; if ( ( rowSwap % 2 ) == 1 ) rowSwap = n - rowSwap ; } else { colSwap = Math . Min ( colSwap , n - colSwap ) ; rowSwap = Math . Min ( rowSwap , n - rowSwap ) ; } return ( rowSwap + colSwap ) / 2 ; } public static void Main ( String [ ] args ) { int [ , ] M = { { 0 , 1 , 1 , 0 } , { 0 , 1 , 1 , 0 } , { 1 , 0 , 0 , 1 } , { 1 , 0 , 0 , 1 } } ; int ans = minSwaps ( M ) ; Console . WriteLine ( ans ) ; } }";"Minimum row or column swaps required to make every pair of adjacent cell of a Binary Matrix distinct | C # program for the above approach ; Function to return number of moves to convert matrix into chessboard ; Size of the matrix ; Traverse the matrix ; Initialize rowSum to count 1 s in row ; Initialize colSum to count 1 s in column ; To store no . of rows to be corrected ; To store no . of columns to be corrected ; Traverse in the range [ 0 , N - 1 ] ; Check if rows is either N / 2 or ( N + 1 ) / 2 and return - 1 ; Check if rows is either N / 2 or ( N + 1 ) / 2 and return - 1 ; Check if N is odd ; Check if column required to be corrected is odd and then assign N - colSwap to colSwap ; Check if rows required to be corrected is odd and then assign N - rowSwap to rowSwap ; Take min of colSwap and N - colSwap ; Take min of rowSwap and N - rowSwap ; Finally return answer ; Driver Code ; Given matrix ; Function Call ; Print answer"
C#;"using System ; class GFG { static void count_setbit ( int N ) { int result = 0 ; for ( int i = 0 ; i < 32 ; i ++ ) { if ( ( ( 1 << i ) & N ) > 0 ) { result ++ ; } } Console . WriteLine ( result ) ; } static void Main ( ) { int N = 43 ; count_setbit ( N ) ; } }";"Minimum number of coins having value equal to powers of 2 required to obtain N | C # program for above approach ; Function to count of setbit in N ; Stores count of setbit in N ; Iterate over the range [ 0 , 31 ] ; If current bit is set ; Update result ; Driver Code"
C#;"using System ; class GFG { static int mod = 1000000007 ; static int ValOfTheExpression ( int n ) { int [ ] factorial = new int [ n + 1 ] ; factorial [ 0 ] = factorial [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { factorial [ i ] = ( ( factorial [ i - 1 ] % mod ) * ( i % mod ) ) % mod ; } int [ ] dp = new int [ n + 1 ] ; dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] = ( ( dp [ i - 1 ] % mod ) * ( factorial [ i ] % mod ) ) % mod ; } return dp [ n ] ; } static void Main ( ) { int n = 4 ; Console . WriteLine ( ValOfTheExpression ( n ) ) ; } }";"Evaluate the expression ( N1 * ( N | C # program to implement the above approach ; Function to find the value of the expression ( N ^ 1 * ( N 1 ) ^ 2 * ... * 1 ^ N ) % ( 109 + 7 ) . ; factorial [ i ] : Stores factorial of i ; Base Case for factorial ; Precompute the factorial ; dp [ N ] : Stores the value of the expression ( N ^ 1 * ( N 1 ) ^ 2 * ... * 1 ^ N ) % ( 109 + 7 ) . ; Update dp [ i ] ; Return the answer . ; Driver code ; Function call"
C#;"using System ; public class GFG { static void minChocolates ( int [ ] A , int N ) { int [ ] B = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { B [ i ] = 1 ; } for ( int i = 1 ; i < N ; i ++ ) { if ( A [ i ] > A [ i - 1 ] ) B [ i ] = B [ i - 1 ] + 1 ; else B [ i ] = 1 ; } for ( int i = N - 2 ; i >= 0 ; i -- ) { if ( A [ i ] > A [ i + 1 ] ) B [ i ] = Math . Max ( B [ i + 1 ] + 1 , B [ i ] ) ; else B [ i ] = Math . Max ( B [ i ] , 1 ) ; } int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sum += B [ i ] ; } Console . Write ( sum + "" STRNEWLINE "" ) ; } public static void Main ( String [ ] args ) { int [ ] A = { 23 , 14 , 15 , 14 , 56 , 29 , 14 } ; int N = A . Length ; minChocolates ( A , N ) ; } }";"Chocolate Distribution Problem | Set 2 | C # program for the above approach ; FUnction to print minimum number of candies required ; Distribute 1 chocolate to each ; Traverse from left to right ; Traverse from right to left ; Initialize sum ; Find total sum ; Return sum ; Driver Code ; Given array ; Size of the given array"
C#;"using System ; class GFG { static void constructArrayWithGivenLCM ( int N ) { int [ ] newArr = new int [ N ] ; int j = 0 ; for ( int i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { newArr [ j ] = i ; j ++ ; if ( N / i != i ) { newArr [ j ] = N / i ; j ++ ; } } } Array . Sort ( newArr ) ; for ( int i = j ; i < N ; i ++ ) { Console . Write ( newArr [ i ] + "" ▁ "" ) ; } } public static void Main ( String [ ] args ) { int N = 12 ; constructArrayWithGivenLCM ( N ) ; } }";"Construct longest possible sequence of unique elements with given LCM | C # program to implement the above approach ; Function to construct an array of unique elements whose LCM is N ; Stores array elements whose LCM is N ; Iterate over the range [ 1 , sqrt ( N ) ] ; If N is divisible by i ; Insert i into newArr [ ] ; If N is not perfect square ; Sort the array newArr [ ] ; Print array elements ; Driver Code ; Given N ; Function Call"
C#;"using System ; using System . Collections . Generic ; class GFG { static int getPower ( int p ) { int res = 1 ; while ( p > 0 ) { res *= 5 ; p -- ; } return res ; } static int countNumbersUtil ( int N ) { int count = 0 ; List < int > digits = new List < int > ( ) ; while ( N > 0 ) { digits . Add ( N % 10 ) ; N /= 10 ; } digits . Reverse ( ) ; int D = digits . Count ; for ( int i = 1 ; i <= D ; i ++ ) { int res = getPower ( i ) ; if ( i == D ) { for ( int p = 1 ; p <= D ; p ++ ) { int x = digits [ p - 1 ] ; int tmp = 0 ; if ( p % 2 == 0 ) { tmp = ( 5 - ( x / 2 + 1 ) ) * getPower ( D - p ) ; } else { tmp = ( 5 - ( x + 1 ) / 2 ) * getPower ( D - p ) ; } res -= tmp ; if ( p % 2 != x % 2 ) { break ; } } } count += res ; } return count ; } static void countNumbers ( int L , int R ) { Console . WriteLine ( countNumbersUtil ( R ) - countNumbersUtil ( L - 1 ) ) ; } public static void Main ( String [ ] args ) { int L = 128 , R = 162 ; countNumbers ( L , R ) ; } }";"Count numbers from given range having odd digits at odd places and even digits at even places | C # program for the above approach ; Function to calculate 5 ^ p ; Stores the result ; Multiply 5 p times ; Return the result ; Function to count all numbers upto N having odd digits at odd places and even digits at even places ; Stores the count ; Stores the digits of N ; Insert the digits of N ; Reverse the vector to arrange the digits from first to last ; Stores count of digits of n ; Stores the count of numbers with i digits ; If the last digit is reached , subtract numbers eceeding range ; Iterate over all the places ; Stores the digit in the pth place ; Stores the count of numbers having a digit greater than x in the p - th position ; Calculate the count of numbers exceeding the range if p is even ; Calculate the count of numbers exceeding the range if p is odd ; Subtract the count of numbers exceeding the range from total count ; If the parity of p and the parity of x are not same ; Add count of numbers having i digits and satisfies the given conditions ; Return the total count of numbers till n ; Function to calculate the count of numbers from given range having odd digits places and even digits at even places ; Count of numbers in range [ L , R ] = Count of numbers till R - ; Count of numbers till ( L - 1 ) ; Driver Code"
C#;"using System ; class GFG { static int alternatingSumOfFirst_N ( int N ) { int alternateSum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) { alternateSum += - i ; } else { alternateSum += i ; } } return alternateSum ; } public static void Main ( String [ ] args ) { int N = 6 ; Console . Write ( alternatingSumOfFirst_N ( N ) ) ; } }";"Sum of first N natural numbers with alternate signs | C # program to implement the above approach ; Function to find the sum of first N natural numbers with alternate signs ; Stores sum of alternate sign of first N natural numbers ; If is an even number ; Update alternateSum ; If i is an odd number ; Update alternateSum ; Driver Code"
C#;"using System ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int findSum ( int N ) { int sum = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( gcd ( i , N ) == 1 ) { sum += i ; } } return sum ; } public static void Main ( String [ ] args ) { int N = 5 ; Console . Write ( findSum ( N ) ) ; } }";"Sum of all numbers up to N that are co | C # program for the above approach ; Function to return gcd of a and b ; Base Case ; Recursive GCD ; Function to calculate the sum of all numbers till N that are coprime with N ; Stores the resultant sum ; Iterate over [ 1 , N ] ; If gcd is 1 ; Update sum ; Return the readonly sum ; Driver Code ; Given N ; Function Call"
C#;"using System ; using System . Collections . Generic ; class GFG { static void solve ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( arr [ i ] , 1 ) ; } } int cnt = 0 ; foreach ( KeyValuePair < int , int > x in mp ) { cnt += ( ( x . Value ) * ( x . Value - 1 ) / 2 ) ; } int [ ] ans = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { ans [ i ] = cnt - ( mp [ arr [ i ] ] - 1 ) ; } for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( ans [ i ] + "" ▁ "" ) ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 1 , 2 , 1 , 2 } ; int N = arr . Length ; solve ( arr , N ) ; } }";"Count all distinct pairs of repeating elements from the array for every array element | C # program for the above approach ; Function to print the required count of pairs excluding the current element ; Store the frequency ; Find all the count ; Delete the contribution of each element for equal pairs ; Print the answer ; Driver Code ; Given array [ ] arr ; Function Call"
C#;"using System ; using System . Collections . Generic ; class GFG { public static void findMode ( int [ ] a , int n ) { Dictionary < int , int > map = new Dictionary < int , int > ( ) ; int max = 0 ; int mode = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( map . ContainsKey ( a [ i ] ) ) { map [ a [ i ] ] = map [ a [ i ] ] + 1 ; } else { map . Add ( a [ i ] , 1 ) ; } if ( map [ a [ i ] ] >= max ) { max = map [ a [ i ] ] ; mode = a [ i ] ; } Console . Write ( mode ) ; Console . Write ( "" ▁ "" ) ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 7 , 3 , 2 , 5 } ; int n = arr . Length ; findMode ( arr , n ) ; } }";"Mode in a stream of integers ( running integers ) | C # implementation of the above approach ; Function that prints the Mode values ; Map used to map integers to its frequency ; To store the maximum frequency ; To store the element with the maximum frequency ; Loop used to read the elements one by one ; Updates the frequency of that element ; Checks for maximum Number of occurrence ; Updates the maximum frequency ; Updates the Mode ; Driver Code ; Function Call"
C#;"using System . Collections . Generic ; using System ; class GFG { static long modexp ( long x , long n , long m ) { if ( n == 0 ) { return 1 ; } else if ( n % 2 == 0 ) { return modexp ( ( x * x ) % m , n / 2 , m ) ; } else { return ( x * modexp ( ( x * x ) % m , ( n - 1 ) / 2 , m ) % m ) ; } } static long modInverse ( long x , long m ) { return modexp ( x , m - 2 , m ) ; } static void countNumbers ( string N ) { long m = 1000000007 ; long [ ] factorial = new long [ 100001 ] ; factorial [ 0 ] = 1 ; for ( int i = 1 ; i < 100001 ; i ++ ) { factorial [ i ] = ( factorial [ i - 1 ] * i ) % m ; } long [ ] count = new long [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { count [ i ] = 0 ; } long length = N . Length ; for ( int i = 0 ; i < length ; i ++ ) count [ N [ i ] - '0' ] ++ ; long result = factorial [ ( int ) length ] ; for ( int i = 0 ; i < 10 ; i ++ ) { result = ( result * modInverse ( factorial [ ( int ) count [ i ] ] , m ) ) % m ; } Console . WriteLine ( result ) ; } public static void Main ( ) { string N = ""0223"" ; countNumbers ( N ) ; } }";"Count of distinct numbers formed by shuffling the digits of a large number N | C # program for the above approach ; Recursive function to return the value of ( x ^ n ) % m ; Base Case ; If N is even ; Else N is odd ; Function to find modular inverse of a number x under modulo m ; Using Fermat 's little theorem ; Function to count of numbers formed by shuffling the digits of a large number N ; Modulo value ; Array to store the factorials upto the maximum value of N ; Store factorial of i at index i ; To store count of occurrence of a digit ; Increment the count of digit occured ; Assign the factorial of length of input ; Multiplying result with the modulo multiplicative inverse of factorial of count of i ; Print the result ; Driver code ; Given number as string ; Function call"
C#;"using System ; using System . Collections . Generic ; class GFG { static int [ ] spf = new int [ 10001 ] ; static void spf_array ( int [ ] spf ) { spf [ 1 ] = 1 ; for ( int i = 2 ; i < 1000 ; i ++ ) spf [ i ] = i ; for ( int i = 4 ; i < 1000 ; i += 2 ) spf [ i ] = 2 ; for ( int i = 3 ; i * i < 1000 ; i ++ ) { if ( spf [ i ] == i ) { for ( int j = i * i ; j < 1000 ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } static void frequent_prime ( int [ ] arr , int N , int K ) { spf_array ( spf ) ; SortedDictionary < int , int > Hmap = new SortedDictionary < int , int > ( ) ; List < int > result = new List < int > ( ) ; int i = 0 ; for ( i = 0 ; i < N ; i ++ ) { int x = arr [ i ] ; while ( x != 1 ) { if ( Hmap . ContainsKey ( spf [ x ] ) ) Hmap [ spf [ x ] ] = spf [ x ] + 1 ; else Hmap . Add ( spf [ x ] , 1 ) ; x = x / spf [ x ] ; } } Hmap . Remove ( 1 ) ; foreach ( KeyValuePair < int , int > x in Hmap ) { int primeNum = x . Key ; int frequency = x . Value ; if ( frequency % K == 0 ) { result . Add ( primeNum ) ; } } if ( result . Count > 0 ) { foreach ( int it in result ) { Console . Write ( it + "" ▁ "" ) ; } } else { Console . Write ( "" { } "" ) ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 4 , 6 } ; int K = 1 ; int N = arr . Length ; frequent_prime ( arr , N , K ) ; } }";"Find prime factors of Array elements whose sum of exponents is divisible by K | C # program for the above approach ; To store the smallest prime factor till 10 ^ 5 ; Function to compute smallest prime factor array ; Initialize the spf array first element ; Marking smallest prime factor for every number to be itself ; Separately marking smallest prime factor for every even number as 2 ; Checking if i is prime ; Marking SPF for all numbers divisible by i ; Marking spf [ j ] if it is not previously marked ; Function that finds minimum operation ; Create a spf [ ] array ; Map created to store the unique prime numbers ; To store the result ; To store every unique prime number ; Erase 1 as a key because it is not a prime number ; First prime number ; Frequency is divisible by K then insert primeNum in the result [ ] ; Print the elements if it exists ; Driver code ; Given array [ ] arr ; Given K ; Function call"
C#;"using System ; class GFG { static void Kmultiples ( int n , int k ) { int a = n ; for ( int i = 1 ; i <= k ; i ++ ) { Console . Write ( n + "" ▁ * ▁ "" + i + "" ▁ = ▁ "" + a + "" STRNEWLINE "" ) ; int j = 0 ; while ( n >= ( 1 << j ) ) { a += n & ( 1 << j ) ; j ++ ; } } } public static void Main ( String [ ] args ) { int N = 16 , K = 7 ; Kmultiples ( N , K ) ; } }";"Generate first K multiples of N using Bitwise operators | C # program to implement the above approach ; Function to print the first K multiples of N ; Print the value of N * i ; Iterate each bit of N and add Math . Pow ( 2 , pos ) , where pos is the index of each set bit ; Check if current bit at pos j is fixed or not ; For next set bit ; Driver Code"
C#;"using System ; using System . Linq ; class GFG { private static double calculateB ( int [ ] x , int [ ] y ) { int n = x . Length ; int sx = x . Sum ( ) ; int sy = y . Sum ( ) ; int sxsy = 0 ; int sx2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sxsy += x [ i ] * y [ i ] ; sx2 += x [ i ] * x [ i ] ; } double b = ( double ) ( n * sxsy - sx * sy ) / ( n * sx2 - sx * sx ) ; return b ; } public static void leastRegLine ( int [ ] X , int [ ] Y ) { double b = calculateB ( X , Y ) ; int n = X . Length ; int meanX = X . Sum ( ) / n ; int meanY = Y . Sum ( ) / n ; double a = meanY - b * meanX ; Console . WriteLine ( "" Regression ▁ line : "" ) ; Console . Write ( "" Y ▁ = ▁ "" ) ; Console . Write ( "" { 0 : F3 } "" , a ) ; Console . Write ( "" ▁ + ▁ "" ) ; Console . Write ( "" { 0 : F3 } "" , b ) ; Console . Write ( "" * X "" ) ; } public static void Main ( String [ ] args ) { int [ ] X = { 95 , 85 , 80 , 70 , 60 } ; int [ ] Y = { 90 , 80 , 70 , 65 , 60 } ; leastRegLine ( X , Y ) ; } }";"Least Square Regression Line | C # program to find the regression line ; Function to calculate b ; Sum of array x ; Sum of array y ; For sum of product of x and y ; Sum of square of x ; Function to find the least regression line ; Finding b ; Calculating a ; Printing regression line ; Driver code ; Statistical data"
C#;"using System ; class GFG { static int countRepeatingDigits ( int N ) { int res = 0 ; int [ ] cnt = new int [ 10 ] ; while ( N > 0 ) { int rem = N % 10 ; cnt [ rem ] ++ ; N = N / 10 ; } for ( int i = 0 ; i < 10 ; i ++ ) { if ( cnt [ i ] > 1 ) { res ++ ; } } return res ; } public static void Main ( String [ ] args ) { int N = 12 ; Console . WriteLine ( countRepeatingDigits ( N ) ) ; } }";"Count of repeating digits in a given Number | C # program for the above approach ; Function that returns the count of repeating digits of the given number ; Initialize a variable to store count of Repeating digits ; Initialize cnt array to store digit count ; Iterate through the digits of N ; Retrieve the last digit of N ; Increase the count of digit ; Remove the last digit of N ; Iterate through the cnt array ; If frequency of digit is greater than 1 ; Increment the count of Repeating digits ; Return count of repeating digit ; Driver Code ; Given array [ ] arr ; Function Call"
C#;"using System ; class GFG { static void findTemperature ( int x , int y , int s ) { double Day1 , Day2 ; double diff = ( x - y ) * 6 ; Day2 = ( diff + s ) / 2 ; Day1 = s - Day2 ; Console . Write ( "" Day1 ▁ : ▁ "" + Day1 + ' STRNEWLINE ' ) ; Console . WriteLine ( "" Day2 ▁ : ▁ "" + Day2 + ' STRNEWLINE ' ) ; } public static void Main ( string [ ] args ) { int x = 5 , y = 10 , s = 40 ; findTemperature ( x , y , s ) ; } }";"Find temperature of missing days using given sum and average | C # program for the above approach ; Function for finding the temperature ; Store Day1 - Day2 in diff ; Remaining from s will be Day1 ; Print Day1 and Day2 ; Driver Code ; Functions"
C#;"using System ; class GFG { static int freqCount ( String str , char k ) { int count = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == k ) count ++ ; } return count ; } static void findAandB ( int n , int k ) { int flag = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( freqCount ( i . ToString ( ) , ( char ) ( k + 48 ) ) == 0 && freqCount ( ( n - i ) . ToString ( ) , ( char ) ( k + 48 ) ) == 0 ) { Console . Write ( "" ( "" + i + "" , ▁ "" + ( n - i ) + "" ) "" ) ; flag = 1 ; break ; } } if ( flag == 0 ) Console . Write ( - 1 ) ; } public static void Main ( String [ ] args ) { int N = 100 ; int K = 0 ; findAandB ( N , K ) ; } }";"Find two numbers whose sum is N and does not contain any digit as K | C # program for the above approach ; Function to find two numbers whose sum is N and do not contain any digit as k ; Check every number i and ( n - i ) ; Check if i and n - i doesn 't  contain k in them print i and n-i ; Check if flag is 0 then print - 1 ; Driver code ; Given N and K ; Function call"
C#;"using System ; class GFG { static long calculate ( long p , long q ) { long mod = 998244353 , expo ; expo = mod - 2 ; while ( expo != 0 ) { if ( ( expo & 1 ) == 1 ) { p = ( p * q ) % mod ; } q = ( q * q ) % mod ; expo >>= 1 ; } return p ; } public static void Main ( string [ ] args ) { long p = 1 , q = 4 ; Console . WriteLine ( calculate ( p , q ) ) ; } }";"Find the value of P and modular inverse of Q modulo 998244353 | C # implementation to find the value of P . Q - 1 mod 998244353 ; Function to find the value of P * Q ^ - 1 mod 998244353 ; Loop to find the value until the expo is not zero ; Multiply p with q if expo is odd ; Reduce the value of expo by 2 ; Driver code ; Function call"
C#;"using System ; class GFG { static void maxLCMWithGivenSum ( int X ) { int A , B ; if ( ( X & 1 ) == 1 ) { A = X / 2 ; B = X / 2 + 1 ; } else { if ( ( X / 2 ) % 2 == 0 ) { A = X / 2 - 1 ; B = X / 2 + 1 ; } else { A = X / 2 - 2 ; B = X / 2 + 2 ; } } Console . WriteLine ( A + "" ▁ "" + B ) ; } public static void Main ( String [ ] args ) { int X = 30 ; maxLCMWithGivenSum ( X ) ; } }";"Find two numbers with given sum and maximum possible LCM | C # program of the above approach ; Function that print two numbers with the sum X and maximum possible LCM ; Variables to store the result ; If X is odd ; If X is even ; If floor ( X / 2 ) is even ; If floor ( X / 2 ) is odd ; Print the result ; Driver code ; Given number ; Function call"
C#;"using System ; class GFG { static int MaxSubarrayLength ( int [ ] arr , int n , int k ) { int left = - 1 ; int right = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % k ) != 0 ) { if ( left == - 1 ) { left = i ; } right = i ; } sum += arr [ i ] ; } if ( ( sum % k ) != 0 ) { return n ; } else if ( left == - 1 ) { return - 1 ; } else { int prefix_length = left + 1 ; int suffix_length = n - right ; return n - Math . Min ( prefix_length , suffix_length ) ; } } public static void Main ( string [ ] args ) { int [ ] arr = { 6 , 3 , 12 , 15 } ; int n = arr . Length ; int K = 3 ; Console . Write ( MaxSubarrayLength ( arr , n , K ) ) ; } }";"Length of longest subarray whose sum is not divisible by integer K | C # program to find the length of the longest subarray whose sum is not divisible by integer K ; Function to find the longest subarray with sum is not divisible by k ; left is the index of the leftmost element that is not divisible by k ; right is the index of the rightmost element that is not divisible by k ; sum of the array ; Find the element that is not multiple of k ; left = - 1 means we are finding the leftmost element that is not divisible by k ; Updating the rightmost element ; Update the sum of the array up to the index i ; Check if the sum of the array is not divisible by k , then return the size of array ; All elements of array are divisible by k , then no such subarray possible so return - 1 ; Length of prefix elements that can be removed ; Length of suffix elements that can be removed ; Return the length of subarray after removing the elements which have lesser number of elements ; Driver code"
C#;"using System ; class GFG { static int solve ( int X , int Y ) { if ( X > Y ) { int temp = X ; X = Y ; Y = temp ; } if ( X == Y ) Console . WriteLine ( 0 ) ; else if ( Y % X == 0 ) Console . WriteLine ( 1 ) ; else Console . WriteLine ( 2 ) ; return 0 ; } public static void Main ( String [ ] args ) { int X = 8 , Y = 13 ; solve ( X , Y ) ; } }";"Minimum steps to convert X to Y by repeated division and multiplication | C # implementation to find minimum steps to convert X to Y by repeated division and multiplication ; Check if X is greater than Y then swap the elements ; Check if X equals Y ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { static long countQuadraples ( long N ) { long cnt = 0 ; Dictionary < long , long > m = new Dictionary < long , long > ( ) ; for ( long a = 1 ; a <= N ; a ++ ) { for ( long b = 1 ; b <= N ; b ++ ) { long x = a * a + b * b ; if ( m . ContainsKey ( x ) ) m [ x ] = m [ x ] + 1 ; else m . Add ( x , 1 ) ; } } for ( long c = 1 ; c <= N ; c ++ ) { for ( long d = 1 ; d <= N ; d ++ ) { long x = c * c + d * d ; if ( m . ContainsKey ( x ) ) cnt += m [ x ] ; } } return cnt ; } public static void Main ( String [ ] args ) { long N = 2 ; Console . WriteLine ( countQuadraples ( N ) ) ; } }";"Count quadruplets ( A , B , C , D ) till N such that sum of square of A and B is equal to that of C and D | C # program for the above approach ; Function to count the quadruples ; Counter variable ; Map to store the sum of pair ( a ^ 2 + b ^ 2 ) ; Iterate till N ; Calculate a ^ 2 + b ^ 2 ; Increment the value in map ; Check if this sum was also in a ^ 2 + b ^ 2 ; Return the count ; Driver code ; Given N ; Function call"
C#;"using System ; class GFG { static int count_pairs ( int [ ] a , int [ ] b , int N ) { int i , j ; int count = 0 ; for ( i = 0 ; i < ( N - 1 ) ; i ++ ) { for ( j = ( i + 1 ) ; j < N ; j ++ ) { if ( ( a [ i ] + a [ j ] ) > ( b [ i ] + b [ j ] ) ) { count ++ ; } } } return count ; } public static void Main ( ) { int N = 5 ; int [ ] a = new int [ ] { 1 , 2 , 3 , 4 , 5 } ; int [ ] b = new int [ ] { 2 , 5 , 6 , 1 , 9 } ; Console . Write ( count_pairs ( a , b , N ) ) ; } }";"Count of distinct index pair ( i , j ) such that element sum of First Array is greater | C # program for the above problem ; function to find the number of pairs satisfying the given cond . ; variables used for traversal ; count variable to store the count of possible pairs ; Nested loop to find out the possible pairs ; Check if the given condition is satisfied or not . If yes then increment the count . ; Return the count value ; Driver Code ; Size of the arrays ; Initialise the arrays ; function call that returns the count of possible pairs"
C#;"using System ; class GFG { static int numberOfPairs ( int [ ] a , int [ ] b , int n ) { int [ ] c = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { c [ i ] = a [ i ] - b [ i ] ; } Array . Sort ( c ) ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( c [ i ] <= 0 ) continue ; int pos = - 1 ; for ( int j = 0 ; j < n ; j ++ ) { if ( c [ i ] + c [ j ] > 0 ) { pos = j ; break ; } } answer += ( i - pos ) ; } return answer ; } static void Main ( ) { int n = 5 ; int [ ] a = { 1 , 2 , 3 , 4 , 5 } ; int [ ] b = { 2 , 5 , 6 , 1 , 9 } ; Console . WriteLine ( numberOfPairs ( a , b , n ) ) ; } }";"Count of distinct index pair ( i , j ) such that element sum of First Array is greater | C # program of the above approach ; Function to find the number of pairs . ; Array c [ ] where c [ i ] = a [ i ] - b [ i ] ; Sort the array c ; Initialise answer as 0 ; Iterate from index 0 to n - 1 ; If c [ i ] <= 0 then in the sorted array c [ i ] + c [ pos ] can never greater than 0 where pos < i ; Which is equivalent to c [ j ] >= - c [ i ] + 1 ; Add ( i - pos ) to answer ; Return the answer ; Driver Code ; Number of elements in a and b ; Array a ; Array b"
C#;"using System ; using System . Collections ; using System . Collections . Generic ; class GFG { static void print_h_index ( int [ ] arr , int N ) { ArrayList ms = new ArrayList ( ) ; for ( int i = 0 ; i < N ; i ++ ) { ms . Add ( arr [ i ] ) ; int t = int . MaxValue ; foreach ( int x in ms ) { if ( x < t ) { t = x ; } } if ( t < ms . Count ) { ms . Remove ( t ) ; } Console . Write ( ms . Count + "" ▁ "" ) ; } } public static void Main ( string [ ] args ) { int [ ] arr = { 9 , 10 , 7 , 5 , 0 , 10 , 2 , 0 } ; int N = arr . Length ; print_h_index ( arr , N ) ; } }";"Find K for every Array element such that at least K prefixes are â ‰¥ K | C # program for the above approach ; Function to find the K - value for every index in the array ; Multiset to store the array in the form of red - black tree ; Iterating over the array ; Inserting the current value in the multiset ; Condition to check if the smallest value in the set is less than it 's size ; Erase the smallest value ; h - index value will be the size of the multiset ; Driver code ; Array ; Size of the array ; Function call"
C#;"using System ; using System . Collections ; using System . Linq ; using System . Collections . Generic ; class GFG { static List < bool > findPrimes ( int [ ] arr , int n ) { int max_val = arr . Max ( ) ; List < bool > prime = new List < bool > ( max_val + 1 ) ; for ( int i = 0 ; i < max_val + 1 ; i ++ ) prime . Add ( true ) ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } return prime ; } static void nonRepeatingPrimes ( int [ ] arr , int n ) { List < bool > prime = findPrimes ( arr , n ) ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) if ( mp . ContainsKey ( arr [ i ] ) ) mp [ arr [ i ] ] ++ ; else mp . Add ( arr [ i ] , 1 ) ; } foreach ( KeyValuePair < int , int > entry in mp ) { if ( entry . Value == 1 ) Console . WriteLine ( entry . Key ) ; } } public static void Main ( string [ ] args ) { int [ ] arr = { 2 , 3 , 4 , 6 , 7 , 9 , 7 , 23 , 21 , 3 } ; int n = arr . Length ; nonRepeatingPrimes ( arr , n ) ; } }";"Non | C # program to find Non - repeating Primes ; Function to find count of prime ; Find maximum value in the array ; Create a boolean array "" prime [ 0 . . n ] "" . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; Remaining part of SIEVE ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Function to print Non - repeating primes ; Precompute primes using Sieve ; Create HashMap to store frequency of prime numbers ; Traverse through array elements and Count frequencies of all primes ; Traverse through map and print non repeating primes ; Driver code"
C#;"using System ; class GFG { static int prefixProduct ( int [ ] a , int n ) { for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i ] * a [ i - 1 ] ; } for ( int j = 0 ; j < n ; j ++ ) { Console . Write ( a [ j ] + "" , ▁ "" ) ; } return 0 ; } public static void Main ( string [ ] args ) { int [ ] arr = new int [ ] { 2 , 4 , 6 , 5 , 10 } ; int N = 5 ; prefixProduct ( arr , N ) ; } }";"Prefix Product Array | C # program to generate Prefix Product Array ; Function to generate prefix product array ; Update the array with the product of prefixes ; Print the array ; Driver Code"
C#;"using System ; class GFG { static int countWays ( int N ) { if ( N < 4 ) return 0 ; int ans = ( ( N - 1 ) * ( N - 2 ) ) / 2 ; int s = 0 ; for ( int i = 2 ; i <= N - 3 ; i ++ ) { for ( int j = 1 ; j < i ; j ++ ) { if ( N == 2 * i + j ) s ++ ; } } if ( N % 3 == 0 ) s = 3 * s + 1 ; else s = 3 * s ; return ans - s ; } public static void Main ( ) { int N = 10 ; Console . Write ( countWays ( N ) ) ; } }";"Count of ways to distribute N items among 3 people with one person receiving maximum | C # program to find the number of ways to distribute N item among three people such that one person always gets the maximum value ; Function to find the number of ways to distribute N items among 3 people ; No distribution possible ; Total number of ways to distribute N items among 3 people ; Store the number of distributions which are not possible ; Count possibilities of two persons receiving the maximum ; If N is divisible by 3 ; Return the final count of ways to distribute ; Driver Code"
C#;"using System ; class GFG { static bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static bool isMagnanimous ( int N ) { String s = N . ToString ( ) ; int l = s . Length ; if ( l < 2 ) return false ; for ( int i = 0 ; i < l - 1 ; i ++ ) { String left = s . Substring ( 0 , i + 1 ) ; String right = s . Substring ( i + 1 ) ; int x = int . Parse ( left ) ; int y = int . Parse ( right ) ; if ( ! isPrime ( x + y ) ) return false ; } return true ; } public static void Main ( String [ ] args ) { int N = 12 ; if ( isMagnanimous ( N ) ) Console . Write ( "" Yes STRNEWLINE "" ) ; else Console . Write ( "" No STRNEWLINE "" ) ; } }";"Magnanimous Numbers | C # implementation to check if a number is Magnanimous ; Function to check if n is prime ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function to check if the number is Magnanimous or not ; Converting the number to string ; Finding length of string ; Number should not be of single digit ; Loop to find all left and right part of the string ; Driver code"
C#;"using System ; class GFG { static readonly int limit = 10000000 ; static int [ ] position = new int [ limit + 1 ] ; static void sieve ( ) { position [ 0 ] = - 1 ; position [ 1 ] = - 1 ; int pos = 0 ; for ( int i = 2 ; i <= limit ; i ++ ) { if ( position [ i ] == 0 ) { position [ i ] = ++ pos ; for ( int j = i * 2 ; j <= limit ; j += i ) position [ j ] = - 1 ; } } } static int getSum ( int n ) { int sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = n / 10 ; } return sum ; } static bool isHonakerPrime ( int n ) { int pos = position [ n ] ; if ( pos == - 1 ) return false ; return getSum ( n ) == getSum ( pos ) ; } public static void Main ( String [ ] args ) { sieve ( ) ; int N = 121 ; if ( isHonakerPrime ( N ) ) Console . Write ( "" Yes STRNEWLINE "" ) ; else Console . Write ( "" No STRNEWLINE "" ) ; } }";"Honaker Prime Number | C # program for above approach ; Function to precompute the position of every prime number using Sieve ; 0 and 1 are not prime numbers ; Variable to store the position ; Incrementing the position for every prime number ; Function to get sum of digits ; Function to check whether the given number is Honaker Prime number or not ; Driver code ; Precompute the prime numbers till 10 ^ 6 ; Given Number ; Function Call"
C#;"using System ; class GFG { static int N = 4 , M = 5 ; static Boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) if ( n % i == 0 ) return false ; return true ; } static int takeSum ( int [ ] [ ] a ) { int s = 0 ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) s += a [ i ] [ j ] ; return s ; } public static void Main ( String [ ] args ) { int [ ] [ ] a = new int [ ] [ ] { new int [ ] { 1 , 2 , 3 , 4 , 2 } , new int [ ] { 0 , 1 , 2 , 3 , 34 } , new int [ ] { 0 , 34 , 21 , 12 , 12 } , new int [ ] { 1 , 2 , 3 , 6 , 6 } } ; int sum = takeSum ( a ) ; if ( isPrime ( sum ) ) Console . Write ( "" YES "" + "" STRNEWLINE "" ) ; else Console . Write ( "" NO "" + "" STRNEWLINE "" ) ; } }";"Check if Matrix sum is prime or not | C # implementation to check if the sum of matrix is prime or not ; Function to check whether a number is prime or not ; Corner case ; Check from 2 to n - 1 ; Function for to find the sum of the given matrix ; Driver Code"
C#;"using System ; class GFG { static long sumOfSumSeries ( int N ) { long sum = 0L ; for ( int i = 1 ; i <= N ; i ++ ) { sum = sum + ( i * ( i + 1 ) ) / 2 ; } return sum ; } public static void Main ( ) { int N = 5 ; Console . Write ( sumOfSumSeries ( N ) ) ; } }";"Sum of sum | C # program to implement the above approach ; Function to find the sum ; Calculate sum - series for every natural number and add them ; Driver code"
C#;"using System ; class GFG { static long sumOfSumSeries ( int n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; } public static void Main ( String [ ] args ) { int N = 5 ; Console . Write ( sumOfSumSeries ( N ) ) ; } }";"Sum of sum | C # program to implement the above approach ; Function to find the sum ; Driver code"
C#;"using System ; class GFG { static bool isContaindigit ( int n ) { while ( n > 0 ) { if ( ! ( n % 10 == 0 n % 10 == 1 n % 10 == 8 ) ) return false ; n = n / 10 ; } return true ; } static bool ispalindrome ( int n ) { string temp = n . ToString ( ) ; int l = temp . Length ; for ( int i = 0 ; i < l / 2 ; i ++ ) { if ( temp [ i ] != temp [ l - i - 1 ] ) return false ; } return true ; } static bool isTetradic ( int n ) { if ( ispalindrome ( n ) && isContaindigit ( n ) ) return true ; return false ; } static void printTetradicPrimesLessThanN ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; Array . Fill ( prime , true ) ; int p = 2 ; while ( p * p <= n ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i < n + 1 ; i += p ) prime [ i ] = false ; } p += 1 ; } for ( p = 2 ; p < n + 1 ; p ++ ) { if ( prime [ p ] && isTetradic ( p ) ) Console . Write ( p + "" ▁ "" ) ; } } static void Main ( ) { int n = 1000 ; printTetradicPrimesLessThanN ( n ) ; } }";"Tetradic Primes | C # implementation to print all Tetradic primes smaller than or equal to N . ; Function to check if the number N having all digits lies in the set ( 0 , 1 , 8 ) ; Function to check if the number N is palindrome ; Function to check if a number N is Tetradic ; Function to generate all primes and checking whether number is Tetradic or not ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Print all Tetradic prime numbers ; Checking whether the given number is prime Tetradic or not ; Driver code"
C#;"using System ; class GFG { static int concat ( int a , int b ) { String s1 = a . ToString ( ) ; String s2 = b . ToString ( ) ; String s = s1 + s2 ; int c = Int32 . Parse ( s ) ; return c ; } static bool isAstonishing ( int n ) { for ( int i = 1 ; i < n ; i ++ ) { int sum = 0 ; for ( int j = i ; j < n ; j ++ ) { sum += j ; if ( sum == n ) { int concatenation = concat ( i , j ) ; if ( concatenation == n ) { return true ; } } } } return false ; } public static void Main ( String [ ] args ) { int n = 429 ; if ( isAstonishing ( n ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Astonishing Numbers | C # implementation for the above approach ; Function to concatenate two integers into one ; Convert both the integers to String ; Concatenate both Strings ; Convert the concatenated String to integer ; return the formed integer ; Function to check if N is a Astonishing number ; Loop to find sum of all integers from i till the sum becomes >= n ; variable to store sum of all integers from i to j and check if sum and concatenation equals n or not ; finding concatenation of i and j ; condition for Astonishing number ; Driver Code ; Given Number ; Function Call"
C#;"using System ; using System . Collections . Generic ; class GFG { static bool checkSame ( int n , int b ) { Dictionary < int , int > m = new Dictionary < int , int > ( ) ; while ( n != 0 ) { int r = n % b ; n = n / b ; if ( m . ContainsKey ( r ) ) { m [ r ] = m [ r ] + 1 ; } else { m . Add ( r , 1 ) ; } } int last = - 1 ; foreach ( KeyValuePair < int , int > i in m ) { if ( last != - 1 && i . Value != last ) { return false ; } else { last = i . Value ; } } return true ; } public static void Main ( String [ ] args ) { int n = 9 ; int Base = 2 ; if ( checkSame ( n , Base ) ) Console . Write ( "" Yes "" ) ; else Console . Write ( "" NO "" ) ; } }";"Digitally balanced numbers | C # implementation to check if a number is a digitally balanced number ; Function to check if the digits in the number is the same number of digits ; Loop to iterate over the digits of the number N ; Loop to iterate over the map ; Driver Code ; Function to check"
C#;"using System ; class GFG { static int seriesSum ( int n ) { int sum = 0 ; int currProd = 1 ; int currSum = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { currProd *= i ; currSum += i ; sum += currProd - currSum ; } return sum ; } public static void Main ( ) { int N = 5 ; Console . Write ( seriesSum ( N ) ) ; } }";"Sum of series formed by difference between product and sum of N natural numbers | C # program to implement the above approach ; Function to calculate the sum upto Nth term ; Stores the sum of the series ; Stores the product of natural numbers upto the current term ; Stores the sum of natural numbers upto the upto current term ; Generate the remaining terms and calculate sum ; Update the sum ; Return the sum ; Driver code"
C#;"using System ; class GFG { static int count ( int [ ] a , int n ) { int countElements = 0 ; for ( int i = 0 ; i < n ; i ++ ) { bool flag = true ; for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; if ( a [ i ] % a [ j ] == 0 ) { flag = false ; break ; } } if ( flag == true ) ++ countElements ; } return countElements ; } public static void Main ( String [ ] args ) { int [ ] arr = { 86 , 45 , 18 , 4 , 8 , 28 , 19 , 33 , 2 } ; int n = arr . Length ; Console . Write ( count ( arr , n ) ) ; } }";"Count of elements not divisible by any other elements of Array | C # program for the above approach ; Function to count the number of elements of array which are not divisible by any other element in the array [ ] arr ; Iterate over the array ; Check if the element is itself or not ; Check for divisibility ; Return the readonly result ; Driver Code ; Given array ; Function call"
C#;"using System ; class GFG { static int smallestNumber ( int N ) { return ( int ) ( N * Math . Ceiling ( Math . Pow ( 10 , ( N - 1 ) ) / N ) ) ; } public static void Main ( ) { int N = 2 ; Console . Write ( smallestNumber ( N ) ) ; } }";"Smallest N digit number divisible by N | C # program for the above approach ; Function to find the smallest N - digit number divisible by N ; Return the smallest N - digit number calculated using above formula ; Driver Code ; Given N ; Function Call"
C#;"using System ; class GFG { static int CountPairs ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] % 2 == 0 arr [ j ] % 2 == 0 ) count ++ ; } } return count ; } public static void Main ( String [ ] args ) { int [ ] arr = { 8 , 2 , 3 , 1 , 4 , 2 } ; int n = arr . Length ; Console . WriteLine ( CountPairs ( arr , n ) ) ; } }";"Count pairs in an array containing at least one even value | C # implementation to count pairs in an array such that each pair contains at least one even element ; Function to count the pairs in the array such as there is at least one even element in each pair ; Generate all possible pairs and increment then count if the condition is satisfied ; Driver code ; Function Call"
C#;"using System ; class GFG { static int CountPairs ( int [ ] arr , int n ) { int even = 0 , odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return ( even * ( even - 1 ) ) / 2 + ( even * odd ) ; } public static void Main ( ) { int [ ] arr = { 8 , 2 , 3 , 1 , 4 , 2 } ; int n = arr . Length ; Console . Write ( CountPairs ( arr , n ) ) ; } }";"Count pairs in an array containing at least one even value | C # implementation to Count pairs in an array such that each pair contains at least one even element ; Function to count the pairs in the array such as there is at least one even element in each pair ; Store count of even and odd elements ; Check element is even or odd ; Driver Code"
C#;"using System ; class GFG { static bool isComposite ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; } static bool isGiugaNum ( int n ) { if ( ! ( isComposite ( n ) ) ) return false ; int N = n ; while ( n % 2 == 0 ) { if ( ( N / 2 - 1 ) % 2 != 0 ) return false ; n = n / 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { if ( ( N / i - 1 ) % i != 0 ) return false ; n = n / i ; } } if ( n > 2 ) if ( ( N / n - 1 ) % n != 0 ) return false ; return true ; } static void Main ( ) { int N = 30 ; if ( isGiugaNum ( N ) ) Console . Write ( "" Yes "" ) ; else Console . Write ( "" No "" ) ; } }";"Giuga Numbers | C # program for the above approach ; Function to check if n is a composite number ; Corner cases ; This is checked to skip middle 5 numbers ; Function to check if N is a Giuga Number ; N should be composite to be a Giuga Number ; Print the number of 2 s that divide n ; N must be odd at this point . So we can skip one element ; While i divides n , print i and divide n ; This condition is to handle the case when n is a prime number > 2 ; Driver code ; Given Number N ; Function Call"
C#;"using System ; class GFG { static bool isDroll ( int n ) { if ( n == 1 ) return false ; int sum_even = 0 ; int sum_odd = 0 ; while ( n % 2 == 0 ) { sum_even += 2 ; n = n / 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { sum_odd += i ; n = n / i ; } } if ( n > 2 ) sum_odd += n ; return sum_even == sum_odd ; } public static void Main ( ) { int n = 72 ; if ( isDroll ( n ) ) Console . Write ( "" Yes "" ) ; else Console . Write ( "" No "" ) ; } }";"Droll Numbers | C # program for the above approach ; Function to check droll numbers ; To store sum of even prime factors ; To store sum of odd prime factors ; Add the number of 2 s that divide n in sum_even ; N must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; While i divides n , print i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; Condition to check droll number ; Driver code ; Given Number N ; Function Call"
C#;"using System ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static int CountPairs ( int n ) { int cnt = 0 ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int div1 = i ; int div2 = n / i ; int sum = div1 + div2 ; if ( gcd ( sum , n ) == 1 ) cnt += 1 ; } } return cnt ; } public static void Main ( ) { int n = 24 ; Console . WriteLine ( CountPairs ( n ) ) ; } }";"Count all pairs of divisors of a number N whose sum is coprime with N | C # program to count all pairs of divisors such that their sum is coprime with N ; Function to find gcd of a and b ; Function to count all valid pairs ; Initialize count ; Check if sum of pair and n are coprime ; Return the result ; Driver method"
C#;"using System ; class GFG { static bool isPossible ( int A , int B ) { return ( A - B > 1 ) ; } public static void Main ( ) { int A = 10 , B = 4 ; if ( isPossible ( A , B ) ) Console . Write ( "" Yes "" ) ; else Console . Write ( "" No "" ) ; } }";"Check if A can be converted to B by reducing with a Prime number | C # implementation to find if it is possible to make a equal to b ; Function to find if it is possible to make A equal to B ; Driver Code ; Function Call"
C#;"using System ; using System . Collections . Generic ; class GFG { static int [ ] sub = new int [ 100005 ] ; static int minDivisorDifference ( int n ) { int num1 = 0 ; int num2 = 0 ; for ( int i = ( int ) Math . Sqrt ( n ) ; i <= n ; i ++ ) { if ( n % i == 0 ) { num1 = i ; num2 = n / i ; break ; } } return Math . Abs ( num1 - num2 ) ; } static int dfs ( List < int > [ ] g , int u , int par ) { sub [ u ] = minDivisorDifference ( u ) ; int mx = 0 ; foreach ( int c in g [ u ] ) { if ( c != par ) { int ans = dfs ( g , c , u ) ; mx = Math . Max ( mx , ans ) ; } } sub [ u ] += mx ; return sub [ u ] ; } public static void Main ( String [ ] args ) { List < int > [ ] g = new List < int > [ 100005 ] ; for ( int i = 0 ; i < g . Length ; i ++ ) g [ i ] = new List < int > ( ) ; int edges = 6 ; g [ 18 ] . Add ( 7 ) ; g [ 7 ] . Add ( 18 ) ; g [ 18 ] . Add ( 15 ) ; g [ 15 ] . Add ( 18 ) ; g [ 15 ] . Add ( 2 ) ; g [ 2 ] . Add ( 15 ) ; g [ 7 ] . Add ( 4 ) ; g [ 4 ] . Add ( 7 ) ; g [ 7 ] . Add ( 12 ) ; g [ 12 ] . Add ( 7 ) ; g [ 12 ] . Add ( 9 ) ; g [ 9 ] . Add ( 12 ) ; int root = 18 ; Console . Write ( dfs ( g , root , - 1 ) ) ; } }";"Maximize sum of minimum difference of divisors of nodes in N | C # program to maximize the sum of minimum difference of divisors of nodes in an n - ary tree ; Array to store the result at each node ; Function to get minimum difference between the divisors of a number ; Iterate from square root of N to N ; return absolute difference ; DFS function to calculate the maximum sum ; Store the min difference ; Add the maximum of all children to sub [ u ] ; Return maximum sum of node ' u ' to its parent ; Driver code"
C#;"using System ; class GFG { static Boolean isCenteredcube ( int N ) { int i = 1 ; while ( true ) { int ith_term = ( 2 * i + 1 ) * ( i * i + i + 1 ) ; if ( ith_term == N ) { return true ; } if ( ith_term > N ) { return false ; } i ++ ; } } public static void Main ( ) { int N = 9 ; if ( isCenteredcube ( N ) ) { Console . WriteLine ( "" Yes "" ) ; } else { Console . WriteLine ( "" No "" ) ; } } }";"Program to check if N is a Centered Cubic Number | C # program to check if N is a centered cubic number ; Function to check if N is a centered cubic number ; Iterating from 1 ; Infinite loop ; Finding ith_term ; Checking if the number N is a centered cube number ; If ith_term > N then N is not a centered cube number ; Incrementing i ; Driver code ; Function call"
C#;"using System ; class GFG { static float productOfGP ( float a , float r , int n ) { float product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { product = product * a ; a = a * r ; } return product ; } public static void Main ( ) { float a = 1 , r = 2 ; int N = 4 ; Console . Write ( productOfGP ( a , r , N ) ) ; } }";"Product of N terms of a given Geometric series | C # program for the above approach ; Function to calculate product of geometric series ; Initialise final product with 1 ; Multiply product with each term stored in a ; Return the final product ; Driver Code ; Given first term and common ratio ; Number of terms ; Function Call"
C#;"using System ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; } static int findlcm ( int [ ] arr , int n ) { int ans = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { ans = ( ( ( arr [ i ] * ans ) ) / ( gcd ( arr [ i ] , ans ) ) ) ; } return ans ; } static void addReduce ( int n , int [ ] num , int [ ] den ) { int final_numerator = 0 ; int final_denominator = findlcm ( den , n ) ; for ( int i = 0 ; i < n ; i ++ ) { final_numerator = final_numerator + ( num [ i ] ) * ( final_denominator / den [ i ] ) ; } int GCD = gcd ( final_numerator , final_denominator ) ; final_numerator /= GCD ; final_denominator /= GCD ; Console . Write ( final_numerator + "" / "" + final_denominator ) ; } public static void Main ( string [ ] args ) { int N = 3 ; int [ ] arr1 = { 1 , 2 , 5 } ; int [ ] arr2 = { 2 , 1 , 6 } ; addReduce ( N , arr1 , arr2 ) ; } }";"Sum of given N fractions in reduced form | C # program for the above approach ; Function to find GCD of a & b using Euclid Lemma ; Base case ; Function to find the LCM of all elements in arr [ ] ; Initialize result ; Iterate arr [ ] to find LCM ; Return the final LCM ; Function to find the sum of N fraction in reduced form ; To store the sum of all final numerators ; Find the LCM of all denominator ; Find the sum of all N numerators & denominators ; Add each fraction one by one ; Find GCD of final numerator and denominator ; Convert into reduced form by dividing from GCD ; Print the final fraction ; Driver code ; Given N ; Given numerator ; Given denominator ; Function call"
C#;"using System ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static int minLCM ( int [ ] arr , int n ) { int ans = Int32 . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { int g = gcd ( arr [ i ] , arr [ j ] ) ; int lcm = arr [ i ] / g * arr [ j ] ; ans = Math . Min ( ans , lcm ) ; } } return ans ; } public static void Main ( ) { int [ ] arr = { 2 , 4 , 3 , 6 , 5 } ; int n = arr . Length ; Console . Write ( minLCM ( arr , n ) ) ; } }";"Minimum LCM of all pairs in a given array | C # program to find minimum possible lcm from any pair ; Function to compute GCD of two numbers ; Function that return minimum possible lcm from any pair ; Fix the ith element and iterate over all the array to find minimum LCM ; Driver code"
C#;"using System ; class GFG { static void solve ( int n ) { int upper_limit = ( int ) ( Math . Ceiling ( Math . Pow ( n , 1.0 / 4 ) ) ) ; for ( int x = 0 ; x <= upper_limit ; x ++ ) { for ( int y = 0 ; y <= upper_limit ; y ++ ) { int num1 = x * x * x * x ; int num2 = y * y * y * y ; if ( num1 - num2 == n ) { Console . Write ( "" x ▁ = ▁ "" + x + "" , ▁ y ▁ = ▁ "" + y ) ; return ; } } } Console . Write ( - 1 ) ; } public static void Main ( String [ ] args ) { int n = 15 ; solve ( n ) ; } }";"Find two numbers whose difference of fourth power is equal to N | C # implementation to find the values of x and y for the given equation with integer N ; Function which find required x & y ; Upper limit of x & y , if such x & y exists ; num1 stores x ^ 4 ; num2 stores y ^ 4 ; If condition is satisfied the print and return ; If no such pair exists ; Driver code"
C#;"using System ; class GFG { static bool divisorsSame ( int n ) { int even_div = 0 , odd_div = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) { if ( i % 2 == 0 ) { even_div ++ ; } else { odd_div ++ ; } } else { if ( i % 2 == 0 ) { even_div ++ ; } else { odd_div ++ ; } if ( n / i % 2 == 0 ) { even_div ++ ; } else { odd_div ++ ; } } } } return ( even_div == odd_div ) ; } public static void Main ( ) { int N = 6 ; if ( divisorsSame ( N ) ) { Console . Write ( "" Yes "" ) ; } else { Console . Write ( "" No "" ) ; } } }";"Check if count of even divisors of N is equal to count of odd divisors | C # code for the above program ; Function to check if count of even and odd divisors are equal ; To store the count of even factors and odd factors ; Loop till [ 1 , sqrt ( N ) ] ; If divisors are equal add only one ; Check for even divisor ; Odd divisor ; Check for both divisor i . e . , i and N / i ; Check if i is odd or even ; Check if N / i is odd or even ; Return true if count of even_div and odd_div are equals ; Driver code ; Given number ; Function call"
C#;"using System ; class GFG { static bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static bool isBalancedPrime ( int n ) { if ( ! isPrime ( n ) n == 2 ) return false ; int previous_prime = n - 1 ; int next_prime = n + 1 ; while ( ! isPrime ( next_prime ) ) next_prime ++ ; while ( ! isPrime ( previous_prime ) ) previous_prime -- ; int mean = ( previous_prime + next_prime ) / 2 ; if ( n == mean ) return true ; else return false ; } public static void Main ( ) { int n = 53 ; if ( isBalancedPrime ( n ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Check if N is a Balanced Prime number or not | C # program to check if a given number is Balanced prime ; Utility function to check if a number is prime or not ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function that returns true if n is a Balanced prime ; If n is not a prime number or n is the first prime then return false ; Initialize previous_prime to n - 1 and next_prime to n + 1 ; Find next prime number ; Find previous prime number ; Arithmetic mean ; If n is a weak prime ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { static readonly int N = 100001 ; static List < int > [ ] adj = new List < int > [ N ] ; static int [ ] a = new int [ N ] ; static int [ ] ans = new int [ N ] ; static bool hasOddNumberOfDivisors ( int n ) { if ( ( double ) Math . Sqrt ( n ) == ( int ) Math . Sqrt ( n ) ) return true ; return false ; } static int dfs ( int node , int parent ) { int count = 0 ; foreach ( int i in adj [ node ] ) { if ( i != parent ) { count += dfs ( i , node ) ; } } if ( hasOddNumberOfDivisors ( a [ node ] ) ) ++ count ; ans [ node ] = count ; return count ; } public static void Main ( String [ ] args ) { int n = 5 ; int [ ] q = { 4 , 1 , 5 , 3 } ; for ( int i = 0 ; i < adj . Length ; i ++ ) adj [ i ] = new List < int > ( ) ; adj [ 1 ] . Add ( 2 ) ; adj [ 2 ] . Add ( 1 ) ; adj [ 2 ] . Add ( 3 ) ; adj [ 3 ] . Add ( 2 ) ; adj [ 3 ] . Add ( 4 ) ; adj [ 4 ] . Add ( 3 ) ; adj [ 1 ] . Add ( 5 ) ; adj [ 5 ] . Add ( 1 ) ; a [ 1 ] = 4 ; a [ 2 ] = 9 ; a [ 3 ] = 14 ; a [ 4 ] = 100 ; a [ 5 ] = 5 ; dfs ( 1 , - 1 ) ; for ( int i = 0 ; i < q . Length ; i ++ ) { Console . Write ( ans [ q [ i ] ] + "" ▁ "" ) ; } } }";"Count of nodes having odd divisors in the given subtree for Q queries | C # implementation to count the number of nodes having odd number of divisors for each query ; Adjacency list for tree . ; Array for values and answer at ith node . ; Function to check whether N has odd divisors or not ; DFS function to pre - compute the answers ; Initialize the count ; Repeat for every child ; Increase the count if current node has odd number of divisors ; Driver Code ; Adjacency List ; Function call"
C#;"using System ; class GFG { public static int lowerBound ( int [ ] array , int length , int value ) { int low = 0 ; int high = length ; while ( low < high ) { int mid = ( low + high ) / 2 ; if ( value <= array [ mid ] ) { high = mid ; } else { low = mid + 1 ; } } return low ; } public static int costCalculation ( int current , int [ ] arr , int n , int [ ] pref , int a , int r , int minimum ) { int index = lowerBound ( arr , arr . Length , current ) ; int left = index * current - pref [ index ] ; int right = pref [ n ] - pref [ index ] - ( n - index ) * current ; int res = Math . Min ( left , right ) ; left -= res ; right -= res ; int total = res * minimum ; total += left * a ; total += right * r ; return total ; } public static void solve ( int [ ] arr , int n , int a , int r , int m ) { Array . Sort ( arr ) ; int minimum = Math . Min ( a + r , m ) ; int [ ] pref = new int [ n + 1 ] ; Array . Fill ( pref , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) pref [ i + 1 ] = pref [ i ] + arr [ i ] ; int ans = 10000 ; for ( int i = 0 ; i < n ; i ++ ) ans = Math . Min ( ans , costCalculation ( arr [ i ] , arr , n , pref , a , r , minimum ) ) ; ans = Math . Min ( ans , costCalculation ( pref [ n ] / n , arr , n , pref , a , r , minimum ) ) ; ans = Math . Min ( ans , costCalculation ( pref [ n ] / n + 1 , arr , n , pref , a , r , minimum ) ) ; Console . WriteLine ( ans ) ; } public static void Main ( string [ ] args ) { int [ ] arr = { 5 , 5 , 3 , 6 , 5 } ; int A = 1 , R = 2 , M = 4 ; int size = arr . Length ; solve ( arr , size , A , R , M ) ; } }";"Minimum Cost to make all array elements equal using given operations | C # implementation to find the minimum cost to make all array elements equal ; Checks if the value is less than middle element of the array ; Function that returns the cost of making all elements equal to current element ; Compute the lower bound of current element ; Calculate the requirement of add operation ; Calculate the requirement of subtract operation ; Compute minimum of left and right ; Computing the total cost of add and subtract operations ; Function that prints minimum cost of making all elements equal ; Sort the given array ; Calculate minimum from a + r and m ; Compute prefix sum and store in pref array ; Find the minimum cost from the given elements ; Finding the minimum cost from the other cases where minimum cost can occur ; Printing the minimum cost of making all elements equal ; Driver Code ; Function Call"
C#;"using System ; class GFG { static int countBinaries ( int N ) { int ctr = 1 ; int ans = 0 ; while ( N > 0 ) { if ( N % 10 == 1 ) { ans += ( int ) Math . Pow ( 2 , ctr - 1 ) ; } else if ( N % 10 > 1 ) { ans = ( int ) ( Math . Pow ( 2 , ctr ) - 1 ) ; } ctr ++ ; N /= 10 ; } return ans ; } public static void Main ( String [ ] args ) { int N = 20 ; Console . Write ( countBinaries ( N ) ) ; } }";"Count of integers up to N which represent a Binary number | C # program to count the number of integers upto N which are of the form of binary representations ; Function to return the count ; If the current last digit is 1 ; Add 2 ^ ( ctr - 1 ) possible integers to the answer ; If the current digit exceeds 1 ; Set answer as 2 ^ ctr - 1 as all possible binary integers with ctr number of digits can be obtained ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { static int countBinaries ( int N ) { List < int > powersOfTwo = new List < int > ( ) ; powersOfTwo . Add ( 1 ) ; for ( int i = 1 ; i < 11 ; i ++ ) { powersOfTwo . Add ( powersOfTwo [ i - 1 ] * 2 ) ; } int ctr = 1 ; int ans = 0 ; while ( N > 0 ) { if ( N % 10 == 1 ) { ans += powersOfTwo [ ctr - 1 ] ; } else if ( N % 10 > 1 ) { ans = powersOfTwo [ ctr ] - 1 ; } ctr ++ ; N /= 10 ; } return ans ; } static public void Main ( ) { int N = 20 ; Console . Write ( countBinaries ( N ) ) ; } }";"Count of integers up to N which represent a Binary number | C # program to count the number of integers upto N which are of the form of binary representations ; Function to return the count ; PreCompute and store the powers of 2 ; If the current last digit is 1 ; Add 2 ^ ( ctr - 1 ) possible integers to the answer ; If the current digit exceeds 1 ; Set answer as 2 ^ ctr - 1 as all possible binary integers with ctr number of digits can be obtained ; Driver Code"
C#;"using System ; class GFG { public static int Centered_Hexadecagonal_num ( int n ) { return ( 8 * n * n - 8 * n + 1 ) ; } public static int sum_Centered_Hexadecagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Hexadecagonal_num ( i ) ; } return summ ; } public static void Main ( ) { int n = 5 ; Console . Write ( sum_Centered_Hexadecagonal_num ( n ) ) ; } }";"Find the sum of the first Nth Centered Hexadecagonal Number | C # program to find the sum of the first N centred hexadecagonal numbers ; Centered_Hexadecagonal number function ; Formula to calculate nth Centered_Hexadecagonal number & return it into main function . ; Function to find the sum of the first N centered hexadecagonal number ; Variable to store the sum ; Loop to iterate through the first N numbers ; Finding the sum ; Driver Code ; Display first Nth Centered_Hexadecagonal number"
C#;"using System ; class GFG { public static int center_heptagonal_num ( int n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; } public static int sum_center_heptagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += center_heptagonal_num ( i ) ; } return summ ; } public static void Main ( ) { int n = 5 ; Console . Write ( sum_center_heptagonal_num ( n ) ) ; } }";"Find the sum of the first N Centered heptagonal number | C # program to find the sum of the first N centered heptagonal numbers ; Function to find the N - th centered heptagonal number ; Formula to calculate nth centered heptagonal number ; Function to find the sum of the first N centered heptagonal numbers ; Variable to store the sum ; Iterating through the range 1 to N ; Driver Code"
C#;"using System ; class GFG { static int Centered_Dodecagonal_num ( int n ) { return 6 * n * ( n - 1 ) + 1 ; } static int sum_Centered_Dodecagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Dodecagonal_num ( i ) ; } return summ ; } public static void Main ( ) { int n = 5 ; Console . Write ( sum_Centered_Dodecagonal_num ( n ) ) ; } }";"Find the sum of the first N Centered Dodecagonal Number | C # program to find the sum of the first N centred dodecagonal number ; Function to find the N - th centered dodecagonal number ; Formula to calculate nth Centered_Dodecagonal number ; Function to find the sum of the first N Centered_Dodecagonal number ; Variable to store the sum ; Iterating from 1 to N ; Finding the sum ; Driver code"
C#;"using System ; class GFG { static int center_Octagonal_num ( int n ) { return ( 4 * n * n - 4 * n + 1 ) ; } static int sum_center_Octagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += center_Octagonal_num ( i ) ; } return summ ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( sum_center_Octagonal_num ( n ) ) ; } }";"Find the sum of the first N Centered Octagonal Number | C # program to find the sum of the first N centered octagonal number ; Function to find N - th centered octagonal number ; Formula to calculate nth centered octagonal number ; Function to find the sum of the first N centered octagonal numbers ; Variable to store the sum ; Iterating through the first N numbers ; Driver code"
C#;"using System ; class GFG { static int Centered_decagonal_num ( int n ) { return ( 5 * n * n - 5 * n + 1 ) ; } static int sum_Centered_decagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_decagonal_num ( i ) ; } return summ ; } public static void Main ( String [ ] args ) { int n = 5 ; Console . WriteLine ( sum_Centered_decagonal_num ( n ) ) ; } }";"Find the sum of the first N Centered Decagonal Numbers | C # program to find the sum of the first N centred decagonal number ; Function to find the N - th centred decagonal number ; Formula to calculate nth centered_decagonal number & return it into main function . ; Function to find the sum of the first N centered decagonal numbers ; Variable to store the sum ; Iterating through the range ; Driver code ; Display first Nth centered_decagonal number"
C#;"using System ; class GFG { static int center_octadecagon_num ( int n ) { return ( 9 * n * n - 9 * n + 1 ) ; } static int sum_center_octadecagon_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += center_octadecagon_num ( i ) ; } return summ ; } public static void Main ( String [ ] args ) { int n = 3 ; Console . WriteLine ( sum_center_octadecagon_num ( n ) ) ; } }";"Find the sum of the first N Centered Octadecagonal Numbers | C # program to find the sum of the first N centered octadecagonal numbers ; Function to find the N - th centered octadecagonal number ; Formula to calculate nth centered octadecagonal number ; Function to find the sum of the first N centered octadecagonal numbers ; Variable to store the sum ; Iterating through the range 1 to N ; Driver Code"
C#;"using System ; class GFG { static int Centered_Pentadecagonal_num ( int n ) { return ( 15 * n * n - 15 * n + 2 ) / 2 ; } static int sum_Centered_Pentadecagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Pentadecagonal_num ( i ) ; } return summ ; } public static void Main ( String [ ] args ) { int n = 5 ; Console . WriteLine ( sum_Centered_Pentadecagonal_num ( n ) ) ; } }";"Find the sum of the first Nth Centered Pentadecagonal Number | C # program to find the sum of the first N centered pentadecagonal number ; Function to find the centered pentadecagonal number ; Formula to calculate N - th centered pentadecagonal number ; Function to find the sum of the first N centered pentadecagonal numbers ; Variable to store the sum ; Driver Code"
C#;"using System ; class GFG { public static bool isoctagonal ( int N ) { double n = ( 2 + Math . Sqrt ( 12 * N + 4 ) ) / 6 ; return ( n - ( int ) n ) == 0 ; } public static void Main ( String [ ] args ) { int N = 8 ; if ( isoctagonal ( N ) ) { Console . WriteLine ( "" Yes "" ) ; } else { Console . WriteLine ( "" No "" ) ; } } }";"Program to check if N is a Octagonal Number | C # program for the above approach ; Function to check if N is a octagonal number ; Condition to check if the number is a octagonal number ; Driver code ; Given number ; Function call"
C#;"using System ; class GFG { public static bool isPentadecagon ( int N ) { double n = ( 11 + Math . Sqrt ( 104 * N + 121 ) ) / 26 ; return ( n - ( int ) n ) == 0 ; } public static void Main ( String [ ] args ) { int N = 15 ; if ( isPentadecagon ( N ) ) { Console . WriteLine ( "" Yes "" ) ; } else { Console . WriteLine ( "" No "" ) ; } } }";"Program to check if N is a Pentadecagonal Number | C # program for the above approach ; Function to check if N is a pentadecagon number ; Condition to check if the number is a pentadecagon number ; Driver code ; Given Number ; Function call"
C#;"using System ; class GFG { public static bool istetradecagonal ( int N ) { double n = ( 10 + Math . Sqrt ( 96 * N + 100 ) ) / 24 ; return ( n - ( int ) n ) == 0 ; } static public void Main ( ) { int N = 11 ; if ( istetradecagonal ( N ) ) { Console . Write ( "" Yes "" ) ; } else { Console . Write ( "" No "" ) ; } } }";"Program to check if N is a Tetradecagonal Number | C # program for the above approach ; Function to check if N is a tetradecagonal number ; Condition to check if the number is a tetradecagonal number ; Driver Code ; Given number ; Function call"
C#;"using System ; class GFG { public static int Icosagonal_num ( int n ) { return ( 18 * n * n - 16 * n ) / 2 ; } public static int sum_Icosagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { summ += Icosagonal_num ( i ) ; } return summ ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( sum_Icosagonal_num ( n ) ) ; } }";"Find the sum of the first Nth Icosagonal Numbers | C # program to find the sum of the first N icosagonal number ; Function to calculate the N - th icosagonal number ; Formula to calculate nth icosagonal number & return it ; Function to find the sum of the first N icosagonal numbers ; Variable to store the sum ; Loop to iterate through the first N values and find the sum of first N icosagonal numbers ; Function to get the Icosagonal_num ; Driver code ; Display the sum of first N icosagonal number"
C#;"using System ; class GFG { static int Centered_Pentagonal_num ( int n ) { return ( 5 * n * n - 5 * n + 2 ) / 2 ; } static int sum_Centered_Pentagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Pentagonal_num ( i ) ; } return summ ; } public static void Main ( String [ ] args ) { int n = 5 ; Console . Write ( ( sum_Centered_Pentagonal_num ( n ) ) ) ; } }";"Find the sum of the first N Centered Pentagonal Number | C # program to find the sum of the first N centered pentagonal numbers ; Function to find the Centered_Pentagonal number ; Formula to calculate nth Centered_Pentagonal number & return it into main function . ; Function to find the sum of the first N Centered_Pentagonal numbers ; To get the sum ; Iterating through the range 1 to N ; Driver code ; Display first Nth Centered_Pentagonal number"
C#;"using System ; class GFG { public static int Centered_tridecagonal_num ( int n ) { return ( 13 * n * ( n - 1 ) + 2 ) / 2 ; } public static int sum_Centered_tridecagonal_num ( int n ) { int summ = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { summ += Centered_tridecagonal_num ( i ) ; } return summ ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( sum_Centered_tridecagonal_num ( n ) ) ; } }";"Find the sum of the first Nth Centered Tridecagonal Numbers | C # program to find the sum of the first Nth centered tridecagonal number ; Function to calculate the N - th centered tridecagonal number ; Formula to calculate Nth centered tridecagonal number & return it ; Function to find the sum of the first N centered tridecagonal numbers ; Variable to store the sum ; Loop to iterate and find the sum of first N centered tridecagonal numbers ; Driver code"
C#;"using System ; class GFG { static bool isConcentrichexagonal ( int N ) { float n = ( float ) Math . Sqrt ( ( 2 * N ) / 3 ) ; return ( n - ( int ) n ) == 0 ; } public static void Main ( ) { int N = 6 ; if ( isConcentrichexagonal ( N ) ) { Console . Write ( "" Yes "" ) ; } else { Console . Write ( "" No "" ) ; } } }";"Program to check if N is a Concentric Hexagonal Number | C # program to check if N is a concentric hexagonal number ; Function to check if the number is a concentric hexagonal number ; Condition to check if the number is a concentric hexagonal number ; Driver Code ; Function call"
C#;"using System ; using System . Linq ; class GFG { static bool [ ] Prime ; static void computePrime ( int N ) { Prime = new bool [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) { Prime [ i ] = true ; } Prime [ 0 ] = Prime [ 1 ] = false ; for ( int i = 2 ; i * i <= N ; i ++ ) { if ( Prime [ i ] ) { for ( int j = i * i ; j < N ; j += i ) { Prime [ j ] = false ; } } } } static int countSexyPairs ( int [ ] arr , int n ) { int maxE = arr . Max ( ) ; computePrime ( maxE ) ; int count = 0 ; int [ ] freq = new int [ maxE + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } Array . Sort ( arr ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( Prime [ arr [ i ] ] ) { if ( arr [ i ] + 6 < freq . Length && freq [ arr [ i ] + 6 ] > 0 && Prime [ arr [ i ] + 6 ] ) { count ++ ; } } } return count ; } public static void Main ( String [ ] args ) { int [ ] arr = { 6 , 7 , 5 , 11 , 13 } ; int n = arr . Length ; Console . Write ( countSexyPairs ( arr , n ) ) ; } }";"Count Sexy Prime Pairs in the given array | C # program to count Sexy Prime pairs in array ; To store check the prime number ; A utility function that find the Prime Numbers till N ; Resize the Prime Number ; Loop till Math . Sqrt ( N ) to find prime numbers and make their multiple false in the bool array Prime ; Function that returns the count of SPP ( Sexy Prime Pair ) Pairs ; Find the maximum element in the given array [ ] arr ; Function to calculate the prime numbers till N ; To store the count of pairs ; To store the frequency of element in the array [ ] arr ; Sort before traversing the array ; Traverse the array and find the pairs with SPP ( Sexy Prime Pair ) s ; If current element is Prime , then check for ( current element + 6 ) ; Return the count of pairs ; Driver code ; Function call to find SPP ( Sexy Prime Pair ) s pair"
C#;"using System ; class GFG { static void countWays ( int n ) { if ( n <= 2 ) { Console . WriteLine ( "" - 1"" ) ; } else { int ans = ( n - 1 ) * ( n - 2 ) / 2 ; Console . WriteLine ( ans ) ; } } static void Main ( ) { int N = 5 ; countWays ( N ) ; } }";"Count of ways to write N as a sum of three numbers | C # program to count the total number of ways to write N as a sum of three numbers ; Function to find the number of ways ; Check if number is less than 2 ; Calculate the sum ; Driver code"
C#;"using System ; class GFG { public static bool isPowerOfTwo ( int n ) { return ( Math . Ceiling ( Math . Log ( n ) / Math . Log ( 2 ) ) == Math . Floor ( Math . Log ( n ) / Math . Log ( 2 ) ) ) ; } public static void Main ( String [ ] args ) { int N = 8 ; if ( isPowerOfTwo ( N ) ) { Console . WriteLine ( "" Yes "" ) ; } else { Console . WriteLine ( "" No "" ) ; } } }";"Logarithm tricks for Competitive Programming | C # implementation to check that a integer is a power of Two ; Function to check if the number is a power of two ; Driver Code"
C#;"using System ; class GFG { static int count_pairs ( int x ) { int ans = 1 ; while ( x > 0 ) { if ( x % 2 == 1 ) ans = ans * 3 ; x = x / 2 ; } return ans ; } public static void Main ( String [ ] args ) { int X = 6 ; Console . Write ( count_pairs ( X ) + "" STRNEWLINE "" ) ; } }";"Count of pairs having bit size at most X and Bitwise OR equal to X | C # implementation to count number of possible pairs of ( a , b ) such that their Bitwise OR gives the value X ; Function to count the pairs ; Initializing answer with 1 ; Iterating through bits of x ; Check if bit is 1 ; Multiplying ans by 3 if bit is 1 ; Driver code"
C#;"using System ; class GFG { static void kthNonDivisible ( int N , int K ) { int L = 1 ; int H = Int32 . MaxValue ; int ans = 0 ; while ( L <= H ) { int mid = ( L + H ) / 2 ; int sol = mid - mid / N ; if ( sol > K ) { H = mid - 1 ; } else if ( sol < K ) { L = mid + 1 ; } else { ans = mid ; H = mid - 1 ; } } Console . Write ( ans ) ; } static void Main ( ) { int N = 3 ; int K = 7 ; kthNonDivisible ( N , K ) ; } }";"Find the Kth number which is not divisible by N | C # implementation for above approach ; Function to find the Kth not divisible by N ; Lowest possible value ; Highest possible value ; To store the Kth non divisible number of N ; Using binary search ; Calculating mid value ; Sol would have the value by subtracting all multiples of n till mid ; Check if sol is greater than k ; H should be reduced to find minimum possible value ; Check if sol is less than k then L will be mid + 1 ; Check if sol is equal to k ; ans will be mid ; H would be reduced to find any more possible value ; Print the answer ; Driver code ; Function Call"
C#;"using System ; public class GFG { static void printPair ( int n ) { Console . Write ( 1 + "" ▁ "" + ( n - 1 ) ) ; } public static void Main ( String [ ] args ) { int n = 14 ; printPair ( n ) ; } }";"Print any pair of integers with sum of GCD and LCM equals to N | C # implementation to print any pair of integers whose summation of GCD and LCM is equal to integer N ; Function to print the required pair ; Print the pair ; Driver code"
C#;"using System ; class GFG { static bool isAutoBiographyNum ( int number ) { int count = 0 , position , size , digit ; string NUM ; NUM = number . ToString ( ) ; size = NUM . Length ; for ( int i = 0 ; i < size ; i ++ ) { position = NUM [ i ] - '0' ; count = 0 ; for ( int j = 0 ; j < size ; j ++ ) { digit = NUM [ j ] - '0' ; if ( digit == i ) count ++ ; } if ( position != count ) return false ; } return true ; } static int checkArray ( int [ ] arr , int n ) { int current_length = 0 ; int max_length = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isAutoBiographyNum ( arr [ i ] ) == true ) { current_length ++ ; } else { current_length = 0 ; } max_length = Math . Max ( max_length , current_length ) ; } return max_length ; } public static void Main ( string [ ] args ) { int [ ] arr = { 21200 , 1 , 1303 , 1210 , 2020 } ; int n = arr . Length ; Console . WriteLine ( checkArray ( arr , n ) ) ; } }";"Find the length of largest subarray in which all elements are Autobiographical Numbers | C # program to find the length of the largest subarray whose every element is an autobiographical number ; Function to check number is autobiographical ; Convert integer to string ; Iterate for every digit to check for their total count ; Check occurrence of every number and count them ; Check if any position mismatches with total count them return with false else continue with loop ; Function to return the length of the largest subarray whose every element is a autobiographical number ; Utility function which checks every element of array for autobiographical number ; Check if element arr [ i ] is an autobiographical number ; Increment the current length ; Update max_length value ; Return the final result ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { public class pair { public int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } static void sumOfSquares ( int n , List < pair > vp ) { for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { int h = n - i * i , h1 = ( int ) Math . Sqrt ( h ) ; if ( h1 * h1 == h ) { int a = Math . Max ( h1 , i ) , b = Math . Min ( h1 , i ) ; if ( vp . Count == 1 && a != vp [ 0 ] . first ) vp . Add ( new pair ( a , b ) ) ; if ( vp . Count == 0 ) vp . Add ( new pair ( a , b ) ) ; if ( vp . Count == 2 ) return ; } } } static void findFactors ( int n ) { List < pair > vp = new List < pair > ( ) ; sumOfSquares ( n , vp ) ; if ( vp . Count != 2 ) Console . Write ( "" Factors ▁ Not ▁ Possible "" ) ; int a , b , c , d ; a = vp [ 0 ] . first ; b = vp [ 0 ] . second ; c = vp [ 1 ] . first ; d = vp [ 1 ] . second ; if ( a < c ) { int t = a ; a = c ; c = t ; t = b ; b = d ; d = t ; } int k , h , l , m ; k = __gcd ( a - c , d - b ) ; h = __gcd ( a + c , d + b ) ; l = ( a - c ) / k ; m = ( d - b ) / k ; Console . Write ( "" a ▁ = ▁ "" + a + "" TABSYMBOL TABSYMBOL ( A ) ▁ a ▁ - ▁ c ▁ = ▁ "" + ( a - c ) + "" TABSYMBOL TABSYMBOL k ▁ = ▁ gcd [ A , ▁ C ] ▁ = ▁ "" + k + "" STRNEWLINE "" ) ; Console . Write ( "" b ▁ = ▁ "" + b + "" TABSYMBOL TABSYMBOL ( B ) ▁ a ▁ + ▁ c ▁ = ▁ "" + ( a + c ) + "" TABSYMBOL TABSYMBOL h ▁ = ▁ gcd [ B , ▁ D ] ▁ = ▁ "" + h + "" STRNEWLINE "" ) ; Console . Write ( "" c ▁ = ▁ "" + c + "" TABSYMBOL TABSYMBOL ( C ) ▁ d ▁ - ▁ b ▁ = ▁ "" + ( d - b ) + "" TABSYMBOL TABSYMBOL l ▁ = ▁ A / k ▁ = ▁ "" + l + "" STRNEWLINE "" ) ; Console . Write ( "" d ▁ = ▁ "" + d + "" TABSYMBOL TABSYMBOL ( D ) ▁ d ▁ + ▁ b ▁ = ▁ "" + ( d + b ) + "" TABSYMBOL TABSYMBOL m ▁ = ▁ c / k ▁ = ▁ "" + m + "" STRNEWLINE "" ) ; if ( k % 2 == 0 && h % 2 == 0 ) { k = k / 2 ; h = h / 2 ; Console . Write ( "" Factors ▁ are : ▁ "" + ( ( k ) * ( k ) + ( h ) * ( h ) ) + "" ▁ "" + ( l * l + m * m ) + "" STRNEWLINE "" ) ; } else { l = l / 2 ; m = m / 2 ; Console . Write ( "" Factors ▁ are : ▁ "" + ( ( l ) * ( l ) + ( m ) * ( m ) ) + "" ▁ "" + ( k * k + h * h ) + "" STRNEWLINE "" ) ; } } public static void Main ( String [ ] args ) { int n = 100000 ; findFactors ( n ) ; } }";"Euler 's Factorization method | C # program to implement Eulers Factorization algorithm ;  ; Recursive function to return gcd of a and b ; Function to return N as the sum of two squares in two possible ways ; Iterate a loop from 1 to Math . Sqrt ( n ) ; If i * i is square check if there exists another integer such that h is a perfect square and i * i + h = n ; If h is perfect square ; Store in the sorted way ; If there is already a pair check if pairs are equal or not ; Insert the first pair ; If two pairs are found ; Function to find the factors ; Get pairs where a ^ 2 + b ^ 2 = n ; Number cannot be represented as sum of squares in two ways ; Assign a , b , c , d ; Swap if a < c because if a - c < 0 , GCD cant be computed . ; Compute the values of k , h , l , m using the formula mentioned in the approach ; Print the values of a , b , c , d and k , l , m , h ; Printing the factors ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { static readonly int MAX = 100000 ; static List < int > [ ] graph = new List < int > [ MAX + 1 ] ; static bool [ ] Prime = new bool [ MAX + 1 ] ; static int [ ] height = new int [ MAX + 1 ] ; static void SieveOfEratosthenes ( ) { int i , j ; Prime [ 0 ] = Prime [ 1 ] = false ; for ( i = 2 ; i * i <= MAX ; i ++ ) { if ( Prime [ i ] ) { for ( j = 2 * i ; j < MAX ; j += i ) { Prime [ j ] = false ; } } } } static void dfs ( int node , int parent , int h ) { height [ node ] = h ; foreach ( int to in graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node , h + 1 ) ; } } static void primeHeightNode ( int N ) { SieveOfEratosthenes ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( Prime [ height [ i ] ] ) { Console . Write ( i + "" ▁ "" ) ; } } } public static void Main ( String [ ] args ) { int N = 5 ; for ( int i = 0 ; i < Prime . Length ; i ++ ) Prime [ i ] = true ; for ( int i = 0 ; i < graph . Length ; i ++ ) graph [ i ] = new List < int > ( ) ; graph [ 1 ] . Add ( 2 ) ; graph [ 1 ] . Add ( 3 ) ; graph [ 2 ] . Add ( 4 ) ; graph [ 2 ] . Add ( 5 ) ; dfs ( 1 , 1 , 0 ) ; primeHeightNode ( N ) ; } }";"Print the nodes of the Binary Tree whose height is a Prime number | C # implementation of nodes at prime height in the given tree ; To store Prime Numbers ; To store height of each node ; Function to find the prime numbers till 10 ^ 5 ; Traverse all multiple of i and make it false ; Function to perform dfs ; Store the height of node ; Function to find the nodes at prime height ; To precompute prime number till 10 ^ 5 ; Check if height [ node ] is prime ; Driver code ; Number of nodes ; Edges of the tree"
C#;"using System ; class GFG { public static int reverse ( int a ) { int rev = 0 ; while ( a != 0 ) { int r = a % 10 ; rev = rev * 10 + r ; a = a / 10 ; } return ( rev ) ; } public static int prime ( int a ) { int k = 0 ; for ( int i = 2 ; i < a ; i ++ ) { if ( a % i == 0 ) { k = 1 ; break ; } } if ( k == 1 ) { return ( 0 ) ; } else { return ( 1 ) ; } } public static int adam ( int a ) { int r1 = reverse ( a ) ; int s1 = a * a ; int s2 = r1 * r1 ; int r2 = reverse ( s2 ) ; if ( s1 == r2 ) { return ( 1 ) ; } else { return ( 0 ) ; } } public static void find ( int m , int n ) { if ( m > n ) { Console . WriteLine ( "" INVALID ▁ INPUT "" ) ; } else { for ( int i = m ; i <= n ; i ++ ) { int l = prime ( i ) ; int k = adam ( i ) ; if ( ( l == 1 ) && ( k == 1 ) ) { Console . Write ( i + "" TABSYMBOL "" ) ; } } } } public static void Main ( String [ ] args ) { int L = 5 , R = 100 ; find ( L , R ) ; } }";"Find Prime Adam integers in the given range [ L , R ] | C # program to find all prime adam numbers in the given range ; Reversing a number by taking remainder at a time ; Function to check if a number is a prime or not ; Iterating till the number ; Checking for factors ; Returning 1 if the there are no factors of the number other than 1 or itself ; Function to check whether a number is an adam number or not ; Reversing given number ; Squaring given number ; Squaring reversed number ; Reversing the square of the reversed number ; Checking if the square of the number and the square of its reverse are equal or not ; Function to find all the prime adam numbers in the given range ; If the first number is greater than the second number , print invalid ; Iterating through all the numbers in the given range ; Checking for prime number ; Checking for Adam number ; Driver code"
C#;"using System ; class GFG { static int sumDig ( int n ) { int s = 0 ; while ( n != 0 ) { s = s + ( n % 10 ) ; n = n / 10 ; } return s ; } static bool Pec ( int n ) { int dup = n ; int dig = sumDig ( n ) ; if ( dig * 3 == dup ) return true ; else return false ; } public static void Main ( ) { int n = 36 ; if ( Pec ( n ) == true ) Console . Write ( "" Yes "" ) ; else Console . Write ( "" No "" ) ; } }";"Determine whether the given integer N is a Peculiar Number or not | C # implementation to check if the number is peculiar ; Function to find sum of digits of a number ; Function to check if the number is peculiar ; Store a duplicate of n ; Driver code"
C#;"using System ; class GFG { static int digit_sum ( int n ) { int sum = 0 , m ; while ( n > 0 ) { m = n % 10 ; sum = sum + m ; n = n / 10 ; } return ( sum ) ; } static int reverse ( int n ) { int r = 0 ; while ( n != 0 ) { r = r * 10 ; r = r + n % 10 ; n = n / 10 ; } return ( r ) ; } static void operation ( int n ) { int i = 1 , a , count = 0 , r ; while ( count < n ) { a = digit_sum ( i ) ; r = reverse ( i ) ; if ( i % a == 0 && r % a == 0 ) { Console . Write ( i + "" ▁ "" ) ; count ++ ; i ++ ; } else i ++ ; } } public static void Main ( ) { int n = 10 ; operation ( n ) ; } }";"Find N numbers such that a number and its reverse are divisible by sum of its digits | C # program to print the first N numbers such that every number and the reverse of the number is divisible by its sum of digits ; Function to calculate the sum of digits ; Loop to iterate through every digit of the number ; Returning the sum of digits ; Function to calculate the reverse of a number ; Loop to calculate the reverse of the number ; Return the reverse of the number ; Function to print the first N numbers such that every number and the reverse of the number is divisible by its sum of digits ; Loop to continuously check and generate number until there are n outputs ; Variable to hold the sum of the digit of the number ; Computing the reverse of the number ; Checking if the condition satisfies . Increment the count and print the number if it satisfies . ; Driver code"
C#;"using System ; class GFG { static void createSets ( int N ) { if ( N <= 2 ) { Console . WriteLine ( "" - 1"" ) ; return ; } for ( int i = 2 ; i <= N ; i += 2 ) Console . Write ( i + "" ▁ "" ) ; Console . Write ( "" STRNEWLINE "" ) ; for ( int i = 1 ; i <= N ; i += 2 ) { Console . Write ( i + "" ▁ "" ) ; } } public static void Main ( String [ ] args ) { int N = 6 ; createSets ( N ) ; } }";"Split N natural numbers into two sets having GCD of their sums greater than 1 | C # program to split N natural numbers into two sets having GCD of their sums greater than 1 ; Function to create and print the two sets ; No such split possible for N <= 2 ; Print the first set consisting of even elements ; Print the second set consisting of odd ones ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { static int ans = 0 ; static List < int > [ ] graph = new List < int > [ 100 ] ; static int [ ] weight = new int [ 100 ] ; static bool isPowerful ( int n ) { while ( n % 2 == 0 ) { int power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( int factor = 3 ; factor <= Math . Sqrt ( n ) ; factor += 2 ) { int power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; } static void dfs ( int node , int parent ) { if ( isPowerful ( weight [ node ] ) ) ans += 1 ; foreach ( int to in graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node ) ; } } public static void Main ( String [ ] args ) { for ( int i = 0 ; i < graph . Length ; i ++ ) graph [ i ] = new List < int > ( ) ; weight [ 1 ] = 5 ; weight [ 2 ] = 10 ; weight [ 3 ] = 11 ; weight [ 4 ] = 8 ; weight [ 5 ] = 6 ; graph [ 1 ] . Add ( 2 ) ; graph [ 2 ] . Add ( 3 ) ; graph [ 2 ] . Add ( 4 ) ; graph [ 1 ] . Add ( 5 ) ; dfs ( 1 , 1 ) ; Console . Write ( ans ) ; } }";"Count the nodes in the given tree whose weight is a powerful number | C # implementation to count the nodes in thegiven tree whose weight is a powerful number ; Function to check if the number is powerful ; First divide the number repeatedly by 2 ; Check if only 2 ^ 1 divides n , then return false ; Check if n is not a power of 2 then this loop will execute ; Find highest power of "" factor "" that divides n ; Check if only factor ^ 1 divides n , then return false ; n must be 1 now if it is not a prime number . Since prime numbers are not powerful , we return false if n is not 1. ; Function to perform dfs ; Check if weight of the current node is a powerful number ; Driver code ; Weights of the node ; Edges of the tree"
C#;"using System ; class GFG { static int CountWays ( int N , int M ) { int count = 1 ; count = ( int ) Math . Pow ( 3 , M + N ) ; count *= ( int ) Math . Pow ( 2 , M * N ) ; return count ; } static void Main ( ) { int N = 3 ; int M = 2 ; Console . Write ( CountWays ( N , M ) ) ; } }";"Number of ways to color boundary of each block of M * N table | C # program to count the number of ways to color boundary of each block of M * N table . ; Function to compute all way to fill the boundary of all sides of the unit square ; Count possible ways to fill all upper and left side of the rectangle M * N ; Count possible ways to fill all side of the all squares unit size ; Driver code ; Number of rows ; Number of columns"
C#;"using System ; using System . Collections . Generic ; class GFG { static void findNthNumber ( int N ) { int [ ] arr = new int [ N + 1 ] ; Queue < int > q = new Queue < int > ( ) ; for ( int i = 1 ; i <= 9 ; i ++ ) q . Enqueue ( i ) ; for ( int i = 1 ; i <= N ; i ++ ) { arr [ i ] = q . Peek ( ) ; q . Dequeue ( ) ; if ( arr [ i ] % 10 != 0 ) q . Enqueue ( arr [ i ] * 10 + arr [ i ] % 10 - 1 ) ; q . Enqueue ( arr [ i ] * 10 + arr [ i ] % 10 ) ; if ( arr [ i ] % 10 != 9 ) q . Enqueue ( arr [ i ] * 10 + arr [ i ] % 10 + 1 ) ; } Console . WriteLine ( arr [ N ] ) ; } public static void Main ( String [ ] args ) { int N = 21 ; findNthNumber ( N ) ; } }";"Nth positive number whose absolute difference of adjacent digits is at most 1 | C # program to find Nth number with absolute difference between all adjacent digits at most 1. ; Return Nth number with absolute difference between all adjacent digits at most 1. ; To store all such numbers ; Enqueue all integers from 1 to 9 in increasing order . ; Perform the operation N times so that we can get all such N numbers . ; Store the front element of queue , in array and pop it from queue . ; If the last digit of dequeued integer is not 0 , then enqueue the next such number . ; Enqueue the next such number ; If the last digit of dequeued integer is not 9 , then enqueue the next such number . ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { static void findUniqueElements ( int [ ] arr , int N , int K ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) s . Add ( arr [ i ] ) ; int arr_sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) arr_sum += arr [ i ] ; int set_sum = 0 ; foreach ( int i in s ) set_sum += i ; Console . WriteLine ( ( K * set_sum - arr_sum ) / ( K - 1 ) ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 } ; int N = arr . Length ; int K = 3 ; findUniqueElements ( arr , N , K ) ; } }";"Unique element in an array where all elements occur K times except one | Set 2 | C # program for the above approach ; Function that find the unique element in the array [ ] arr ; Store all unique element in set ; Sum of all element of the array ; Sum of element in the set ; Print the unique element using formula ; Driver code ; Function call"
C#;"using System ; class GFG { static void findEquation ( int a , int b , int c ) { int X = ( a + b + c ) ; int Y = ( a * b ) + ( b * c ) + ( c * a ) ; int Z = a * b * c ; Console . Write ( "" x ^ 3 ▁ - ▁ "" + X + "" x ^ 2 ▁ + ▁ "" + Y + "" x ▁ - ▁ "" + Z + "" ▁ = ▁ 0"" ) ; } public static void Main ( ) { int a = 5 , b = 2 , c = 3 ; findEquation ( a , b , c ) ; } }";"Form the Cubic equation from the given roots | C # program for the approach ; Function to find the cubic equation whose roots are a , b and c ; Find the value of coefficient ; Print the equation as per the above coefficients ; Driver Code ; Function Call"
C#;"using System ; class GFG { static double dydx ( double x , double y ) { return ( x - y ) / 2 ; } static double Gill ( double x0 , double y0 , double x , double h ) { int n = ( int ) ( ( x - x0 ) / h ) ; double k1 , k2 , k3 , k4 ; double y = y0 ; for ( int i = 1 ; i <= n ; i ++ ) { k1 = h * dydx ( x0 , y ) ; k2 = h * dydx ( x0 + 0.5 * h , y + 0.5 * k1 ) ; k3 = h * dydx ( x0 + 0.5 * h , y + 0.5 * ( - 1 + Math . Sqrt ( 2 ) ) * k1 + k2 * ( 1 - 0.5 * Math . Sqrt ( 2 ) ) ) ; k4 = h * dydx ( x0 + h , y - ( 0.5 * Math . Sqrt ( 2 ) ) * k2 + k3 * ( 1 + 0.5 * Math . Sqrt ( 2 ) ) ) ; y = y + ( 1.0 / 6 ) * ( k1 + ( 2 - Math . Sqrt ( 2 ) ) * k2 + ( 2 + Math . Sqrt ( 2 ) ) * k3 + k4 ) ; x0 = x0 + h ; } return y ; } public static void Main ( String [ ] args ) { double x0 = 0 , y = 3.0 , x = 5.0 , h = 0.2 ; Console . Write ( "" y ( x ) ▁ = ▁ { 0 : F6 } "" , Gill ( x0 , y , x , h ) ) ; } }";"Gill 's 4th Order Method to solve Differential Equations | C # program to implement Gill 's method ; A sample differential equation "" dy / dx ▁ = ▁ ( x ▁ - ▁ y ) /2"" ; Finds value of y for a given x using step size h and initial value y0 at x0 ; Count number of iterations using step size or height h ; Value of K_i ; Initial value of y ( 0 ) ; Iterate for number of iteration ; Value of K1 ; Value of K2 ; Value of K3 ; Value of K4 ; Find the next value of y ( n + 1 ) using y ( n ) and values of K in the above steps ; Update next value of x ; Return the final value of dy / dx ; Driver Code"
C#;"using System ; class GFG { static void PrintReverseOrder ( int N ) { for ( int i = N ; i > 0 ; i -- ) Console . Write ( i + "" ▁ "" ) ; } public static void Main ( String [ ] args ) { int N = 5 ; PrintReverseOrder ( N ) ; } }";"Program to print numbers from N to 1 in reverse order | C # program to print all numbers between 1 to N in reverse order ; Recursive function to print from N to 1 ; Driver code"
C#;"using System ; class GFG { static int findAns ( int a , int b , int n ) { int lcm = ( a * b ) / __gcd ( a , b ) ; int multiples = ( n / lcm ) + 1 ; int answer = Math . Max ( a , b ) * multiples ; int lastvalue = lcm * ( n / lcm ) + Math . Max ( a , b ) ; if ( lastvalue > n ) { answer = answer - ( lastvalue - n - 1 ) ; } return answer ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void Main ( String [ ] args ) { int a = 1 , b = 13 , n = 500 ; Console . Write ( findAns ( a , b , n ) + "" STRNEWLINE "" ) ; } }";"Find count of numbers from 0 to n which satisfies the given equation for a value K | C # implementation to find the total count of all the numbers from 0 to n which satisfies the given equation for a value K ; Function to find the values ; Calculate the LCM ; Calculate the multiples of lcm ; Find the values which satisfies the given condition ; Subtract the extra values ; Return the readonly result ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { static Double ArithmeticMean ( Double A , Double B ) { return ( A + B ) / 2 ; } static Double HarmonicMean ( Double A , Double B ) { return ( 2 * A * B ) / ( A + B ) ; } static void CheckArithmeticHarmonic ( Double [ ] arr , Double A , Double B , int N ) { Double AM = ArithmeticMean ( A , B ) ; Double HM = HarmonicMean ( A , B ) ; Dictionary < Double , int > Hash = new Dictionary < Double , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { Hash [ arr [ i ] ] = 1 ; } if ( Hash . ContainsKey ( A ) && Hash . ContainsKey ( B ) ) { if ( Hash . ContainsKey ( AM ) && Hash . ContainsKey ( HM ) ) { Console . Write ( "" GM ▁ = ▁ "" ) ; Console . Write ( Math . Round ( Math . Sqrt ( AM * HM ) , 2 ) ) ; } else { Console . WriteLine ( "" AM ▁ and ▁ HM ▁ not ▁ found "" ) ; } } else { Console . WriteLine ( "" numbers ▁ not ▁ found "" ) ; } } public static void Main ( ) { Double [ ] arr = { 1.0 , 2.0 , 2.5 , 3.0 , 4.0 , 4.5 , 5.0 , 6.0 } ; int N = ( arr . Length ) ; Double A = 3.0 ; Double B = 6.0 ; CheckArithmeticHarmonic ( arr , A , B , N ) ; } }";"Program to find if two numbers and their AM and HM are present in an array using STL | C # program to check if two numbers are present in an array then their AM and HM are also present . Finally , find the GM of the numbers ; Function to find the Arithmetic Mean of 2 numbers ; Function to find the Harmonic Mean of 2 numbers ; Following function checks and computes the desired results based on the means ; Calculate means ; Hash container ( Set ) to store elements HashMap < Double , int > Hash = new HashMap < Double , int > ( ) ; ; Insertion of array elements in the Set ; Conditionals to check if numbers are present in array by Hashing ; Conditionals to check if the AM and HM of the numbers are present in array ; If all conditions are satisfied , the Geometric Mean is calculated ; If numbers are found but the respective AM and HM are not found in the array ; If none of the conditions are satisfied ; Driver code"
C#;"using System ; class GFG { static void movesRequired ( int a , int b ) { int total_moves = a % b ; Console . Write ( total_moves ) ; } public static void Main ( String [ ] args ) { int A = 10 , B = 3 ; movesRequired ( A , B ) ; } }";"Minimum decrements to make integer A divisible by integer B | C # implementation to count total numbers moves to make integer A divisible by integer B ; Function that print number of moves required ; Calculate modulo ; Print the required answer ; Driver code ; Initialise A and B"
C#;"using System ; class GFG { static void PythagoreanTriplet ( int n ) { int flag = 0 ; for ( int a = 1 ; a < n ; a ++ ) { int b = ( n * n - 2 * n * a ) / ( 2 * n - 2 * a ) ; int c = n - a - b ; if ( a * a + b * b == c * c && b > 0 && c > 0 ) { Console . Write ( a + "" ▁ "" + b + "" ▁ "" + c ) ; flag = 1 ; break ; } } if ( flag == 0 ) { Console . Write ( "" - 1"" ) ; } return ; } public static void Main ( String [ ] args ) { int N = 12 ; PythagoreanTriplet ( N ) ; } }";"Pythagorean Triplet with given sum using single loop | C # program to find the Pythagorean Triplet with given sum ; Function to calculate the Pythagorean triplet in O ( n ) ; Iterate a from 1 to N - 1. ; Calculate value of b ; The value of c = n - a - b ; Driver code ; Function call"
C#;"using System ; class GFG { static bool check ( int X , int K ) { int prime , temp , sqr , i ; prime = 0 ; temp = X ; sqr = Convert . ToInt32 ( Math . Sqrt ( X ) ) ; for ( i = 2 ; i <= sqr ; i ++ ) { while ( temp % i == 0 ) { temp = temp / i ; prime ++ ; } } if ( temp > 2 ) prime ++ ; if ( X == 1 ) return false ; if ( prime == 1 && K == 1 ) return true ; else if ( prime >= K ) return true ; else return false ; } static public void Main ( ) { int X , K ; X = 4 ; K = 2 ; if ( check ( X , K ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Check if there exists a number with X factors out of which exactly K are prime | C # program to check if there exists a number with X factors out of which exactly K are prime ; Function to check if such number exists ; To store the sum of powers of prime factors of X which determines the maximum count of numbers whose product can form X ; Determining the prime factors of X ; To check if the number is prime ; If X is 1 , then we cannot form a number with 1 factor and K prime factor ( as K is atleast 1 ) ; If X itself is prime then it can be represented as a power of only 1 prime factor which is X itself so we return true ; If sum of the powers of prime factors of X is greater than or equal to K , which means X can be represented as a product of K numbers , we return true ; In any other case , we return false as we cannot form a number with X factors and K prime factors ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { class Node { public int key ; public Node left , right ; } ; static Node newNode ( int key ) { Node temp = new Node ( ) ; temp . key = key ; temp . left = temp . right = null ; return ( temp ) ; } static int N = 1000000 ; static List < int > prime = new List < int > ( ) ; static void SieveOfEratosthenes ( ) { bool [ ] check = new bool [ N + 1 ] ; for ( int i = 0 ; i <= N ; i ++ ) check [ i ] = true ; for ( int p = 2 ; p * p <= N ; p ++ ) { if ( check [ p ] == true ) { prime . Add ( p ) ; for ( int i = p * p ; i <= N ; i += p ) check [ i ] = false ; } } } static bool isPathCo_Prime ( List < int > path ) { int max = 0 ; foreach ( int x in path ) { if ( max < x ) max = x ; } for ( int i = 0 ; i * prime [ i ] <= max / 2 ; i ++ ) { int ct = 0 ; foreach ( int x in path ) { if ( x % prime [ i ] == 0 ) ct ++ ; } if ( ct > 1 ) { return false ; } } return true ; } static void printCo_PrimePaths ( List < int > path ) { foreach ( int x in path ) { Console . Write ( x + "" ▁ "" ) ; } Console . WriteLine ( ) ; } static void findCo_PrimePaths ( Node root , List < int > path ) { if ( root == null ) return ; path . Add ( root . key ) ; findCo_PrimePaths ( root . left , path ) ; findCo_PrimePaths ( root . right , path ) ; if ( root . left == null && root . right == null ) { if ( isPathCo_Prime ( path ) ) { printCo_PrimePaths ( path ) ; } } path . RemoveAt ( path . Count - 1 ) ; } static void printCo_PrimePaths ( Node node ) { SieveOfEratosthenes ( ) ; List < int > path = new List < int > ( ) ; findCo_PrimePaths ( node , path ) ; } public static void Main ( String [ ] args ) { Node root = newNode ( 10 ) ; root . left = newNode ( 48 ) ; root . right = newNode ( 3 ) ; root . right . left = newNode ( 11 ) ; root . right . right = newNode ( 37 ) ; root . right . left . left = newNode ( 7 ) ; root . right . left . right = newNode ( 29 ) ; root . right . right . left = newNode ( 42 ) ; root . right . right . right = newNode ( 19 ) ; root . right . right . right . left = newNode ( 7 ) ; printCo_PrimePaths ( root ) ; } }";"Print all Coprime path of a Binary Tree | C # program for printing Co - prime paths of binary Tree ; A Tree node ; Utility function to create a new node ; List to store all the prime numbers ; Function to store all the prime numbers in an array ; Create a bool array "" prime [ 0 . . N ] "" and initialize all the entries in it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p greater than or equal to the square of it numbers which are multiples of p and are less than p ^ 2 are already marked . ; Function to check whether Path is Co - prime or not ; Iterating through the array to find the maximum element in the array ; Incrementing the variable if any of the value has a factor ; If not co - prime ; Function to print a Co - Prime path ; Function to find co - prime paths of binary tree ; Base case ; Store the value in path vector ; Recursively call for left sub tree ; Recursively call for right sub tree ; Condition to check , if leaf node ; Condition to check , if path co - prime or not ; Print co - prime path ; Remove the last element from the path vector ; Function to find Co - Prime paths In a given binary tree ; To save all prime numbers ; Function call ; Driver Code ; Create Binary Tree as shown ; Print Co - Prime Paths"
C#;"using System ; class GFG { static int mod = 1000000007 ; static int countSubsets ( int [ ] a , int n ) { int answer = 0 ; for ( int i = 0 ; i < ( 1 << n ) ; i ++ ) { int bitwiseAND = - 1 ; int bitwiseOR = 0 ; int bitwiseXOR = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) == 0 ) { if ( bitwiseAND == - 1 ) bitwiseAND = a [ j ] ; else bitwiseAND &= a [ j ] ; bitwiseOR |= a [ j ] ; bitwiseXOR ^= a [ j ] ; } } if ( bitwiseAND == bitwiseOR && bitwiseOR == bitwiseXOR ) answer = ( answer + 1 ) % mod ; } return answer ; } public static void Main ( String [ ] args ) { int N = 6 ; int [ ] A = { 1 , 3 , 2 , 1 , 2 , 1 } ; Console . Write ( countSubsets ( A , N ) ) ; } }";"Number of subsets with same AND , OR and XOR values in an Array | C # implementation to find the number of subsets with equal bitwise AND , OR and XOR values ; Function to find the number of subsets with equal bitwise AND , OR and XOR values ; Traverse through all the subsets ; Finding the subsets with the bits of ' i ' which are set ; Computing the bitwise AND ; Computing the bitwise OR ; Computing the bitwise XOR ; Comparing all the three values ; Driver Code"
C#;"using System ; class GFG { static int count ( int [ ] arr , int N , int K ) { int count = 0 , ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == K ) { count = count + 1 ; } else { ans += ( count * ( count + 1 ) ) / 2 ; count = 0 ; } } ans = ans + ( count * ( count + 1 ) ) / 2 ; return ans ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 0 , 0 , 1 , 1 , 0 , 0 } ; int N = arr . Length ; int K = 0 ; Console . Write ( count ( arr , N , K ) ) ; } }";"Count of Subsets containing only the given value K | C # implementation to find the number of subsets formed by the given value K ; Function to find the number of subsets formed by the given value K ; Count is used to maintain the number of continuous K 's ; Iterating through the array ; If the element in the array is equal to K ; count * ( count + 1 ) / 2 is the total number of subsets with only K as their element ; Change count to 0 because other element apart from K has been found ; To handle the last set of K 's ; Driver code"
C#;"using System ; class GFG { static void convertToTernary ( int N ) { if ( N == 0 ) return ; int x = N % 3 ; N /= 3 ; if ( x < 0 ) N += 1 ; convertToTernary ( N ) ; if ( x < 0 ) Console . Write ( x + ( 3 * - 1 ) ) ; else Console . Write ( x ) ; } static void convert ( int Decimal ) { Console . Write ( "" Ternary ▁ number ▁ of ▁ "" + Decimal + "" ▁ is : ▁ "" ) ; if ( Decimal != 0 ) { convertToTernary ( Decimal ) ; } else Console . WriteLine ( ""0"" ) ; } public static void Main ( string [ ] args ) { int Decimal = 2747 ; convert ( Decimal ) ; } }";"Ternary number system or Base 3 numbers | C # program to convert decimal number to ternary number ; Function to convert a decimal number to a ternary number ; Base case ; Finding the remainder when N is divided by 3 ; Recursive function to call the function for the integer division of the value N / 3 ; Handling the negative cases ; Function to convert the decimal to ternary ; If the number is greater than 0 , compute the ternary representation of the number ; Driver Code"
C#;"using System ; class GFG { static int get ( int x , int y , int z ) { if ( x > z ) return - 1 ; int val = z - x ; int div = ( z - x ) / y ; int ans = div * y + x ; return ans ; } public static void Main ( String [ ] args ) { int x = 1 , y = 5 , z = 8 ; Console . Write ( get ( x , y , z ) + "" STRNEWLINE "" ) ; } }";"Largest number less than or equal to Z that leaves a remainder X when divided by Y | C # implementation to Find the largest non - negative number that is less than or equal to integer Z and leaves a remainder X when divided by Y ; Function to get the number ; remainder can ' t ▁ be ▁ larger ▁ ▁ than ▁ the ▁ largest ▁ number , ▁ ▁ if ▁ so ▁ then ▁ answer ▁ doesn ' t exist . ; reduce number by x ; finding the possible number that is divisible by y ; this number is always <= x as we calculated over z - x ; Driver Code ; initialise the three integers"
C#;"using System ; class GFG { static void solve ( String s ) { String z = s ; int l = s . Length ; int i ; String str ; if ( s . IndexOf ( ' + ' ) != - 1 ) { i = s . IndexOf ( ' + ' ) ; str = s . Replace ( ' + ' , ' - ' ) ; } else { i = s . IndexOf ( ' - ' ) ; str = s . Replace ( ' - ' , ' + ' ) ; } Console . WriteLine ( "" Conjugate ▁ of ▁ "" + z + "" ▁ = ▁ "" + str ) ; } public static void Main ( String [ ] args ) { String s = ""3-4i "" ; solve ( s ) ; } }";"Find the conjugate of a Complex number | C # implementation to find the conjugate of a complex number ; Function to find conjugate of a complex number ; Store index of ' + ' ; Store index of ' - ' ; print the result ; Driver code ; Initialise the complex number"
C#;"using System ; class GFG { static int minOperations ( int A , int B ) { if ( A > B ) { A = A + B ; B = A - B ; A = A - B ; } B = B / __gcd ( A , B ) ; return B - 1 ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void Main ( String [ ] args ) { int A = 7 , B = 15 ; Console . Write ( minOperations ( A , B ) + "" STRNEWLINE "" ) ; } }";"Minimum operations required to make two numbers equal | C # program to find minimum operations required to make two numbers equal ; Function to return the minimum operations required ; Keeping B always greater ; Reduce B such that gcd ( A , B ) becomes 1. ; Driver code"
C#;"using System ; class GFG { static void quadrant ( String s ) { int l = s . Length ; int i ; if ( s . Contains ( "" + "" ) ) { i = s . IndexOf ( ' + ' ) ; } else { i = s . IndexOf ( ' - ' ) ; } String real = s . Substring ( 0 , i ) ; String imaginary = s . Substring ( i + 1 , l - 2 - i ) ; int x = Int32 . Parse ( real ) ; int y = Int32 . Parse ( imaginary ) ; if ( x > 0 && y > 0 ) Console . Write ( "" Quadrant ▁ 1"" ) ; else if ( x < 0 && y > 0 ) Console . Write ( "" Quadrant ▁ 2"" ) ; else if ( x < 0 && y < 0 ) Console . Write ( "" Quadrant ▁ 3"" ) ; else if ( x > 0 && y < 0 ) Console . Write ( "" Quadrant ▁ 4"" ) ; else if ( x == 0 && y > 0 ) Console . Write ( "" Lies ▁ on ▁ positive "" + "" ▁ Imaginary ▁ axis "" ) ; else if ( x == 0 && y < 0 ) Console . Write ( "" Lies ▁ on ▁ negative "" + "" ▁ Imaginary ▁ axis "" ) ; else if ( y == 0 && x < 0 ) Console . Write ( "" Lies ▁ on ▁ negative "" + "" ▁ X - axis "" ) ; else if ( y == 0 && x > 0 ) Console . Write ( "" Lies ▁ on ▁ positive "" + "" ▁ X - axis "" ) ; else Console . Write ( "" Lies ▁ on ▁ the ▁ Origin "" ) ; } public static void Main ( String [ ] args ) { String s = ""5 + 3i "" ; quadrant ( s ) ; } }";"Program to determine the Quadrant of a Complex number | C # program to determine the quadrant of a complex number ; Function to determine the quadrant of a complex number ; Storing the index of ' + ' ; Storing the index of ' - ' ; Finding the real part of the complex number ; Finding the imaginary part of the complex number ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { class Node { public int data ; public Node next ; } ; static Node push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_ref ; head_ref = new_node ; return head_ref ; } static int largestElement ( Node head_ref ) { int max = int . MinValue ; Node head = head_ref ; while ( head != null ) { if ( max < head . data ) max = head . data ; head = head . next ; } return max ; } static void createHash ( HashSet < int > hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . Add ( prev ) ; hash . Add ( curr ) ; while ( curr <= maxElement ) { int temp = curr + prev ; hash . Add ( temp ) ; prev = curr ; curr = temp ; } } static void sumAndProduct ( Node head_ref ) { int maxEle = largestElement ( head_ref ) ; HashSet < int > hash = new HashSet < int > ( ) ; createHash ( hash , maxEle ) ; int prod = 1 ; int sum = 0 ; Node ptr = head_ref ; while ( ptr != null ) { if ( hash . Contains ( ptr . data ) ) { prod *= ptr . data ; sum += ptr . data ; } ptr = ptr . next ; } Console . Write ( "" Sum ▁ = ▁ "" + sum + "" STRNEWLINE "" ) ; Console . Write ( "" Product ▁ = ▁ "" + prod ) ; } public static void Main ( String [ ] args ) { Node head = null ; head = push ( head , 13 ) ; head = push ( head , 6 ) ; head = push ( head , 8 ) ; head = push ( head , 16 ) ; head = push ( head , 15 ) ; sumAndProduct ( head ) ; } }";"Sum and Product of all Fibonacci Nodes of a Singly Linked List | C # implementation to find the sum and product of all of the Fibonacci nodes in a singly linked list ; Node of the singly linked list ; Function to insert a node at the beginning of the singly Linked List ; Allocate new node ; Insert the data ; Link the old list to the new node ; Move the head to point the new node ; Function that returns the largest element from the linked list . ; Declare a max variable and initialize with int . MinValue ; Check loop while head not equal to null ; If max is less then head . data then assign value of head . data to max otherwise node points to next node . ; Function to create a hash table to check Fibonacci numbers ; Inserting the first two numbers in the hash ; Loop to add Fibonacci numbers upto the maximum element present in the linked list ; Function to find the required sum and product ; Find the largest node value in Singly Linked List ; Creating a set containing all the fibonacci numbers upto the maximum data value in the Singly Linked List ; Traverse the linked list ; If current node is fibonacci ; Find the sum and the product ; Driver code ; Create the linked list 15.16 . 8.6 .13"
C#;"using System ; class GFG { static void product_subarrays ( int [ ] arr , int n ) { int product = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { for ( int k = i ; k <= j ; k ++ ) product *= arr [ k ] ; } } Console . Write ( product + "" STRNEWLINE "" ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 10 , 3 , 7 } ; int n = arr . Length ; product_subarrays ( arr , n ) ; } }";"Product of all Subarrays of an Array | C # program to find product of all subarray of an array ; Function to find product of all subarrays ; Variable to store the product ; Compute the product while traversing for subarrays ; Printing product of all subarray ; Driver code ; Function call"
C#;"using System ; class Gfg { static int val ( char c ) { if ( c >= '0' && c <= '9' ) return ( int ) c - '0' ; else return ( int ) c - ' A ' + 10 ; } static int toDeci ( string str , int base_var ) { int len = str . Length ; int power = 1 ; int num = 0 ; int i ; for ( i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str [ i ] ) >= base_var ) { Console . WriteLine ( "" Invalid ▁ Number "" ) ; return - 1 ; } num += val ( str [ i ] ) * power ; power = power * base_var ; } return num ; } public static bool isEven ( string num , int N ) { int deci = toDeci ( num , N ) ; return ( deci % 2 == 0 ) ; } public static void Main ( string [ ] args ) { string num = ""11A "" ; int N = 16 ; if ( isEven ( num , N ) ) { Console . WriteLine ( "" Even "" ) ; } else { Console . WriteLine ( "" Odd "" ) ; } } }";"Check if a N base number is Even or Odd | C # code to check if a Octal number is Even or Odd ; To return value of a char . ; Function to convert a number from N base to decimal ; power of base ; Decimal equivalent is str [ len - 1 ] * 1 + str [ len - 1 ] * base + str [ len - 1 ] * ( base ^ 2 ) + ... ; A digit in input number must be less than number 's base ; Returns true if n is even , else odd ; Driver code"
C#;"using System ; class GFG { static int [ ] fact = new int [ 21 ] ; static void preCompute ( ) { fact [ 0 ] = 1 ; for ( int i = 1 ; i < 18 ; i ++ ) fact [ i ] = ( fact [ i - 1 ] * i ) ; } static void nextFactorial ( int N ) { for ( int i = 0 ; i < 21 ; i ++ ) { if ( N < fact [ i ] ) { Console . WriteLine ( fact [ i ] ) ; break ; } } } public static void Main ( string [ ] args ) { preCompute ( ) ; int N = 120 ; nextFactorial ( N ) ; } }";"Find the next Factorial greater than N | C # implementation of the above approach ; Array that stores the factorial till 20 ; Function to pre - compute the factorial till 20 ; Precomputing factorials ; Function to return the next factorial number greater than N ; Traverse the factorial array ; Find the next just greater factorial than N ; Driver Code ; Function to precalculate the factorial till 20 ; Function call"
C#;"using System ; public class GFG { static void findDistinctOddSum ( int n , int k ) { if ( ( k * k ) <= n && ( n + k ) % 2 == 0 ) { int val = 1 ; int sum = 0 ; for ( int i = 1 ; i < k ; i ++ ) { Console . Write ( val + "" ▁ "" ) ; sum += val ; val += 2 ; } Console . Write ( n - sum + "" STRNEWLINE "" ) ; } else Console . Write ( "" NO ▁ STRNEWLINE "" ) ; } public static void Main ( String [ ] args ) { int n = 100 ; int k = 4 ; findDistinctOddSum ( n , k ) ; } }";"Find K distinct positive odd integers with sum N | C # implementation to find K odd positive integers such that their sum is equal to given number ; Function to find K odd positive integers such that their sum is N ; Condition to check if there are enough values to check ; Driver Code"
C#;"using System ; class GFG { static void checkArray ( int [ ] a , int [ ] b , int n ) { int operations = 0 ; int i = 0 ; while ( i < n ) { if ( a [ i ] - b [ i ] == 0 ) { i ++ ; continue ; } int diff = a [ i ] - b [ i ] ; i ++ ; while ( i < n && a [ i ] - b [ i ] == diff ) { i ++ ; } operations ++ ; } Console . WriteLine ( operations ) ; } public static void Main ( string [ ] args ) { int [ ] a = { 3 , 7 , 1 , 4 , 1 , 2 } ; int [ ] b = { 3 , 7 , 3 , 6 , 3 , 2 } ; int size = a . Length ; checkArray ( a , b , size ) ; } }";"Minimum number of operations to convert array A to array B by adding an integer into a subarray | C # implementation to find the minimum number of operations in which the array A can be converted to another array B ; Function to find the minimum number of operations in which array A can be converted to array B ; Loop to iterate over the array ; if both elements are equal then move to next element ; Calculate the difference between two elements ; loop while the next pair of elements have same difference ; Increase the number of operations by 1 ; Print the number of operations required ; Driver Code"
C#;"using System ; using System . Collections . Generic ; public class GFG { public static Dictionary < int , int > insertPF ( Dictionary < int , int > primeFact , int fact ) { if ( primeFact . ContainsKey ( fact ) ) { int freq ; freq = primeFact [ fact ] ; primeFact [ fact ] = ++ freq ; } else { primeFact . Add ( fact , 1 ) ; } return primeFact ; } public static Dictionary < int , int > primeFactors ( int n ) { Dictionary < int , int > primeFact = new Dictionary < int , int > ( ) ; while ( n % 2 == 0 ) { primeFact = insertPF ( primeFact , 2 ) ; n /= 2 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { primeFact = insertPF ( primeFact , i ) ; n /= i ; } } if ( n > 2 ) primeFact = insertPF ( primeFact , n ) ; return primeFact ; } public static String perfectCube ( int n ) { Dictionary < int , int > primeFact ; primeFact = primeFactors ( n ) ; foreach ( int freq in primeFact . Values ) { if ( freq % 3 != 0 ) return "" No "" ; } return "" Yes "" ; } public static void Main ( String [ ] args ) { int N = 216 ; Console . WriteLine ( perfectCube ( N ) ) ; } }";"Perfect Cube | C # program to check if a number is a perfect cube using prime factors ; Inserts the prime factor in the Hash Map if not present If present updates it 's frequency ; A utility function to find all prime factors of a given number N ; Insert the number of 2 s that divide n ; n must be odd at this point . So we can skip one element ; While i divides n , insert i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; Function to check if a number is a perfect cube ; Using values ( ) for iteration over keys ; Driver Code ; Function to check if N is perfect cube or not"
C#;"using System ; class GFG { static int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; } static int ways ( int n ) { if ( n < 3 ) { return 0 ; } int c2 = 0 ; int c1 = n - 3 ; int l = c1 + 1 ; int s = 0 ; int exp_c2 = c1 / 2 ; while ( exp_c2 >= c2 ) { int f1 = factorial ( l ) ; int f2 = factorial ( c1 ) ; int f3 = factorial ( c2 ) ; int f4 = ( f2 * f3 ) ; s += f1 / f4 ; c2 += 1 ; c1 -= 2 ; l -= 1 ; } return s ; } static void Main ( ) { int n = 7 ; int ans = ways ( n ) ; Console . WriteLine ( ans ) ; } }";"Count ways to reach the Nth stair using multiple 1 or 2 steps and a single step 3 | C # implementation to find the number the number of ways to reach Nth stair by taking 1 or 2 steps at a time and 3 rd step exactly once ; Single line to find factorial ; Function to find the number of ways ; Base Case ; Count of 2 - steps ; Count of 1 - steps ; Initial length of sequence ; Expected count of 2 - steps ; Loop to find the ways for every possible sequence ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { static Dictionary < int , int > m = new Dictionary < int , int > ( ) ; static void precompute ( ) { int fact = 1 ; for ( int i = 1 ; i <= 18 ; i ++ ) { fact = fact * i ; m . Add ( fact , i ) ; } } public static void Main ( String [ ] args ) { precompute ( ) ; int K = 120 ; Console . Write ( m [ K ] + "" STRNEWLINE "" ) ; K = 6 ; Console . Write ( m [ K ] + "" STRNEWLINE "" ) ; } }";"Find N from the value of N ! | C # program to find a number such that the factorial of that number is given ; Map to precompute and store the factorials of the numbers ; Function to precompute factorial ; Calculating the factorial for each i and storing in a map ; Driver code ; Precomputing the factorials"
C#;"using System ; class GFG { static int calNum ( int year ) { return ( year / 4 ) - ( year / 100 ) + ( year / 400 ) ; } static void leapNum ( int l , int r ) { l -- ; int num1 = calNum ( r ) ; int num2 = calNum ( l ) ; Console . Write ( num1 - num2 + "" STRNEWLINE "" ) ; } public static void Main ( String [ ] args ) { int l1 = 1 , r1 = 400 ; leapNum ( l1 , r1 ) ; int l2 = 400 , r2 = 2000 ; leapNum ( l2 , r2 ) ; } }";"Count of Leap Years in a given year range | C # implementation to find the count of leap years in given range of the year ; Function to calculate the number of leap years in range of ( 1 , year ) ; Function to calculate the number of leap years in given range ; Driver Code"
C#;"using System ; class GFG { class Cantor { public double start , end ; public Cantor next ; } ; static Cantor cantor ; static Cantor startList ( Cantor head , double start_num , double end_num ) { if ( head == null ) { head = new Cantor ( ) ; head . start = start_num ; head . end = end_num ; head . next = null ; } return head ; } static Cantor propagate ( Cantor head ) { Cantor temp = head ; if ( temp != null ) { Cantor newNode = new Cantor ( ) ; double diff = ( ( ( temp . end ) - ( temp . start ) ) / 3 ) ; newNode . end = temp . end ; temp . end = ( ( temp . start ) + diff ) ; newNode . start = ( newNode . end ) - diff ; newNode . next = temp . next ; temp . next = newNode ; propagate ( temp . next . next ) ; } return head ; } static void print ( Cantor temp ) { while ( temp != null ) { Console . Write ( "" [ { 0 : F6 } ] ▁ - - ▁ [ { 1 : F6 } ] "" , temp . start , temp . end ) ; temp = temp . next ; } Console . Write ( "" STRNEWLINE "" ) ; } static void buildCantorSet ( int A , int B , int L ) { Cantor head = null ; head = startList ( head , A , B ) ; for ( int i = 0 ; i < L ; i ++ ) { Console . Write ( "" Level _ { 0 } ▁ : ▁ "" , i ) ; print ( head ) ; propagate ( head ) ; } Console . Write ( "" Level _ { 0 } ▁ : ▁ "" , L ) ; print ( head ) ; } public static void Main ( String [ ] args ) { int A = 0 ; int B = 9 ; int L = 2 ; buildCantorSet ( A , B , L ) ; } }";"Ternary representation of Cantor set | C # implementation to find the cantor set for n levels and for a given start_num and end_num ; The Linked List Structure for the Cantor Set ; Function to initialize the Cantor Set List ; Function to propogate the list by adding new nodes for the next levels ; Modifying the start and end values for the next level ; Changing the pointers to the next node ; Recursively call the function to generate the Cantor Set for the entire level ; Function to print a level of the Set ; Function to build and display the Cantor Set for each level ; Driver code"
C#;"using System ; class GFG { static int N = 100005 ; static int mod = 1000000007 ; static int temp = 391657242 ; static int [ ] factorial = new int [ N ] ; static int [ ] modinverse = new int [ N ] ; static int power ( int a , int m1 ) { if ( m1 == 0 ) return 1 ; else if ( m1 == 1 ) return a ; else if ( m1 == 2 ) return ( a * a ) % mod ; else if ( ( m1 & 1 ) != 0 ) return ( a * power ( power ( a , m1 / 2 ) , 2 ) ) % mod ; else return power ( power ( a , m1 / 2 ) , 2 ) % mod ; } static void factorialfun ( ) { factorial [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) factorial [ i ] = ( factorial [ i - 1 ] * i ) % mod ; } static void modinversefun ( ) { modinverse [ N - 1 ] = power ( factorial [ N - 1 ] , mod - 2 ) % mod ; for ( int i = N - 2 ; i >= 0 ; i -- ) modinverse [ i ] = ( modinverse [ i + 1 ] * ( i + 1 ) ) % mod ; } static int binomial ( int n , int r ) { if ( r > n ) return 0 ; int a = ( factorial [ n ] * modinverse [ n - r ] ) % mod ; a = ( a * modinverse [ r ] ) % mod ; return a ; } static int max_min ( int [ ] a , int n , int k ) { Array . Sort ( a ) ; factorialfun ( ) ; modinversefun ( ) ; int ans = 0 ; k -- ; for ( int i = 0 ; i < n ; i ++ ) { int x = n - i - 1 ; if ( x >= k ) ans -= binomial ( x , k ) * a [ i ] % mod ; int y = i ; if ( y >= k ) ans += binomial ( y , k ) * a [ i ] % mod ; ans = ( ans + mod ) % mod ; } return ans % temp ; } public static void Main ( string [ ] args ) { int [ ] a = { 1 , 1 , 3 , 4 } ; int k = 2 ; int n = a . Length ; Console . WriteLine ( max_min ( a , n , k ) ) ; } }";"Find sum of f ( s ) for all the chosen sets from the given array | C # implementation of the approach ; To store the factorial and the factorial mod inverse of a number ; Function to find ( a ^ m1 ) % mod ; Function to find factorial of all the numbers ; Function to find the factorial mod inverse of all the numbers ; Function to return nCr ; Function to find sum of f ( s ) for all the chosen sets from the given array ; Sort the given array ; Calculate the factorial and modinverse of all elements ; For all the possible sets Calculate max ( S ) and min ( S ) ; Driver code"
C#;"using System ; class GFG { static int countNumber ( int N , int S ) { int countElements = 0 ; int currSum = 0 ; while ( currSum <= S ) { currSum += N ; N -- ; countElements ++ ; } return countElements ; } public static void Main ( ) { int N , S ; N = 5 ; S = 11 ; int count = countNumber ( N , S ) ; Console . WriteLine ( count ) ; } }";"Length of Smallest subarray in range 1 to N with sum greater than a given value | C # implementation of the above implementation ; Function to return the count of minimum elements such that the sum of those elements is > S . ; Initialize currentSum = 0 ; Loop from N to 1 to add the numbers and check the condition . ; Driver code"
C#;"using System ; class GFG { readonly static int INT_MAX = int . MaxValue ; static int countDistinct ( int n ) { int [ ] arr = new int [ 10 ] ; int count = 0 ; while ( n != 0 ) { int r = n % 10 ; arr [ r ] = 1 ; n /= 10 ; } for ( int i = 0 ; i < 10 ; i ++ ) { if ( arr [ i ] != 0 ) count ++ ; } return count ; } static int countDigit ( int n ) { int c = 0 ; while ( n != 0 ) { int r = n % 10 ; c ++ ; n /= 10 ; } return c ; } static int nextNumberDistinctDigit ( int n ) { while ( n < INT_MAX ) { int distinct_digits = countDistinct ( n + 1 ) ; int total_digits = countDigit ( n + 1 ) ; if ( distinct_digits == total_digits ) { return n + 1 ; } else n ++ ; } return - 1 ; } public static void Main ( String [ ] args ) { int n = 2019 ; Console . WriteLine ( nextNumberDistinctDigit ( n ) ) ; } }";"Next Number with distinct digits | C # program to find next consecutive Number with all distinct digits ; Function to count distinct digits in a number ; To count the occurrence of digits in number from 0 to 9 ; Iterate over the digits of the number Flag those digits as found in the array ; Traverse the array arr and count the distinct digits in the array ; Function to return the total number of digits in the number ; Iterate over the digits of the number ; Function to return the next number with distinct digits ; Count the distinct digits in N + 1 ; Count the total number of digits in N + 1 ; Return the next consecutive number ; Increment Number by 1 ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { static int mod = 1000000007 ; static int N = 1000005 ; static int [ ] lpf = new int [ N ] ; static void least_prime_factor ( ) { for ( int i = 1 ; i < N ; i ++ ) lpf [ i ] = i ; for ( int i = 2 ; i < N ; i ++ ) if ( lpf [ i ] == i ) for ( int j = i * 2 ; j < N ; j += i ) if ( lpf [ j ] == j ) lpf [ j ] = i ; } static long power ( long a , long m1 ) { if ( m1 == 0 ) return 1 ; else if ( m1 == 1 ) return a ; else if ( m1 == 2 ) return ( a * a ) % mod ; else if ( ( m1 & 1 ) != 0 ) return ( a * power ( power ( a , m1 / 2 ) , 2 ) ) % mod ; else return power ( power ( a , m1 / 2 ) , 2 ) % mod ; } static long sum_of_elements ( long [ ] a , int n ) { least_prime_factor ( ) ; Dictionary < long , long > prime_factor = new Dictionary < long , long > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { long temp = a [ i ] ; Dictionary < long , long > single_number = new Dictionary < long , long > ( ) ; while ( temp > 1 ) { long x = lpf [ ( int ) temp ] ; if ( single_number . ContainsKey ( x ) ) { single_number [ x ] ++ ; } else { single_number [ x ] = 1 ; } temp /= x ; } if ( i == 0 ) prime_factor = single_number ; else { foreach ( KeyValuePair < long , long > ele in single_number ) { if ( prime_factor . ContainsKey ( ele . Key ) ) { prime_factor [ ele . Key ] = Math . Max ( ele . Value , prime_factor [ ele . Key ] ) ; } else { prime_factor [ ele . Key ] = Math . Max ( ele . Value , 0 ) ; } } } } long ans = 0 , lcm = 1 ; foreach ( KeyValuePair < long , long > x in prime_factor ) { lcm = ( lcm * power ( x . Key , x . Value ) ) % mod ; } for ( int i = 0 ; i < n ; i ++ ) ans = ( ans + ( lcm * power ( a [ i ] , mod - 2 ) ) % mod ) % mod ; return ans ; } public static void Main ( string [ ] args ) { long [ ] a = { 2 , 3 , 4 } ; int n = a . Length ; Console . Write ( sum_of_elements ( a , n ) ) ; } }";"Minimum possible sum of array B such that AiBi = AjBj for all 1 â ‰¤ i < j â ‰¤ N | C # implementation of the approach ; To store least prime factors of all the numbers ; Function to find the least prime factor of all the numbers ; Function to return the ( ( a ^ m1 ) % mod ) ; Function to return the sum of elements of array B ; Find the prime factors of all the numbers ; To store each prime count in lcm ; Current number ; Map to store the prime count of a single number ; Basic way to calculate all prime factors ; If it is the first number in the array ; Take the maximum count of prime in a number ; Calculate lcm of given array ; Calculate sum of elements of array B ; Driver Code"
C#;"using System ; class GFG { static int findNumberOfEvenCells ( int n , int [ , ] q , int size ) { int [ ] row = new int [ n ] ; int [ ] col = new int [ n ] ; for ( int i = 0 ; i < size ; i ++ ) { int x = q [ i , 0 ] ; int y = q [ i , 1 ] ; row [ x - 1 ] ++ ; col [ y - 1 ] ++ ; } int r1 = 0 , r2 = 0 ; int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( row [ i ] % 2 == 0 ) { r1 ++ ; } if ( row [ i ] % 2 == 1 ) { r2 ++ ; } if ( col [ i ] % 2 == 0 ) { c1 ++ ; } if ( col [ i ] % 2 == 1 ) { c2 ++ ; } } int count = r1 * c1 + r2 * c2 ; return count ; } public static void Main ( ) { int n = 2 ; int [ , ] q = { { 1 , 1 } , { 1 , 2 } , { 2 , 1 } } ; int size = q . GetLength ( 0 ) ; Console . WriteLine ( findNumberOfEvenCells ( n , q , size ) ) ; } }";"Find Number of Even cells in a Zero Matrix after Q queries | C # program find Number of Even cells in a Zero Matrix after Q queries ; Function to find the number of even cell in a 2D matrix ; Maintain two arrays , one for rows operation and one for column operation ; Increment operation on row [ i ] ; Increment operation on col [ i ] ; Count odd and even values in both arrays and multiply them ; Count of rows having even numbers ; Count of rows having odd numbers ; Count of columns having even numbers ; Count of columns having odd numbers ; Driver code"
C#;"using System ; class GFG { static int maxHeight ( int h1 , int h2 ) { return ( ( h1 * h2 ) - h1 - h2 ) ; } public static void Main ( ) { int h1 = 7 , h2 = 5 ; Console . WriteLine ( Math . Max ( 0 , maxHeight ( h1 , h2 ) ) ) ; } }";"Find maximum unreachable height using two ladders | C # implementation of the approach ; Function to return the maximum height which can 't be reached ; Driver code"
C#;"using System ; class GFG { static void FermatFactors ( int n ) { if ( n <= 0 ) { Console . Write ( "" [ "" + n + "" ] "" ) ; return ; } if ( ( n & 1 ) == 0 ) { Console . Write ( "" [ "" + n / 2.0 + "" , "" + 2 + "" ] "" ) ; return ; } int a = ( int ) Math . Ceiling ( Math . Sqrt ( n ) ) ; if ( a * a == n ) { Console . Write ( "" [ "" + a + "" , "" + a + "" ] "" ) ; return ; } int b ; while ( true ) { int b1 = a * a - n ; b = ( int ) ( Math . Sqrt ( b1 ) ) ; if ( b * b == b1 ) break ; else a += 1 ; } Console . Write ( "" [ "" + ( a - b ) + "" , "" + ( a + b ) + "" ] "" ) ; return ; } public static void Main ( ) { FermatFactors ( 6557 ) ; } }";"Fermat 's Factorization Method | C # implementation of fermat 's factorization ; This function finds the value of a and b and returns a + b and a - b ; since fermat 's factorization applicable  for odd positive integers only ; check if n is a even number ; if n is a perfect root , then both its square roots are its factors ; Driver Code"
C#;"using System ; class GFG { static void findNums ( int [ ] arr , int n ) { int S = 0 , X = 0 ; for ( int i = 0 ; i < n ; i ++ ) { S += arr [ i ] ; X ^= arr [ i ] ; } Console . WriteLine ( X + "" ▁ "" + ( X + S ) ) ; } public static void Main ( ) { int [ ] arr = { 1 , 7 } ; int n = arr . Length ; findNums ( arr , n ) ; } }";"Append two elements to make the array satisfy the given condition | C # implementation of the approach ; Function to find the required numbers ; Find the sum and xor ; Print the required elements ; Driver code"
C#;"using System ; class GFG { static void solve ( int A , int B ) { double p = B / 2.0 ; double M = Math . Ceiling ( 4 * p ) ; int N = 1 ; int O = - 2 * A ; double Q = Math . Ceiling ( A * A + 4 * p * p ) ; Console . Write ( M + "" ▁ "" + N + "" ▁ "" + O + "" ▁ "" + Q ) ; } static public void Main ( ) { int a = 1 ; int b = 1 ; solve ( a , b ) ; } }";"Satisfy the parabola when point ( A , B ) and the equation is given | C # implementation of the approach ; Function to find the required values ; Driver code"
C#;"using System ; class GFG { static int findLargest ( int [ ] arr , int n ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) gcd = __gcd ( arr [ i ] , gcd ) ; return gcd ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 3 , 6 , 9 } ; int n = arr . Length ; Console . Write ( findLargest ( arr , n ) ) ; } }";"Largest number dividing maximum number of elements in the array | C # implementation of the approach ; Function to return the largest number that divides the maximum elements from the given array ; Finding gcd of all the numbers in the array ; Driver code"
C#;"using System ; class GFG { static int digitSum ( int n ) { int sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n /= 10 ; } return sum ; } static bool isPalindrome ( int n ) { int divisor = 1 ; while ( n / divisor >= 10 ) divisor *= 10 ; while ( n != 0 ) { int leading = n / divisor ; int trailing = n % 10 ; if ( leading != trailing ) return false ; n = ( n % divisor ) / 10 ; divisor = divisor / 100 ; } return true ; } static bool isDigitSumPalindrome ( int n ) { int sum = digitSum ( n ) ; if ( isPalindrome ( sum ) ) return true ; return false ; } static public void Main ( ) { int n = 56 ; if ( isDigitSumPalindrome ( n ) ) Console . Write ( "" Yes "" ) ; else Console . Write ( "" No "" ) ; } }";"Check if the sum of digits of N is palindrome | C # implementation of the approach ; Function to return the sum of digits of n ; Function that returns true if n is palindrome ; Find the appropriate divisor to extract the leading digit ; If first and last digit not same return false ; Removing the leading and trailing digit from number ; Reducing divisor by a factor of 2 as 2 digits are dropped ; Function that returns true if the digit sum of n is palindrome ; Sum of the digits of n ; If the digit sum is palindrome ; Driver code"
C#;"using System ; class GFG { static int xorK ( int n , int k ) { if ( k % 2 == 1 ) return n ; return 0 ; } public static void Main ( String [ ] args ) { int n = 123 , k = 3 ; Console . Write ( xorK ( n , k ) ) ; } }";"Find the value of N XOR 'ed to itself K times | C # implementation of the approach ; Function to return n ^ n ^ ... k times ; If k is odd the answer is the number itself ; Else the answer is 0 ; Driver code"
C#;"using System ; class GFG { static int N = 20 ; static int mod = 1000000007 ; static int [ ] factorial = new int [ N ] ; static int [ ] modinverse = new int [ N ] ; static int power ( int a , int m1 ) { if ( m1 == 0 ) return 1 ; else if ( m1 == 1 ) return a ; else if ( m1 == 2 ) return ( a * a ) % mod ; else if ( ( m1 & 1 ) != 0 ) return ( a * power ( power ( a , m1 / 2 ) , 2 ) ) % mod ; else return power ( power ( a , m1 / 2 ) , 2 ) % mod ; } static void factorialfun ( ) { factorial [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) factorial [ i ] = ( factorial [ i - 1 ] * i ) % mod ; } static void modinversefun ( ) { modinverse [ N - 1 ] = power ( factorial [ N - 1 ] , mod - 2 ) % mod ; for ( int i = N - 2 ; i >= 0 ; i -- ) modinverse [ i ] = ( modinverse [ i + 1 ] * ( i + 1 ) ) % mod ; } static int binomial ( int n , int r ) { if ( r > n ) return 0 ; int a = ( factorial [ n ] * modinverse [ n - r ] ) % mod ; a = ( a * modinverse [ r ] ) % mod ; return a ; } static int arrange ( int n , int m , int k ) { factorialfun ( ) ; modinversefun ( ) ; int ans = 0 ; for ( int i = 1 ; i < n ; i ++ ) ans += ( i * ( n - i ) * m * m ) % mod ; ans = 8 ; for ( int i = 1 ; i < m ; i ++ ) ans += ( i * ( m - i ) * n * n ) % mod ; ans = ( ans * binomial ( n * m - 2 , k - 2 ) ) % mod + 8 ; return ans ; } public static void Main ( String [ ] args ) { int n = 2 , m = 2 , k = 2 ; Console . WriteLine ( arrange ( n , m , k ) ) ; } }";"Find the sum of the costs of all possible arrangements of the cells | C # implementation of the approach ; To store the factorials and factorial mod inverse of the numbers ; Function to return ( a ^ m1 ) % mod ; Function to find the factorials of all the numbers ; Function to find factorial mod inverse of all the numbers ; Function to return nCr ; Function to return the sum of the costs of all the possible arrangements of the cells ; For all possible X 's ; For all possible Y 's ; Driver code"
C#;"using System ; class GFG { static int findNthDigit ( int p , int q , int N ) { int res = 0 ; while ( N > 0 ) { N -- ; p *= 10 ; res = p / q ; p %= q ; } return res ; } public static void Main ( ) { int p = 1 , q = 2 , N = 1 ; Console . WriteLine ( findNthDigit ( p , q , N ) ) ; } }";"Find the Nth digit in the proper fraction of two numbers | C # implementation of the approach ; Function to print the Nth digit in the fraction ( p / q ) ; To store the resultant digit ; While N > 0 compute the Nth digit by dividing p and q and store the result into variable res and go to next digit ; Driver code"
C#;"using System ; class GFG { static int sumArr ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; } static int sumModArr ( int [ ] arr , int n ) { int subSum = arr [ n - 1 ] ; for ( int i = n - 2 ; i >= 0 ; i -- ) { int curr = arr [ i ] ; arr [ i ] -= subSum ; subSum += curr ; } return sumArr ( arr , n ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 40 , 25 , 12 , 10 } ; int n = arr . Length ; Console . WriteLine ( sumModArr ( arr , n ) ) ; } }";"Sum of the updated array after performing the given operation | C # implementation of the approach ; Utility function to return the sum of the array ; Function to return the sum of the modified array ; Subtract the subarray sum ; Sum of subarray arr [ i ... n - 1 ] ; Return the sum of the modified array ; Driver code"
C#;"using System ; class GFG { static int NumUnsignBits = 64 ; static long findNum ( long x ) { for ( int i = 0 ; i < NumUnsignBits - 1 ; i ++ ) { if ( ( ( x >> i ) & 1 ) != ( ( x >> ( i + 1 ) ) & 1 ) ) { x ^= ( 1 << i ) | ( 1 << ( i + 1 ) ) ; return x ; } } return long . MinValue ; } public static void Main ( String [ ] args ) { int n = 92 ; Console . WriteLine ( findNum ( n ) ) ; } }";"Find closest integer with the same weight | C # implementation of the approach ; Function to return the number closest to x which has equal number of set bits as x ; Loop for each bit in x and compare with the next bit ; Driver code"
C#;"using System ; class GFG { static int cntCakes ( int n , int m ) { int sum = ( n * ( n + 1 ) ) / 2 ; int quo = m / sum ; int rem = m % sum ; double ans = m - quo * sum ; double x = ( - 1 + Math . Pow ( ( 8 * rem ) + 1 , 0.5 ) ) / 2 ; ans = ans - x * ( x + 1 ) / 2 ; return ( int ) ans ; } static public void Main ( ) { int n = 3 ; int m = 8 ; int ans = cntCakes ( n , m ) ; Console . Write ( ans ) ; } }";"Cake Distribution Problem | C # implementation of the approach ; Function to return the remaining count of cakes ; Sum for 1 cycle ; no . of full cycle and remainder ; Driver Code"
C#;"using System ; class GFG { static int cntSquares ( int n ) { return n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; } public static void Main ( String [ ] args ) { Console . Write ( cntSquares ( 4 ) ) ; } }";"Find the number of squares inside the given square grid | C # implementation of the approach ; Function to return the number of squares inside an n * n grid ; Driver code"
C#;"using System ; class GFG { static int reverse ( int num ) { int rev = 0 ; while ( num > 0 ) { rev = rev * 10 + num % 10 ; num = num / 10 ; } return rev ; } static bool isPalindrome ( int num ) { if ( num == reverse ( num ) ) return true ; return false ; } static void printPalindromes ( int d ) { if ( d <= 0 ) return ; int smallest = ( int ) Math . Pow ( 10 , d - 1 ) ; int largest = ( int ) Math . Pow ( 10 , d ) - 1 ; for ( int i = smallest ; i <= largest ; i ++ ) { if ( isPalindrome ( i ) ) Console . Write ( i + "" ▁ "" ) ; } } public static void Main ( String [ ] args ) { int d = 2 ; printPalindromes ( d ) ; } }";"Find all palindrome numbers of given digits | C # implementation of the approach ; Function to return the reverse of num ; Function that returns true if num is palindrome ; If the number is equal to the reverse of it then it is a palindrome ; Function to print all the d - digit palindrome numbers ; Smallest and the largest d - digit numbers ; Starting from the smallest d - digit number till the largest ; If the current number is palindrome ; Driver code"
C#;"using System ; class GFG { static void getXandYintercept ( int [ ] P , int [ ] Q ) { int a = P [ 1 ] - Q [ 1 ] ; int b = P [ 0 ] - Q [ 0 ] ; if ( b == 0 ) { Console . WriteLine ( P [ 0 ] ) ; Console . WriteLine ( "" infinity "" ) ; return ; } if ( a == 0 ) { Console . WriteLine ( "" infinity "" ) ; Console . WriteLine ( P [ 1 ] ) ; return ; } double m = a / ( b * 1.0 ) ; int x = P [ 0 ] ; int y = P [ 1 ] ; double c = y - m * x ; y = 0 ; double r = ( y - c ) / ( m * 1.0 ) ; Console . WriteLine ( r ) ; x = 0 ; y = ( int ) ( m * x + c ) ; Console . WriteLine ( c ) ; } public static void Main ( ) { int [ ] p1 = { 5 , 2 } ; int [ ] p2 = { 2 , 7 } ; getXandYintercept ( p1 , p2 ) ; } }";"Find X and Y intercepts of a line passing through the given points | C # implementation of the approach ; Function to find the X and Y intercepts of the line passing through the given points ; if line is parallel to y axis ; x - intercept will be p [ 0 ] ; y - intercept will be infinity ; if line is parallel to x axis ; x - intercept will be infinity ; y - intercept will be p [ 1 ] ; Slope of the line ; y = mx + c in where c is unknown Use any of the given point to find c ; For finding the x - intercept put y = 0 ; For finding the y - intercept put x = 0 ; Driver code"
C#;"using System ; class GFG { static int min_moves ( int n ) { int ans = int . MaxValue ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { ans = Math . Min ( ans , i + n / i - 2 ) ; } } return ans ; } public static void Main ( String [ ] args ) { int n = 10 ; Console . WriteLine ( min_moves ( n ) ) ; } }";"Minimum number of moves to reach N starting from ( 1 , 1 ) | C # implementation of the approach ; Function to return the minimum number of moves required to reach the cell containing N starting from ( 1 , 1 ) ; To store the required answer ; For all possible values of divisors ; If i is a divisor of n ; Get the moves to reach n ; Return the required answer ; Driver code"
C#;"using System ; class GFG { static int MOD = 2019 ; static int min_modulo ( int l , int r ) { if ( r - l >= MOD ) return 0 ; else { int ans = MOD - 1 ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = i + 1 ; j <= r ; j ++ ) { ans = Math . Min ( ans , ( i * j ) % MOD ) ; } } return ans ; } } public static void Main ( String [ ] args ) { int l = 2020 , r = 2040 ; Console . WriteLine ( min_modulo ( l , r ) ) ; } }";"Minimum possible value of ( i * j ) % 2019 | C # implementation of the approach ; Function to return the minimum possible value of ( i * j ) % 2019 ; If we can get a number divisible by 2019 ; Find the minimum value by running nested loops ; Driver code"
C#;"using System ; class GFG { static void find_numbers ( int N ) { if ( N == 1 ) { Console . Write ( - 1 ) ; } else { Console . Write ( N + "" ▁ "" + ( N + 1 ) + "" ▁ "" + ( N * ( N + 1 ) ) ) ; } } public static void Main ( String [ ] args ) { int N = 5 ; find_numbers ( N ) ; } }";"Represent ( 2 / N ) as the sum of three distinct positive integers of the form ( 1 / m ) | C # implementation of the approach ; Function to find the required fractions ; Base condition ; For N > 1 ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { static int countPairs ( int [ ] arr , int n ) { Dictionary < int , int > map = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) map [ arr [ i ] - i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) map [ arr [ i ] - i ] ++ ; int res = 0 ; foreach ( KeyValuePair < int , int > x in map ) { int cnt = x . Value ; res += ( ( cnt * ( cnt - 1 ) ) / 2 ) ; } return res ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 5 , 6 , 7 , 9 } ; int n = arr . Length ; Console . WriteLine ( countPairs ( arr , n ) ) ; } }";"Count the pairs in an array such that the difference between them and their indices is equal | C # implementation of the approach ; Function to return the count of all valid pairs ; To store the frequencies of ( arr [ i ] - i ) ; To store the required count ; If cnt is the number of elements whose difference with their index is same then ( ( cnt * ( cnt - 1 ) ) / 2 ) such pairs are possible ; Driver code"
C#;"using System ; class GFG { static string minInt ( char [ ] str ) { for ( int i = 0 ; i < str . Length ; i ++ ) { if ( ( int ) str [ i ] >= ( int ) ( '5' ) ) { str [ i ] = ( char ) ( ( ( int ) ( '9' ) - ( int ) ( str [ i ] ) ) + ( int ) ( '0' ) ) ; } } if ( str [ 0 ] == '0' ) str [ 0 ] = '9' ; string s = new string ( str ) ; return s ; } static public void Main ( ) { string str = ""589"" ; Console . WriteLine ( minInt ( str . ToCharArray ( ) ) ) ; } }";"Minimum possible number with the given operation | C # implementation of the above approach ; Function to return the minimum possible integer that can be obtained from the given integer after performing the given operations ; For every digit ; Digits less than 5 need not to be changed as changing them will lead to a larger number ; The resulting integer cannot have leading zero ; Driver code"
C#;"using System ; class GFG { static long minOperations ( long n ) { long count = 0 ; long d = 0 ; if ( n == 1 ) return 0 ; while ( n > 9 ) { d = Math . Max ( n % 10 , d ) ; n /= 10 ; count += 10 ; } d = Math . Max ( d , n - 1 ) ; count += Math . Abs ( d ) ; return count - 1 ; } public static void Main ( String [ ] args ) { long n = 240 ; Console . WriteLine ( minOperations ( n ) ) ; } }";"Reduce N to 1 with minimum number of given operations | C # implementation of the approach ; Function to return the minimum number of given operations required to reduce n to 1 ; To store the count of operations ; To store the digit ; If n is already then no operation is required ; Extract all the digits except the first digit ; Store the maximum of that digits ; for each digit ; First digit ; Add the value to count ; Driver code"
C#;"using System ; using System . Text ; class GFG { static StringBuilder findMaximumNum ( StringBuilder str , int n , int k ) { for ( int i = 0 ; i < n ; i ++ ) { if ( k < 1 ) break ; if ( str [ i ] != '9' ) { str [ i ] = '9' ; k -- ; } } return str ; } public static void Main ( ) { StringBuilder str = new StringBuilder ( ""569431"" ) ; int n = str . Length ; int k = 3 ; Console . WriteLine ( findMaximumNum ( str , n , k ) ) ; } }";"Find the largest number that can be formed by changing at most K digits | C # implementation of the approach ; Function to return the maximum number that can be formed by changing at most k digits in str ; For every digit of the number ; If no more digits can be replaced ; If current digit is not already 9 ; Replace it with 9 ; One digit has been used ; Driver code"
C#;"using System ; class GFG { static int solve ( int ang , int n ) { if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) { return 0 ; } else if ( ( ang * n ) % 180 != 0 ) { return 0 ; } int ans = 1 ; int freq = ( ang * n ) / 180 ; ans = ans * ( n - 1 - freq ) ; ans = ans * n ; return ans ; } public static void Main ( String [ ] args ) { int ang = 90 , n = 4 ; Console . WriteLine ( solve ( ang , n ) ) ; } }";"Number of occurrences of a given angle formed using 3 vertices of a n | C # implementation of the approach ; Function that calculates occurrences of given angle that can be created using any 3 sides ; Maximum angle in a regular n - gon is equal to the interior angle If the given angle is greater than the interior angle then the given angle cannot be created ; The given angle times n should be divisible by 180 else it cannot be created ; Initialise answer ; Calculate the frequency of given angle for each vertex ; Multiply answer by frequency . ; Multiply answer by the number of vertices . ; Driver code"
C#;"using System ; class GFG { static bool prime ( int n ) { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } static void thirdNumber ( int a , int b ) { int sum = 0 , temp = 0 ; sum = a + b ; temp = 1 ; if ( sum == 0 ) { temp = 2 ; } while ( ! prime ( sum + temp ) ) { temp += 2 ; } Console . Write ( temp ) ; } static public void Main ( ) { int a = 3 , b = 5 ; thirdNumber ( a , b ) ; } }";"Find third number such that sum of all three number becomes prime | C # implementation of the above approach ; Function that will check whether number is prime or not ; Function to print the 3 rd number ; If the sum is odd ; If sum is not prime ; Driver code"
C#;"using System ; class GFG { static int nCr ( int n , int r ) { int ans = 1 ; for ( int i = 1 ; i <= r ; i += 1 ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; } static int total_ways ( int N , int X ) { return ( nCr ( N - 1 , X - 1 ) + nCr ( N - 1 , X ) ) ; } public static void Main ( String [ ] args ) { int N = 5 , X = 3 ; Console . WriteLine ( total_ways ( N , X ) ) ; } }";"Total ways of selecting a group of X men from N men with or without including a particular man | C # implementation of the approach ; Function to return the value of nCr ; Initialize the answer ; Divide simultaneously by i to avoid overflow ; Function to return the count of ways ; Driver code"
C#;"using System ; class GFG { static int calculate ( int n , int k , int m , int power ) { if ( n > m ) { if ( power == 0 ) return 0 ; else return power - 1 ; } else if ( n == m ) return power ; else return calculate ( n * k , k , m , power + 1 ) ; } public static void Main ( String [ ] args ) { int N = 1 , K = 2 , M = 5 ; Console . WriteLine ( calculate ( N , K , M , 0 ) ) ; } }";"Compute the maximum power with a given condition | C # program for Compute maximum power to which K can be raised so that given condition remains true ; Function to return the largest power ; If n is greater than given M ; If n == m ; Checking for the next power ; Driver Code"
C#;"using System ; class GFG { static void printNumber ( int holes ) { if ( holes == 0 ) Console . Write ( ""1"" ) ; else if ( holes == 1 ) Console . Write ( ""0"" ) ; else { int rem = 0 , quo = 0 ; rem = holes % 2 ; quo = holes / 2 ; if ( rem == 1 ) Console . Write ( ""4"" ) ; for ( int i = 0 ; i < quo ; i ++ ) Console . Write ( ""8"" ) ; } } static public void Main ( ) { int holes = 3 ; printNumber ( holes ) ; } }";"Program to find the number from given holes | C # implementation of the above approach ; Function that will find out the number ; If number of holes equal 0 then return 1 ; If number of holes equal 0 then return 0 ; If number of holes is more than 0 or 1. ; If number of holes is odd ; Driver code ; Calling Function"
C#;"using System ; class GFG { static int minCost ( int [ ] arr , int n ) { int count_even = 0 ; int count_odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count_even ++ ; else count_odd ++ ; } return Math . Min ( count_even , count_odd ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 4 , 3 , 1 , 5 } ; int n = arr . Length ; Console . WriteLine ( minCost ( arr , n ) ) ; } }";"Minimum cost to make all array elements equal | C # implementation of the approach ; Function to return the minimum cost to make each array element equal ; To store the count of even numbers present in the array ; To store the count of odd numbers present in the array ; Iterate through the array and find the count of even numbers and odd numbers ; Driver code"
C#;"using System ; class GFG { static int negProdSubArr ( int [ ] arr , int n ) { int positive = 1 , negative = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; if ( i > 0 ) arr [ i ] *= arr [ i - 1 ] ; if ( arr [ i ] == 1 ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; } static int posProdSubArr ( int [ ] arr , int n ) { int total = ( n * ( n + 1 ) ) / 2 ; int cntNeg = negProdSubArr ( arr , n ) ; return ( total - cntNeg ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 5 , - 4 , - 3 , 2 , - 5 } ; int n = arr . Length ; Console . WriteLine ( posProdSubArr ( arr , n ) ) ; } }";"Number of Subarrays with positive product | C # implementation of the approach ; Function to return the count of subarrays with negative product ; Replace current element with 1 if it is positive else replace it with - 1 instead ; Take product with previous element to form the prefix product ; Count positive and negative elements in the prefix product array ; Return the required count of subarrays ; Function to return the count of subarrays with positive product ; Total subarrays possible ; Count to subarrays with negative product ; Return the count of subarrays with positive product ; Driver code"
C#;"using System ; class GFG { static int MAX = 10000 ; static bool [ ] prime = new bool [ MAX + 1 ] ; static void SieveOfEratosthenes ( ) { int i ; for ( i = 0 ; i < MAX + 1 ; i ++ ) { prime [ i ] = true ; } prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } } static int xorFirstNPrime ( int n ) { int count = 0 , num = 1 ; int xorVal = 0 ; while ( count < n ) { if ( prime [ num ] ) { xorVal ^= num ; count ++ ; } num ++ ; } return xorVal ; } static public void Main ( ) { SieveOfEratosthenes ( ) ; int n = 4 ; Console . Write ( xorFirstNPrime ( n ) ) ; } }";"Find the XOR of first N Prime Numbers | C # implementation of the approach ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Set all multiples of p to non - prime ; Function to return the xor of 1 st N prime numbers ; Count of prime numbers ; XOR of prime numbers ; If the number is prime xor it ; Increment the count ; Get to the next number ; Driver code ; Create the sieve ; Find the xor of 1 st n prime numbers"
C#;"using System ; class GFG { static long mod = 1000000007 ; static long inv2 = 500000004 ; static long modulo ( String num ) { long res = 0 ; for ( int i = 0 ; i < num . Length ; i ++ ) res = ( res * 10 + ( long ) num [ i ] - '0' ) % mod ; return res ; } static long findSum ( String L , String R ) { long a , b , l , r , ret ; a = modulo ( L ) ; b = modulo ( R ) ; l = ( ( a * ( a - 1 ) ) % mod * inv2 ) % mod ; r = ( ( b * ( b + 1 ) ) % mod * inv2 ) % mod ; ret = ( r % mod - l % mod ) ; if ( ret < 0 ) ret = ret + mod ; else ret = ret % mod ; return ret ; } public static void Main ( String [ ] args ) { String L = ""88949273204"" ; String R = ""98429729474298592"" ; Console . WriteLine ( findSum ( L , R ) ) ; } }";"Sum of all natural numbers from L to R ( for large values of L and R ) | C # implementation of the approach ; Value of inverse modulo 2 with 10 ^ 9 + 7 ; Function to return num % 1000000007 where num is a large number ; Initialize result ; One by one process all the digits of string ' num ' ; Function to return the sum of the longegers from the given range modulo 1000000007 ; a stores the value of L modulo 10 ^ 9 + 7 ; b stores the value of R modulo 10 ^ 9 + 7 ; l stores the sum of natural numbers from 1 to ( a - 1 ) ; r stores the sum of natural numbers from 1 to b ; If the result is negative ; Driver code"
C#;"using System ; class GFG { static int maxSubArraySum ( int [ ] a , int n , int k , int i ) { int max_so_far = int . MinValue , max_ending_here = 0 ; while ( i < n ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; i += k ; } return max_so_far ; } static int find ( int [ ] arr , int n , int k ) { int maxSum = 0 ; for ( int i = 0 ; i <= Math . Min ( n , k ) ; i ++ ) { maxSum = Math . Max ( maxSum , maxSubArraySum ( arr , n , k , i ) ) ; } return maxSum ; } public static void Main ( ) { int [ ] arr = { 2 , - 3 , - 1 , - 1 , 2 } ; int n = arr . Length ; int k = 2 ; Console . WriteLine ( find ( arr , n , k ) ) ; } }";"Maximum subsequence sum such that all elements are K distance apart | C # implementation of the approach ; Function to return the maximum subarray sum for the array { a [ i ] , a [ i + k ] , a [ i + 2 k ] , ... } ; Function to return the sum of the maximum required subsequence ; To store the result ; Run a loop from 0 to k ; Find the maximum subarray sum for the array { a [ i ] , a [ i + k ] , a [ i + 2 k ] , ... } ; Return the maximum value ; Driver code"
C#;"using System ; class GFG { static int MAX = 1000000 ; static bool [ ] prime = new bool [ MAX + 1 ] ; static void SieveOfEratosthenes ( ) { for ( int i = 0 ; i <= MAX ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } } static void solve ( int n ) { int count = 0 ; for ( int i = 3 ; count < n ; i ++ ) { if ( prime [ i ] ) { Console . Write ( i + "" ▁ "" ) ; count ++ ; } } } public static void Main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int n = 6 ; solve ( n ) ; } }";"Generate N integers satisfying the given conditions | C # implementation of the above approach ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Set all multiples of p to non - prime ; Function to find the first n odd prime numbers ; To store the current count of prime numbers ; Starting with 3 as 2 is an even prime number ; If i is prime ; Print i and increment count ; Driver code ; Create the sieve"
C#;"using System ; class GFG { static void solve ( int n ) { int n_2 = n / 2 ; String den ; den = ""1"" ; while ( n_2 -- > 0 ) den += '0' ; Console . WriteLine ( 1 + "" / "" + den ) ; } public static void Main ( String [ ] args ) { int N = 5 ; solve ( N ) ; } }";"Probability that a N digit number is palindrome | C # implementation of the approach ; Find the probability that a n digit number is palindrome ; Denominator ; Assign 10 ^ ( floor ( n / 2 ) ) to denominator ; Display the answer ; Driver code"
C#;"using System ; class GFG { static int MOD = 1000000007 ; static int countWays ( int n ) { int ans = 1 ; for ( int i = 0 ; i < n ; i ++ ) { ans *= 2 ; ans %= MOD ; } return ( ( ans - 1 + MOD ) % MOD ) ; } public static void Main ( String [ ] args ) { int n = 3 ; Console . WriteLine ( countWays ( n ) ) ; } }";"Ways to choose balls such that at least one ball is chosen | C # implementation of the approach ; Function to return the count of ways to choose the balls ; Calculate ( 2 ^ n ) % MOD ; Subtract the only where no ball was chosen ; Driver code"
C#;"using System ; class GFG { static void findMin ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; Array . Sort ( arr ) ; int min = arr [ 0 ] ; int max = 0 ; for ( int i = n - 1 ; i >= 1 ; i -- ) { int num = arr [ i ] ; int total = num + min ; int j ; for ( j = 2 ; j <= num ; j ++ ) { if ( num % j == 0 ) { int d = j ; int now = ( num / d ) + ( min * d ) ; int reduce = total - now ; if ( reduce > max ) max = reduce ; } } } Console . WriteLine ( sum - max ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . Length ; findMin ( arr , n ) ; } }";"Minimize the sum of the array according the given condition | C # implementation of the above approach ; Function to return the minimum sum ; sort the array to find the minimum element ; finding the number to divide ; Checking to what instance the sum has decreased ; getting the max difference ; Driver Code"
C#;"using System ; class GFG { static void convert_To_Len_th_base ( int n , int [ ] arr , int len , int L ) { for ( int i = 0 ; i < L ; i ++ ) { Console . Write ( arr [ n % len ] ) ; n /= len ; } Console . WriteLine ( ) ; } static void print ( int [ ] arr , int len , int L ) { for ( int i = 0 ; i < ( int ) Math . Pow ( len , L ) ; i ++ ) { convert_To_Len_th_base ( i , arr , len , L ) ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 } ; int len = arr . Length ; int L = 2 ; print ( arr , len , L ) ; } }";"Print all the permutation of length L using the elements of an array | Iterative | C # implementation for above approach ; Convert the number to Lth base and print the sequence ; Sequence is of length L ; Print the ith element of sequence ; Print all the permuataions ; There can be ( len ) ^ l permutations ; Convert i to len th base ; Driver code ; function call"
C#;"using System ; using System . Collections . Generic ; class GFG { static int totalways ( int [ ] arr , int n ) { Dictionary < int , int > cnt = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( cnt . ContainsKey ( arr [ i ] ) ) { cnt [ arr [ i ] ] = cnt [ arr [ i ] ] + 1 ; } else { cnt . Add ( arr [ i ] , 1 ) ; } } if ( n % 2 == 1 ) { int start = 0 , endd = n - 1 ; for ( int i = start ; i <= endd ; i = i + 2 ) { if ( i == 0 ) { if ( cnt [ i ] != 1 ) { return 0 ; } } else { if ( cnt [ i ] != 2 ) { return 0 ; } } } int ways = 1 ; start = 2 ; endd = n - 1 ; for ( int i = start ; i <= endd ; i = i + 2 ) { ways = ways * 2 ; } return ways ; } else if ( n % 2 == 0 ) { int start = 1 , endd = n - 1 ; for ( int i = 1 ; i <= endd ; i = i + 2 ) { if ( cnt [ i ] != 2 ) return 0 ; } int ways = 1 ; for ( int i = start ; i <= endd ; i = i + 2 ) { ways = ways * 2 ; } return ways ; } return int . MinValue ; } public static void Main ( String [ ] args ) { int N = 5 ; int [ ] arr = { 2 , 4 , 4 , 0 , 2 } ; Console . WriteLine ( totalways ( arr , N ) ) ; } }";"Number of possible permutations when absolute difference between number of elements to the right and left are given | C # implementation of the above approach ; Function to find the number of permutations possible of the original array to satisfy the given absolute differences ; To store the count of each a [ i ] in a map ; if n is odd ; check the count of each whether it satisfy the given criteria or not ; there is only 1 way for middle element . ; for others there are 2 ways . ; now find total ways ; When n is even . ; there will be no middle element so for each a [ i ] there will be 2 ways ; Driver Code"
C#;"using System ; class GFG { static int proizvolov ( int [ ] a , int [ ] b , int n ) { return n * n ; } public static void Main ( ) { int [ ] a = { 1 , 5 , 6 , 8 , 10 } ; int [ ] b = { 9 , 7 , 4 , 3 , 2 } ; int n = a . Length ; Console . WriteLine ( proizvolov ( a , b , n ) ) ; } }";"Proizvolov 's Identity | C # program to implement proizvolov 's identity ; Function to implement proizvolov 's identity ; According to proizvolov 's identity ; Driver code ; Function call"
C#;"using System ; class GFG { static double calculateLnx ( double n ) { double num , mul , cal , sum = 0 ; num = ( n - 1 ) / ( n + 1 ) ; for ( int i = 1 ; i <= 1000 ; i ++ ) { mul = ( 2 * i ) - 1 ; cal = Math . Pow ( num , mul ) ; cal = cal / mul ; sum = sum + cal ; } sum = 2 * sum ; return sum ; } static double calculateLogx ( double lnx ) { return ( lnx / 2.303 ) ; } public static void Main ( String [ ] args ) { double lnx , logx , n = 5 ; lnx = calculateLnx ( n ) ; logx = calculateLogx ( lnx ) ; Console . WriteLine ( "" ln ▁ "" + n + "" ▁ = ▁ "" + lnx ) ; Console . WriteLine ( "" log10 ▁ "" + n + "" ▁ = ▁ "" + logx ) ; } }";"Find the ln ( X ) and log10X with the help of expansion | C # code to Find the ln x and log < sub > 10 < / sub > x with the help of expansion ; Function to calculate ln x using expansion ; terminating value of the loop can be increased to improve the precision ; Function to calculate log10 x ; Driver Code ; setprecision ( 3 ) is used to display the output up to 3 decimal places"
C#;"using System ; class GFG { static int sum ( int A , int B , int R ) { int sum = 0 ; for ( int i = 1 ; i <= R ; i ++ ) { sum = sum + ( i * A ) ; A = A + B ; } return sum ; } public static void Main ( ) { int A = 5 , B = 3 , R = 3 ; Console . Write ( sum ( A , B , R ) ) ; } }";"Find the sum of elements of the Matrix generated by the given rules | C # implementation of the approach ; Function to return the required sum ; To store the sum ; For every row ; Update the sum as A appears i number of times in the current row ; Update A for the next row ; Return the sum ; Driver code"
C#;"using System ; class GFG { static int countSetBits ( int n ) { n ++ ; int powerOf2 = 2 ; int cnt = n / 2 ; while ( powerOf2 <= n ) { int totalPairs = n / powerOf2 ; cnt += ( totalPairs / 2 ) * powerOf2 ; cnt += ( totalPairs % 2 == 1 ) ? ( n % powerOf2 ) : 0 ; powerOf2 <<= 1 ; } return cnt ; } public static void Main ( String [ ] args ) { int n = 14 ; Console . WriteLine ( countSetBits ( n ) ) ; } }";"Count total set bits in all numbers from 1 to n | Set 2 | C # implementation of the approach ; Function to return the sum of the count of set bits in the integers from 1 to n ; Ignore 0 as all the bits are unset ; To store the powers of 2 ; To store the result , it is initialized with n / 2 because the count of set least significant bits in the integers from 1 to n is n / 2 ; Loop for every bit required to represent n ; Total count of pairs of 0 s and 1 s ; totalPairs / 2 gives the complete count of the pairs of 1 s Multiplying it with the current power of 2 will give the count of 1 s in the current bit ; If the count of pairs was odd then add the remaining 1 s which could not be groupped together ; Next power of 2 ; Return the result ; Driver code"
C#;"using System ; class Gfg { static int getHeight ( int X ) { return ( 2 * X ) ; } public static void Main ( ) { int X = 35 ; Console . WriteLine ( getHeight ( X ) ) ; } }";"Find the height of a right | C # implementation of the approach ; Function to return the height of the right - angled triangle whose area is X times its base ; Driver code"
C#;"using System ; class GFG { static double SumofInverseDivisors ( int N , int Sum ) { double ans = ( double ) ( Sum ) * 1.0 / ( double ) ( N ) ; return ans ; } static public void Main ( ) { int N = 9 ; int Sum = 13 ; Console . Write ( SumofInverseDivisors ( N , Sum ) ) ; } }";"Find sum of inverse of the divisors when sum of divisors and the number is given | C # implementation of above approach ; Function to return the sum of inverse of divisors ; Calculating the answer ; Return the answer ; Driver code ; Function call"
C#;"using System ; class GFG { static int NoofTriplets ( int N , int K ) { int [ ] cnt = new int [ K ] ; Array . Fill ( cnt , 0 , cnt . Length , 0 ) ; for ( int i = 1 ; i <= N ; i += 1 ) { cnt [ i % K ] += 1 ; } if ( ( K & 1 ) != 0 ) { return cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] ; } else { return ( cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] + cnt [ K / 2 ] * cnt [ K / 2 ] * cnt [ K / 2 ] ) ; } } static public void Main ( ) { int N = 3 , K = 2 ; Console . Write ( NoofTriplets ( N , K ) ) ; } }";"Number of triplets such that each value is less than N and each pair sum is a multiple of K | C # implementation of the approach ; Function to return the number of triplets ; Initializing the count array ; Storing the frequency of each modulo class ; If K is odd ; If K is even ; Driver Code ; Function Call"
C#;"using System ; class GFG { static int findNumber ( int n ) { int num = n - 1 ; num = 2 * ( int ) Math . Pow ( 4 , num ) ; num = ( int ) Math . Floor ( num / 3.0 ) ; return num ; } static public void Main ( ) { int n = 5 ; Console . Write ( findNumber ( n ) ) ; } }";"Find a number containing N | C # implementation of the approach ; Function to compute number using our deduced formula ; Initialize num to n - 1 ; Driver code"
C#;"using System ; class GFG { static int findXOR ( int n ) { int mod = n % 4 ; if ( mod == 0 ) return n ; else if ( mod == 1 ) return 1 ; else if ( mod == 2 ) return n + 1 ; else if ( mod == 3 ) return 0 ; return 0 ; } static int findXOR ( int l , int r ) { return ( findXOR ( l - 1 ) ^ findXOR ( r ) ) ; } public static void Main ( ) { int l = 4 , r = 8 ; Console . WriteLine ( findXOR ( l , r ) ) ; } }";"Find XOR of numbers from the range [ L , R ] | C # implementation of the approach ; Function to return the XOR of elements from the range [ 1 , n ] ; If n is a multiple of 4 ; If n % 4 gives remainder 1 ; If n % 4 gives remainder 2 ; If n % 4 gives remainder 3 ; Function to return the XOR of elements from the range [ l , r ] ; Driver code"
C#;"using System ; class GFG { static int GCD ( int a , int b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } static int findReachable ( int [ ] arr , int D , int A , int B , int n ) { int gcd_AB = GCD ( A , B ) ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] - D ) % gcd_AB == 0 ) count ++ ; } return count ; } public static void Main ( ) { int [ ] arr = { 4 , 5 , 6 , 7 , 8 , 9 } ; int n = arr . Length ; int D = 4 , A = 4 , B = 6 ; Console . WriteLine ( findReachable ( arr , D , A , B , n ) ) ; } }";"Number of elements from the array which are reachable after performing given operations on D | C # implementation of the approach ; Function to return the GCD of a and b ; Function to return the count of reachable integers from the given array ; GCD of A and B ; To store the count of reachable integers ; If current element can be reached ; Return the count ; Driver code"
C#;"using System ; class GFG { static long power ( int x , long y ) { long res = 1 ; while ( y > 0 ) { if ( y == 1 ) res = ( res * x ) ; y = y >> 1 ; x = ( x * x ) ; } return res ; } static long solve ( int L ) { int n = L / 2 + 1 ; long ans = power ( n , n - 2 ) ; return ans ; } static public void Main ( ) { int L = 6 ; Console . WriteLine ( solve ( L ) ) ; } }";"Number of trees whose sum of degrees of all the vertices is L | C # implementation of the approach ; Iterative Function to calculate ( x ^ y ) in O ( log y ) ; Initialize result ; If y is odd , multiply x with result ; y must be even now y = y / 2 ; Function to return the count of required trees ; number of nodes ; Return the result ; Driver code"
C#;"using System ; public class AP { static void makeAP ( int [ ] arr , int n ) { int initial_term , common_difference ; if ( n == 3 ) { common_difference = arr [ 2 ] - arr [ 1 ] ; initial_term = arr [ 1 ] - common_difference ; } else if ( ( arr [ 1 ] - arr [ 0 ] ) == arr [ 2 ] - arr [ 1 ] ) { initial_term = arr [ 0 ] ; common_difference = arr [ 1 ] - arr [ 0 ] ; } else if ( ( arr [ 2 ] - arr [ 1 ] ) == ( arr [ 3 ] - arr [ 2 ] ) ) { common_difference = arr [ 2 ] - arr [ 1 ] ; initial_term = arr [ 1 ] - common_difference ; } else { common_difference = ( arr [ 3 ] - arr [ 0 ] ) / 3 ; initial_term = arr [ 0 ] ; } for ( int i = 0 ; i < n ; i ++ ) Console . Write ( initial_term + ( i * common_difference ) + "" ▁ "" ) ; Console . WriteLine ( ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 7 } ; int n = arr . Length ; makeAP ( arr , n ) ; } }";"Change one element in the given array to make it an Arithmetic Progression | C # program to change one element of an array such that the resulting array is in arithmetic progression . ; Finds the initial term and common difference and prints the resulting array . ; Check if the first three elements are in arithmetic progression ; Check if the first element is not in arithmetic progression ; The first and fourth element are in arithmetic progression ; Print the arithmetic progression ; Driver code"
C#;"using System ; class GFG { static int getfactor ( int n , int p ) { int pw = 0 ; while ( n != 0 ) { n /= p ; pw += n ; } return pw ; } static int isDivisible ( int n , int r , int p ) { int x1 = getfactor ( n , p ) ; int x2 = getfactor ( r , p ) ; int x3 = getfactor ( n - r , p ) ; if ( x1 > x2 + x3 ) return 1 ; return 0 ; } static public void Main ( ) { int n = 7 , r = 2 , p = 7 ; if ( isDivisible ( n , r , p ) == 1 ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Find if nCr is divisible by the given prime | C # Implementation of above approach ; Function to return the highest power of p that divides n ! implementing Legendre Formula ; Return the highest power of p which divides n ! ; Function to return N digits number which is divisible by D ; Find the highest powers of p that divide n ! , r ! and ( n - r ) ! ; If nCr is divisible by p ; Driver code"
C#;"using System ; class GFG { static bool isEven ( int [ ] arr , int n , int r ) { if ( r % 2 == 0 ) { if ( arr [ n - 1 ] % 2 == 0 ) return true ; } else { int oddCount = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( arr [ i ] % 2 != 0 ) oddCount ++ ; } if ( oddCount % 2 == 0 ) return true ; } return false ; } public static void Main ( ) { int [ ] arr = { 1 , 0 } ; int n = arr . Length ; int r = 2 ; if ( isEven ( arr , n , r ) ) Console . WriteLine ( "" Even "" ) ; else Console . WriteLine ( "" Odd "" ) ; } }";"Check if the number is even or odd whose digits and base ( radix ) is given | C # implementation of the approach ; Function that returns true if the number represented by arr [ ] is even in base r ; If the base is even , then the last digit is checked ; If base is odd , then the number of odd digits are checked ; To store the count of odd digits ; Number is odd ; Driver code"
C#;"using System ; class GFG { static int closetAND ( int [ ] arr , int n , int k ) { int ans = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) { int X = arr [ i ] ; for ( int j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = Math . Min ( ans , Math . Abs ( k - X ) ) ; if ( X <= k ) break ; } } return ans ; } public static void Main ( String [ ] args ) { int [ ] arr = { 4 , 7 , 10 } ; int n = arr . Length ; int k = 2 ; Console . WriteLine ( closetAND ( arr , n , k ) ) ; } }";"Bitwise AND of sub | C # implementation of the approach ; Function to return the minimum possible value of | K - X | where X is the bitwise AND of the elements of some sub - array ; Check all possible sub - arrays ; Find the overall minimum ; No need to perform more AND operations as | k - X | will increase ; Driver code"
C#;"using System ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static int countQuadruplets ( int l , int r , int k ) { int [ ] frequency = new int [ r + 1 ] ; for ( int i = l ; i <= r ; i ++ ) { for ( int j = l ; j <= r ; j ++ ) { frequency [ gcd ( i , j ) ] ++ ; } } long answer = 0 ; for ( int i = 1 ; i <= r ; i ++ ) { for ( int j = 1 ; j <= r ; j ++ ) { if ( gcd ( i , j ) == k ) { answer += ( frequency [ i ] * frequency [ j ] ) ; } } } return ( int ) answer ; } static public void Main ( ) { int l = 1 , r = 10 , k = 2 ; Console . WriteLine ( countQuadruplets ( l , r , k ) ) ; } }";"Count of quadruplets from range [ L , R ] having GCD equal to K | C # implementation of the approach ; Function to return the gcd of a and b ; Function to return the count of quadruplets having gcd = k ; Count the frequency of every possible gcd value in the range ; To store the required count ; Calculate the answer using frequency values ; Return the required count ; Driver code"
C#;"using System ; class GFG { static void solve ( int [ ] a , int n ) { int ones = 0 , twos = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ones ++ ; else twos ++ ; } int ind = 0 ; if ( twos > 0 ) a [ ind ++ ] = 2 ; bool evenOnes = ( ones % 2 == 0 ) ? true : false ; if ( evenOnes ) ones -= 1 ; for ( int i = 0 ; i < ones ; i ++ ) a [ ind ++ ] = 1 ; for ( int i = 0 ; i < twos - 1 ; i ++ ) a [ ind ++ ] = 2 ; if ( evenOnes ) a [ ind ++ ] = 1 ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( a [ i ] + "" ▁ "" ) ; } static public void Main ( ) { int [ ] a = { 1 , 2 , 1 , 2 , 1 } ; int n = a . Length ; solve ( a , n ) ; } }";"Rearrange the array to maximize the number of primes in prefix sum of the array | C # implementation of the approach ; Function to print the re - arranged array ; Count the number of ones and twos in a [ ] ; If the array element is 1 ; Array element is 2 ; If it has at least one 2 Fill up first 2 ; Decrease the cnt of ones if even ; Fill up with odd count of ones ; Fill up with remaining twos ; If even ones , then fill last position ; Print the rearranged array ; Driver code"
C#;"using System ; class GFG { static void CreateArray ( int N , int even , int odd ) { int EvenPreSums = 1 ; int temp = - 1 ; int OddPreSums = 0 ; for ( int i = 0 ; i <= N + 1 ; i ++ ) { if ( i * ( ( N + 1 ) - i ) == odd ) { temp = 0 ; OddPreSums = i ; break ; } } if ( temp == - 1 ) { Console . WriteLine ( temp ) ; } else { EvenPreSums = ( ( N + 1 ) - OddPreSums ) ; int e = 1 ; int o = 0 ; int CurrSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( CurrSum % 2 == 0 ) { if ( e < EvenPreSums ) { e ++ ; Console . Write ( ""0 ▁ "" ) ; } else { o ++ ; Console . Write ( ""1 ▁ "" ) ; CurrSum ++ ; } } else { if ( e < EvenPreSums ) { e ++ ; Console . Write ( ""1 ▁ "" ) ; CurrSum ++ ; } else { o ++ ; Console . Write ( ""0 ▁ "" ) ; } } } Console . WriteLine ( ) ; } } static public void Main ( ) { int N = 15 ; int even = 60 , odd = 60 ; CreateArray ( N , even , odd ) ; } }";"Generate an Array in which count of even and odd sum sub | C # implementation of the approach ; Function to generate and print the required array ; Find the number of odd prefix sums ; If no odd prefix sum found ; Calculating the number of even prefix sums ; Stores the current prefix sum ; If current prefix sum is even ; Print 0 until e = EvenPreSums - 1 ; Print 1 when e = EvenPreSums ; Print 0 for rest of the values ; Driver code"
C#;"using System ; using System . Linq ; class GFG { static int changeTheArray ( int [ ] arr , int n ) { int minEle = arr . Min ( ) ; int maxEle = arr . Max ( ) ; int minOperations = int . MaxValue ; for ( int num = minEle ; num <= maxEle ; num ++ ) { int operations = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != num ) { operations += ( Math . Abs ( num - arr [ i ] ) - 1 ) ; } } minOperations = Math . Min ( minOperations , operations ) ; } return minOperations ; } public static void Main ( String [ ] args ) { int [ ] arr = { 10 , 1 , 4 } ; int n = arr . Length ; Console . WriteLine ( changeTheArray ( arr , n ) ) ; } }";"Minimum operations required to change the array such that | arr [ i ] | C # implementation of the approach ; Function to return the minimum number of operations required ; Minimum and maximum elements from the array ; To store the minimum number of operations required ; To store the number of operations required to change every element to either ( num - 1 ) , num or ( num + 1 ) ; If current element is not already num ; Add the count of operations required to change arr [ i ] ; Update the minimum operations so far ; Driver code"
C#;"using System ; class GFG { static int findX ( int A , int B ) { int j = 0 , x = 0 ; while ( A != 0 B != 0 ) { if ( ( A % 2 == 1 ) && ( B % 2 == 1 ) ) { x += ( 1 << j ) ; } A >>= 1 ; B >>= 1 ; j += 1 ; } return x ; } public static void Main ( String [ ] args ) { int A = 2 , B = 3 ; int X = findX ( A , B ) ; Console . WriteLine ( "" X ▁ = ▁ "" + X + "" , ▁ Sum ▁ = ▁ "" + ( ( A ^ X ) + ( B ^ X ) ) ) ; } }";"Choose X such that ( A xor X ) + ( B xor X ) is minimized | C # implementation of the approach ; Function to return the integer X such that ( A xor X ) + ( B ^ X ) is minimized ; While either A or B is non - zero ; Position at which both A and B have a set bit ; Inserting a set bit in x ; Right shifting both numbers to traverse all the bits ; Driver code"
C#;"using System ; class GFG { public static int findX ( int A , int B ) { return A & B ; } public static int findSum ( int A , int B ) { return A ^ B ; } public static void Main ( String [ ] args ) { int A = 2 , B = 3 ; Console . Write ( "" X ▁ = ▁ "" + findX ( A , B ) + "" , ▁ Sum ▁ = ▁ "" + findSum ( A , B ) ) ; } }";"Choose X such that ( A xor X ) + ( B xor X ) is minimized | C # implementation of above approach ; Finding X ; Finding Sum ; Driver Code"
C#;"using System ; class GFG { static bool isSumEqual ( int [ ] ar , int n ) { int sum = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += ar [ i ] ; if ( sum == ar [ n - 1 ] ) return true ; return false ; } static public void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 10 } ; int n = arr . Length ; if ( isSumEqual ( arr , n ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Compare sum of first N | C # implementation of the approach ; Function that returns true if sum of first n - 1 elements of the array is equal to the last element ; Find the sum of first n - 1 elements of the array ; If sum equals to the last element ; Driver code"
C#;"using System ; class GFG { static double perfectSquares ( int a , int b ) { return ( Math . Floor ( Math . Sqrt ( b ) ) - Math . Ceiling ( Math . Sqrt ( a ) ) + 1 ) ; } static double countOnes ( int [ ] arr , int n ) { return perfectSquares ( 1 , n ) ; } static public void Main ( ) { int N = 10 ; int [ ] arr = { 0 } ; Console . WriteLine ( countOnes ( arr , N ) ) ; } }";"Count number of 1 s in the array after N moves | C # implementation of the above approach ; Function to count number of perfect squares ; Counting number of perfect squares between a and b ; Function to count number of 1 s in array after N moves ; Driver Code ; Initialize array size ; Initialize all elements to 0"
C#;"using System ; class GFG { static void printPosition ( int [ ] A , int [ ] B , int sizeOfA , int sizeOfB ) { for ( int i = 1 ; i < sizeOfA ; i ++ ) { A [ i ] += A [ i - 1 ] ; } for ( int i = 0 ; i < sizeOfB ; i ++ ) { int row = lower_bound ( A , 0 , A . Length , B [ i ] ) ; int boxNumber = ( row >= 1 ) ? B [ i ] - A [ row - 1 ] : B [ i ] ; Console . WriteLine ( row + 1 + "" , ▁ "" + boxNumber + "" STRNEWLINE "" ) ; } } private static int lower_bound ( int [ ] a , int low , int high , int element ) { while ( low < high ) { int middle = low + ( high - low ) / 2 ; if ( element > a [ middle ] ) { low = middle + 1 ; } else { high = middle ; } } return low ; } static public void Main ( ) { int [ ] A = { 2 , 2 , 2 , 2 } ; int [ ] B = { 1 , 2 , 3 , 4 } ; int sizeOfA = A . Length ; int sizeOfB = B . Length ; printPosition ( A , B , sizeOfA , sizeOfB ) ; } }";"Find the position of box which occupies the given ball | C # implementation of the approach ; Function to print the position of each boxes where a ball has to be placed ; Find the cumulative sum of array A [ ] ; Find the position of box for each ball ; Row number ; Column ( position of box in particular row ) ; Row + 1 denotes row if indexing of array start from 1 ; Driver code"
C#;"using System ; class GFG { static void primeFactors ( int n , int [ ] freq ) { int cnt = 0 ; while ( n % 2 == 0 ) { cnt ++ ; n = n / 2 ; } freq [ 2 ] = cnt ; for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { cnt = 0 ; while ( n % i == 0 ) { cnt ++ ; n = n / i ; } freq [ i ] = cnt ; } if ( n > 2 ) freq [ n ] = 1 ; } static int getMaximumPower ( int n , int m ) { int [ ] freq1 = new int [ n + 1 ] ; int [ ] freq2 = new int [ m + 1 ] ; primeFactors ( n , freq1 ) ; primeFactors ( m , freq2 ) ; int maxi = 0 ; for ( int i = 2 ; i <= m ; i ++ ) { if ( freq1 [ i ] == 0 && freq2 [ i ] == 0 ) continue ; if ( freq2 [ i ] > freq1 [ i ] ) return 0 ; if ( freq2 [ i ] != 0 ) { maxi = Math . Max ( maxi , freq1 [ i ] / freq2 [ i ] ) ; } } return maxi ; } public static void Main ( String [ ] args ) { int n = 48 , m = 4 ; Console . WriteLine ( getMaximumPower ( n , m ) ) ; } }";"Highest power of a number that divides other number | C # program to implement the above approach ; Function to get the prime factors and its count of times it divides ; Count the number of 2 s that divide n ; n must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; While i divides n , count i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; Function to return the highest power ; Initialize two arrays ; Get the prime factors of n and m ; Iterate and find the maximum power ; If i not a prime factor of n and m ; If i is a prime factor of n and m If count of i dividing m is more than i dividing n , then power will be 0 ; If i is a prime factor of M ; get the maximum power ; Drivers code"
C#;"using System ; class GFG { static void findDivisors ( int n ) { int [ ] div = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j * i <= n ; j ++ ) div [ i * j ] ++ ; } for ( int i = 1 ; i <= n ; i ++ ) Console . Write ( div [ i ] + "" ▁ "" ) ; } static void Main ( ) { int n = 10 ; findDivisors ( n ) ; } }";"Find the number of divisors of all numbers in the range [ 1 , n ] | C # implementation of the approach ; Function to find the number of divisors of all numbers in the range [ 1 , n ] ; Array to store the count of divisors ; For every number from 1 to n ; Increase divisors count for every number divisible by i ; Print the divisors ; Driver code"
C#;"using System ; class GFG { static int decideWinner ( int [ ] a , int n ) { int count0 = 0 ; int count1 = 0 ; int count2 = 0 ; int count3 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 4 == 0 ) count0 ++ ; else if ( a [ i ] % 4 == 1 ) count1 ++ ; else if ( a [ i ] % 4 == 2 ) count2 ++ ; else if ( a [ i ] % 4 == 3 ) count3 ++ ; } if ( count0 % 2 == 0 && count1 % 2 == 0 && count2 % 2 == 0 && count3 == 0 ) return 1 ; else return 2 ; } public static void Main ( ) { int [ ] a = { 4 , 8 , 5 , 9 } ; int n = a . Length ; if ( decideWinner ( a , n ) == 1 ) Console . Write ( "" X ▁ wins "" ) ; else Console . Write ( "" Y ▁ wins "" ) ; } }";"Predict the winner of the game on the basis of absolute difference of sum by selecting numbers | C # implementation of the approach ; Function to decide the winner ; Iterate for all numbers in the array ; If mod gives 0 ; If mod gives 1 ; If mod gives 2 ; If mod gives 3 ; Check the winning condition for X ; Driver code"
C#;"using System ; class GFG { public static int CntDivbyX ( int [ ] arr , int n , int x ) { int number = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { number = ( number * 2 + arr [ i ] ) % x ; if ( number == 0 ) count += 1 ; } return count ; } public static void Main ( ) { int [ ] arr = { 1 , 0 , 1 , 0 , 1 , 1 , 0 } ; int n = 7 ; int x = 2 ; Console . Write ( CntDivbyX ( arr , n , x ) ) ; } }";"Count all prefixes of the given binary array which are divisible by x | C # implementation of the approach ; Function to return the count of total binary prefix which are divisible by x ; Initialize with zero ; Instead of converting all prefixes to decimal , take reminder with x ; If number is divisible by x then reminder = 0 ; Driver code"
C#;"using System ; class GFG { public static int numLen ( int K ) { if ( K % 2 == 0 K % 5 == 0 ) return - 1 ; int number = 0 ; int len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = ( number * 10 + 1 ) % K ; if ( number == 0 ) return len ; } return - 1 ; } public static void Main ( ) { int K = 7 ; Console . WriteLine ( numLen ( K ) ) ; } }";"Length of the smallest number which is divisible by K and formed by using 1 's only | C # implementation of the approach ; Function to return length of the resultant number ; If K is a multiple of 2 or 5 ; Instead of generating all possible numbers 1 , 11 , 111 , 111 , ... , K 1 's  Take remainder with K ; If number is divisible by k then remainder will be 0 ; Driver code"
C#;"using System ; class GFG { static int max_Element = ( int ) ( 1e6 + 5 ) ; static int [ ] sum1 = new int [ max_Element ] ; static int [ ] sum2 = new int [ max_Element ] ; static int [ ] sum3 = new int [ max_Element ] ; static void precomputation ( int [ ] arr , int n ) { for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum1 [ j ] += i ; for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum2 [ j ] += ( sum1 [ j ] - i ) * i ; for ( int i = 1 ; i < max_Element ; i ++ ) sum2 [ i ] /= 2 ; for ( int i = 1 ; i < max_Element ; i ++ ) for ( int j = i ; j < max_Element ; j += i ) sum3 [ j ] += i * ( sum2 [ j ] - i * ( sum1 [ j ] - i ) ) ; for ( int i = 1 ; i < max_Element ; i ++ ) sum3 [ i ] /= 3 ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( sum3 [ arr [ i ] ] + "" ▁ "" ) ; } public static void Main ( ) { int [ ] arr = { 9 , 5 , 6 } ; int n = arr . Length ; precomputation ( arr , n ) ; } }";"Sum of multiplication of triplet of divisors of a number | C # implementation of the approach ; Global array declaration ; Function to find the sum of multiplication of every triplet in the divisors of a number ; sum1 [ x ] represents the sum of all the divisors of x ; Adding i to sum1 [ j ] because i is a divisor of j ; sum2 [ x ] represents the sum of all the divisors of x ; Here i is divisor of j and sum1 [ j ] - i represents sum of all divisors of j which do not include i so we add i * ( sum1 [ j ] - i ) to sum2 [ j ] ; In the above implementation we have considered every pair two times so we have to divide every sum2 array element by 2 ; Here i is the divisor of j and we are trying to add the sum of multiplication of all triplets of divisors of j such that one of the divisors is i ; In the above implementation we have considered every triplet three times so we have to divide every sum3 array element by 3 ; Print the results ; Driver code ; Precomputing"
C#;"using System ; class GFG { static int fib ( int n ) { double phi = ( 1 + Math . Sqrt ( 5 ) ) / 2 ; return ( int ) Math . Round ( Math . Pow ( phi , n ) / Math . Sqrt ( 5 ) ) ; } static int calculateSum ( int l , int r ) { int sum = fib ( r + 2 ) - fib ( l + 1 ) ; return sum ; } public static void Main ( ) { int l = 4 , r = 8 ; Console . WriteLine ( calculateSum ( l , r ) ) ; } }";"Sum of Fibonacci Numbers in a range | C # implementation of the approach ; Function to return the nth Fibonacci number ; Function to return the required sum ; Using our deduced result ; Driver code"
C#;"using System ; class GFG { static void printBalancedExpression ( int a , int b , int c , int d ) { if ( ( ( a == d ) && ( a != 0 ) ) || ( ( a == 0 ) && ( c == 0 ) && ( d == 0 ) ) ) { for ( int i = 1 ; i <= a ; i ++ ) Console . Write ( "" ( ( "" ) ; for ( int i = 1 ; i <= c ; i ++ ) Console . Write ( "" ) ( "" ) ; for ( int i = 1 ; i <= d ; i ++ ) Console . Write ( "" ) ) "" ) ; for ( int i = 1 ; i <= b ; i ++ ) Console . Write ( "" ( ) "" ) ; } else Console . Write ( - 1 ) ; } public static void Main ( ) { int a = 3 , b = 1 , c = 4 , d = 3 ; printBalancedExpression ( a , b , c , d ) ; } }";"Print the balanced bracket expression using given brackets | C # implementation of the approach ; Function to print balanced bracket expression if it is possible ; If the condition is met ; Print brackets of type - 1 ; Print brackets of type - 3 ; Print brackets of type - 4 ; Print brackets of type - 2 ; If the condition is not met ; Driver code"
C#;"using System ; class GFG { static int factorial ( int f ) { int fact = 1 ; for ( int i = 2 ; i <= f ; i ++ ) fact *= ( int ) i ; return fact ; } static int findPermutation ( int N , int M ) { int permutation = factorial ( N + M - 1 ) / ( factorial ( N ) * factorial ( M - 1 ) ) ; return permutation ; } public static void Main ( ) { int N = 3 , M = 3 ; Console . Write ( findPermutation ( N , M ) ) ; } }";"Count numbers having N 0 ' s ▁ and ▁ and ▁ M ▁ 1' s with no leading zeros | C # implementation of the approach ; Function to return the factorial of a number ; Function to return the count of distinct ( N + M ) digit numbers having N 0 ' s ▁ and ▁ and ▁ M ▁ 1' s with no leading zeros ; Driver code"
C#;"using System ; class GFG { static int maxValue ( int n ) { if ( n == 1 ) return 0 ; return ( ( n * n / 2 ) - 1 ) ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( maxValue ( n ) ) ; } }";"Maximum value of | arr [ 0 ] | C # implementation of the approach ; Function to return the maximum required value ; Driver code"
C#;"using System ; class GFG { static void findCount ( int n ) { long a = 1 , b = 0 , c = 0 ; int x = n / 60 ; a = ( long ) Math . Pow ( 32 , x ) ; x = 60 * x ; for ( int i = x + 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { b += a ; a = 0 ; } if ( i % 5 == 0 ) { c += b ; b = 0 ; } if ( i % 12 == 0 ) { a += ( 2 * c ) ; c = 0 ; } } Console . WriteLine ( "" a ▁ = ▁ "" + a + "" , ▁ b ▁ = ▁ "" + b + "" , ▁ c ▁ = ▁ "" + c ) ; } static void Main ( ) { int n = 72 ; findCount ( n ) ; } }";"Count of a , b & c after n seconds for given reproduction rate | C # implementation of the approach ; Function to print the count of a , b and c after n seconds ; Number of multiples of 60 below n ; Multiple of 60 nearest to n ; Change all a to b ; Change all b to c ; Change each c to two a ; Print the updated values of a , b and c ; Driver code"
C#;"using System ; class GFG { static int factorial ( int n ) { return ( n == 1 n == 0 ) ? 1 : factorial ( n - 1 ) * n ; } static int gcdOfFactorial ( int [ ] arr , int n ) { int minm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) minm = minm > arr [ i ] ? arr [ i ] : minm ; return factorial ( minm ) ; } static void Main ( ) { int [ ] arr = { 9 , 12 , 122 , 34 , 15 } ; int n = arr . Length ; Console . WriteLine ( gcdOfFactorial ( arr , n ) ) ; } }";"Find GCD of factorial of elements of given array | C # implementation of the above approach ; Implementation of factorial function ; Function to find GCD of factorial of elements from array ; find the minimum element of array ; return the factorial of minimum element ; Driver Code"
C#;"using System ; class GFG { static long sum ( int n ) { if ( n == 1 ) return 1 ; else return ( ( long ) Math . Pow ( n , n ) + sum ( n - 1 ) ) ; } public static void Main ( ) { int n = 2 ; Console . Write ( sum ( n ) ) ; } }";"Sum of the series 1 ^ 1 + 2 ^ 2 + 3 ^ 3 + ... . . + n ^ n using recursion | C # implementation of the approach ; Recursive function to return the sum of the given series ; 1 ^ 1 = 1 ; Recursive call ; Driver code"
C#;"using System ; class GFG { static int mod = 1000000007 ; static long power ( long a , long n ) { if ( n == 0 ) return 1 ; long p = power ( a , n / 2 ) % mod ; p = ( p * p ) % mod ; if ( ( n & 1 ) == 1 ) p = ( p * a ) % mod ; return p ; } static int countPermutations ( int n ) { if ( n == 1 ) { return 0 ; } return ( ( int ) power ( 2 , n - 1 ) - 2 ) % mod ; } static public void Main ( ) { int n = 5 ; Console . WriteLine ( countPermutations ( n ) ) ; } }";"Count permutations that are first decreasing then increasing . | C # implementation of the above approach ; Function to compute a ^ n % mod ; Function to count permutations that are first decreasing and then increasing ; For n = 1 return 0 ; Calculate and return result ; Driver code"
C#;"using System ; class GFG { static long numbers ( int n ) { return ( long ) ( Math . Pow ( 2 , n + 1 ) ) - 2 ; } static void Main ( ) { int n = 2 ; Console . WriteLine ( numbers ( n ) ) ; } }";"Find the count of numbers that can be formed using digits 3 , 4 only and having length at max N . | C # program to find the count of numbers that can be formed using digits 3 , 4 only and having length at max N . ; Function to find the count of numbers that can be formed using digits 3 , 4 only and having length at max N . ; Driver code"
C#;"using System ; class GFG { public static long NumberofWays ( int n ) { long x = ( 1l * ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) / ( 4 * 3 * 2 * 1 ) ; long y = ( 1l * ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) ; return ( 1l * x * y ) ; } public static void Main ( string [ ] args ) { int n = 4 ; Console . WriteLine ( NumberofWays ( n ) ) ; } }";"Ways to place 4 items in n ^ 2 positions such that no row / column contains more than one | C # implementation of the approach ; Function to return the number of ways to place 4 items in n ^ 2 positions ; Driver code"
C#;"using System ; public class GFG { public static int nthTerm ( int N ) { int nth = 0 ; nth = ( N * N * ( N + 1 ) ) / 2 ; return nth ; } public static void Main ( string [ ] args ) { int N = 5 ; Console . WriteLine ( nthTerm ( N ) ) ; } }";"Find Nth term of the series 1 , 6 , 18 , 40 , 75 , ... . | C # code to generate ' Nth ' term of this sequence ; Function to generate a fixed number ; ( N ^ 2 * ( N + 1 ) ) / 2 ; Driver Method"
C#;"using System ; public class GFG { public static void findNumbers ( int n ) { int i = 1 ; while ( i <= n ) { Console . Write ( ( ( 2 * i ) - 1 ) + "" ▁ "" ) ; i ++ ; } } public static void Main ( string [ ] args ) { int n = 3 ; findNumbers ( n ) ; } }";"Print n numbers such that their sum is a perfect square | C # implementation of the approach ; Function to print n numbers such that their sum is a perfect square ; Print ith odd number ; Driver code"
C#;"using System ; class GFG { static void findMissingNums ( int [ ] even , int sizeEven , int [ ] odd , int sizeOdd ) { int minEven = int . MaxValue ; int maxEven = int . MinValue ; int minOdd = int . MaxValue ; int maxOdd = int . MinValue ; int sumEvenArr = 0 , sumOddArr = 0 ; for ( int i = 0 ; i < sizeEven ; i ++ ) { minEven = Math . Min ( minEven , even [ i ] ) ; maxEven = Math . Max ( maxEven , even [ i ] ) ; sumEvenArr += even [ i ] ; } for ( int i = 0 ; i < sizeOdd ; i ++ ) { minOdd = Math . Min ( minOdd , odd [ i ] ) ; maxOdd = Math . Max ( maxOdd , odd [ i ] ) ; sumOddArr += odd [ i ] ; } int totalTerms = 0 , reqSum = 0 ; totalTerms = minEven / 2 ; int evenSumMin = ( totalTerms * ( totalTerms + 1 ) ) ; totalTerms = maxEven / 2 ; int evenSumMax = ( totalTerms * ( totalTerms + 1 ) ) ; reqSum = evenSumMax - evenSumMin + minEven ; Console . WriteLine ( "" Even ▁ = ▁ "" + ( reqSum - sumEvenArr ) ) ; totalTerms = ( minOdd / 2 ) + 1 ; int oddSumMin = totalTerms * totalTerms ; totalTerms = ( maxOdd / 2 ) + 1 ; int oddSumMax = totalTerms * totalTerms ; reqSum = oddSumMax - oddSumMin + minOdd ; Console . WriteLine ( "" Odd ▁ = ▁ "" + ( reqSum - sumOddArr ) ) ; } static void Main ( ) { int [ ] even = { 6 , 4 , 8 , 14 , 10 } ; int sizeEven = even . Length ; int [ ] odd = { 7 , 5 , 3 , 11 , 13 } ; int sizeOdd = odd . Length ; findMissingNums ( even , sizeEven , odd , sizeOdd ) ; } }";"Missing even and odd elements from the given arrays | C # implementation of the approach ; Function to find the missing numbers ; To store the minimum and the maximum odd and even elements from the arrays ; To store the sum of the array elements ; Get the minimum and the maximum even elements from the array ; Get the minimum and the maximum odd elements from the array ; To store the total terms in the series and the required sum of the array ; Total terms from 2 to minEven ; Sum of all even numbers from 2 to minEven ; Total terms from 2 to maxEven ; Sum of all even numbers from 2 to maxEven ; Required sum for the even array ; Missing even number ; Total terms from 1 to minOdd ; Sum of all odd numbers from 1 to minOdd ; Total terms from 1 to maxOdd ; Sum of all odd numbers from 1 to maxOdd ; Required sum for the odd array ; Missing odd number ; Driver code"
C#;"using System ; class GFG { static int findMinimum ( int x , int y ) { int low = 0 , high = y ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( ( mid * 2 + ( y - mid ) ) >= x ) high = mid - 1 ; else low = mid + 1 ; } return low ; } static public void Main ( ) { int x = 6 , y = 5 ; Console . WriteLine ( findMinimum ( x , y ) ) ; } }";"Minimum matches the team needs to win to qualify | C # implementation of the approach ; Function to return the minimum number of matches to win to qualify for next round ; Do a binary search to find ; Find mid element ; Check for condition to qualify for next round ; Driver code"
C#;"using System ; public class GFG { static void getResult ( int n ) { int proOdd = 1 ; int proEven = 1 ; String num = String . Join ( "" "" , n ) ; for ( int i = 0 ; i < num . Length ; i ++ ) if ( i % 2 == 0 ) proOdd = proOdd * ( num [ i ] - '0' ) ; else proEven = proEven * ( num [ i ] - '0' ) ; if ( proOdd == proEven ) Console . Write ( "" Yes "" ) ; else Console . Write ( "" No "" ) ; } public static void Main ( String [ ] args ) { int n = 4324 ; getResult ( n ) ; } }";"Check if product of digits of a number at even and odd places is equal | C # implementation of the approach ; To store the respective product ; Converting integer to String ; Traversing the String ; Driver code"
C#;"using System ; class GFG { static int sumOfDigits ( int x ) { int sum = 0 ; while ( x != 0 ) { sum += x % 10 ; x = x / 10 ; } return sum ; } static int countNumbers ( int l , int r ) { int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( i % 2 == 0 && sumOfDigits ( i ) % 3 == 0 ) count ++ ; } return count ; } public static void Main ( ) { int l = 1000 , r = 6000 ; Console . WriteLine ( countNumbers ( l , r ) ) ; } }";"Count of all even numbers in the range [ L , R ] whose sum of digits is divisible by 3 | C # implementation of the approach ; Function to return the sum of digits of x ; Function to return the count of required numbers ; If i is divisible by 2 and sum of digits of i is divisible by 3 ; Return the required count ; Driver code"
C#;"using System ; class GfG { static int findMinSum ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] * ( n - i ) ; return sum ; } public static void Main ( String [ ] args ) { int [ ] arr = { 3 , 5 , 7 , 8 } ; int n = arr . Length ; Console . WriteLine ( findMinSum ( arr , n ) ) ; } }";"Sum of minimum element of all subarrays of a sorted array | C # implementation of the above approach ; Function to find the sum of minimum of all subarrays ; Driver code"
C#;"using System ; class GFG { static int maxLenSubArr ( int [ ] a , int n ) { int count , j ; int cm = 1 , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max ) max = a [ i ] ; } for ( int i = 0 ; i < n - 1 ; ) { count = 1 ; if ( a [ i ] == a [ i + 1 ] && a [ i ] == max ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] == max ) { count ++ ; i ++ ; } else break ; } if ( count > cm ) cm = count ; } else i ++ ; } return cm ; } static public void Main ( ) { int [ ] arr = { 6 , 1 , 6 , 6 , 0 } ; int n = arr . Length ; Console . WriteLine ( maxLenSubArr ( arr , n ) ) ; } }";"Longest Sub | C # implementation of the approach ; Function to return the max length of the sub - array that have the maximum average ( average value of the elements ) ; Finding the maximum value ; If consecutive maximum found ; Find the max length of consecutive max ; Driver code"
C#;"using System ; class GFG { static int minSum ( int [ ] arr , int n , int x ) { int sum = 0 ; int largestDivisible = - 1 , minimum = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % x == 0 && largestDivisible < arr [ i ] ) largestDivisible = arr [ i ] ; if ( arr [ i ] < minimum ) minimum = arr [ i ] ; } if ( largestDivisible == - 1 ) return sum ; int sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ; return Math . Min ( sum , sumAfterOperation ) ; } public static void Main ( ) { int [ ] arr = { 5 , 5 , 5 , 5 , 6 } ; int n = arr . Length ; int x = 3 ; Console . WriteLine ( minSum ( arr , n , x ) ) ; } }";"Minimum possible sum of array elements after performing the given operation | C # implementation of the approach ; Function to return the minimized sum ; To store the largest element from the array which is divisible by x ; Sum of array elements before performing any operation ; If current element is divisible by x and it is maximum so far ; Update the minimum element ; If no element can be reduced then there 's no point in performing the  operation as we will end up increasing  the sum when an element is multiplied by x ; Subtract the chosen elements from the sum and then add their updated values ; Return the minimized sum ; Driver code"
C#;"using System ; class GfG { static int maxAND ( int L , int R ) { if ( L == R ) return L ; else if ( ( R - L ) == 1 ) return ( R & L ) ; else { if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) return ( ( R - 1 ) & R ) ; else return ( ( R - 2 ) & ( R - 1 ) ) ; } } public static void Main ( ) { int L = 1 , R = 632 ; Console . WriteLine ( maxAND ( L , R ) ) ; } }";"Maximum Bitwise AND pair from given range | C # implementation of the approach ; Function to return the maximum bitwise AND possible among all the possible pairs ; If there is only a single value in the range [ L , R ] ; If there are only two values in the range [ L , R ] ; Driver code"
C#;"using System ; class GFG { static bool checkSpecialPrime ( bool [ ] sieve , int num ) { while ( num > 0 ) { if ( sieve [ num ] ) { return false ; } num /= 10 ; } return true ; } static void findSpecialPrime ( int N ) { bool [ ] sieve = new bool [ N * 10 + 1 ] ; sieve [ 0 ] = sieve [ 1 ] = true ; for ( int i = 2 ; i <= N * 10 ; i ++ ) { if ( ! sieve [ i ] ) { for ( int j = i * i ; j <= N * 10 ; j += i ) { sieve [ j ] = true ; } } } while ( true ) { if ( checkSpecialPrime ( sieve , N ) ) { Console . WriteLine ( N ) ; break ; } else N ++ ; } } static void Main ( ) { int N = 379 ; findSpecialPrime ( N ) ; N = 100 ; findSpecialPrime ( N ) ; } }";"Smallest Special Prime which is greater than or equal to a given number | C # program to find the Smallest Special Prime which is greater than or equal to a given number ; Function to check whether the number is a special prime or not ; While number is not equal to zero ; If the number is not prime return false . ; Else remove the last digit by dividing the number by 10. ; If the number has become zero then the number is special prime , hence return true ; Function to find the Smallest Special Prime which is greater than or equal to a given number ; Initially all numbers are considered Primes . ; There is always an answer possible ; Checking if the number is a special prime or not ; If yes print the number and break the loop . ; Else increment the number . ; Driver code"
C#;"using System ; class GFG { static int minMoves ( int n ) { string s = n . ToString ( ) ; int ans = Int32 . MaxValue ; int len = s . Length ; for ( int i = 0 ; i < len ; ++ i ) { for ( int j = 0 ; j < len ; ++ j ) { if ( i == j ) continue ; char [ ] t = s . ToCharArray ( ) ; int cur = 0 ; for ( int k = i ; k < len - 1 ; ++ k ) { swap ( t , k , k + 1 ) ; ++ cur ; } for ( int k = j - ( ( j > i ) ? 1 : 0 ) ; k < len - 2 ; ++ k ) { swap ( t , k , k + 1 ) ; ++ cur ; } int pos = - 1 ; for ( int k = 0 ; k < len ; ++ k ) { if ( t [ k ] != '0' ) { pos = k ; break ; } } for ( int k = pos ; k > 0 ; -- k ) { swap ( t , k , k - 1 ) ; ++ cur ; } int nn = Convert . ToInt32 ( new String ( t ) ) ; if ( nn % 25 == 0 ) ans = Math . Min ( ans , cur ) ; } } if ( ans == Int32 . MaxValue ) return - 1 ; return ans ; } static void swap ( char [ ] t , int i , int j ) { char temp = t [ i ] ; t [ i ] = t [ j ] ; t [ j ] = temp ; } static void Main ( ) { int n = 509201 ; Console . WriteLine ( minMoves ( n ) ) ; } }";"Minimum number of given moves required to make N divisible by 25 | C # implementation of the approach ; Function to return the minimum number of moves required to make n divisible by 25 ; Convert number into string ; To store required answer ; Length of the string ; To check all possible pairs ; Make a duplicate string ; Number of swaps required to place ith digit in last position ; Number of swaps required to place jth digit in 2 nd last position ; Find first non zero digit ; Place first non zero digit in the first position ; Convert string to number ; If this number is divisible by 25 then cur is one of the possible answer ; If not possible ; Driver code"
C#;"using System ; class GFG { static int getMaxNum ( int a , int b , int c ) { if ( b % c == 0 ) return b ; int x = ( ( b / c ) * c ) ; if ( x >= a && x <= b ) return x ; else return - 1 ; } public static void Main ( ) { int a = 2 , b = 10 , c = 3 ; Console . WriteLine ( getMaxNum ( a , b , c ) ) ; } }";"Maximum positive integer divisible by C and is in the range [ A , B ] | C # implementation of the above approach ; Function to return the required number ; If b % c = 0 then b is the required number ; Else get the maximum multiple of c smaller than b ; Driver code"
C#;"using System ; class GFG { static int getPairs ( int [ ] a ) { int n = a . Length ; int count = ( n * ( n - 1 ) ) / 2 ; return count ; } public static void Main ( ) { int [ ] a = { 2 , 4 , 3 , 1 } ; Console . Write ( getPairs ( a ) ) ; } }";"Count of pairs ( x , y ) in an array such that x < y | C # implementation of the approach ; Function to return the number of pairs ( x , y ) such that x < y ; Length of the array ; Calculate the number of valid pairs ; Return the count of valid pairs ; Driver code"
C#;"using System ; class GFG { static int countSquares ( int row , int column ) { int topLeft = Math . Min ( row , column ) - 1 ; int bottomRight = 8 - Math . Max ( row , column ) ; int topRight = Math . Min ( row , 9 - column ) - 1 ; int bottomLeft = 8 - Math . Max ( row , 9 - column ) ; return ( topLeft + topRight + bottomRight + bottomLeft ) ; } public static void Main ( ) { int row = 4 , column = 4 ; Console . WriteLine ( countSquares ( row , column ) ) ; } }";"Count the total number of squares that can be visited by Bishop in one move | C # implementation of above approach ; Function to return the count of total positions the Bishop can visit in a single move ; Count top left squares ; Count bottom right squares ; Count top right squares ; Count bottom left squares ; Return total count ; Driver code ; Bishop 's Position"
C#;"using System ; class GFG { static bool canTakeDown ( int bishopX , int bishopY , int pawnX , int pawnY ) { if ( pawnX - bishopX == pawnY - bishopY ) return true ; else if ( - pawnX + bishopX == pawnY - bishopY ) return true ; else return false ; } public static void Main ( ) { int bishopX = 5 , bishopY = 5 ; int pawnX = 1 , pawnY = 1 ; if ( canTakeDown ( bishopX , bishopY , pawnX , pawnY ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Check whether Bishop can take down Pawn or not | C # implementation of above approach ; Function that return true if the Bishop can take down the pawn ; If pawn is at angle 45 or 225 degree from bishop 's Position ; If pawn is at angle 135 or 315 degree from bishop 's Position ; Driver code ; Bishop 's Position ; Pawn 's Position"
C#;"using System ; class GFG { static int N = 1000005 ; static int [ ] primeFactors = new int [ N ] ; static void findPrimeFactors ( ) { for ( int i = 2 ; i < N ; i ++ ) if ( primeFactors [ i ] == 0 ) for ( int j = i ; j < N ; j += i ) primeFactors [ j ] = primeFactors [ j / i ] + 1 ; for ( int i = 1 ; i < N ; i ++ ) primeFactors [ i ] += primeFactors [ i - 1 ] ; } static public void Main ( ) { findPrimeFactors ( ) ; int a = 6 , b = 3 ; Console . WriteLine ( primeFactors [ a ] - primeFactors [ b ] ) ; } }";"Find maximum operations to reduce N to 1 | C # program to find maximum number moves possible ; To store number of prime factors of each number ; Function to find number of prime factors of each number ; if i is a prime number ; increase value by one from it 's preveious multiple ; make prefix sum this will be helpful for multiple test cases ; Driver Code ; Generate primeFactors array ; required answer"
C#;"using System ; class GFG { static int digitSum ( int n ) { int ans = 0 ; while ( n != 0 ) { ans += n % 10 ; n /= 10 ; } return ans ; } static int findInt ( int n , int m ) { int minDigit = ( int ) Math . Floor ( ( double ) ( m / 9 ) ) ; int start = ( int ) Math . Pow ( 10 , minDigit ) - ( int ) Math . Pow ( 10 , minDigit ) % n ; while ( start < int . MaxValue ) { if ( digitSum ( start ) == m ) return start ; else start += n ; } return - 1 ; } static public void Main ( ) { int n = 13 , m = 32 ; Console . WriteLine ( findInt ( n , m ) ) ; } }";"Smallest integer with digit sum M and multiple of N | C # implementation of the above approach ; Function to return digit sum ; Function to find out the smallest integer ; Start of the iterator ( Smallest multiple of n ) ; Driver code"
C#;"using System ; class GFG { static double smallestDivisor ( int n ) { double mx = Math . Sqrt ( n ) ; for ( int i = 2 ; i <= mx ; i ++ ) if ( n % i == 0 ) return i ; return n ; } static double maxSum ( int n ) { long res = n ; while ( n > 1 ) { double divi = smallestDivisor ( n ) ; n /= ( int ) divi ; res += n ; } return res ; } public static void Main ( ) { int n = 34 ; Console . WriteLine ( maxSum ( n ) ) ; } }";"Maximum sum after repeatedly dividing N by a divisor | C # implementation of the above approach ; Function to find the smallest divisor ; Function to find the maximum sum ; Driver Code"
C#;"using System ; class GFG { static bool isPossible ( int n , int k , int [ ] arr ) { int sum = arr [ 0 ] ; int maxVal = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { sum += arr [ i ] ; maxVal = Math . Max ( maxVal , arr [ i ] ) ; } if ( ( float ) maxVal > ( float ) ( sum + k ) / n ) return false ; return true ; } public static void Main ( ) { int k = 8 ; int [ ] arr = { 1 , 2 , 3 , 4 } ; int n = arr . Length ; if ( isPossible ( n , k , arr ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Make all elements of an array equal with the given operation | C # implementation of the approach ; Function that returns true if all the elements of the array can be made equal with the given operation ; To store the sum of the array elements and the maximum element from the array ; Driver code"
C#;"using System ; class GFG { static int maxResult ( int n , int a , int b , int c ) { int maxVal = 0 ; for ( int i = 0 ; i <= n ; i += a ) for ( int j = 0 ; j <= n - i ; j += b ) { float z = ( float ) ( n - ( i + j ) ) / ( float ) c ; if ( Math . Floor ( z ) == Math . Ceiling ( z ) ) { int x = i / a ; int y = j / b ; maxVal = Math . Max ( maxVal , x + y + ( int ) z ) ; } } return maxVal ; } public static void Main ( String [ ] args ) { int n = 10 , a = 5 , b = 3 , c = 4 ; Console . WriteLine ( maxResult ( n , a , b , c ) ) ; } }";"Maximize the value of x + y + z such that ax + by + cz = n | C # implementation of the approach ; Function to return the maximum value of ( x + y + z ) such that ( ax + by + cz = n ) ; i represents possible values of a * x ; j represents possible values of b * y ; If z is an integer ; Driver code ; Function Call"
C#;"using System ; class GFG { static bool EqualNumbers ( int [ ] a , int n ) { for ( int i = 0 ; i < n ; i ++ ) { while ( a [ i ] % 2 == 0 ) { a [ i ] /= 2 ; } while ( a [ i ] % 3 == 0 ) { a [ i ] /= 3 ; } if ( a [ i ] != a [ 0 ] ) { return false ; } } return true ; } public static void Main ( ) { int [ ] a = { 50 , 75 , 150 } ; int n = a . Length ; if ( EqualNumbers ( a , n ) ) { Console . WriteLine ( "" Yes "" ) ; } else { Console . WriteLine ( "" No "" ) ; } } }";"Make all numbers of an array equal | C # implementation of above approach ; Function that returns true if all the array elements can be made equal with the given operation ; Divide number by 2 ; Divide number by 3 ; Driver code"
C#;"using System ; class GFG { static long max_gcd ( long n , long p ) { int count = 0 ; long gcd = 1 ; while ( p % 2 == 0 ) { p >>= 1 ; count ++ ; } if ( count > 0 ) gcd *= ( long ) Math . Pow ( 2 , count / n ) ; for ( long i = 3 ; i <= Math . Sqrt ( p ) ; i += 2 ) { count = 0 ; while ( p % i == 0 ) { count ++ ; p = p / i ; } if ( count > 0 ) { gcd *= ( long ) Math . Pow ( i , count / n ) ; } } if ( p > 2 ) gcd *= ( long ) Math . Pow ( p , 1 / n ) ; return gcd ; } public static void Main ( ) { long n = 3 ; long p = 80 ; Console . WriteLine ( max_gcd ( n , p ) ) ; } }";"Maximum GCD from Given Product of Unknowns | C # implementation of the approach ; Function to return the required gcd ; Count the number of times 2 divides p ; Equivalent to p = p / 2 ; ; If 2 divides p ; Check all the possible numbers that can divide p ; If n in the end is a prime number ; Return the required gcd ; Driver code"
C#;"using System ; class GFG { static int getMinNum ( int a , int b , int c ) { if ( c < a c > b ) { return c ; } int x = ( ( b / c ) * c ) + c ; return x ; } static public void Main ( ) { int a = 2 , b = 4 , c = 4 ; Console . WriteLine ( getMinNum ( a , b , c ) ) ; } }";"Minimum positive integer divisible by C and is not in range [ A , B ] | C # implementation of the approach ; Function to return the required number ; If doesn 't belong to the range  then c is the required number ; Else get the next multiple of c starting from b + 1 ; Driver code"
C#;"using System ; class GFG { static int countPairs ( int n ) { if ( n == 2 ) return 4 ; int num = ( ( n / 2 ) + 1 ) ; int max = n % num ; int count = n - max ; return count ; } static public void Main ( ) { int n = 5 ; Console . WriteLine ( countPairs ( n ) ) ; } }";"Count of pairs of ( i , j ) such that ( ( n % i ) % j ) % n is maximized | C # implementation of above approach ; Function to return the count of required pairs ; Special case ; Number which will give the max value for ( ( n % i ) % j ) % n ; To store the maximum possible value of ( ( n % i ) % j ) % n ; Count of possible pairs ; Driver code"
C#;"using System ; class GFG { static bool checkSub ( string sub , string s ) { int j = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) if ( sub [ j ] == s [ i ] ) j ++ ; return j == sub . Length ; } static int getMultiple ( string s ) { for ( int i = 0 ; i < 1e3 ; i += 8 ) { if ( checkSub ( i . ToString ( ) , s ) ) return i ; } return - 1 ; } static void Main ( ) { string s = ""3454"" ; Console . WriteLine ( getMultiple ( s ) ) ; } }";"Remove characters from a numeric string such that string becomes divisible by 8 | C # program to remove digits from a numeric string such that the number becomes divisible by 8 ; Function that return true if sub is a sub - sequence in s ; Function to return a multiple of 8 formed after removing 0 or more characters from the given string ; Iterate over all multiples of 8 ; If current multiple exists as a subsequence in the given string ; Driver Code"
C#;"using System ; public class GFG { static String getResult ( int n ) { string st = n . ToString ( ) ; for ( int i = 0 ; i < st . Length ; i ++ ) { int d = st [ i ] - 48 ; if ( n % d == 0 ) { return "" Yes "" ; } } return "" No "" ; } public static void Main ( String [ ] args ) { int n = 9876543 ; Console . Write ( getResult ( n ) ) ; } }";"Program to check if a number is divisible by any of its digits | C # implementation of above approach ; Converting integer to string ; Traversing the string ; find the actual digit ; If the number is divisible by digits then return yes ; If no digits are dividing the number then return no ; Driver Code ; passing this number to get result function"
C#;"using System ; class GFG { static float sum ( float n ) { if ( n < 2 ) return 1 ; else return 1 / n + ( sum ( n - 1 ) ) ; } public static void Main ( ) { Console . WriteLine ( sum ( 8 ) ) ; Console . WriteLine ( sum ( 10 ) ) ; } }";"Program to find sum of harmonic series | C # program to find sum of harmonic series using recursion ; Base condition ; Driven Code"
C#;"using System ; using System . Collections ; class GFG { static ArrayList findingValues ( int m , int n , int mth , int nth ) { int d = ( Math . Abs ( mth - nth ) ) / Math . Abs ( ( m - 1 ) - ( n - 1 ) ) ; int a = mth - ( ( m - 1 ) * d ) ; ArrayList res = new ArrayList ( ) ; res . Add ( a ) ; res . Add ( d ) ; return res ; } static int findSum ( int m , int n , int mth , int nth , int p ) { ArrayList ad = findingValues ( m , n , mth , nth ) ; int a = ( int ) ad [ 0 ] ; int d = ( int ) ad [ 1 ] ; int sum = ( p * ( 2 * a + ( p - 1 ) * d ) ) / 2 ; return sum ; } public static void Main ( ) { int m = 6 , n = 10 , mTerm = 12 , nTerm = 20 , p = 5 ; Console . WriteLine ( findSum ( m , n , mTerm , nTerm , p ) ) ; } }";"Sum of P terms of an AP if Mth and Nth terms are given | C # implementation of the above approach ; Function to calculate the value of the ; Calculate value of d using formula ; Calculate value of a using formula ; Return pair ; Function to calculate value sum of first p numbers of the series ; First calculate value of a and d ; Calculate the sum by using formula ; Return the sum ; Driver Code"
C#;"using System ; using System . Linq ; using System . Collections . Generic ; using System . Collections ; class GFG { static void powerfulIntegers ( int x , int y , int bound ) { HashSet < int > s = new HashSet < int > ( ) ; ArrayList powersOfY = new ArrayList ( ) ; int i ; powersOfY . Add ( 1 ) ; for ( i = y ; i < bound && y != 1 ; i = i * y ) powersOfY . Add ( i ) ; i = 0 ; while ( true ) { int xPowI = ( int ) Math . Pow ( x , i ) ; for ( int j = 0 ; j != powersOfY . Count ; ++ j ) { int num = xPowI + ( int ) powersOfY [ j ] ; if ( num <= bound ) s . Add ( num ) ; else break ; } if ( xPowI >= bound x == 1 ) break ; i ++ ; } int [ ] ar = s . ToArray ( ) ; Array . Sort ( ar ) ; s . Clear ( ) ; s . UnionWith ( ar ) ; foreach ( int t in s ) { Console . Write ( t + "" ▁ "" ) ; } } static void Main ( ) { int x = 2 , y = 3 , bound = 10 ; powerfulIntegers ( x , y , bound ) ; } }";"Print all integers that are sum of powers of two given numbers | C # implementation of the approach ; Function to print powerful integers ; Set is used to store distinct numbers in sorted order ; Store all the powers of y < bound in a vector to avoid calculating them again and again ; x ^ i ; If num is within limits insert it into the set ; Break out of the inner loop ; Adding any number to it will be out of bounds ; Increment i ; Print the contents of the set ; Driver code ; Print powerful integers"
C#;"using System ; class GFG { static void candies ( int n , int k ) { int count = 0 ; int ind = 1 ; int [ ] arr = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) arr [ i ] = 0 ; while ( n > 0 ) { int f1 = ( ind - 1 ) * k ; int f2 = ind * k ; int sum1 = ( f1 * ( f1 + 1 ) ) / 2 ; int sum2 = ( f2 * ( f2 + 1 ) ) / 2 ; int res = sum2 - sum1 ; if ( res <= n ) { count ++ ; n -= res ; ind ++ ; } { int i = 0 ; int term = ( ( ind - 1 ) * k ) + 1 ; while ( n > 0 ) { if ( term <= n ) { arr [ i ++ ] = term ; n -= term ; term ++ ; } else { arr [ i ++ ] = n ; n = 0 ; } } } } for ( int i = 0 ; i < k ; i ++ ) arr [ i ] += ( count * ( i + 1 ) ) + ( k * ( count * ( count - 1 ) ) / 2 ) ; for ( int i = 0 ; i < k ; i ++ ) Console . Write ( arr [ i ] + "" ▁ "" ) ; } public static void Main ( ) { int n = 10 , k = 3 ; candies ( n , k ) ; } }";"Distribute N candies among K people | C # code for better approach to distribute candies ; Function to find out the number of candies every person received ; Count number of complete turns ; Get the last term ; Stores the number of candies ; Last term of last and current series ; Sum of current and last series ; Sum of current series only ; If sum of current is less than N ; else Individually distribute ; First term ; Distribute candies till there ; Candies available ; Not available ; Count the total candies ; Print the total candies ; Driver Code"
C#;"using System ; class GFG { static void candies ( int n , int k ) { int count = 0 ; int ind = 1 ; int [ ] arr = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) arr [ i ] = 0 ; int low = 0 , high = n ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; int sum = ( mid * ( mid + 1 ) ) >> 1 ; if ( sum <= n ) { count = mid / k ; low = mid + 1 ; } else { high = mid - 1 ; } } int last = ( count * k ) ; n -= ( last * ( last + 1 ) ) / 2 ; int j = 0 ; int term = ( count * k ) + 1 ; while ( n > 0 ) { if ( term <= n ) { arr [ j ++ ] = term ; n -= term ; term ++ ; } else { arr [ j ] += n ; n = 0 ; } } for ( int i = 0 ; i < k ; i ++ ) arr [ i ] += ( count * ( i + 1 ) ) + ( k * ( count * ( count - 1 ) ) / 2 ) ; for ( int i = 0 ; i < k ; i ++ ) Console . Write ( arr [ i ] + "" ▁ "" ) ; } public static void Main ( ) { int n = 7 , k = 4 ; candies ( n , k ) ; } }";"Distribute N candies among K people | C # implementation of the above approach ; Function to find out the number of candies every person received ; Count number of complete turns ; Get the last term ; Stores the number of candies ; Do a binary search to find the number whose sum is less than N . ; Get mide ; If sum is below N ; Find number of complete turns ; Right halve ; Left halve ; Last term of last complete series ; Subtract the sum till ; First term of incomplete series ; Count the total candies ; Print the total candies ; Driver Code"
C#;"using System ; public class GFG { static int printSmallest ( int [ ] a ) { Array . Sort ( a ) ; int i , j , num ; for ( i = 0 ; i < 3 ; i ++ ) { if ( a [ i ] % 3 == 0 ) { return a [ i ] ; } } for ( i = 0 ; i < 3 ; i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) { num = ( a [ i ] * 10 ) + a [ j ] ; if ( num % 3 == 0 ) { return num ; } } } return a [ 0 ] * 100 + a [ 0 ] * 10 + a [ 0 ] ; } public static void Main ( ) { int [ ] arr = { 7 , 7 , 1 } ; Console . Write ( printSmallest ( arr ) ) ; } }";"Smallest multiple of 3 which consists of three given non | C # implementation of the approach ; Function to return the minimum number divisible by 3 formed by the given digits ; Sort the given array in ascending ; Check if any single digit is divisible by 3 ; Check if any two digit number formed by the given digits is divisible by 3 starting from the minimum ; Generate the two digit number ; If none of the above is true , we can form three digit number by taking a [ 0 ] three times . ; Driver code"
C#;"using System ; public class GFG { static void updateMatrix ( int n , int [ , ] q , int [ , ] mat ) { int i , j ; for ( i = 0 ; i < q . GetLength ( 0 ) ; i ++ ) { int X1 = q [ i , 0 ] ; int Y1 = q [ i , 1 ] ; int X2 = q [ i , 2 ] ; int Y2 = q [ i , 3 ] ; mat [ X1 , Y1 ] ++ ; if ( Y2 + 1 < n ) mat [ X2 , Y2 + 1 ] -- ; else if ( X2 + 1 < n ) mat [ X2 + 1 , 0 ] -- ; } int sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { sum += mat [ i , j ] ; Console . Write ( sum + "" ▁ "" ) ; } Console . WriteLine ( ) ; } } public static void Main ( ) { int n = 5 ; int [ , ] mat = new int [ n , n ] ; int [ , ] q = { { 0 , 0 , 1 , 2 } , { 1 , 2 , 3 , 4 } , { 1 , 4 , 3 , 4 } } ; updateMatrix ( n , q , mat ) ; } }";"Print matrix after applying increment operations in M ranges | C # implementation of the above approach ; Function to update and print the matrix after performing queries ; Add 1 to the first element of the sub - matrix ; If there is an element after the last element of the sub - matrix then decrement it by 1 ; Calculate the running sum ; Print the updated element ; Next line ; Driver code ; Size of the matrix ; Queries"
C#;"using System ; class GFG { static void printArr ( float [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + "" ▁ "" ) ; } static void replaceMax ( float [ ] arr , int n ) { float max = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } float min = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < min ) min = arr [ i ] ; } float range = max - min ; float coeffOfRange = range / ( max + min ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max ) { arr [ i ] = coeffOfRange ; break ; } } printArr ( arr , n ) ; } public static void Main ( ) { float [ ] arr = { 15 , 16 , 10 , 9 , 6 , 7 , 17 } ; int n = arr . Length ; replaceMax ( arr , n ) ; } }";"Replace the maximum element in the array by coefficient of range | C # implementation to replace maximum element by coefficient of range ; Utility function to print the contents of the array ; Function to replace the maximum element from the array with the coefficient of range of the array ; Maximum element from the array ; Minimum element from the arra ; Calculate the coefficient of range for the array ; Assuming all the array elements are distinc Replace the maximum element with the coefficient of range of the array ; Print the updated array ; Driver code"
C#;"using System ; class GFG { static void divide ( int a , int b ) { for ( int i = 2 ; i <= Math . Min ( a , b ) ; i ++ ) { while ( a % i == 0 && b % i == 0 ) { a = a / i ; b = b / i ; } } Console . WriteLine ( "" A ▁ = ▁ "" + a + "" , ▁ B ▁ = ▁ "" + b ) ; } static public void Main ( ) { int A = 10 , B = 15 ; divide ( A , B ) ; } }";"Divide the two given numbers by their common divisors | C # implementation of above approach ; print the numbers after dividing them by their common factors ; iterate from 1 to minimum of a and b ; if i is the common factor of both the numbers ; Driver code ; divide A and B by their common factors"
C#;"using System ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static void commDiv ( int a , int b ) { int n = gcd ( a , b ) ; a = a / n ; b = b / n ; Console . WriteLine ( "" A ▁ = ▁ "" + a + "" , ▁ B ▁ = ▁ "" + b ) ; } public static void Main ( ) { int a = 10 , b = 15 ; commDiv ( a , b ) ; } }";"Divide the two given numbers by their common divisors | C # implementation of above approach ; Function to calculate gcd of two numbers ; Function to calculate all common divisors of two given numbers a , b -- > input integer numbers ; find gcd of a , b ; Driver code"
C#;"using System ; public class GFG { static int minAbsDiff ( int n ) { int left = 1 << ( ( int ) Math . Floor ( Math . Log ( n ) / Math . Log ( 2 ) ) ) ; int right = left * 2 ; return Math . Min ( ( n - left ) , ( right - n ) ) ; } static public void Main ( ) { int n = 15 ; Console . WriteLine ( minAbsDiff ( n ) ) ; } }";"Minimum absolute difference between N and a power of 2 | C # implementation of the above approach ; Function to return the minimum difference between N and a power of 2 ; Power of 2 closest to n on its left ; Power of 2 closest to n on its right ; Return the minimum abs difference ; Driver code"
C#;"using System ; class GFG { static double find_probability ( double p , double q , double r , double s ) { double t = ( 1 - p / q ) * ( 1 - r / s ) ; double ans = ( p / q ) / ( 1 - t ) ; return ans ; } public static void Main ( ) { double p = 1 , q = 2 , r = 1 , s = 2 ; Console . WriteLine ( find_probability ( p , q , r , s ) ) ; } }";"Find probability that a player wins when probabilities of hitting the target are given | C # mplementation of the approach ; Function to return the probability of the winner ; Driver Code ; Will print 9 digits after the decimal point"
C#;"using System ; class GfG { public static void FindAllElements ( int n , int k ) { int sum = k ; int [ ] A = new int [ k ] ; for ( int i = 0 ; i < k ; i ++ ) A [ i ] = 1 ; for ( int i = k - 1 ; i >= 0 ; -- i ) { while ( sum + A [ i ] <= n ) { sum += A [ i ] ; A [ i ] *= 2 ; } } if ( sum != n ) { Console . Write ( "" Impossible "" ) ; } else { for ( int i = 0 ; i < k ; ++ i ) Console . Write ( A [ i ] + "" ▁ "" ) ; } } public static void Main ( String [ ] args ) { int n = 12 ; int k = 6 ; FindAllElements ( n , k ) ; } }";"Represent n as the sum of exactly k powers of two | Set 2 | C # implementation of the above approach ; Function to print k numbers which are powers of two and whose sum is equal to n ; Initialising the sum with k ; Initialising an array A with k elements and filling all elements with 1 ; Iterating A [ ] from k - 1 to 0 ; Update sum and A [ i ] till sum + A [ i ] is less than equal to n ; Impossible to find the combination ; Possible solution is stored in A [ ] ; Driver code"
C#;"using System ; class GFG { public static int removeZero ( int n ) { int res = 0 ; int d = 1 ; while ( n > 0 ) { if ( n % 10 != 0 ) { res += ( n % 10 ) * d ; d *= 10 ; } n /= 10 ; } return res ; } public static bool isEqual ( int a , int b ) { if ( removeZero ( a ) + removeZero ( b ) == removeZero ( a + b ) ) return true ; return false ; } public static void Main ( ) { int a = 105 , b = 106 ; if ( isEqual ( a , b ) == true ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Check whether a + b = c or not after removing all zeroes from a , b and c | C # program to check the sum after Removing all zeroes is true or not ; Function to remove zeroes ; Initialize result to zero holds the Result after removing zeroes from no ; Initialize variable d to 1 that holds digits of no ; Loop while n is greater then zero ; Check if n mod 10 is not equal to zero ; store the result by removing zeroes And increment d by 10 ; Go to the next digit ; Return the result ; Function to check if sum is true after Removing all zeroes . ; Call removeZero ( ) for both sides and check whether they are equal After removing zeroes . ; Driver Code"
C#;"using System ; class Geeks { public static void sumArray ( int [ ] arr , int n ) { int [ ] leftSum = new int [ n ] ; int [ ] rightSum = new int [ n ] ; int [ ] Sum = new int [ n ] ; int i = 0 , j = 0 ; leftSum [ 0 ] = 0 ; rightSum [ n - 1 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) leftSum [ i ] = arr [ i - 1 ] + leftSum [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) rightSum [ j ] = arr [ j + 1 ] + rightSum [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) Sum [ i ] = leftSum [ i ] + rightSum [ i ] ; for ( i = 0 ; i < n ; i ++ ) Console . Write ( Sum [ i ] + "" ▁ "" ) ; } public static void Main ( ) { int [ ] arr = { 3 , 6 , 4 , 8 , 9 } ; int n = arr . Length ; sumArray ( arr , n ) ; } }";"A Sum Array Puzzle | C # implementation of above approach ; Allocate memory for temporary arrays leftSum [ ] , rightSum [ ] and Sum [ ] ; Left most element of left array is always 0 ; Right most element of right array is always 0 ; Construct the left array ; Construct the right array ; Construct the sum array using left [ ] and right [ ] ; print the sum array ; Driver function to test above function"
C#;"using System ; class solution { static int minimumX ( int n , int k ) { int mini = int . MaxValue ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int fir = i ; int sec = n / i ; int num1 = fir * k + sec ; int res = ( num1 / k ) * ( num1 % k ) ; if ( res == n ) mini = Math . Min ( num1 , mini ) ; int num2 = sec * k + fir ; res = ( num2 / k ) * ( num2 % k ) ; if ( res == n ) mini = Math . Min ( num2 , mini ) ; } } return mini ; } public static void Main ( ) { int n = 4 , k = 6 ; Console . WriteLine ( minimumX ( n , k ) ) ; n = 5 ; k = 5 ; Console . WriteLine ( minimumX ( n , k ) ) ; } }";"Find minimum x such that ( x % k ) * ( x / k ) == n | Set | C # Program to find the minimum positive X such that the given equation holds true ; This function gives the required answer ; Iterate for all the factors ; Check if i is a factor ; Consider i to be A and n / i to be B ; Consider i to be B and n / i to be A ; Driver Code to test above function"
C#;"using System ; public class GFG { static int minimumX ( int n , int k ) { int ans = int . MaxValue ; for ( int rem = k - 1 ; rem > 0 ; rem -- ) { if ( n % rem == 0 ) ans = Math . Min ( ans , rem + ( n / rem ) * k ) ; } return ans ; } static public void Main ( ) { int n = 4 , k = 6 ; Console . WriteLine ( minimumX ( n , k ) ) ; n = 5 ; k = 5 ; Console . WriteLine ( minimumX ( n , k ) ) ; } }";"Find minimum x such that ( x % k ) * ( x / k ) == n | C # Program to find the minimum positive X such that the given equation holds true ; This function gives the required answer ; Iterate over all possible remainders ; it must divide n ; Driver Code to test above function"
C#;"using System ; class GFG { static int getHermiteNumber ( int n ) { if ( n == 0 ) return 1 ; else if ( n == 1 ) return 1 ; else return - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; } public static void Main ( ) { int n = 6 ; Console . WriteLine ( getHermiteNumber ( n ) ) ; } }";"Find nth Hermite number | C # program to find nth Hermite number ; Function to return nth Hermite number ; Base condition ; Driver Code ; Print nth Hermite number"
C#;"using System ; class GFG { static void find ( int n ) { int b = n ; int a = b * ( n - 1 ) ; if ( a * b > n && a / b < n ) { Console . Write ( "" a ▁ = ▁ "" + a + "" , ▁ b ▁ = ▁ "" + b ) ; } else Console . WriteLine ( - 1 ) ; } public static void Main ( ) { int n = 10 ; find ( n ) ; } }";"Find numbers a and b that satisfy the given conditions | C # implementation of the above approach ; Function to print the required numbers ; Suppose b = n and we want a % b = 0 and also ( a / b ) < n so a = b * ( n - 1 ) ; Special case if n = 1 we get a = 0 so ( a * b ) < n ; If no pair satisfies the conditions ; Driver code"
C#;"using System ; class GFG { static bool isPerfect ( int N ) { if ( ( Math . Sqrt ( N ) - Math . Floor ( Math . Sqrt ( N ) ) ) != 0 ) return false ; return true ; } static void getClosestPerfectSquare ( int N ) { if ( isPerfect ( N ) ) { Console . WriteLine ( N + "" ▁ "" + ""0"" ) ; return ; } int aboveN = - 1 , belowN = - 1 ; int n1 ; n1 = N + 1 ; while ( true ) { if ( isPerfect ( n1 ) ) { aboveN = n1 ; break ; } else n1 ++ ; } n1 = N - 1 ; while ( true ) { if ( isPerfect ( n1 ) ) { belowN = n1 ; break ; } else n1 -- ; } int diff1 = aboveN - N ; int diff2 = N - belowN ; if ( diff1 > diff2 ) Console . WriteLine ( belowN + "" ▁ "" + diff2 ) ; else Console . WriteLine ( aboveN + "" ▁ "" + diff1 ) ; } public static void Main ( ) { int N = 1500 ; getClosestPerfectSquare ( N ) ; } }";"Closest perfect square and its distance | C # program to find the closest perfect square taking minimum steps to reach from a number ; Function to check if a number is perfect square or not ; Function to find the closest perfect square taking minimum steps to reach from a number ; Variables to store first perfect square number above and below N ; Finding first perfect square number greater than N ; Finding first perfect square number less than N ; Variables to store the differences ; Driver code"
C#;"using System ; class GFG { static int den3 , num3 ; static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static void lowest ( ) { int common_factor = gcd ( num3 , den3 ) ; den3 = den3 / common_factor ; num3 = num3 / common_factor ; } static void addFraction ( int num1 , int den1 , int num2 , int den2 ) { den3 = gcd ( den1 , den2 ) ; den3 = ( den1 * den2 ) / den3 ; num3 = ( num1 ) * ( den3 / den1 ) + ( num2 ) * ( den3 / den2 ) ; lowest ( ) ; } public static void Main ( String [ ] args ) { int num1 = 1 , den1 = 500 , num2 = 2 , den2 = 1500 ; addFraction ( num1 , den1 , num2 , den2 ) ; Console . Write ( "" { 0 } / { 1 } ▁ + ▁ { 2 } / { 3 } ▁ is ▁ equal ▁ to ▁ { 4 } / { 5 } STRNEWLINE "" , num1 , den1 , num2 , den2 , num3 , den3 ) ; } }";"Fraction | C # program to add 2 fractions ; Function to return gcd of a and b ; Function to convert the obtained fraction into it 's simplest form ; Finding gcd of both terms ; Converting both terms into simpler terms by dividing them by common factor ; Function to add two fractions ; Finding gcd of den1 and den2 ; Denominator of final fraction obtained finding LCM of den1 and den2 LCM * GCD = a * b ; Changing the fractions to have same denominator . Numerator of the final fraction obtained ; Calling function to convert final fraction into it 's simplest form ; Driver Code"
C#;"using System ; public class GFG { static int findLargestDivisor ( int n ) { for ( int i = 2 ; i < Math . Sqrt ( n ) + 1 ; i ++ ) { while ( n % ( i * i ) == 0 ) { n = n / i ; } } return n ; } public static void Main ( ) { int n = 12 ; Console . WriteLine ( findLargestDivisor ( n ) ) ; n = 97 ; Console . WriteLine ( findLargestDivisor ( n ) ) ; } }";"Largest Divisor of a Number not divisible by a perfect square | Efficient C # Program to find the largest divisor not divisible by any perfect square greater than 1 ; Function to find the largest divisor not divisible by any perfect square greater than 1 ; If the number is divisible by i * i , then remove one i ; Now all squares are removed from n ; Driver Code"
C#;"using System ; class GFG { static bool checkIsAP ( int [ ] arr , int n ) { if ( n == 1 ) return true ; Array . Sort ( arr ) ; int d = arr [ 1 ] - arr [ 0 ] ; for ( int i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; } public static void Main ( ) { int [ ] arr = { 20 , 15 , 5 , 0 , 10 } ; int n = arr . Length ; if ( checkIsAP ( arr , n ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Arithmetic Progression | C # program to check if a given array can form arithmetic progression ; Returns true if a permutation of arr [ 0. . n - 1 ] can form arithmetic progression ; Sort array ; After sorting , difference between consecutive elements must be same . ; Driver Code"
C#;"using System ; public class GFG { static bool isTriPerfect ( int n ) { int sum = 1 + n ; int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; else sum = sum + i + n / i ; } i += 1 ; } if ( sum == 3 * n & n != 1 ) return true ; else return false ; } public static void Main ( ) { int n = 120 ; if ( isTriPerfect ( n ) ) Console . WriteLine ( n + "" ▁ is ▁ a ▁ Triperfect ▁ number "" ) ; } }";"Check if a number is Triperfect Number | C # code to check if a given number is Triperfect or not ; Returns true if n is Triperfect ; To store sum of divisors . Adding 1 and n since they are divisors of n . ; Find all divisors and add them ; If sum of divisors is equal to 3 * n , then n is a Triperfect number ; Driver program"
C#;"using System ; public class GFG { static int sum ( int N , int X , int Y ) { int S1 , S2 , S3 ; S1 = ( ( N / X ) ) * ( 2 * X + ( N / X - 1 ) * X ) / 2 ; S2 = ( ( N / Y ) ) * ( 2 * Y + ( N / Y - 1 ) * Y ) / 2 ; S3 = ( ( N / ( X * Y ) ) ) * ( 2 * ( X * Y ) + ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 ; return S1 + S2 - S3 ; } public static void Main ( ) { int N = 14 ; int X = 3 , Y = 5 ; Console . Write ( sum ( N , X , Y ) ) ; } }";"Sum of first N natural numbers which are divisible by X or Y | C # program to find sum of numbers from 1 to N which are divisible by X or Y ; Function to calculate the sum of numbers divisible by X or Y ; Driver code"
C#;"using System ; class GFG { static int findTwoThreePrime ( int l , int r ) { if ( l == 1 ) l ++ ; int count = 0 ; for ( int i = l ; i <= r ; i ++ ) { int num = i ; while ( num % 2 == 0 ) num /= 2 ; while ( num % 3 == 0 ) num /= 3 ; if ( num == 1 ) count ++ ; } return count ; } static public void Main ( ) { int l = 1 , r = 10 ; Console . WriteLine ( findTwoThreePrime ( l , r ) ) ; } }";"Count numbers from range whose prime factors are only 2 and 3 | C # program to count the numbers within a range whose prime factors are only 2 and 3 ; Function to count the number within a range whose prime factors are only 2 and 3 ; Start with 2 so that 1 doesn 't get counted ; While num is divisible by 2 , divide it by 2 ; While num is divisible by 3 , divide it by 3 ; If num got reduced to 1 then it has only 2 and 3 as prime factors ; Driver code"
C#;"using System ; class GFG { static String getNumber ( string s ) { int number_of_digits = s . Length ; int [ ] freq = new int [ 10 ] ; for ( int i = 0 ; i < number_of_digits ; i ++ ) { if ( s [ i ] == '1' s [ i ] == '2' s [ i ] == '3' s [ i ] == '5' s [ i ] == '7' ) { freq [ s [ i ] - 48 ] += 1 ; } if ( s [ i ] == '4' ) { freq [ 2 ] += 2 ; freq [ 3 ] ++ ; } if ( s [ i ] == '6' ) { freq [ 5 ] ++ ; freq [ 3 ] ++ ; } if ( s [ i ] == '8' ) { freq [ 7 ] ++ ; freq [ 2 ] += 3 ; } if ( s [ i ] == '9' ) { freq [ 7 ] ++ ; freq [ 3 ] += 2 ; freq [ 2 ] ++ ; } } string t = "" "" ; if ( freq [ 1 ] == number_of_digits || freq [ 0 ] == number_of_digits || ( freq [ 0 ] + freq [ 1 ] ) == number_of_digits ) { return s ; } else { for ( int i = 9 ; i >= 2 ; i -- ) { int ctr = freq [ i ] ; while ( ( ctr -- ) > 0 ) { t += ( char ) ( i + 48 ) ; } } return t ; } } public static void Main ( ) { string s = ""1280"" ; Console . WriteLine ( getNumber ( s ) ) ; } }";"Maximum number with same digit factorial product | C # implementation of the approach ; Function to return the required number ; Count the frequency of each digit ; 4 ! can be expressed as 2 ! * 2 ! * 3 ! ; 6 ! can be expressed as 5 ! * 3 ! ; 8 ! can be expressed as 7 ! * 2 ! * 2 ! * 2 ! ; 9 ! can be expressed as 7 ! * 3 ! * 3 ! * 2 ! ; To store the required number ; If number has only either 1 and 0 as its digits ; Generate the greatest number possible ; Driver code"
C#;"using System ; public class GFG { static int reversDigits ( int num ) { int rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = num / 10 ; } return rev_num ; } static void icanobifNumbers ( int N ) { int first = 0 , second = 1 ; if ( N == 1 ) Console . Write ( first ) ; else if ( N == 2 ) Console . Write ( first + "" ▁ "" + second ) ; else { Console . Write ( first + "" ▁ "" + second + "" ▁ "" ) ; for ( int i = 3 ; i <= N ; i ++ ) { int x = reversDigits ( first ) ; int y = reversDigits ( second ) ; Console . Write ( x + y + "" ▁ "" ) ; int temp = second ; second = x + y ; first = temp ; } } } public static void Main ( ) { int N = 12 ; icanobifNumbers ( N ) ; } }";"Program to find first N Iccanobif Numbers | C # program to find first N Icanobif numbers ; Iterative function to reverse digits of num ; Function to print first N Icanobif Numbers ; Initialize first , second numbers ; Print first two numbers ; Reversing digit of previous two terms and adding them ; Driver Code"
C#;"using System ; class GFG { static int addNDigits ( int a , int b , int n ) { int num = a ; for ( int i = 0 ; i <= 9 ; i ++ ) { int tmp = a * 10 + i ; if ( tmp % b == 0 ) { a = tmp ; break ; } } if ( num == a ) return - 1 ; for ( int j = 0 ; j < n - 1 ; j ++ ) a *= 10 ; return a ; } public static void Main ( ) { int a = 5 , b = 3 , n = 3 ; Console . WriteLine ( addNDigits ( a , b , n ) ) ; } }";"Add N digits to A such that it is divisible by B after each addition | C # implementation of the approach ; Try all digits from ( 0 to 9 ) ; Fails in the first move itself ; Add ( n - 1 ) 0 's ; Driver Code"
C#;"using System ; class GFG { static int Triplets ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = i ; j <= n ; ++ j ) { int x = i * i + j * j ; int y = ( int ) Math . Sqrt ( x ) ; if ( y * y == x && y <= n ) ++ ans ; } } return ans ; } static void Main ( ) { int n = 10 ; Console . WriteLine ( Triplets ( n ) ) ; } }";"Count number of triplets ( a , b , c ) such that a ^ 2 + b ^ 2 = c ^ 2 and 1 <= a <= b <= c <= n | C # program to Find number of Triplets 1 <= a <= b <= c <= n , Such that a ^ 2 + b ^ 2 = c ^ 2 ; function to ind number of Triplets 1 <= a <= b <= c <= n , Such that a ^ 2 + b ^ 2 = c ^ 2 ; to store required answer ; run nested loops for first two numbers . ; third number ; check if third number is perfect square and less than n ; Driver code ; function call"
C#;"using System ; class GFG { static int solve ( int n , int base1 ) { int sum = 0 ; while ( n > 0 ) { int remainder1 = n % base1 ; sum += remainder1 ; n = n / base1 ; } return sum ; } static void SumsOfDigits ( int n ) { int sum = 0 ; for ( int base1 = 2 ; base1 <= n / 2 ; ++ base1 ) sum += solve ( n , base1 ) ; Console . WriteLine ( sum ) ; } public static void Main ( String [ ] args ) { int n = 8 ; SumsOfDigits ( n ) ; } }";"Sum of the digits of a number N written in all bases from 2 to N / 2 | C # implementation of the approach ; Function to calculate the sum of the digits of n in the given base ; Sum of digits ; Digit of n in the given base ; Add the digit ; Function to calculate the sum of digits of n in base1s from 2 to n / 2 ; to store digit sum in all bases ; function call for multiple bases ; Driver Code"
C#;"using System ; public class GFG { static bool checkPerfectcube ( int n ) { int d = ( int ) Math . Ceiling ( Math . Pow ( n , ( double ) 1 / 3 ) ) ; if ( d * d * d == n ) return true ; return false ; } static int largestNonPerfectcubeNumber ( int [ ] a , int n ) { int maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( checkPerfectcube ( a [ i ] ) == false ) maxi = Math . Max ( a [ i ] , maxi ) ; } return maxi ; } public static void Main ( ) { int [ ] a = { 16 , 64 , 25 , 2 , 3 , 10 } ; int n = a . Length ; Console . WriteLine ( largestNonPerfectcubeNumber ( a , n ) ) ; } }";"Largest number in an array that is not a perfect cube | C # program to find the largest non - perfect cube number among n numbers ; Function to check if a number is perfect cube number or not ; takes the sqrt of the number ; checks if it is a perfect cube number ; Function to find the largest non perfect cube number in the array ; stores the maximum of all perfect cube numbers ; Traverse all elements in the array ; store the maximum if current element is a non perfect cube ; Driver Code"
C#;"using System ; class GFG { static void checkIfPossibleRec ( int x , int a , int b , bool [ ] isPossible , int n ) { if ( x > n ) return ; if ( isPossible [ x ] ) return ; isPossible [ x ] = true ; checkIfPossibleRec ( x + a , a , b , isPossible , n ) ; checkIfPossibleRec ( x + b , a , b , isPossible , n ) ; } static bool checkPossible ( int n , int a , int b ) { bool [ ] isPossible = new bool [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) isPossible [ i ] = false ; checkIfPossibleRec ( 0 , a , b , isPossible , n ) ; return isPossible [ n ] ; } static public void Main ( ) { int a = 3 , b = 7 , n = 8 ; if ( checkPossible ( a , b , n ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Check if N can be represented as sum of integers chosen from set { A , B } | C # program to find if number N can be represented as sum of a ' s ▁ and ▁ b ' s ; Function to find if number N can be represented as sum of a ' s ▁ and ▁ b ' s ; base condition ; if x is already visited ; set x as possible ; recursive call ; Driver Code"
C#;"using System ; class GFG { static int sumOdd ( int n ) { int terms = ( n + 1 ) / 2 ; int sum = terms * terms ; return sum ; } static int suminRange ( int l , int r ) { return sumOdd ( r ) - sumOdd ( l - 1 ) ; } public static void Main ( ) { int l = 2 , r = 5 ; Console . WriteLine ( "" Sum ▁ of ▁ odd ▁ natural ▁ numbers ▁ "" + "" from ▁ L ▁ to ▁ R ▁ is ▁ "" + suminRange ( l , r ) ) ; } }";"Sum of all odd natural numbers in range L and R | C # program to print the sum of all numbers in range L and R ; Function to return the sum of all odd natural numbers ; Function to return the sum of all odd numbers in range L and R ; Driver Code"
C#;"using System ; public class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int sumcommDiv ( int a , int b ) { int n = gcd ( a , b ) ; int sum = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum += i ; else sum += ( n / i ) + i ; } } return sum ; } static public void Main ( ) { int a = 10 , b = 15 ; Console . WriteLine ( "" Sum ▁ = ▁ "" + sumcommDiv ( a , b ) ) ; } }";"Sum of common divisors of two numbers A and B | C # implementation of above approach ; Function to calculate gcd of two numbers ; Function to calculate all common divisors of two given numbers a , b -- > input integer numbers ; find gcd of a , b ; Find the sum of divisors of n . ; if ' i ' is factor of n ; check if divisors are equal ; Driver program to run the case"
C#;"using System ; class GFG { static String checkNumber ( int N ) { int temp = N ; while ( temp > 0 ) { if ( temp % 1000 == 144 ) temp /= 1000 ; else if ( temp % 100 == 14 ) temp /= 100 ; else if ( temp % 10 == 1 ) temp /= 10 ; else { return "" NO "" ; } } return "" YES "" ; } public static void Main ( ) { int N = 1414 ; Console . WriteLine ( checkNumber ( N ) ) ; } }";"Check if a number is formed by Concatenation of 1 , 14 or 144 only | C # program to check if a number is formed by Concatenation of 1 , 14 or 144 only ; Function to check if a number is formed by Concatenation of 1 , 14 or 144 only ; check for each possible digit if given number consist other then 1 , 14 , 144 print NO else print YES ; Driver Code"
C#;"using System ; class GFG { static int getResult ( int n ) { if ( ( n & 1 ) > 0 ) return 1 ; return - 1 ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( getResult ( n ) ) ; } }";"Fibonacci problem ( Value of Fib ( N ) * Fib ( N ) | C # implementation of the approach ; Driver code"
C#;"using System ; class GFG { static void findAandB ( double N ) { double val = N * N - 4.0 * N ; if ( val < 0 ) { Console . WriteLine ( "" NO "" ) ; return ; } double a = ( N + Math . Sqrt ( val ) ) / 2.0 ; double b = ( N - Math . Sqrt ( val ) ) / 2.0 ; Console . WriteLine ( "" a ▁ = ▁ "" + a ) ; Console . WriteLine ( "" b ▁ = ▁ "" + b ) ; } static void Main ( ) { double N = 69.0 ; findAandB ( N ) ; } }";"Find two numbers with sum and product both same as N | C # program to find a and b such that a * b = N and a + b = N ; Function to return the smallest string ; Not possible ; find a and b ; Driver Code"
C#;"class GFG { static int minOperations ( int [ ] A , int n ) { if ( ( n & 1 ) > 0 ) return - 1 ; int zeros = 0 , consZeros = 0 , ones = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( A [ i ] == 0 ) zeros ++ ; else ones ++ ; if ( i + 1 < n ) { if ( A [ i ] == 0 && A [ i + 1 ] == 0 ) consZeros ++ ; } } if ( A [ 0 ] == A [ n - 1 ] && A [ 0 ] == 0 ) consZeros ++ ; if ( zeros == ones ) return consZeros ; else return - 1 ; } static void Main ( ) { int [ ] A = new int [ ] { 1 , 1 , 0 , 0 } ; int n = A . Length ; System . Console . WriteLine ( minOperations ( A , n ) ) ; } }";"Find minimum operations needed to make an Array beautiful | C # implementation of above approach ; Function to find minimum operations required to make array beautiful ; counting consecutive zeros . ; check that start and end are same ; check is zero and one are equal ; Driver program"
C#;"using System ; class GFG { static int countdig ( int m ) { if ( m == 0 ) return 0 ; else return 1 + countdig ( m / 10 ) ; } static int countSteps ( int x ) { int c = 0 ; int last = x ; while ( last > 0 ) { int digits = countdig ( last ) ; digits -= 1 ; int divisor = ( int ) Math . Pow ( 10 , digits ) ; int first = last / divisor ; int lastnumber = first * divisor ; int skipped = ( last - lastnumber ) / first ; skipped += 1 ; c += skipped ; last = last - ( first * skipped ) ; } return c ; } static void Main ( ) { int n = 14 ; Console . WriteLine ( countSteps ( n ) ) ; } }";"Steps to reduce N to zero by subtracting its most significant digit at every step | C # program to find the count of Steps to reduce N to zero by subtracting its most significant digit at every step ; Function to count the number of digits in a number m ; Function to count the number of steps to reach 0 ; count the total number of stesp ; iterate till we reach 0 ; count the digits in last ; decrease it by 1 ; find the number on whose division , we get the first digit ; first digit in last ; find the first number less than last where the first digit changes ; find the number of numbers with same first digit that are jumped ; count the steps ; the next number with a different first digit ; Driver code"
C#;"using System ; class GFG { static long power ( long x , long y , long p ) { while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static long gcd ( long a , long b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static long powerGCD ( long a , long b , long n ) { long e = power ( a , n , b ) ; return gcd ( e , b ) ; } public static void Main ( ) { long a = 5 , b = 4 , n = 2 ; Console . Write ( powerGCD ( a , b , n ) ) ; } }";"GCD of a number raised to some power and another number | C # program of the above approach ; Calculates modular exponentiation , i . e . , ( x ^ y ) % p in O ( log y ) ; x = x % p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 ; y = y / 2 ; Returns GCD of a ^ n and b ; Driver code"
C#;"using System ; class GFG { static bool allOddDigits ( int n ) { while ( n != 0 ) { if ( ( n % 10 ) % 2 == 0 ) return false ; n /= 10 ; } return true ; } static int largestNumber ( int n ) { if ( n % 2 == 0 ) n -- ; for ( int i = n ; ; i -= 2 ) if ( allOddDigits ( i ) ) return i ; } public static void Main ( ) { int N = 23 ; Console . WriteLine ( largestNumber ( N ) ) ; } }";"Largest number not greater than N all the digits of which are odd | C # program to print the largest integer not greater than N with all odd digits ; Function to check if all digits of a number are odd ; iterate for all digits ; if digit is even ; all digits are odd ; function to return the largest number with all digits odd ; iterate till we find a number with all digits odd ; Driver Code"
C#;"using System ; class GFG { static int largestNumber ( int n ) { string s = "" "" ; int duplicate = n ; while ( n > 0 ) { s = ( char ) ( n % 10 + 48 ) + s ; n /= 10 ; } int index = - 1 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( ( ( int ) ( s [ i ] - '0' ) % 2 & 1 ) == 0 ) { index = i ; break ; } } if ( index == - 1 ) return duplicate ; int num = 0 ; for ( int i = 0 ; i < index ; i ++ ) num = num * 10 + ( int ) ( s [ i ] - '0' ) ; num = num * 10 + ( ( int ) s [ index ] - ( int ) ( '0' ) - 1 ) ; for ( int i = index + 1 ; i < s . Length ; i ++ ) num = num * 10 + 9 ; return num ; } static void Main ( ) { int N = 24578 ; Console . WriteLine ( largestNumber ( N ) ) ; } }";"Largest number not greater than N all the digits of which are odd | C # program to print the largest integer not greater than N with all odd digits ; function to return the largest number with all digits odd ; convert the number to a string for easy operations ; find first even digit ; if no even digit , then N is the answer ; till first even digit , add all odd numbers ; decrease 1 from the even digit ; add 9 in the rest of the digits ; Driver Code"
C#;"using System ; class GFG { static int countNumbers ( int N ) { return ( int ) ( Math . Sqrt ( N ) ) - 1 ; } public static void Main ( ) { int N = 36 ; Console . Write ( countNumbers ( N ) ) ; } }";"Count number less than N which are product of perfect squares | C # program to count number less than N which are product of any two perfect squares ; Function to count number less than N which are product of any two perfect squares ; Driver Code"
C#;"using System ; public class GFG { static int countOrderedPairs ( int N ) { int count_pairs = 0 ; for ( int i = 1 ; i <= ( int ) Math . Sqrt ( N - 1 ) ; ++ i ) { for ( int j = i ; j * i < N ; ++ j ) ++ count_pairs ; } count_pairs *= 2 ; count_pairs -= ( int ) ( Math . Sqrt ( N - 1 ) ) ; return count_pairs ; } static public void Main ( ) { int N = 5 ; Console . WriteLine ( countOrderedPairs ( N ) ) ; } }";"Count ordered pairs with product less than N | C # implementation of above approach ; Function to return count of Ordered pairs whose product are less than N ; Initialize count to 0 ; count total pairs ; multiply by 2 to get ordered_pairs ; subtract redundant pairs ( a , b ) where a == b . ; return answer ; Driver code ; function call to print required answer"
C#;"using System ; class GFG { static void pairwiseDifference ( int [ ] arr , int n ) { int diff ; for ( int i = 0 ; i < n - 1 ; i ++ ) { diff = Math . Abs ( arr [ i ] - arr [ i + 1 ] ) ; Console . WriteLine ( diff + "" ▁ "" ) ; } } public static void Main ( String [ ] args ) { int [ ] arr = { 4 , 10 , 15 , 5 , 6 } ; int n = arr . Length ; pairwiseDifference ( arr , n ) ; } }";"Absolute Difference of all pairwise consecutive elements in an array | C # program to print the absolute difference of the consecutive elements ; Function to print pairwise absolute difference of consecutive elements ; absolute difference between consecutive numbers ; Driver Code"
C#;"using System ; public class GFG { static long sumAP ( long n , long d ) { n /= d ; return ( n ) * ( 1 + n ) * d / 2 ; } static long sumMultiples ( long n ) { n -- ; return sumAP ( n , 2 ) + sumAP ( n , 5 ) - sumAP ( n , 10 ) ; } static public void Main ( ) { long n = 20 ; Console . WriteLine ( sumMultiples ( n ) ) ; } }";"Find the sum of all multiples of 2 and 5 below N | C # program to find the sum of all multiples of 2 and 5 below N ; Function to find sum of AP series ; Number of terms ; Function to find the sum of all multiples of 2 and 5 below N ; Since , we need the sum of multiples less than N ; Driver code"
C#;"using System ; class GFG { static int markingScheme ( int N , int [ ] answerKey , int [ ] studentAnswer ) { int positive = 0 , negative = 0 , notattempt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( studentAnswer [ i ] == 0 ) notattempt ++ ; else if ( answerKey [ i ] == studentAnswer [ i ] ) positive ++ ; else if ( answerKey [ i ] != studentAnswer [ i ] ) negative ++ ; } return ( positive * 3 ) + ( negative * - 1 ) ; } static public void Main ( ) { int [ ] answerKey = { 1 , 2 , 3 , 4 , 1 } ; int [ ] studentAnswer = { 1 , 2 , 3 , 4 , 0 } ; int N = answerKey . Length ; int marking_Scheme = markingScheme ( N , answerKey , studentAnswer ) ; Console . WriteLine ( marking_Scheme ) ; } }";"Find the total marks obtained according to given marking scheme | C # implementation of above approach ; Function that calculates marks . ; for not attempt score + 0 ; for each correct answer score + 3 ; for each wrong answer score - 1 ; calculate total marks ; Driver code"
C#;"class GFG { static int MAX = 10000 ; static bool [ ] prime = new bool [ MAX + 1 ] ; static void SieveOfEratosthenes ( ) { prime [ 1 ] = true ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == false ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = true ; } } } static int solve ( int n ) { int count = 0 , num = 1 ; int prod = 1 ; while ( count < n ) { if ( ! prime [ num ] ) { prod *= num ; count ++ ; } num ++ ; } return prod ; } public static void Main ( ) { SieveOfEratosthenes ( ) ; int n = 5 ; System . Console . WriteLine ( solve ( n ) ) ; } }";"Find the Product of first N Prime Numbers | C # implementation of above solution ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Set all multiples of p to non - prime ; find the product of 1 st N prime numbers ; count of prime numbers ; product of prime numbers ; if the number is prime add it ; increase the count ; get to next number ; Driver code ; create the sieve ; find the value of 1 st n prime numbers"
C#;"using System ; using System . Collections . Generic ; class GFG { static int divisor ( int a ) { int div = 1 , count = 0 ; for ( int i = 2 ; i <= Math . Sqrt ( a ) ; i ++ ) { while ( a % i == 0 ) { count ++ ; a = a / i ; } div = div * ( count + 1 ) ; count = 0 ; } if ( a > 1 ) { div = div * ( 2 ) ; } return div ; } static int OddDivCount ( int a , int b ) { int res = 0 ; for ( int i = a ; i <= b ; ++ i ) { int divCount = divisor ( i ) ; if ( divCount % 2 == 1 ) { ++ res ; } } return res ; } public static void Main ( String [ ] args ) { int a = 1 , b = 10 ; Console . WriteLine ( OddDivCount ( a , b ) ) ; } }";"Program to find count of numbers having odd number of divisors in given range | C # implementation of the approach ; Function to return the count of divisors of a number ; Count the powers of the current prime i which divides a ; Update the count of divisors ; Reset the count ; If the remaining a is prime then a ^ 1 will be one of its prime factors ; Function to count numbers having odd number of divisors in range [ A , B ] ; To store the count of elements having odd number of divisors ; Iterate from a to b and find the count of their divisors ; To store the count of divisors of i ; If the divisor count of i is odd ; Driver code"
C#;"using System ; public class GFG { static bool Check_is_possible ( int l , int r , int k ) { int div_count = ( r / k ) - ( l / k ) ; if ( l % k == 0 ) { div_count ++ ; } return ( div_count > 1 ) ; } public static void Main ( ) { int l = 30 , r = 70 , k = 10 ; if ( Check_is_possible ( l , r , k ) ) { Console . WriteLine ( "" YES "" ) ; } else { Console . WriteLine ( "" NO "" ) ; } } }";"Check if there is any pair in a given range with GCD is divisible by k | C # program to count the numbers divisible by k in a given range ; Returns count of numbers in [ l r ] that are divisible by k . ; Add 1 explicitly as l is divisible by k ; l is not divisible by k ; Driver Code"
C#;"using System ; class gfg { public static double nth_group ( int n ) { return n * ( 2 * Math . Pow ( n , 2 ) + 1 ) ; } public static int Main ( ) { int N = 5 ; Console . WriteLine ( nth_group ( N ) ) ; return 0 ; } }";"Find sum of N | C # program to find sum in Nth group ; calculate sum of Nth group ; Driver code"
C#;"using System ; class GFG { static void printPossible ( int a , int b , int c ) { if ( ( a + b + c ) % 2 != 0 a + b < c ) Console . Write ( "" NO "" ) ; else Console . Write ( "" YES "" ) ; } public static void Main ( ) { int a = 2 , b = 4 , c = 2 ; printPossible ( a , b , c ) ; } }";"Find if a molecule can be formed from 3 atoms using their valence numbers | C # implementation of the above approach ; Function to check if it is possible ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { static bool isPerfectPower ( int n ) { if ( n == 1 ) { return true ; } for ( int x = 2 ; x <= Math . Sqrt ( n ) ; x ++ ) { int y = 2 ; int p = ( int ) Math . Pow ( x , y ) ; while ( p <= n && p > 0 ) { if ( p == n ) { return true ; } y ++ ; p = ( int ) Math . Pow ( x , y ) ; } } return false ; } static bool isStrongNumber ( int n ) { Dictionary < int , int > count = new Dictionary < int , int > ( ) ; while ( n % 2 == 0 ) { n = n / 2 ; if ( count . ContainsKey ( 2 ) ) { count [ 2 ] = count [ 2 ] + 1 ; } else { count . Add ( 2 , 1 ) ; } } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { n = n / i ; if ( count . ContainsKey ( i ) ) { count [ i ] = count [ i ] + 1 ; } else { count . Add ( i , 1 ) ; } } } if ( n > 2 ) { if ( count . ContainsKey ( n ) ) { count [ n ] = count [ n ] + 1 ; } else { count . Add ( n , 1 ) ; } } int flag = 0 ; foreach ( KeyValuePair < int , int > b in count ) { if ( b . Value == 1 ) { flag = 1 ; break ; } } if ( flag == 1 ) { return false ; } else { return true ; } } static bool isTrojan ( int n ) { if ( ! isPerfectPower ( n ) && isStrongNumber ( n ) ) { return true ; } else { return false ; } } public static void Main ( String [ ] args ) { int n = 108 ; if ( isTrojan ( n ) ) { Console . WriteLine ( "" Yes "" ) ; } else { Console . WriteLine ( "" No "" ) ; } } }";"Check if a number is a Trojan Number | C # program to check if a number is Trojan Number or not ; Function to check if a number can be expressed as x ^ y ; Try all numbers from 2 to sqrt ( n ) as base ; Keep increasing y while power ' p ' is smaller than n . ; Function to check if a number is Strong ; count the number for each prime factor ; minimum number of prime divisors should be 2 ; Function to check if a number is Trojan Number ; Driver Code"
C#;"using System ; class GFG { static void Sum_upto_nth_Term ( int n ) { int r = n * ( n + 1 ) * ( 2 * n + 7 ) / 3 ; Console . Write ( r ) ; } public static void Main ( ) { int N = 5 ; Sum_upto_nth_Term ( N ) ; } }";"Find the sum of first N terms of the series 2 Ã — 3 + 4 Ã — 4 + 6 Ã — 5 + 8 Ã — 6 + ... | C # program to find sum upto N term of the series : 2 A 3 + 4 A 4 + 6 A 5 + 8 A 6 + ... ; calculate sum upto N term of series ; Driver code"
C#;"using System ; class GFG { static int CalculateDifference ( int [ ] arr , int n ) { int max_val = int . MinValue ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_val ) max_val = arr [ i ] ; } bool [ ] prime = new bool [ max_val + 1 ] ; for ( int i = 0 ; i <= max_val ; i ++ ) prime [ i ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int S1 = 0 , S2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { S1 += arr [ i ] ; } else if ( arr [ i ] != 1 ) { S2 += arr [ i ] ; } } return Math . Abs ( S2 - S1 ) ; } public static void Main ( string [ ] args ) { int [ ] arr = { 1 , 3 , 5 , 10 , 15 , 7 } ; int n = arr . Length ; Console . WriteLine ( CalculateDifference ( arr , n ) ) ; } }";"Absolute Difference between the Sum of Non | C # program to find the Absolute Difference between the Sum of Non - Prime numbers and Prime numbers of an Array ; Function to find the difference between the sum of non - primes and the sum of primes of an array . ; Find maximum value in the array ; USE SIEVE TO FIND ALL PRIME NUMBERS LESS THAN OR EQUAL TO max_val Create a boolean array "" prime [ 0 . . n ] "" . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; Remaining part of SIEVE ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Store the sum of primes in S1 and the sum of non primes in S2 ; the number is prime ; the number is non - prime ; Return the absolute difference ; Driver Code ; Get the array ; Find the absolute difference"
C#;"using System ; class GFG { public double sum ( int x , int n ) { double total = 1.0 ; double previous = 1.0 ; for ( int i = 1 ; i <= n ; i ++ ) { previous = ( ( previous * x ) / ( i + 1 ) ) ; total = total + previous ; } return total ; } } class geek { public static void Main ( ) { GFG g = new GFG ( ) ; int x = 5 , n = 4 ; Console . WriteLine ( "" Sum ▁ is : ▁ "" + g . sum ( x , n ) ) ; } }";"Program to find sum of 1 + x / 2 ! + x ^ 2 / 3 ! + ... + x ^ n / ( n + 1 ) ! | C # implementation of the approach ; Function to compute the series sum ; To store the value of S [ i - 1 ] ; Iterate over n to store sum in total ; Update previous with S [ i ] ; Driver code ; Get x and n ; Find and print the sum"
C#;"using System ; class GFG { static int numberOfDivisors ( int num ) { int c = 0 ; for ( int i = 1 ; i <= num ; i ++ ) { if ( num % i == 0 ) { c += 1 ; } } return c ; } static int countNumbers ( int n ) { int c = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( numberOfDivisors ( i ) == 9 ) c += 1 ; } return c ; } public static void Main ( ) { int n = 1000 ; Console . Write ( countNumbers ( n ) ) ; } }";"Count number of integers less than or equal to N which has exactly 9 divisors | C # implementation of above approach ; Function to count factors in O ( N ) ; iterate and check if factor or not ; Function to count numbers having exactly 9 divisors ; check for all numbers <= N ; check if exactly 9 factors or not ; Driver Code"
C#;"using System ; class GFG { static int numberOfDistinct ( int n ) { int ans = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { ans ++ ; if ( ( n / i ) != i ) ans ++ ; } } return ans ; } static public void Main ( ) { int n = 3 ; Console . WriteLine ( numberOfDistinct ( n ) ) ; } }";"Number of distinct integers obtained by lcm ( X , N ) / X | C # program to find distinct integers ontained by lcm ( x , num ) / x ; Function to count the number of distinct integers ontained by lcm ( x , num ) / x ; iterate to count the number of factors ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { static readonly int MAX = 1000 ; static List < int > arr = new List < int > ( ) ; static void ulam ( ) { arr . Add ( 1 ) ; arr . Add ( 2 ) ; for ( int i = 3 ; i < MAX ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr . Count - 1 ; j ++ ) { for ( int k = j + 1 ; k < arr . Count ; k ++ ) { if ( arr [ j ] + arr [ k ] == i ) { count ++ ; } if ( count > 1 ) break ; } if ( count > 1 ) break ; } if ( count == 1 ) { arr . Add ( i ) ; } } } public static void Main ( String [ ] args ) { ulam ( ) ; int n = 9 ; Console . WriteLine ( arr [ n - 1 ] ) ; } }";"Ulam Number Sequence | C # code to print nth Ulam number ; Array to store Ulam Number ; Function to compute ulam Number ; push First 2 two term of the sequence in the array for further calculation ; loop to generate Ulam number ; traverse the array and check if i can be represented as sum of two distinct element of the array ; If count is 2 that means i can be represented as sum of two distinct terms of the sequence ; i is ulam number ; Driver code ; pre compute Ulam Number sequence ; print nth Ulam number"
C#;"using System ; class GFG { static int NumberOfRectangles ( int n , int m ) { if ( n % 2 == 0 ) return ( n / 2 ) * m ; else if ( m % 2 == 0 ) return ( m / 2 ) * n ; return ( n * m - 1 ) / 2 ; } public static void Main ( ) { int n = 3 , m = 3 ; Console . WriteLine ( NumberOfRectangles ( n , m ) ) ; } }";"Find the number of rectangles of size 2 * 1 which can be placed inside a rectangle of size n * m | C # program to Find the number of rectangles of size 2 * 1 can be placed inside a rectangle of size n * m ; function to Find the number of rectangles of size 2 * 1 can be placed inside a rectangle of size n * m ; if n is even ; if m is even ; if both are odd ; Driver Code ; function call"
C#;"using System ; class GFG { static long findNumUtil ( long res , int a , int aCount , int b , int bCount , int n ) { if ( res > 1e11 ) return ( long ) 1e11 ; if ( aCount == bCount && res >= n ) return res ; return Math . Min ( findNumUtil ( res * 10 + a , a , aCount + 1 , b , bCount , n ) , findNumUtil ( res * 10 + b , a , aCount , b , bCount + 1 , n ) ) ; } static int findNum ( int n , int a , int b ) { int result = 0 ; int aCount = 0 ; int bCount = 0 ; return ( int ) findNumUtil ( result , a , aCount , b , bCount , n ) ; } public static void Main ( ) { int N = 4500 ; int A = 4 ; int B = 7 ; Console . WriteLine ( findNum ( N , A , B ) ) ; } }";"Next greater Number than N with the same quantity of digits A and B | C # program to find next greater Number than N with the same quantity of digits A and B ; Recursive function to find the required number ; If the resulting number is >= n and count of a = count of b , return the number ; select minimum of two and call the function again ; Function to find the number next greater Number than N with the same quantity of digits A and B ; Driver code"
C#;"using System ; class GFG { public static void Main ( ) { int n = 7 ; int k = 3 ; if ( n % k == 0 ) Console . WriteLine ( n / k + "" ▁ "" + n / k ) ; else Console . WriteLine ( ( n - ( n % k ) ) / k + "" ▁ "" + ( ( ( n - ( n % k ) ) / k ) + 1 ) ) ; } }";"Minimum and maximum number of N chocolates after distribution among K students | C # implementation of the above approach ; Driver code"
C#;"using System ; class GFG { public static void Main ( ) { float m = 50 , n = 5 , x = 67 , h = 2927 ; int z = ( int ) ( Math . Ceiling ( ( h / 60 * 1.0 ) ) ) ; if ( z <= n ) Console . WriteLine ( z * m ) ; else Console . WriteLine ( n * m + ( z - n ) * x ) ; } }";"Total money to be paid after traveling the given number of hours | C # implementation of the above approach ; calculating hours travelled"
C#;"using System ; class GFG { static double sumProductDifference ( int a , int b , int c , int d , int e ) { double rootSum = ( double ) ( - 1 * b ) / a ; double rootProduct = ( double ) e / a ; return Math . Abs ( rootSum - rootProduct ) ; } public static void Main ( ) { Console . Write ( sumProductDifference ( 8 , 4 , 6 , 4 , 1 ) ) ; } }";"Absolute difference between sum and product of roots of a quartic equation | C # implementation of above approach ; Function taking coefficient of each term of equation as input ; Finding sum of roots ; Finding product of roots ; Absolute difference ; Driver Code"
C#;"using System ; class GFG { static int numberOfSolutions ( int n ) { int c = 0 ; for ( int x = 0 ; x <= n ; ++ x ) if ( n == x + ( n ^ x ) ) ++ c ; return c ; } public static void Main ( ) { int n = 3 ; Console . Write ( numberOfSolutions ( n ) ) ; } }";"Number of solutions of n = x + n âŠ • x | C # implementation of above approach ; Function to find the number of solutions of n = n xor x ; Counter to store the number of solutions found ; Driver code"
C#;"using System ; class GFG { static int minimumLectures ( int m , int n ) { int ans = 0 ; if ( n < ( int ) Math . Ceiling ( 0.75 * m ) ) ans = ( int ) Math . Ceiling ( ( ( 0.75 * m ) - n ) / 0.25 ) ; else ans = 0 ; return ans ; } public static void Main ( ) { int M = 9 , N = 1 ; Console . WriteLine ( minimumLectures ( M , N ) ) ; } }";"Program to find minimum number of lectures to attend to maintain 75 % | C # Program to find minimum number of lectures to attend to maintain 75 % attendance ; Method to compute minimum lecture ; Formula to compute ; Driver Code"
C#;"using System ; class GFG { static int countNumbers ( int N ) { return ( int ) ( Math . Pow ( 10 , N ) - Math . Pow ( 8 , N ) ) / 2 ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( countNumbers ( n ) ) ; } }";"Count Numbers with N digits which consists of odd number of 0 's | C # program to count numbers with N digits which consists of odd number of 0 's ; Function to count Numbers with N digits which consists of odd number of 0 's ; Driver code"
C#;"using System ; class GFG { static int MAX = 10000 ; static int [ ] prefix = new int [ MAX + 1 ] ; static void buildPrefix ( ) { bool [ ] prime = new bool [ MAX + 1 ] ; for ( int i = 0 ; i < MAX + 1 ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } prefix [ 0 ] = prefix [ 1 ] = 0 ; for ( int p = 2 ; p <= MAX ; p ++ ) { prefix [ p ] = prefix [ p - 1 ] ; if ( prime [ p ] == true ) prefix [ p ] += p ; } } static int sumPrimeRange ( int L , int R ) { buildPrefix ( ) ; return prefix [ R ] - prefix [ L - 1 ] ; } public static void Main ( ) { int L = 10 , R = 20 ; Console . WriteLine ( sumPrimeRange ( L , R ) ) ; } }";"Sum of all Primes in a given range using Sieve of Eratosthenes | C # program to find sum of primes in range L to R ; prefix [ i ] is going to store sum of primes till i ( including i ) . ; Function to build the prefix sum array ; Create a boolean array "" prime [ 0 . . n ] "" . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Build prefix array ; Function to return sum of prime in range ; Driver code"
C#;"using System ; class GFG { static int calculateSum ( int n ) { return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) + n * ( n + 1 ) / 2 + 2 * ( n ) ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( "" Sum ▁ = ▁ "" + calculateSum ( n ) ) ; } }";"Sum of the first N terms of the series 5 , 12 , 23 , 38. ... | C # program to find sum of first n terms ; Function to calculate the sum ; Driver code ; number of terms to be included in sum ; find the Sn"
C#;"using System ; class GFG { static void checkSolution ( int a , int b , int c ) { if ( ( ( b * b ) - ( 4 * a * c ) ) > 0 ) Console . WriteLine ( ""2 ▁ solutions "" ) ; else if ( ( ( b * b ) - ( 4 * a * c ) ) == 0 ) Console . WriteLine ( ""1 ▁ solution "" ) ; else Console . WriteLine ( "" No ▁ solutions "" ) ; } public static void Main ( ) { int a = 2 , b = 5 , c = 2 ; checkSolution ( a , b , c ) ; } }";"Program to find number of solutions in Quadratic Equation | C # Program to find the solutions of specified equations ; Method to check for solutions of equations ; If the expression is greater than 0 , then 2 solutions ; If the expression is equal to 0 , then 2 solutions ; Else no solutions ; Driver Code"
C#;"using System ; class GFG { static long Bits ( int kilobytes ) { long Bits = 0 ; Bits = kilobytes * 8192 ; return Bits ; } static long Bytes ( int kilobytes ) { long Bytes = 0 ; Bytes = kilobytes * 1024 ; return Bytes ; } static public void Main ( ) { int kilobytes = 1 ; Console . WriteLine ( kilobytes + "" ▁ Kilobytes ▁ = ▁ "" + Bytes ( kilobytes ) + "" ▁ Bytes ▁ and ▁ "" + Bits ( kilobytes ) + "" ▁ Bits . "" ) ; } }";"Program to convert KiloBytes to Bytes and Bits | C # implementation of above program ; Function to calculates the bits ; calculates Bits 1 kilobytes ( s ) = 8192 bits ; Function to calculates the bytes ; calculates Bytes 1 KB = 1024 bytes ; Driver code"
C#;"using System ; class GFG { public static void Main ( ) { int n = 3 ; int [ ] a = { 1 , 2 , 3 } ; int i = 0 ; long sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } long x = sum / n ; if ( x * n == sum ) Console . WriteLine ( x ) ; else Console . WriteLine ( "" - 1"" ) ; } }";"Program to find the Hidden Number | C # Program to find the hidden number ; Driver Code ; Getting the size of array ; Getting the array of size n ; Solution ; Finding sum of the array elements ; Dividing sum by size n ; Print x , if found"
C#;"using System ; class GFG { static double findSum ( long n ) { return Math . Sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; } public static void Main ( ) { long n = 10 ; Console . WriteLine ( findSum ( n ) ) ; } }";"Find sum of the series ? 3 + ? 12 + ... ... ... upto N terms | C # implementation of above approach ; Function to find the sum ; Apply AP formula ; Driver code ; number of terms"
C#;"using System ; class GFG { static int sum ( int x , int y , int n ) { int sum1 = ( int ) ( ( Math . Pow ( x , 2 ) * ( Math . Pow ( x , 2 * n ) - 1 ) ) / ( Math . Pow ( x , 2 ) - 1 ) ) ; int sum2 = ( int ) ( ( x * y * ( Math . Pow ( x , n ) * Math . Pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ) ; return sum1 + sum2 ; } public static void Main ( ) { int x = 2 , y = 2 , n = 2 ; Console . Write ( sum ( x , y , n ) ) ; } }";"Find the sum of the series x ( x + y ) + x ^ 2 ( x ^ 2 + y ^ 2 ) + x ^ 3 ( x ^ 3 + y ^ 3 ) + ... + x ^ n ( x ^ n + y ^ n ) | C # program to find the sum of series ; Function to return required sum ; sum of first series ; sum of second series ; Driver code ; function call to print sum"
C#;"using System ; class GFG { static void printPair ( int g , int l ) { Console . Write ( g + "" ▁ "" + l ) ; } public static void Main ( ) { int g = 3 , l = 12 ; printPair ( g , l ) ; } }";"Find any pair with given GCD and LCM | C # program to print any pair with a given gcd G and lcm L ; Function to print the pairs ; Driver Code"
C#;"using System ; class GFG { static int calculateSum ( int n ) { int a1 = 1 , a2 = 2 ; int r = 2 ; int d = 1 ; return ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( int ) ( Math . Pow ( r , n ) - 1 ) / ( r - 1 ) ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( "" Sum ▁ = ▁ "" + calculateSum ( n ) ) ; } }";"Sum of first n terms of a given series 3 , 6 , 11 , ... . . | C # program to find sum of first n terms ; Function to calculate the sum ; starting number ; Common Ratio ; Common difference ; Driver code ; N th term to be find ; find the Sn"
C#;"using System ; class GFG { public static long repeatedSum ( long n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; } public static long repeatedProduct ( long n ) { long prod = 1 ; while ( n > 0 prod > 9 ) { if ( n == 0 ) { n = prod ; prod = 1 ; } prod *= n % 10 ; n /= 10 ; } return prod ; } public static long maxSumProduct ( long N ) { if ( N < 10 ) return N ; return Math . Max ( repeatedSum ( N ) , repeatedProduct ( N ) ) ; } public static void Main ( ) { long n = 631 ; Console . WriteLine ( maxSumProduct ( n ) ) ; } }";"Maximum of sum and product of digits until number is reduced to a single digit | C # implementation of above approach ; Function to sum the digits until it becomes a single digit ; Function to product the digits until it becomes a single digit ; Loop to do sum while sum is not less than or equal to 9 ; Function to find the maximum among repeated sum and repeated product ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { static List < int > digits = new List < int > ( ) ; static bool [ ] vis = new bool [ 170 ] ; static int [ , , , ] dp = new int [ 19 , 19 , 2 , 170 ] ; static void ConvertIntoDigit ( int n ) { while ( n > 0 ) { int dig = n % 10 ; digits . Add ( dig ) ; n /= 10 ; } digits . Reverse ( ) ; } static int solve ( int idx , int k , int tight , int sum ) { if ( idx == digits . Count && k == 0 && sum % 2 == 1 ) { if ( ! vis [ sum ] ) { vis [ sum ] = true ; return 1 ; } return 0 ; } if ( idx > digits . Count ) { return 0 ; } if ( dp [ idx , k , tight , sum ] > 0 ) { return dp [ idx , k , tight , sum ] ; } int j ; if ( idx < digits . Count && tight == 0 ) { j = digits [ idx ] ; } else { j = 9 ; } int cnt = 0 ; for ( int i = ( k > 0 ? 0 : 1 ) ; i <= j ; i ++ ) { int newtight = tight ; if ( i < j ) { newtight = 1 ; } if ( i == 0 ) cnt += solve ( idx + 1 , k - 1 , newtight , sum ) ; else cnt += solve ( idx + 1 , k , newtight , sum + i ) ; } return dp [ idx , k , tight , sum ] = cnt ; } public static void Main ( String [ ] args ) { int N , k ; N = 169 ; k = 2 ; ConvertIntoDigit ( N ) ; k = digits . Count - k ; Console . Write ( solve ( 0 , k , 0 , 0 ) ) ; } }";"Count numbers with exactly K non | C # program to count the numbers having exactly K non - zero digits and sum of digits are odd and distinct . ; To store digits of N ; visited map ; DP Table ; Push all the digits of N into digits vector ; Function returns the count ; If desired number is formed whose sum is odd ; If it is not present in map , mark it as true and return 1 ; Sum is present in map already ; Desired result not found ; If that state is already calculated just return that state value ; Upper limit ; To store the count of desired numbers ; If k is non - zero , i ranges from 0 to j else [ 1 , j ] ; If current digit is 0 , decrement k and recurse sum is not changed as we are just adding 0 that makes no difference ; If i is non zero , then k remains unchanged and value is added to sum ; Memoize and return ; Driver code ; K is the number of exact non - zero elements to have in number ; break N into its digits ; We keep record of 0 s we need to place in the number"
C#;"using System ; class GFG { static int countSubsets ( int N ) { if ( N <= 2 ) return N ; if ( N == 3 ) return 2 ; int [ ] DP = new int [ N + 1 ] ; DP [ 0 ] = 0 ; DP [ 1 ] = 1 ; DP [ 2 ] = 2 ; DP [ 3 ] = 2 ; for ( int i = 4 ; i <= N ; i ++ ) { DP [ i ] = DP [ i - 2 ] + DP [ i - 3 ] ; } return DP [ N ] ; } public static void Main ( String [ ] args ) { int N = 20 ; Console . Write ( countSubsets ( N ) ) ; } }";"Count of subsets of integers from 1 to N having no adjacent elements | C # code to count subsets not containing adjacent elements from 1 to N ; Function to count subsets ; Driver code"
C#;"using System ; class GFG { static int [ , ] dp = new int [ 500 , 500 ] ; static int CountSets ( int x , int pos ) { if ( x <= 0 ) { if ( pos == 0 ) return 1 ; else return 0 ; } if ( pos == 0 ) return 1 ; if ( dp [ x , pos ] != - 1 ) return dp [ x , pos ] ; int answer = CountSets ( x - 1 , pos ) + CountSets ( x - 2 , pos - 1 ) ; return dp [ x , pos ] = answer ; } static int CountOrderedSets ( int n ) { int [ ] factorial = new int [ 10000 ] ; factorial [ 0 ] = 1 ; for ( int i = 1 ; i < 10000 ; i ++ ) factorial [ i ] = factorial [ i - 1 ] * i ; int answer = 0 ; for ( int i = 0 ; i < 500 ; i ++ ) { for ( int j = 0 ; j < 500 ; j ++ ) { dp [ i , j ] = - 1 ; } } for ( int i = 1 ; i <= n ; i ++ ) { int sets = CountSets ( n , i ) * factorial [ i ] ; answer = answer + sets ; } return answer ; } public static void Main ( String [ ] args ) { int N = 3 ; Console . Write ( CountOrderedSets ( N ) ) ; } }";"Count the number of ordered sets not containing consecutive numbers | C # program to count the number of ordered sets not containing consecutive numbers ; DP table ; Function to calculate the count of ordered set for a given size ; Base cases ; If subproblem has been soved before ; Store and return answer to this subproblem ; Function returns the count of all ordered sets ; Prestore the factorial value ; Initialise the dp table ; Iterate all ordered set sizes and find the count for each one maximum ordered set size will be smaller than N as all elements are distinct and non consecutive . ; Multiply ny size ! for all the arrangements because sets are ordered . ; Add to total answer ; Driver code"
C#;"using System ; class GFG { static int numberOfArithmeticSequences ( int [ ] L , int N ) { if ( N <= 2 ) return 0 ; int count = 0 ; int res = 0 ; for ( int i = 2 ; i < N ; ++ i ) { if ( L [ i ] - L [ i - 1 ] == L [ i - 1 ] - L [ i - 2 ] ) { ++ count ; } else { count = 0 ; } res += count ; } return res ; } public static void Main ( String [ ] args ) { int [ ] L = { 1 , 3 , 5 , 6 , 7 , 8 } ; int N = L . Length ; Console . Write ( numberOfArithmeticSequences ( L , N ) ) ; } }";"Count the Arithmetic sequences in the Array of size at least 3 | C # program to find all arithmetic sequences of size atleast 3 ; Function to find all arithmetic sequences of size atleast 3 ; If array size is less than 3 ; Finding arithmetic subarray length ; To store all arithmetic subarray of length at least 3 ; Check if current element makes arithmetic sequence with previous two elements ; Begin with a new element for new arithmetic sequences ; Accumulate result in till i . ; Return readonly count ; Driver code ; Function to find arithmetic sequences"
C#;"using System ; class GFG { static int CountOfTriplets ( int [ ] a , int n ) { int answer = 0 ; int x = 0 ; int [ ] count = new int [ 100005 ] ; int [ ] ways = new int [ 100005 ] ; for ( int i = 0 ; i < n ; i ++ ) { x ^= a [ i ] ; answer += count [ x ] * i - ways [ x ] ; count [ x ] ++ ; ways [ x ] += ( i + 1 ) ; } return answer ; } public static void Main ( String [ ] args ) { int [ ] Arr = { 3 , 6 , 12 , 8 , 6 , 2 , 1 , 5 } ; int N = Arr . Length ; Console . Write ( CountOfTriplets ( Arr , N ) ) ; } }";"Count triplet of indices ( i , j , k ) such that XOR of elements between [ i , j ) equals [ j , k ] | C # program to count the Number of triplets in array having subarray XOR equal ; Function return the count of triplets having subarray XOR equal ; XOR value till i ; Count and ways array as defined above ; Using the formula stated ; Increase the frequency of x ; Add i + 1 to ways [ x ] for upcoming indices ; Driver code"
C#;"using System ; public class GFG { static int [ , ] dp = new int [ 5000 , ( 1 << 10 ) + 5 ] ; static int getmask ( int val ) { int mask = 0 ; if ( val == 0 ) return 1 ; while ( val > 0 ) { int d = val % 10 ; mask |= ( 1 << d ) ; val /= 10 ; } return mask ; } static int countWays ( int pos , int mask , int [ ] a , int n ) { if ( pos == n ) return ( mask > 0 ? 1 : 0 ) ; if ( dp [ pos , mask ] != - 1 ) return dp [ pos , mask ] ; int count = 0 ; count = count + countWays ( pos + 1 , mask , a , n ) ; if ( ( getmask ( a [ pos ] ) & mask ) == 0 ) { int new_mask = ( mask | ( getmask ( a [ pos ] ) ) ) ; count = count + countWays ( pos + 1 , new_mask , a , n ) ; } return dp [ pos , mask ] = count ; } static int numberOfSubarrays ( int [ ] a , int n ) { for ( int i = 0 ; i < 5000 ; i ++ ) { for ( int j = 0 ; j < ( 1 << 10 ) + 5 ; j ++ ) { dp [ i , j ] = - 1 ; } } return countWays ( 0 , 0 , a , n ) ; } public static void Main ( String [ ] args ) { int N = 4 ; int [ ] A = { 1 , 12 , 23 , 34 } ; Console . Write ( numberOfSubarrays ( A , N ) ) ; } }";"Count of subarrays of an Array having all unique digits | C # program to find the count of subarrays of an Array having all unique digits ; Dynamic programming table ; Function to obtain the mask for any integer ; Function to count the number of ways ; Subarray must not be empty ; If subproblem has been solved ; Excluding this element in the subarray ; If there are no common digits then only this element can be included ; Calculate the new mask if this element is included ; Store and return the answer ; Function to find the count of subarray with all digits unique ; initializing dp ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { static List < int > fib = new List < int > ( ) ; class node { public node left ; public int data ; public node right ; } ; static node newNode ( int data ) { node temp = new node ( ) ; temp . data = data ; temp . left = null ; temp . right = null ; return temp ; } static int height ( node root ) { if ( root == null ) return 0 ; return ( Math . Max ( height ( root . left ) , height ( root . right ) ) + 1 ) ; } static void FibonacciSeries ( int n ) { fib . Add ( 0 ) ; fib . Add ( 1 ) ; for ( int i = 2 ; i < n ; i ++ ) fib . Add ( fib [ i - 1 ] + fib [ i - 2 ] ) ; } static int CountPathUtil ( node root , int i , int count ) { if ( root == null || ! ( fib [ i ] == root . data ) ) { return count ; } if ( root . left != null && root . right != null ) { count ++ ; } count = CountPathUtil ( root . left , i + 1 , count ) ; return CountPathUtil ( root . right , i + 1 , count ) ; } static void CountPath ( node root ) { int ht = height ( root ) ; FibonacciSeries ( ht ) ; Console . Write ( CountPathUtil ( root , 0 , 0 ) ) ; } public static void Main ( String [ ] args ) { node root = newNode ( 0 ) ; root . left = newNode ( 1 ) ; root . right = newNode ( 1 ) ; root . left . left = newNode ( 1 ) ; root . left . right = newNode ( 4 ) ; root . right . right = newNode ( 1 ) ; root . right . right . left = newNode ( 2 ) ; CountPath ( root ) ; } }";"Count of Fibonacci paths in a Binary tree | C # program to count all of Fibonacci paths in a Binary tree ; List to store the fibonacci series ; Binary Tree Node ; Function to create a new tree node ; Function to find the height of the given tree ; Function to make fibonacci series upto n terms ; Preorder Utility function to count exponent path in a given Binary tree ; Base Condition , when node pointer becomes null or node value is not a number of Math . Pow ( x , y ) ; Increment count when encounter leaf node ; Left recursive call save the value of count ; Right recursive call and return value of count ; Function to find whether fibonacci path exists or not ; To find the height ; Making fibonacci series upto ht terms ; Driver code ; Create binary tree ; Function Call"
C#;"using System ; using System . Collections . Generic ; public class GFG { static int M = 18 ; static int a , b ; static int [ , , , ] dp = new int [ M , 90 , 90 , 2 ] ; static HashSet < int > fib = new HashSet < int > ( ) ; static void fibonacci ( ) { int prev = 0 , curr = 1 ; fib . Add ( prev ) ; fib . Add ( curr ) ; while ( curr <= 100 ) { int temp = curr + prev ; fib . Add ( temp ) ; prev = curr ; curr = temp ; } } static int count ( int pos , int even , int odd , int tight , List < int > num ) { if ( pos == num . Count ) { if ( num . Count % 2 == 1 ) { odd = odd + even ; even = odd - even ; odd = odd - even ; } int d = even - odd ; if ( fib . Contains ( d ) ) return 1 ; return 0 ; } if ( dp [ pos , even , odd , tight ] != - 1 ) return dp [ pos , even , odd , tight ] ; int ans = 0 ; int limit = ( tight == 1 ? 9 : num [ pos ] ) ; for ( int d = 0 ; d <= limit ; d ++ ) { int currF = tight , currEven = even ; int currOdd = odd ; if ( d < num [ pos ] ) currF = 1 ; if ( pos % 2 == 1 ) currOdd += d ; else currEven += d ; ans += count ( pos + 1 , currEven , currOdd , currF , num ) ; } return dp [ pos , even , odd , tight ] = ans ; } static int solve ( int x ) { List < int > num = new List < int > ( ) ; while ( x > 0 ) { num . Add ( x % 10 ) ; x /= 10 ; } num . Reverse ( ) ; for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < 90 ; j ++ ) { for ( int l = 0 ; l < 90 ; l ++ ) { for ( int k = 0 ; k < 2 ; k ++ ) { dp [ i , j , l , k ] = - 1 ; } } } } return count ( 0 , 0 , 0 , 0 , num ) ; } public static void Main ( String [ ] args ) { fibonacci ( ) ; int L = 1 , R = 50 ; Console . Write ( solve ( R ) - solve ( L - 1 ) + "" STRNEWLINE "" ) ; L = 50 ; R = 100 ; Console . Write ( solve ( R ) - solve ( L - 1 ) + "" STRNEWLINE "" ) ; } }";"Numbers with a Fibonacci difference between Sum of digits at even and odd positions in a given range | C # program to count the numbers in the range having the difference between the sum of digits at even and odd positions as a Fibonacci Number ; To store all the Fibonacci numbers ; Function to generate Fibonacci numbers upto 100 ; Adding the first two Fibonacci numbers in the set ; Computing the remaining Fibonacci numbers using the first two Fibonacci numbers ; Function to return the count of required numbers from 0 to num ; Base Case ; Check if the difference is equal to any fibonacci number ; If this result is already computed simply return it ; Maximum limit upto which we can place digit . If tight is 1 , means number has already become smaller so we can place any digit , otherwise num [ pos ] ; If the current position is odd add it to currOdd , otherwise to currEven ; Function to convert x into its digit vector and uses count ( ) function to return the required count ; Initialize dp ; Driver Code ; Generate fibonacci numbers"
C#;"using System ; class GFG { static int maximumOccurrence ( string s ) { int n = s . Length ; int [ ] freq = new int [ 26 ] ; int [ , ] dp = new int [ 26 , 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = ( s [ i ] - ' a ' ) ; for ( int j = 0 ; j < 26 ; j ++ ) dp [ x , j ] += freq [ j ] ; freq [ x ] ++ ; } int answer = int . MinValue ; for ( int i = 0 ; i < 26 ; i ++ ) answer = Math . Max ( answer , freq [ i ] ) ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) { answer = Math . Max ( answer , dp [ i , j ] ) ; } } return answer ; } public static void Main ( string [ ] args ) { string s = "" xxxyy "" ; Console . Write ( maximumOccurrence ( s ) ) ; } }";"Count maximum occurrence of subsequence in string such that indices in subsequence is in A . P . | C # implementation to find the maximum occurrence of the subsequence such that the indices of characters are in arithmetic progression ; Function to find the maximum occurrence of the subsequence such that the indices of characters are in arithmetic progression ; Frequency for characters ; Loop to count the occurrence of ith character before jth character in the given String ; Increase the frequency of s [ i ] or c of String ; Maximum occurrence of subsequence of length 1 in given String ; Maximum occurrence of subsequence of length 2 in given String ; Driver Code"
C#;"using System ; class GFG { static int mod = 1000000007 ; static int [ , , ] dp = new int [ 1005 , 105 , 2 ] ; static int [ ] powers = new int [ 1005 ] ; static int [ ] powersModk = new int [ 1005 ] ; static int calculate ( int pos , int rem , int z , int k , int n ) { if ( rem == 0 && z != 0 ) { if ( pos != n ) return ( powers [ n - pos - 1 ] * 9 ) % mod ; else return 1 ; } if ( pos == n ) return 0 ; if ( dp [ pos , rem , z ] != - 1 ) return dp [ pos , rem , z ] ; int count = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( i == 0 ) count = ( count + ( calculate ( pos + 1 , ( rem + ( i * powersModk [ pos ] ) % k ) % k , z , k , n ) ) ) % mod ; else count = ( count + ( calculate ( pos + 1 , ( rem + ( i * powersModk [ pos ] ) % k ) % k , 1 , k , n ) ) ) % mod ; } return dp [ pos , rem , z ] = count ; } static int countNumbers ( int n , int k ) { int st = 1 ; int i ; for ( i = 0 ; i <= n ; i ++ ) { powers [ i ] = st ; st *= 10 ; st %= mod ; } st = 1 ; for ( i = 0 ; i <= n ; i ++ ) { powersModk [ i ] = st ; st *= 10 ; st %= mod ; } for ( i = 0 ; i < 1005 ; i ++ ) { for ( int j = 0 ; j < 105 ; j ++ ) { for ( int l = 0 ; l < 2 ; l ++ ) dp [ i , j , l ] = - 1 ; } } return calculate ( 0 , 0 , 0 , k , n ) ; } public static void Main ( String [ ] args ) { int N = 2 ; int K = 2 ; Console . Write ( countNumbers ( N , K ) ) ; } }";"Count the numbers with N digits and whose suffix is divisible by K | C # implementation to Count the numbers with N digits and whose suffix is divisible by K ; Suffix of length pos with remainder rem and Z representing whether the suffix has a non zero digit until now ; Base case ; If count of digits is less than n ; Placing all possible digits in remaining positions ; If remainder non zero and suffix has n digits ; If the subproblem is already solved ; Placing all digits at MSB of suffix and increasing it 's length by 1 ; Non zero digit is placed ; Store and return the solution to this subproblem ; Function to Count the numbers with N digits and whose suffix is divisible by K ; Since we need powers of 10 for counting , it 's better to  pre store them along with their  modulo with 1e9 + 7 for counting ; Since at each recursive step we increase the suffix length by 1 by placing digits at its leftmost position , we need powers of 10 modded with k , in order to fpos the new remainder efficiently ; Initialising dp table values - 1 represents subproblem hasn 't  been solved yet ; Driver Code"
C#;"using System ; class GFG { public static int maxLengthSquare ( int row , int column , int [ , ] arr , int k ) { int [ , ] sum = new int [ row + 1 , column + 1 ] ; int cur_max = 1 ; int max = 0 ; for ( int i = 1 ; i <= row ; i ++ ) { for ( int j = 1 ; j <= column ; j ++ ) { sum [ i , j ] = sum [ i - 1 , j ] + sum [ i , j - 1 ] + arr [ i - 1 , j - 1 ] - sum [ i - 1 , j - 1 ] ; if ( i >= cur_max && j >= cur_max && sum [ i , j ] - sum [ i - cur_max , j ] - sum [ i , j - cur_max ] + sum [ i - cur_max , j - cur_max ] <= k ) { max = cur_max ++ ; } } } return max ; } public static void Main ( ) { int row = 4 , column = 4 ; int [ , ] matrix = { { 1 , 1 , 1 , 1 } , { 1 , 0 , 0 , 0 } , { 1 , 0 , 0 , 0 } , { 1 , 0 , 0 , 0 } } ; int k = 6 ; int ans = maxLengthSquare ( row , column , matrix , k ) ; Console . WriteLine ( ans ) ; } }";"Find Maximum Length Of A Square Submatrix Having Sum Of Elements At | C # implementation of the above approach ; Function to return maximum length of square submatrix having sum of elements at - most K ; Matrix to store prefix sum ; Current maximum length ; Variable for storing maximum length of square ; Calculating prefix sum ; Checking whether there exits square with length cur_max + 1 or not ; Returning the maximum length ; Driver code"
C#;"using System ; class GFG { static int N = 101 ; static int mod = ( int ) 1e9 + 7 ; static int [ , , ] exactsum = new int [ N , N , N ] ; static int [ , , ] exactnum = new int [ N , N , N ] ; static int getSum ( int x , int y , int z ) { int ans = 0 ; exactnum [ 0 , 0 , 0 ] = 1 ; for ( int i = 0 ; i <= x ; ++ i ) { for ( int j = 0 ; j <= y ; ++ j ) { for ( int k = 0 ; k <= z ; ++ k ) { if ( i > 0 ) { exactsum [ i , j , k ] += ( exactsum [ i - 1 , j , k ] * 10 + 4 * exactnum [ i - 1 , j , k ] ) % mod ; exactnum [ i , j , k ] += exactnum [ i - 1 , j , k ] % mod ; } if ( j > 0 ) { exactsum [ i , j , k ] += ( exactsum [ i , j - 1 , k ] * 10 + 5 * exactnum [ i , j - 1 , k ] ) % mod ; exactnum [ i , j , k ] += exactnum [ i , j - 1 , k ] % mod ; } if ( k > 0 ) { exactsum [ i , j , k ] += ( exactsum [ i , j , k - 1 ] * 10 + 6 * exactnum [ i , j , k - 1 ] ) % mod ; exactnum [ i , j , k ] += exactnum [ i , j , k - 1 ] % mod ; } ans += exactsum [ i , j , k ] % mod ; ans %= mod ; } } } return ans ; } public static void Main ( ) { int x = 1 , y = 1 , z = 1 ; Console . WriteLine ( getSum ( x , y , z ) % mod ) ; } }";"Sum of all numbers formed having 4 atmost X times , 5 atmost Y times and 6 atmost Z times | C # program to find sum of all numbers formed having 4 atmost X times , 5 atmost Y times and 6 atmost Z times ; exactsum [ i ] [ j ] [ k ] stores the sum of all the numbers having exact i 4 ' s , ▁ j ▁ 5' s and k 6 's ; exactnum [ i ] [ j ] [ k ] stores numbers of numbers having exact i 4 ' s , ▁ j ▁ 5' s and k 6 's ; Utility function to calculate the sum for x 4 ' s , ▁ y ▁ 5' s and z 6 's ; Computing exactsum [ i , j , k ] as explained above ; Driver code"
C#;"using System ; class GFG { static void findMax ( int [ ] a , int n ) { int [ , ] dp = new int [ n , 2 ] ; int i , j ; for ( i = 0 ; i < n ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) dp [ i , j ] = 0 ; dp [ 0 , 0 ] = a [ 0 ] + a [ 1 ] ; dp [ 0 , 1 ] = a [ 0 ] * a [ 1 ] ; for ( i = 1 ; i <= n - 2 ; i ++ ) { dp [ i , 0 ] = Math . Max ( dp [ i - 1 , 0 ] , dp [ i - 1 , 1 ] ) + a [ i + 1 ] ; dp [ i , 1 ] = dp [ i - 1 , 0 ] - a [ i ] + a [ i ] * a [ i + 1 ] ; } Console . WriteLine ( Math . Max ( dp [ n - 2 , 0 ] , dp [ n - 2 , 1 ] ) ) ; } public static void Main ( ) { int [ ] arr = { 5 , - 1 , - 5 , - 3 , 2 , 9 , - 4 } ; findMax ( arr , 7 ) ; } }";"Maximum value obtained by performing given operations in an Array | C # implementation of the above approach ; A function to calculate the maximum value ; basecases ; Loop to iterate and add the max value in the dp array ; Driver Code"
C#;"using System ; class GFG { static int sum ( int [ ] arr , int l , int r ) { int s = 0 ; for ( int i = l ; i <= r ; i ++ ) { s += arr [ i ] ; } return s ; } static int [ , , ] dp = new int [ 101 , 101 , 101 ] ; static int solve ( int [ ] arr , int l , int r , int k ) { if ( r - l + 1 <= k ) return sum ( arr , l , r ) ; if ( dp [ l , r , k ] != 0 ) return dp [ l , r , k ] ; int sum_ = sum ( arr , l , r ) ; int len_r = ( r - l + 1 ) - k ; int len = ( r - l + 1 ) ; int ans = 0 ; for ( int i = 0 ; i < len - len_r + 1 ; i ++ ) { int sum_sub = sum ( arr , i + l , i + l + len_r - 1 ) ; ans = Math . Max ( ans , ( sum_ - sum_sub ) + ( sum_sub - solve ( arr , i + l , i + l + len_r - 1 , k ) ) ) ; } dp [ l , r , k ] = ans ; return ans ; } public static void Main ( ) { int [ ] arr = { 10 , 15 , 20 , 9 , 2 , 5 } ; int k = 2 ; int n = arr . Length ; Console . WriteLine ( solve ( arr , 0 , n - 1 , k ) ) ; } }";"Optimal strategy for a Game with modifications | C # implementation of the above approach ; Function to return sum of subarray from l to r ; calculate sum by a loop from l to r ; dp to store the values of sub problems ; if length of the array is less than k return the sum ; if the value is previously calculated ; else calculate the value ; select all the sub array of length len_r ; get the sum of that sub array ; check if it is the maximum or not ; store it in the table ; Driver code"
C#;"using System ; class GFG { static int MAXI = 50 ; static int [ , , ] dp = new int [ MAXI , MAXI , MAXI * MAXI ] ; static int n , m ; static int INT_MAX = int . MaxValue ; static int minDifference ( int x , int y , int k , int [ , ] b , int [ , ] c ) { int diff = 0 ; if ( x >= n y >= m ) return INT_MAX ; if ( x == n - 1 && y == m - 1 ) { diff = b [ x , y ] - c [ x , y ] ; return Math . Min ( Math . Abs ( k - diff ) , Math . Abs ( k + diff ) ) ; } int ans = dp [ x , y , k ] ; if ( ans != - 1 ) return ans ; ans = INT_MAX ; diff = b [ x , y ] - c [ x , y ] ; ans = Math . Min ( ans , minDifference ( x + 1 , y , Math . Abs ( k + diff ) , b , c ) ) ; ans = Math . Min ( ans , minDifference ( x , y + 1 , Math . Abs ( k + diff ) , b , c ) ) ; ans = Math . Min ( ans , minDifference ( x + 1 , y , Math . Abs ( k - diff ) , b , c ) ) ; ans = Math . Min ( ans , minDifference ( x , y + 1 , Math . Abs ( k - diff ) , b , c ) ) ; return ans ; } public static void Main ( ) { n = 2 ; m = 2 ; int [ , ] b = { { 1 , 4 } , { 2 , 4 } } ; int [ , ] c = { { 3 , 2 } , { 3 , 1 } } ; for ( int i = 0 ; i < MAXI ; i ++ ) { for ( int j = 0 ; j < MAXI ; j ++ ) { for ( int k = 0 ; k < MAXI * MAXI ; k ++ ) { dp [ i , j , k ] = - 1 ; } } } Console . WriteLine ( minDifference ( 0 , 0 , 0 , b , c ) ) ; } }";"Find the minimum difference path from ( 0 , 0 ) to ( N | C # implementation of the approach ; Function to return the minimum difference path from ( 0 , 0 ) to ( N - 1 , M - 1 ) ; Terminating case ; Base case ; If it is already visited ; Recursive calls ; Return the value ; Driver code ; Function call"
C#;"using System ; class GFG { static int longest_subseq ( int n , int k , String s ) { int [ ] dp = new int [ n ] ; int [ ] max_length = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int curr = s [ i ] - ' a ' ; int lower = Math . Max ( 0 , curr - k ) ; int upper = Math . Min ( 25 , curr + k ) ; for ( int j = lower ; j < upper + 1 ; j ++ ) { dp [ i ] = Math . Max ( dp [ i ] , max_length [ j ] + 1 ) ; } max_length [ curr ] = Math . Max ( dp [ i ] , max_length [ curr ] ) ; } int ans = 0 ; foreach ( int i in dp ) ans = Math . Max ( i , ans ) ; return ans ; } public static void Main ( String [ ] args ) { String s = "" geeksforgeeks "" ; int n = s . Length ; int k = 3 ; Console . Write ( longest_subseq ( n , k , s ) ) ; } }";"Longest subsequence having difference atmost K | C # program for the above approach ; Function to find the longest Special Sequence ; Creating a list with all 0 's of size  equal to the length of String ; Supporting list with all 0 's of size 26 since  the given String consists  of only lower case alphabets ; Converting the ascii value to list indices ; Determining the lower bound ; Determining the upper bound ; Filling the dp array with values ; Filling the max_length array with max length of subsequence till now ; return the max length of subsequence ; Driver Code"
C#;"using System . Collections . Generic ; using System ; class GFG { static bool areAllNegative ( int [ ] arr ) { int n = arr . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) return false ; } return true ; } static int [ ] getRightToLeftKadane ( int [ ] arr ) { int max_so_far = 0 , max_ending_here = 0 ; int size = arr . Length ; int [ ] new_arr = new int [ size ] ; for ( int i = 0 ; i < size ; i ++ ) new_arr [ i ] = arr [ i ] ; for ( int i = size - 1 ; i >= 0 ; i -- ) { max_ending_here = max_ending_here + new_arr [ i ] ; if ( max_ending_here < 0 ) max_ending_here = 0 ; else if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; new_arr [ i ] = max_so_far ; } return new_arr ; } static int [ ] getPrefixSum ( int [ ] arr ) { int n = arr . Length ; int [ ] new_arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) new_arr [ i ] = arr [ i ] ; for ( int i = 1 ; i < n ; i ++ ) new_arr [ i ] = new_arr [ i - 1 ] + new_arr [ i ] ; return new_arr ; } static int maxSumSubArr ( int [ ] a ) { int max_so_far = 0 , max_ending_here = 0 ; int n = a . Length ; for ( int i = 0 ; i < n ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_ending_here < 0 ) max_ending_here = 0 ; else if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; } return max_so_far ; } static int maxSumSubWithOp ( int [ ] arr ) { int [ ] kadane_r_to_l = getRightToLeftKadane ( arr ) ; int size = arr . Length ; int [ ] prefixSum = getPrefixSum ( arr ) ; for ( int i = 1 ; i < size ; i ++ ) { prefixSum [ i ] = Math . Max ( prefixSum [ i - 1 ] , prefixSum [ i ] ) ; } int max_subarray_sum = 0 ; for ( int i = 0 ; i < size - 1 ; i ++ ) { max_subarray_sum = Math . Max ( max_subarray_sum , prefixSum [ i ] + kadane_r_to_l [ i + 1 ] ) ; } return max_subarray_sum ; } static int maxSum ( int [ ] arr , int size ) { if ( areAllNegative ( arr ) ) { int mx = - 1000000000 ; for ( int i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > mx ) mx = arr [ i ] ; } return mx ; } int resSum = maxSumSubArr ( arr ) ; resSum = Math . Max ( resSum , maxSumSubWithOp ( arr ) ) ; int [ ] reverse_arr = new int [ size ] ; for ( int i = 0 ; i < size ; i ++ ) reverse_arr [ size - 1 - i ] = arr [ i ] ; resSum = Math . Max ( resSum , maxSumSubWithOp ( reverse_arr ) ) ; return resSum ; } public static void Main ( ) { int [ ] arr = { - 9 , 21 , 24 , 24 , - 51 , - 6 , 17 , - 42 , - 39 , 33 } ; int size = arr . Length ; Console . Write ( maxSum ( arr , size ) ) ; } }";"Maximum sum subarray after altering the array | C # implementation of the approach ; Function that returns true if all the array element are <= 0 ; If any element is non - negative ; Function to return the vector representing the right to left Kadane array as described in the approach ; Function to return the prefix_sum vector ; Function to return the maximum sum subarray ; Function to get the maximum sum subarray in the modified array ; kadane_r_to_l [ i ] will store the maximum subarray sum for thre subarray arr [ i ... N - 1 ] ; Get the prefix sum array ; To get max_prefix_sum_at_any_index ; Summation of both gives the maximum subarray sum after applying the operation ; Function to return the maximum subarray sum after performing the given operation at most once ; If all element are negative then return the maximum element ; Maximum subarray sum without performing any operation ; Maximum subarray sum after performing the operations of first type ; Reversing the array to use the same existing function for operations of the second type ; Driver code"
C#;"using System ; class GFG { static int max_sum ( int [ ] a , int n ) { int [ , ] dp = new int [ n + 1 , 2 ] ; dp [ 0 , 0 ] = 0 ; dp [ 0 , 1 ] = - 999999 ; for ( int i = 0 ; i <= n - 1 ; i ++ ) { dp [ i + 1 , 0 ] = Math . Max ( dp [ i , 0 ] + a [ i ] , dp [ i , 1 ] - a [ i ] ) ; dp [ i + 1 , 1 ] = Math . Max ( dp [ i , 0 ] - a [ i ] , dp [ i , 1 ] + a [ i ] ) ; } return dp [ n , 0 ] ; } public static void Main ( String [ ] args ) { int [ ] a = { - 10 , 5 , - 4 } ; int n = a . Length ; Console . WriteLine ( max_sum ( a , n ) ) ; } }";"Maximum possible array sum after performing the given operation | C # implementation of the approach ; Function to return the maximum possible sum after performing the given operation ; Dp vector to store the answer ; Base value ; Return the maximum sum ; Driver code"
C#;"using System ; class GFG { static readonly int MOD = 1000000007 ; static int number_of_ways ( int [ ] arr , int n , int k ) { if ( k == 1 ) return 1 ; int [ ] dp = new int [ k + 1 ] ; int i ; for ( i = 0 ; i < k + 1 ; i ++ ) dp [ i ] = - 1 ; for ( i = 0 ; i < n ; i ++ ) dp [ arr [ i ] ] = 0 ; dp [ 0 ] = 1 ; dp [ 1 ] = ( dp [ 1 ] == - 1 ) ? 1 : dp [ 1 ] ; for ( i = 2 ; i <= k ; ++ i ) { if ( dp [ i ] == 0 ) continue ; dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; dp [ i ] %= MOD ; } return dp [ k ] ; } public static void Main ( String [ ] args ) { int [ ] arr = { 3 } ; int n = arr . Length ; int k = 6 ; Console . WriteLine ( number_of_ways ( arr , n , k ) ) ; } }";"Find the number of ways to reach Kth step in stair case | C # implementation of the approach ; Function to return the number of ways to reach the kth step ; Create the dp array ; Broken steps ; Calculate the number of ways for the rest of the positions ; If it is a blocked position ; Number of ways to get to the ith step ; Return the required answer ; Driver code"
C#;"using System ; class GFG { static int findCount ( int n ) { return ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) + 1 ; } public static void Main ( ) { int N = 10 ; Console . Write ( findCount ( N ) ) ; } }";"Minimum number of coins that can generate all the values in the given range | C # program to find minimum number of coins ; Function to find minimum number of coins ; Driver code"
C#;"using System ; class GFG { static int count ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; } static void findSetBits ( int n ) { for ( int i = 0 ; i <= n ; i ++ ) Console . Write ( count ( i ) + "" ▁ "" ) ; } public static void Main ( String [ ] args ) { int n = 5 ; findSetBits ( n ) ; } }";"Calculate the number of set bits for every number from 0 to N | C # implementation of the approach ; Function to find the count of set bits in all the integers from 0 to n ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { static int countWays ( int n ) { List < int > a = new List < int > ( ) ; int i = 1 ; while ( i <= n ) a . Add ( i ++ ) ; int ways = 0 ; do { bool flag = ( a [ 0 ] == 1 ) ; for ( int j = 1 ; j < n ; j ++ ) { if ( Math . Abs ( a [ j ] - a [ j - 1 ] ) > 2 ) flag = false ; } if ( flag ) ways ++ ; } while ( next_permutation ( a ) ) ; return ways ; } static bool next_permutation ( List < int > p ) { for ( int a = p . Count - 2 ; a >= 0 ; -- a ) if ( p [ a ] < p [ a + 1 ] ) for ( int b = p . Count - 1 ; ; -- b ) if ( p [ b ] > p [ a ] ) { int t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; for ( ++ a , b = p . Count - 1 ; a < b ; ++ a , -- b ) { t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; } return true ; } return false ; } public static void Main ( String [ ] args ) { int n = 6 ; Console . Write ( countWays ( n ) ) ; } }";"Count number of ways to arrange first N numbers | C # implementation of the above approach ; Function to return the count of required arrangements ; Create a vector ; Store numbers from 1 to n ; To store the count of ways ; Generate all the permutations using next_permutation in STL ; Initialize flag to true if first element is 1 else false ; Checking if the current permutation satisfies the given conditions ; If the current permutation is invalid then set the flag to false ; If valid arrangement ; Generate the next permutation ;  ; Driver code"
C#;"using System ; class GFG { static int countWays ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 ; } return dp [ n ] ; } public static void Main ( ) { int n = 6 ; Console . WriteLine ( countWays ( n ) ) ; } }";"Count number of ways to arrange first N numbers | C # implementation of the approach ; Function to return the count of required arrangements ; Create the dp array ; Initialize the base cases as explained above ; ( 12 ) as the only possibility ; Generate answer for greater values ; dp [ n ] contains the desired answer ; Driver code"
C#;"using System ; class GFG { static void NumberOfShortestPaths ( int n , int m ) { int [ , ] a = new int [ n , m ] ; for ( int i = n - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < m ; j ++ ) { if ( j == 0 i == n - 1 ) a [ i , j ] = 1 ; else a [ i , j ] = a [ i , j - 1 ] + a [ i + 1 , j ] ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { Console . Write ( a [ i , j ] + "" ▁ "" ) ; } Console . Write ( "" STRNEWLINE "" ) ; } } public static void Main ( String [ ] args ) { int n = 5 , m = 2 ; NumberOfShortestPaths ( n , m ) ; } }";"Number of shortest paths to reach every cell from bottom | C # program to find number of shortest paths ; Function to find number of shortest paths ; Compute the grid starting from the bottom - left corner ; Print the grid ; Driver code ; Function call"
C#;"using System ; class GFG { static int Max_Sum ( int [ ] arr1 , int [ ] arr2 , int n ) { int [ , ] dp = new int [ n , 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { dp [ i , 0 ] = arr1 [ i ] ; dp [ i , 1 ] = arr2 [ i ] ; continue ; } dp [ i , 0 ] = Math . Max ( dp [ i - 1 , 0 ] , dp [ i - 1 , 1 ] + arr1 [ i ] ) ; dp [ i , 1 ] = Math . Max ( dp [ i - 1 , 1 ] , dp [ i - 1 , 0 ] + arr2 [ i ] ) ; } return Math . Max ( dp [ n - 1 , 0 ] , dp [ n - 1 , 1 ] ) ; } public static void Main ( ) { int [ ] arr1 = { 9 , 3 , 5 , 7 , 3 } ; int [ ] arr2 = { 5 , 8 , 1 , 4 , 5 } ; int n = arr1 . Length ; Console . WriteLine ( Max_Sum ( arr1 , arr2 , n ) ) ; } }";"Maximum sum combination from two arrays | C # program to maximum sum combination from two arrays ; Function to maximum sum combination from two arrays ; To store dp value ; For loop to calculate the value of dp ; Return the required answer ; Driver code ; Function call"
C#;"using System ; class GFG { static Boolean checkpossible ( int mask , int [ ] arr , int [ ] prefix , int n , int k ) { int i , j ; Boolean [ , ] dp = new Boolean [ n + 1 , k + 1 ] ; for ( i = 0 ; i < n + 1 ; i ++ ) { for ( j = 0 ; j < k + 1 ; j ++ ) { dp [ i , j ] = false ; } } dp [ 0 , 0 ] = true ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= k ; j ++ ) { for ( int l = i - 1 ; l >= 0 ; -- l ) { if ( dp [ l , j - 1 ] && ( ( ( prefix [ i ] - prefix [ l ] ) & mask ) == mask ) ) { dp [ i , j ] = true ; break ; } } } } return dp [ n , k ] ; } static int Partition ( int [ ] arr , int n , int k ) { int [ ] prefix = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i ] ; } int LOGS = 20 ; int ans = 0 ; for ( int i = LOGS ; i >= 0 ; -- i ) { if ( checkpossible ( ans | ( 1 << i ) , arr , prefix , n , k ) ) { ans = ans | ( 1 << i ) ; } } return ans ; } public static void Main ( String [ ] args ) { int [ ] arr = { 0 , 1 , 2 , 7 , 10 , 23 , 21 , 6 , 8 , 7 , 3 } ; int k = 2 ; int n = arr . Length - 1 ; Console . WriteLine ( Partition ( arr , n , k ) ) ; } }";"Partition the array in K segments such that bitwise AND of individual segment sum is maximized | C # program to find maximum possible AND ; Function to check whether a k - segment partition is possible such that bitwise AND is ' mask ' ; dp [ i , j ] stores whether it is possible to partition first i elements into j - segments such that all j - segments are ' good ' ; Initialising dp ; Filling dp in bottom - up manner ; Finding a cut such that first l elements can be partitioned into j - 1 ' good ' segments and arr [ l + 1 ] + ... + arr [ i ] is a ' good ' segment ; Function to find maximum possible AND ; Array to store prefix sums ; Maximum no of bits in the possible answer ; This will store the final answer ; Constructing answer greedily selecting from the higher most bit ; Checking if array can be partitioned such that the bitwise AND is ans | ( 1 << i ) ; if possible , update the answer ; Return the final answer ; Driver code ; n = 11 , first element is zero to make array 1 based indexing . So , number of elements are 10 ; Function call"
C#;"using System ; class GFG { static int RODS = 3 ; static int N = 3 ; static int [ , , ] dp = new int [ N + 1 , RODS + 1 , RODS + 1 ] ; static void initialize ( ) { for ( int i = 0 ; i <= N ; i += 1 ) { for ( int j = 1 ; j <= RODS ; j ++ ) { for ( int k = 1 ; k <= RODS ; k += 1 ) { dp [ i , j , k ] = int . MaxValue ; } } } } static int mincost ( int idx , int src , int dest , int [ , ] costs ) { if ( idx > N ) return 0 ; if ( dp [ idx , src , dest ] != int . MaxValue ) return dp [ idx , src , dest ] ; int rem = 6 - ( src + dest ) ; int ans = int . MaxValue ; int case1 = costs [ src - 1 , dest - 1 ] + mincost ( idx + 1 , src , rem , costs ) + mincost ( idx + 1 , rem , dest , costs ) ; int case2 = costs [ src - 1 , rem - 1 ] + mincost ( idx + 1 , src , dest , costs ) + mincost ( idx + 1 , dest , src , costs ) + costs [ rem - 1 , dest - 1 ] + mincost ( idx + 1 , src , dest , costs ) ; ans = Math . Min ( case1 , case2 ) ; dp [ idx , src , dest ] = ans ; return ans ; } public static void Main ( String [ ] args ) { int [ , ] costs = { { 0 , 1 , 2 } , { 2 , 0 , 1 } , { 3 , 2 , 0 } } ; initialize ( ) ; Console . WriteLine ( mincost ( 1 , 1 , 3 , costs ) ) ; } }";"Cost Based Tower of Hanoi | C # implementation of the approach ; Function to initialize the dp table ; Initialize with maximum value ; Function to return the minimum cost ; Base case ; If problem is already solved , return the pre - calculated answer ; Number of the auxiliary disk ; Initialize the minimum cost as Infinity ; Calculationg the cost for first case ; Calculating the cost for second case ; Minimum of both the above cases ; Store it in the dp table ; Return the minimum cost ; Driver code"
C#;"using System ; class GFG { static int C = 5 ; static int R = 3 ; static int INT_MAX = 10000000 ; static int [ , ] table = new int [ R , C ] ; static int [ , ] visited = new int [ R , C ] ; static int min ( int p , int q , int r , int s ) { int temp1 = p < q ? p : q ; int temp2 = r < s ? r : s ; if ( temp1 < temp2 ) return temp1 ; return temp2 ; } static int Distance ( int [ , ] arr , int i , int j ) { if ( i >= R j >= C i < 0 j < 0 ) return INT_MAX ; else if ( arr [ i , j ] == 0 ) { table [ i , j ] = INT_MAX ; return INT_MAX ; } else if ( arr [ i , j ] == 2 ) { table [ i , j ] = 0 ; return 0 ; } else if ( visited [ i , j ] == 1 ) { return INT_MAX ; } else { visited [ i , j ] = 1 ; int temp1 = Distance ( arr , i + 1 , j ) ; int temp2 = Distance ( arr , i - 1 , j ) ; int temp3 = Distance ( arr , i , j + 1 ) ; int temp4 = Distance ( arr , i , j - 1 ) ; int min_value = 1 + min ( temp1 , temp2 , temp3 , temp4 ) ; if ( table [ i , j ] > 0 && table [ i , j ] < INT_MAX ) { if ( min_value < table [ i , j ] ) table [ i , j ] = min_value ; } else table [ i , j ] = min_value ; visited [ i , j ] = 0 ; } return table [ i , j ] ; } static int minTime ( int [ , ] arr ) { int max = 0 ; for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { if ( arr [ i , j ] == 1 ) Distance ( arr , i , j ) ; } } for ( int i = 0 ; i < R ; i ++ ) { for ( int j = 0 ; j < C ; j ++ ) { if ( arr [ i , j ] == 1 && table [ i , j ] > max ) max = table [ i , j ] ; } } if ( max < INT_MAX ) return max ; return - 1 ; } public static void Main ( string [ ] args ) { int [ , ] arr = { { 2 , 1 , 0 , 2 , 1 } , { 0 , 0 , 1 , 2 , 1 } , { 1 , 0 , 0 , 2 , 1 } } ; Console . Write ( minTime ( arr ) ) ; } }";"Minimum time required to rot all oranges | Dynamic Programming | C # implementation of the above approach ; DP table to memoize the values ; Visited array to keep track of visited nodes in order to avoid infinite loops ; Function to return the minimum of four numbers ; Function to return the minimum distance to any rotten orange from [ i , j ] ; If i , j lie outside the array ; If 0 then it can 't lead  to any path so return  INT_MAX ; If 2 then we have reached our rotten oranges so return from here ; If this node is already visited then return to avoid infinite loops ; Mark the current node as visited ; Check in all four possible directions ; Take the minimum of all ; If result already exists in the table check if min_value is less than existing value ; Function to return the minimum time required to rot all the oranges ; Calculate the minimum distances to any rotten orange from all the fresh oranges ; Pick the maximum distance of fresh orange to some rotten orange ; If all oranges can be rotten ; Driver Code"
C#;"using System ; class GFG { static int maxLen = 10 ; static int [ ] dp = new int [ maxLen ] ; static bool [ ] visit = new bool [ maxLen ] ; static int maxSum ( int [ ] arr , int i , int n , int k ) { if ( i >= n ) return 0 ; if ( visit [ i ] ) return dp [ i ] ; visit [ i ] = true ; int tot = 0 ; dp [ i ] = maxSum ( arr , i + 1 , n , k ) ; for ( int j = i ; j < ( i + k ) && ( j < n ) ; j ++ ) { tot += arr [ j ] ; dp [ i ] = Math . Max ( dp [ i ] , tot + maxSum ( arr , j + 2 , n , k ) ) ; } return dp [ i ] ; } static public void Main ( ) { int [ ] arr = { - 1 , 2 , - 3 , 4 , 5 } ; int k = 2 ; int n = arr . Length ; Console . WriteLine ( maxSum ( arr , 0 , n , k ) ) ; } }";"Maximum sum of non | C # program to implement above approach ; Variable to store states of dp ; Variable to check if a given state has been solved ; Function to find the maximum sum subsequence such that no two elements are adjacent ; Base case ; To check if a state has been solved ; Variable to store prefix sum for sub - array { i , j } ; Required recurrence relation ; Returning the value ; Driver code ; Input array"
C#;"using System ; class GFG { static int [ ] dp = new int [ 1024 ] ; static int get_binary ( int u ) { int ans = 0 ; while ( u > 0 ) { int rem = u % 10 ; ans |= ( 1 << rem ) ; u /= 10 ; } return ans ; } static int recur ( int u , int [ ] array , int n ) { if ( u == 0 ) return 0 ; if ( dp [ u ] != - 1 ) return dp [ u ] ; for ( int i = 0 ; i < n ; i ++ ) { int mask = get_binary ( array [ i ] ) ; if ( ( mask u ) == u ) { dp [ u ] = Math . Max ( Math . Max ( 0 , dp [ u ^ mask ] ) + array [ i ] , dp [ u ] ) ; } } return dp [ u ] ; } static int solve ( int [ ] array , int n ) { for ( int i = 0 ; i < ( 1 << 10 ) ; i ++ ) { dp [ i ] = - 1 ; } int ans = 0 ; for ( int i = 0 ; i < ( 1 << 10 ) ; i ++ ) { ans = Math . Max ( ans , recur ( i , array , n ) ) ; } return ans ; } static public void Main ( ) { int [ ] array = { 22 , 132 , 4 , 45 , 12 , 223 } ; int n = array . Length ; Console . WriteLine ( solve ( array , n ) ) ; } }";"Maximum subset sum such that no two elements in set have same digit in them | C # implementation of above approach ; Function to create mask for every number ; Recursion for Filling DP array ; Base Condition ; Recurrence Relation ; Function to find Maximum Subset Sum ; Initialize DP array ; Iterate over all possible masks of 10 bit number ; Driver Code"
C#;"using System ; class GFG { static int SIZE = 3 ; static int N = 3 ; static int minSum ( int [ ] A , int [ ] B , int [ ] C , int i , int n , int curr , int [ , ] dp ) { if ( n <= 0 ) return 0 ; if ( dp [ n , curr ] != - 1 ) return dp [ n , curr ] ; if ( curr == 0 ) { return dp [ n , curr ] = Math . Min ( B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; } if ( curr == 1 ) return dp [ n , curr ] = Math . Min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; return dp [ n , curr ] = Math . Min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) ) ; } public static void Main ( ) { int [ ] A = { 1 , 50 , 1 } ; int [ ] B = { 50 , 50 , 50 } ; int [ ] C = { 50 , 50 , 50 } ; int [ , ] dp = new int [ SIZE , N ] ; for ( int i = 0 ; i < SIZE ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) dp [ i , j ] = - 1 ; Console . WriteLine ( Math . Min ( A [ 0 ] + minSum ( A , B , C , 1 , SIZE - 1 , 0 , dp ) , Math . Min ( B [ 0 ] + minSum ( A , B , C , 1 , SIZE - 1 , 1 , dp ) , C [ 0 ] + minSum ( A , B , C , 1 , SIZE - 1 , 2 , dp ) ) ) ) ; } }";"Minimize the sum after choosing elements from the given three arrays | C # implementation of the above approach ; Function to return the minimized sum ; If all the indices have been used ; If this value is pre - calculated then return its value from dp array instead of re - computing it ; If A [ i - 1 ] was chosen previously then only B [ i ] or C [ i ] can chosen now choose the one which leads to the minimum sum ; If B [ i - 1 ] was chosen previously then only A [ i ] or C [ i ] can chosen now choose the one which leads to the minimum sum ; If C [ i - 1 ] was chosen previously then only A [ i ] or B [ i ] can chosen now choose the one which leads to the minimum sum ; Driver code ; Initialize the dp [ ] [ ] array ; min ( start with A [ 0 ] , start with B [ 0 ] , start with C [ 0 ] )"
C#;"using System ; class GFG { static int n = 3 ; static int [ , , ] dp = new int [ n , n , 2 ] ; static bool [ , , ] v = new bool [ n , n , 2 ] ; static int max ( int a , int b , int c ) { int m = a ; if ( m < b ) { m = b ; } if ( m < c ) { m = c ; } return m ; } static int maxScore ( int [ , ] arr , int i , int j , int s ) { if ( i > n - 1 i < 0 j > n - 1 ) { return 0 ; } if ( ( i == 0 ) && ( j == ( n - 1 ) ) ) { return arr [ i , j ] ; } if ( v [ i , j , s ] ) { return dp [ i , j , s ] ; } v [ i , j , s ] = true ; if ( s != 1 ) { dp [ i , j , s ] = arr [ i , j ] + Math . Max ( maxScore ( arr , i + 1 , j , s ) , Math . Max ( maxScore ( arr , i , j + 1 , s ) , maxScore ( arr , i - 1 , j , ( s == 1 ) ? 0 : 1 ) ) ) ; else { dp [ i , j , s ] = arr [ i , j ] + Math . Max ( maxScore ( arr , i - 1 , j , s ) , maxScore ( arr , i , j + 1 , s ) ) ; } return dp [ i , j , s ] ; } static public void Main ( ) { int [ , ] arr = { { 1 , 1 , 1 } , { 1 , 5 , 1 } , { 1 , 1 , 1 } } ; Console . WriteLine ( maxScore ( arr , 0 , 0 , 0 ) ) ; } }";"Maximise matrix sum by following the given Path | C # implementation of the approach ; To store the states of the DP ; Function to return the maximum of the three integers ; Function to return the maximum score ; Base cases ; If the state has already been solved then return it ; Marking the state as solved ; Growing phase ; } Shrinking phase ; Returning the solved state ; Driver code"
C#;"using System ; class GFG { static int MaximumMarks ( int [ ] marksarr , int [ ] timearr , int h , int n , int p ) { int no_of_topics = n + 1 ; int total_time = h + 1 ; int [ , ] T = new int [ no_of_topics , total_time ] ; int i , j ; for ( i = 0 ; i < no_of_topics ; i ++ ) { T [ i , 0 ] = 0 ; } for ( j = 0 ; j < total_time ; j ++ ) { T [ 0 , j ] = 0 ; } for ( i = 1 ; i < no_of_topics ; i ++ ) { for ( j = 1 ; j < total_time ; j ++ ) { if ( j < timearr [ i ] ) { T [ i , j ] = T [ i - 1 , j ] ; } else { T [ i , j ] = Math . Max ( marksarr [ i ] + T [ i - 1 , j - timearr [ i ] ] , T [ i - 1 , j ] ) ; } } } i = no_of_topics - 1 ; j = total_time - 1 ; int sum = 0 ; while ( i > 0 && j > 0 ) { if ( T [ i , j ] == T [ i - 1 , j ] ) { i -- ; } else { sum += timearr [ i ] ; j -= timearr [ i ] ; i -- ; } } int marks = T [ no_of_topics - 1 , total_time - 1 ] ; if ( marks < p ) return - 1 ; return sum ; } public static void Main ( String [ ] args ) { int n = 4 , h = 10 , p = 10 ; int [ ] marksarr = { 0 , 6 , 4 , 2 , 8 } ; int [ ] timearr = { 0 , 4 , 6 , 2 , 7 } ; Console . WriteLine ( MaximumMarks ( marksarr , timearr , h , n , p ) ) ; } }";"Find maximum topics to prepare in order to pass the exam | C # implementation of the approach ; Function to return the maximum marks by considering topics which can be completed in the given time duration ; If we are given 0 time then nothing can be done So all values are 0 ; If we are given 0 topics then the time required will be 0 for sure ; Calculating the maximum marks that can be achieved under the given time constraints ; If time taken to read that topic is more than the time left now at position j then do no read that topic ; Two cases arise : 1 ) Considering current topic 2 ) Ignoring current topic We are finding maximum of ( current topic weightage + topics which can be done in leftover time - current topic time ) and ignoring current topic weightage sum ; Moving upwards in table from bottom right to calculate the total time taken to read the topics which can be done in given time and have highest weightage sum ; It means we have not considered reading this topic for max weightage sum ; Adding the topic time ; Evaluating the left over time after considering this current topic ; One topic completed ; It contains the maximum weightage sum formed by considering the topics ; Condition when exam cannot be passed ; Return the marks that can be obtained after passing the exam ; Driver code ; Number of topics , hours left and the passing marks ; n + 1 is taken for simplicity in loops Array will be indexed starting from 1"
C#;"using System ; class GFG { static int maxLen = 10 ; static int maskLen = 130 ; static int [ , ] dp = new int [ maxLen , maskLen ] ; static bool [ , ] v = new bool [ maxLen , maskLen ] ; static int minSteps ( int [ ] arr , int i , int mask , int n ) { if ( i == n - 1 ) { return 0 ; } if ( i > n - 1 i < 0 ) { return 9999999 ; } if ( ( mask >> i ) % 2 == 1 ) { return 9999999 ; } if ( v [ i , mask ] ) { return dp [ i , mask ] ; } v [ i , mask ] = true ; dp [ i , mask ] = 1 + Math . Min ( minSteps ( arr , i - arr [ i ] , ( mask | ( 1 << i ) ) , n ) , minSteps ( arr , i + arr [ i ] , ( mask | ( 1 << i ) ) , n ) ) ; return dp [ i , mask ] ; } static public void Main ( ) { int [ ] arr = { 1 , 2 , 2 , 2 , 1 , 1 } ; int n = arr . Length ; int ans = minSteps ( arr , 0 , 0 , n ) ; if ( ans >= 9999999 ) { Console . WriteLine ( - 1 ) ; } else { Console . WriteLine ( ans ) ; } } }";"Minimize the number of steps required to reach the end of the array | C # implementation of the above approach ; variable to store states of dp ; variable to check if a given state has been solved ; Function to find the minimum number of steps required to reach the end of the array ; base case ; to check if a state has been solved ; required recurrence relation ; returning the value ; Driver code"
C#;"using System ; class GFG { static int oSRec ( int [ ] arr , int i , int j , int sum ) { if ( j == i + 1 ) return Math . Max ( arr [ i ] , arr [ j ] ) ; return Math . Max ( ( sum - oSRec ( arr , i + 1 , j , sum - arr [ i ] ) ) , ( sum - oSRec ( arr , i , j - 1 , sum - arr [ j ] ) ) ) ; } static int optimalStrategyOfGame ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } return oSRec ( arr , 0 , n - 1 , sum ) ; } static public void Main ( ) { int [ ] arr1 = { 8 , 15 , 3 , 7 } ; int n = arr1 . Length ; Console . WriteLine ( optimalStrategyOfGame ( arr1 , n ) ) ; int [ ] arr2 = { 2 , 2 , 2 , 2 } ; n = arr2 . Length ; Console . WriteLine ( optimalStrategyOfGame ( arr2 , n ) ) ; int [ ] arr3 = { 20 , 30 , 2 , 2 , 2 , 10 } ; n = arr3 . Length ; Console . WriteLine ( optimalStrategyOfGame ( arr3 , n ) ) ; } }";"Optimal Strategy for a Game | Set 2 | C # program to find out maximum value from a given sequence of coins ; For both of your choices , the opponent gives you total sum minus maximum of his value ; Returns optimal value possible that a player can collect from an array of coins of size n . Note than n must be even ; Driver code"
C#;"using System ; class GFG { static Boolean ispower ( long n ) { if ( n < 125 ) { return ( n == 1 n == 5 n == 25 ) ; } if ( n % 125 != 0 ) { return false ; } else { return ispower ( n / 125 ) ; } } static long number ( String s , int i , int j ) { long ans = 0 ; for ( int x = i ; x < j ; x ++ ) { ans = ans * 2 + ( s [ x ] - '0' ) ; } return ans ; } static int minCuts ( String s , int n ) { int [ ] dp = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i ] = n + 1 ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( s [ i - 1 ] == '0' ) { continue ; } for ( int j = 0 ; j < i ; j ++ ) { if ( s [ j ] == '0' ) { continue ; } long num = number ( s , j , i ) ; if ( ! ispower ( num ) ) { continue ; } dp [ i ] = Math . Min ( dp [ i ] , dp [ j ] + 1 ) ; } } return ( ( dp [ n ] < n + 1 ) ? dp [ n ] : - 1 ) ; } public static void Main ( String [ ] args ) { String s = ""101101101"" ; int n = s . Length ; Console . WriteLine ( minCuts ( s , n ) ) ; } }";"Minimum number of sub | C # implementation of the approach ; Function that returns true if n is a power of 5 ; Function to return the decimal value of binary equivalent ; Function to return the minimum cuts required ; Alongocating memory for dp [ ] array ; From length 1 to n ; If previous character is '0' then ignore to avoid number with leading 0 s . ; Ignore s [ j ] = '0' starting numbers ; Number formed from s [ j ... . i ] ; Check for power of 5 ; Assigning min value to get min cut possible ; ( n + 1 ) to check if all the Strings are traversed and no divisible by 5 is obtained like 000000 ; Driver code"
C#;"using System ; class GFG { static int MinOfCubed ( int k ) { if ( k < 8 ) return k ; int res = k ; for ( int i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = Math . Min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; } static public void Main ( ) { int num = 15 ; Console . WriteLine ( MinOfCubed ( num ) ) ; } }";"Minimum number of cubes whose sum equals to given number N | C # implementation of the approach ; Function to return the minimum number of cubes whose sum is k ; If k is less than the 2 ^ 3 ; Initialize with the maximum number of cubes required ; Driver code"
C#;"using System ; class GFG { static int MinOfCubedDP ( int k ) { int [ ] DP = new int [ k + 1 ] ; int j = 1 , t = 1 ; DP [ 0 ] = 0 ; for ( int i = 1 ; i <= k ; i ++ ) { DP [ i ] = int . MaxValue ; while ( j <= i ) { if ( j == i ) DP [ i ] = 1 ; else if ( DP [ i ] > DP [ i - j ] ) DP [ i ] = DP [ i - j ] + 1 ; t ++ ; j = t * t * t ; } t = j = 1 ; } return DP [ k ] ; } public static void Main ( ) { int num = 15 ; Console . WriteLine ( MinOfCubedDP ( num ) ) ; } }";"Minimum number of cubes whose sum equals to given number N | C # implementation of the approach ; Function to return the minimum number of cubes whose sum is k ; While current perfect cube is less than current element ; If i is a perfect cube ; i = ( i - 1 ) + 1 ^ 3 ; Next perfect cube ; Re - initialization for next element ; Driver code"
C#;"using System ; class GFG { static int maxSum ( int [ ] a , int n ) { int ans = 0 ; int [ ] arr = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = a [ i - 1 ] ; int [ , ] dp = new int [ n + 1 , 3 ] ; for ( int i = 1 ; i <= n ; ++ i ) { dp [ i , 0 ] = Math . Max ( arr [ i ] , dp [ i - 1 , 0 ] + arr [ i ] ) ; dp [ i , 1 ] = Math . Max ( 0 , dp [ i - 1 , 0 ] ) - arr [ i ] ; if ( i >= 2 ) dp [ i , 1 ] = Math . Max ( dp [ i , 1 ] , dp [ i - 1 , 1 ] + arr [ i ] ) ; if ( i >= 2 ) dp [ i , 2 ] = dp [ i - 1 , 1 ] - arr [ i ] ; if ( i >= 3 ) dp [ i , 2 ] = Math . Max ( dp [ i , 2 ] , dp [ i - 1 , 2 ] + arr [ i ] ) ; ans = Math . Max ( ans , dp [ i , 0 ] ) ; ans = Math . Max ( ans , dp [ i , 1 ] ) ; ans = Math . Max ( ans , dp [ i , 2 ] ) ; } return ans ; } public static void Main ( ) { int [ ] arr = { - 5 , 3 , 2 , 7 , - 8 , 3 , 7 , - 9 , 10 , 12 , - 6 } ; int n = arr . Length ; Console . WriteLine ( maxSum ( arr , n ) ) ; } }";"Maximum Subarray Sum after inverting at most two elements | C # implementation of the approach ; Function to return the maximum required sub - array sum ; Creating one based indexing ; 2d array to contain solution for each step ; Case 1 : Choosing current or ( current + previous ) whichever is smaller ; Case 2 : ( a ) Altering sign and add to previous case 1 or value 0 ; Case 2 : ( b ) Adding current element with previous case 2 and updating the maximum ; Case 3 : ( a ) Altering sign and add to previous case 2 ; Case 3 : ( b ) Adding current element with previous case 3 ; Updating the maximum value of variable ans ; Return the final solution ; Driver code"
C#;"using System ; using System . Linq ; class GFG { static int maxSum ( int [ ] arr , int k , int n ) { if ( n == 0 ) return 0 ; if ( n == 1 ) return arr [ 0 ] ; if ( n == 2 ) return Math . Max ( arr [ 0 ] , arr [ 1 ] ) ; int [ ] dp = new int [ n ] ; dp [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i <= k ; i ++ ) dp [ i ] = Math . Max ( arr [ i ] , dp [ i - 1 ] ) ; for ( int i = k + 1 ; i < n ; i ++ ) dp [ i ] = Math . Max ( arr [ i ] , dp [ i - ( k + 1 ) ] + arr [ i ] ) ; int max = dp . Max ( ) ; return max ; } static void Main ( ) { int [ ] arr = { 6 , 7 , 1 , 3 , 8 , 2 , 4 } ; int n = arr . Length ; int k = 2 ; Console . WriteLine ( maxSum ( arr , k , n ) ) ; } }";"Maximum sum possible for a sub | C # implementation of the approach ; Function to return the maximum sum possible ; dp [ i ] represent the maximum sum so far after reaching current position i ; Initialize dp [ 0 ] ; Initialize the dp values till k since any two elements included in the sub - sequence must be atleast k indices apart , and thus first element and second element will be k indices apart ; Fill remaining positions ; Return the maximum sum ; Driver code"
C#;"using System ; class GFG { public static int MinimumCost ( int [ ] a , int n , int x ) { for ( int i = 1 ; i < n ; i ++ ) { a [ i ] = Math . Min ( a [ i ] , 2 * a [ i - 1 ] ) ; } int ind = 0 ; int sum = 0 ; while ( x > 0 ) { if ( x != 0 ) sum += a [ ind ] ; ind ++ ; x = x >> 1 ; } return sum ; } public static void Main ( ) { int [ ] a = { 20 , 50 , 60 , 90 } ; int x = 7 ; int n = a . Length ; Console . WriteLine ( MinimumCost ( a , n , x ) ) ; } }";"Minimum cost to form a number X by adding up powers of 2 | C # implementation of the approach ; Function to return the minimum cost ; Re - compute the array ; Add answers for set bits ; If bit is set ; Increase the counter ; Right shift the number ; Driver code"
C#;"using System ; class GFG { static int countWays ( int n , int l , int r ) { int tL = l , tR = r ; int [ ] L = new int [ 3 ] ; int [ ] R = new int [ 3 ] ; L [ l % 2 ] = l ; R [ r % 2 ] = r ; l ++ ; r -- ; if ( l <= tR && r >= tL ) { L [ l % 2 ] = l ; R [ r % 2 ] = r ; } int cnt0 = 0 , cnt1 = 0 ; if ( R [ 0 ] > 0 && L [ 0 ] > 0 ) cnt0 = ( R [ 0 ] - L [ 0 ] ) / 2 + 1 ; if ( R [ 1 ] > 0 && L [ 1 ] > 0 ) cnt1 = ( R [ 1 ] - L [ 1 ] ) / 2 + 1 ; int [ , ] dp = new int [ n + 1 , 3 ] ; dp [ 1 , 0 ] = cnt0 ; dp [ 1 , 1 ] = cnt1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i , 0 ] = ( cnt0 * dp [ i - 1 , 0 ] + cnt1 * dp [ i - 1 , 1 ] ) ; dp [ i , 1 ] = ( cnt0 * dp [ i - 1 , 1 ] + cnt1 * dp [ i - 1 , 0 ] ) ; } return dp [ n , 0 ] ; } static void Main ( ) { int n = 2 , l = 1 , r = 3 ; Console . WriteLine ( countWays ( n , l , r ) ) ; } }";"Ways to form an array having integers in given range such that total sum is divisible by 2 | C # implementation of the approach ; Function to return the number of ways to form an array of size n such that sum of all elements is divisible by 2 ; Represents first and last numbers of each type ( modulo 0 and 1 ) ; Count of numbers of each type between range ; Base Cases ; Ways to form array whose sum upto i numbers modulo 2 is 0 ; Ways to form array whose sum upto i numbers modulo 2 is 1 ; Return the required count of ways ; Driver Code"
C#;"using System ; class GFG { static int M = 1001 ; static int MOD = 998244353 ; static int [ , ] dp = new int [ M , M ] ; static int solve ( int idx , int diff , int N , int M , int K ) { if ( idx > N ) { if ( diff == K ) return 1 ; return 0 ; } if ( dp [ idx , diff ] != - 1 ) return dp [ idx , diff ] ; int ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; return dp [ idx , diff ] = ans % MOD ; } public static void Main ( ) { int N = 3 , M = 3 , K = 0 ; for ( int i = 0 ; i <= M ; i ++ ) for ( int j = 0 ; j <= M ; j ++ ) dp [ i , j ] = - 1 ; Console . WriteLine ( ( M * solve ( 2 , 0 , N , M , K ) ) ) ; } }";"Color N boxes using M colors such that K boxes have different color from the box on its left | C # Program to Paint N boxes using M colors such that K boxes have color different from color of box on its left ; This function returns the required number of ways where idx is the current index and diff is number of boxes having different color from box on its left ; Base Case ; If already computed ; Either paint with same color as previous one ; Or paint with remaining ( M - 1 ) colors ; Driver code ; Multiply M since first box can be painted with any of the M colors and start solving from 2 nd box"
C#;"using System ; class GFG { static int N = 3 ; static int maxPathSum ( int [ , ] tri ) { int ans = 0 ; for ( int i = N - 2 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < N - i ; j ++ ) { if ( j - 1 >= 0 ) tri [ i , j ] += Math . Max ( tri [ i + 1 , j ] , tri [ i + 1 , j - 1 ] ) ; else tri [ i , j ] += tri [ i + 1 , j ] ; ans = Math . Max ( ans , tri [ i , j ] ) ; } } return ans ; } public static void Main ( ) { int [ , ] tri = { { 1 , 5 , 3 } , { 4 , 8 , 0 } , { 1 , 0 , 0 } } ; Console . WriteLine ( maxPathSum ( tri ) ) ; } }";"Maximum path sum in an Inverted triangle | SET 2 | C # program implementation of Max sum problem in a triangle ; Function for finding maximum sum ; Loop for bottom - up calculation ; For each element , check both elements just below the number and below left to the number add the maximum of them to it ; Return the maximum sum ; Driver Code"
C#;"using System ; class GFG { static int subsetXOR ( int [ ] arr , int n , int K ) { int max_ele = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; int m = ( 1 << ( int ) ( Math . Log ( max_ele ) / Math . Log ( 2 ) + 1 ) ) - 1 ; int [ , , ] dp = new int [ n + 1 , m + 1 , n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) for ( int k = 0 ; k <= n ; k ++ ) dp [ i , j , k ] = 0 ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i , 0 , 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= m ; j ++ ) { for ( int k = 0 ; k <= n ; k ++ ) { dp [ i , j , k ] = dp [ i - 1 , j , k ] ; if ( k != 0 ) { dp [ i , j , k ] += k * dp [ i - 1 , j ^ arr [ i - 1 ] , k - 1 ] ; } } } } int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { ans += dp [ n , K , i ] ; } return ans ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 } ; int k = 1 ; int n = arr . Length ; Console . WriteLine ( subsetXOR ( arr , n , k ) ) ; } }";"Count no . of ordered subsets having a particular XOR value | C # implementation of the approach ; Returns count of ordered subsets of arr [ ] with XOR value = K ; Find maximum element in arr [ ] ; Maximum possible XOR value ; The value of dp [ i ] [ j ] [ k ] is the number of subsets of length k having XOR of their elements as j from the set arr [ 0. . . i - 1 ] ; Initializing all the values of dp [ i ] [ j ] [ k ] as 0 ; The xor of empty subset is 0 ; Fill the dp table ; The answer is the number of subsets of all lengths from set arr [ 0. . n - 1 ] having XOR of elements as k ; Driver code"
C#;"using System ; class GFG { static int get_max_splits ( String num_String ) { int count = 0 , current_num ; int running_sum = 0 ; for ( int i = 0 ; i < num_String . Length ; i ++ ) { current_num = num_String [ i ] - '0' ; running_sum += current_num ; if ( current_num % 3 == 0 || ( running_sum != 0 && running_sum % 3 == 0 ) ) { count += 1 ; running_sum = 0 ; } } return count ; } public static void Main ( String [ ] args ) { Console . Write ( get_max_splits ( ""12345"" ) + "" STRNEWLINE "" ) ; } }";"Possible cuts of a number such that maximum parts are divisible by 3 | C # program to find the maximum number of numbers divisible by 3 in large number ; This will contain the count of the splits ; This will keep sum of all successive integers , when they are indivisible by 3 ; This is the condition of finding a split ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { static readonly int M = 20 ; static int [ , , , ] dp = new int [ M , M , 2 , 2 ] ; static int d , K ; static int count ( int pos , int cnt , int tight , int nonz , List < int > num ) { if ( pos == num . Count ) { if ( cnt == K ) return 1 ; return 0 ; } if ( dp [ pos , cnt , tight , nonz ] != - 1 ) return dp [ pos , cnt , tight , nonz ] ; int ans = 0 ; int limit = ( ( tight != 0 ) ? 9 : num [ pos ] ) ; for ( int dig = 0 ; dig <= limit ; dig ++ ) { int currCnt = cnt ; if ( dig == d ) { if ( d != 0 || ( d == 0 && nonz != 0 ) ) currCnt ++ ; } int currTight = tight ; if ( dig < num [ pos ] ) currTight = 1 ; ans += count ( pos + 1 , currCnt , currTight , ( dig != 0 ? 1 : 0 ) , num ) ; } return dp [ pos , cnt , tight , nonz ] = ans ; } static int solve ( int x ) { List < int > num = new List < int > ( ) ; while ( x != 0 ) { num . Add ( x % 10 ) ; x /= 10 ; } num . Reverse ( ) ; for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) for ( int k = 0 ; k < 2 ; k ++ ) for ( int l = 0 ; l < 2 ; l ++ ) dp [ i , j , k , l ] = - 1 ; return count ( 0 , 0 , 0 , 0 , num ) ; } public static void Main ( ) { int L = 11 , R = 100 ; d = 2 ; K = 1 ; Console . Write ( solve ( R ) - solve ( L - 1 ) ) ; } }";"Count of Numbers in a Range where digit d occurs exactly K times | C # Program to find the count of numbers in a range where digit d occurs exactly K times ; states - position , count , tight , nonz ; d is required digit and K is occurrence ; This function returns the count of required numbers from 0 to num ; Last position ; If this result is already computed simply return it ; Maximum limit upto which we can place digit . If tight is 1 , means number has already become smaller so we can place any digit , otherwise num [ pos ] ; Nonz is true if we placed a non zero digit at the starting of the number ; At this position , number becomes smaller ; Next recursive call , also set nonz to 1 if current digit is non zero ; Function to convert x into its digit vector and uses count ( ) function to return the required count ; Initialize dp ; Driver Code"
C#;"using System ; class GFG { public static int solve ( int x ) { int ans = 0 , first = 0 , last , temp = x ; if ( x < 10 ) return x ; last = x % 10 ; while ( x != 0 ) { first = x % 10 ; x /= 10 ; } if ( first <= last ) ans = 9 + temp / 10 ; else ans = 8 + temp / 10 ; return ans ; } public static void Main ( String [ ] args ) { int L = 2 , R = 60 ; Console . WriteLine ( solve ( R ) - solve ( L - 1 ) ) ; L = 1 ; R = 1000 ; Console . WriteLine ( solve ( R ) - solve ( L - 1 ) ) ; } }";"Count of Numbers in Range where first digit is equal to last digit of the number | C # program to implement the above approach ; Base Case ; Calculating the last digit ; Calculating the first digit ; Driver code"
C#;"using System ; class GFG { static int findMinimumCost ( int n , int x , int y ) { int [ ] dp = new int [ n + 1 ] ; dp [ 1 ] = x ; for ( int i = 2 ; i <= n ; i ++ ) { if ( ( i & 1 ) != 0 ) { dp [ i ] = Math . Min ( dp [ i - 1 ] + x , dp [ ( i + 1 ) / 2 ] + y + x ) ; } else { dp [ i ] = Math . Min ( dp [ i - 1 ] + x , dp [ i / 2 ] + y ) ; } } return dp [ n ] ; } public static void Main ( ) { int n = 4 , x = 2 , y = 1 ; Console . WriteLine ( findMinimumCost ( n , x , y ) ) ; } }";"Form N | C # code to find minimum cost to form a N - copy string ; Returns the minimum cost to form a n - copy string Here , x -> Cost to add / remove a single character ' G ' and y -> cost to append the string to itself ; Base Case : to form a 1 - copy string we need to perform an operation of type 1 ( i . e Add ) ; Case1 . Perform a Add operation on ( i - 1 ) - copy string , Case2 . Perform a type 2 operation on ( ( i + 1 ) / 2 ) - copy string ; Case1 . Perform a Add operation on ( i - 1 ) - copy string , Case2 . Perform a type 3 operation on ( i / 2 ) - copy string ; Driver Code"
C#;"using System ; class Solution { static int r = 4 , c = 5 ; static int findMinSteps ( int [ , ] mat , int n , int m , int [ , ] dp , bool [ , ] vis ) { if ( n == 0 || m == 0 || n == ( r - 1 ) || m == ( c - 1 ) ) { return 0 ; } if ( dp [ n , m ] != - 1 ) return dp [ n , m ] ; vis [ n , m ] = true ; int ans1 , ans2 , ans3 , ans4 ; ans1 = ans2 = ans3 = ans4 = ( int ) 1e9 ; if ( mat [ n - 1 , m ] == 0 ) { if ( ! vis [ n - 1 , m ] ) ans1 = 1 + findMinSteps ( mat , n - 1 , m , dp , vis ) ; } if ( mat [ n , m + 1 ] == 0 ) { if ( ! vis [ n , m + 1 ] ) ans2 = 1 + findMinSteps ( mat , n , m + 1 , dp , vis ) ; } if ( mat [ n , m - 1 ] == 0 ) { if ( ! vis [ n , m - 1 ] ) ans3 = 1 + findMinSteps ( mat , n , m - 1 , dp , vis ) ; } if ( mat [ n + 1 , m ] == 0 ) { if ( ! vis [ n + 1 , m ] ) ans4 = 1 + findMinSteps ( mat , n + 1 , m , dp , vis ) ; } dp [ n , m ] = Math . Min ( ans1 , Math . Min ( ans2 , Math . Min ( ans3 , ans4 ) ) ) ; return dp [ n , m ] ; } static int minimumSteps ( int [ , ] mat , int n , int m ) { int twox = - 1 ; int twoy = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { if ( mat [ i , j ] == 2 ) { twox = i ; twoy = j ; break ; } } if ( twox != - 1 ) break ; } int [ , ] dp = new int [ r , r ] ; for ( int j = 0 ; j < r ; j ++ ) for ( int i = 0 ; i < r ; i ++ ) dp [ j , i ] = - 1 ; bool [ , ] vis = new bool [ r , r ] ; for ( int j = 0 ; j < r ; j ++ ) for ( int i = 0 ; i < r ; i ++ ) vis [ j , i ] = false ; int res = findMinSteps ( mat , twox , twoy , dp , vis ) ; if ( res >= 1e9 ) return - 1 ; else return res ; } public static void Main ( ) { int [ , ] mat = { { 1 , 1 , 1 , 0 , 1 } , { 1 , 0 , 2 , 0 , 1 } , { 0 , 0 , 1 , 0 , 1 } , { 1 , 0 , 1 , 1 , 0 } , } ; Console . WriteLine ( minimumSteps ( mat , r , c ) ) ; } }";"Minimum steps to reach any of the boundary edges of a matrix | Set 1 | C # program to find Minimum steps to reach any of the boundary edges of a matrix ; Function to find out minimum steps ; boundary edges reached ; already had a route through this point , hence no need to re - visit ; visiting a position ; vertically up ; horizontally right ; horizontally left ; vertically down ; minimum of every path ; Function that returns the minimum steps ; index to store the location at which you are standing ; find '2' in the matrix ; Initialize dp matrix with - 1 ; Initialize vis matrix with false ; Call function to find out minimum steps using memoization and recursion ; if not possible ; Driver Code"
C#;"using System ; public class GFG { static int nCr ( int n , int r ) { int ans = 1 ; if ( r > n - r ) r = n - r ; for ( int i = 0 ; i < r ; i ++ ) { ans *= ( n - i ) ; ans /= ( i + 1 ) ; } return ans ; } static int countDerangements ( int n ) { int [ ] der = new int [ n + 3 ] ; der [ 0 ] = 1 ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( int i = 3 ; i <= n ; i ++ ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; } static int countPermutations ( int n , int k ) { int ans = 0 ; for ( int i = n - k ; i <= n ; i ++ ) { int ways = nCr ( n , i ) ; ans += ( ways * countDerangements ( n - i ) ) ; } return ans ; } public static void Main ( ) { int n = 5 , k = 3 ; Console . WriteLine ( countPermutations ( n , k ) ) ; } }";"Count the number of special permutations | C # program to count the number of required permutations ; Function to return the number of ways to choose r objects out of n objects ; Function to return the number of derangements of n ; Function to return the required number of permutations ; Ways to choose i indices from n indices ; Dearangements of ( n - i ) indices System . out . println ( ans ) ; ; Driver Code to test above functions"
C#;"using System ; class GFG { class pair { public int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int n = 3 ; static int [ , ] dp = new int [ n , n ] ; static void answerQueries ( pair [ ] queries , int q ) { for ( int i = 0 ; i < q ; i ++ ) { int x = queries [ i ] . first ; x -- ; int y = queries [ i ] . second ; y -- ; Console . WriteLine ( dp [ x , y ] ) ; } } static void pre_compute ( char [ , ] a ) { if ( a [ 0 , 0 ] == ' a ' ) dp [ 0 , 0 ] = 0 ; else dp [ 0 , 0 ] = 1 ; for ( int row = 0 ; row < n ; row ++ ) { for ( int col = 0 ; col < n ; col ++ ) { if ( row != 0 col != 0 ) dp [ row , col ] = int . MaxValue ; if ( row != 0 ) { dp [ row , col ] = Math . Min ( dp [ row , col ] , dp [ row - 1 , col ] ) ; } if ( col != 0 ) { dp [ row , col ] = Math . Min ( dp [ row , col ] , dp [ row , col - 1 ] ) ; } if ( a [ row , col ] != ' a ' && ( row != 0 col != 0 ) ) dp [ row , col ] += 1 ; } } } public static void Main ( String [ ] args ) { char [ , ] a = { { ' a ' , ' b ' , ' a ' } , { ' a ' , ' c ' , ' d ' } , { ' b ' , ' a ' , ' b ' } } ; pair [ ] queries = { new pair ( 1 , 3 ) , new pair ( 3 , 3 ) } ; int q = 2 ; pre_compute ( a ) ; answerQueries ( queries , q ) ; } }";"Paths with maximum number of ' a ' from ( 1 , 1 ) to ( X , Y ) vertically or horizontally | C # program to find paths with maximum number of ' a ' from ( 1 , 1 ) to ( X , Y ) vertically or horizontally ; Function to answer queries ; Iterate till query ; Decrease to get 0 - based indexing ; Print answer ; Function that pre - computes the dp array ; Check fo the first character ; Iterate in row and columns ; If not first row or not first column ; Not first row ; Not first column ; If it is not ' a ' then increase by 1 ; Driver code ; character N X N array ; queries ; number of queries ; function call to pre - compute ; function call to answer every query"
C#;"using System ; class GFG { static int squares ( int i ) { if ( ( i & 1 ) == 1 ) return i / 4 * 2 + 1 ; else return ( i - 1 ) / 4 * 2 + 2 ; } static long bishop_placements ( int n , int k ) { if ( k > 2 * n - 1 ) return 0 ; long [ , ] dp = new long [ n * 2 , k + 1 ] ; for ( int i = 0 ; i < n * 2 ; i ++ ) dp [ i , 0 ] = 1 ; dp [ 1 , 1 ] = 1 ; for ( int i = 2 ; i < n * 2 ; i ++ ) { for ( int j = 1 ; j <= k ; j ++ ) dp [ i , j ] = dp [ i - 2 , j ] + dp [ i - 2 , j - 1 ] * ( squares ( i ) - j + 1 ) ; } long ans = 0 ; for ( int i = 0 ; i <= k ; i ++ ) { ans += dp [ n * 2 - 1 , i ] * dp [ n * 2 - 2 , k - i ] ; } return ans ; } static public void Main ( ) { int n = 2 ; int k = 2 ; long ans = bishop_placements ( n , k ) ; Console . WriteLine ( ans ) ; } }";"Ways to place K bishops on an NÃ — N chessboard so that no two attack | C # implementation of the approach ; returns the number of squares in diagonal i ; returns the number of ways to fill a n * n chessboard with k bishops so that no two bishops attack each other . ; return 0 if the number of valid places to be filled is less than the number of bishops ; dp table to store the values ; Setting the base conditions ; calculate the required number of ways ; stores the answer ; Driver code"
C#;"using System ; public class GFG { static int MAX = 10 ; static int [ , ] F = new int [ MAX , MAX ] ; static int [ ] C = new int [ MAX ] ; static int noOfAssignments ( string S , int n , int i , int c_x ) { if ( F [ i , c_x ] != - 1 ) { return F [ i , c_x ] ; } if ( i == n ) { if ( c_x == 1 ) { F [ i , c_x ] = 0 ; } else { F [ i , c_x ] = 1 ; } return F [ i , c_x ] ; } int c_y = C [ i ] - c_x ; if ( S [ i ] == ' ( ' ) { F [ i , c_x ] = noOfAssignments ( S , n , i + 1 , c_x + 1 ) + noOfAssignments ( S , n , i + 1 , c_x ) ; return F [ i , c_x ] ; } F [ i , c_x ] = 0 ; if ( c_x == 1 ) { F [ i , c_x ] += noOfAssignments ( S , n , i + 1 , c_x - 1 ) ; } if ( c_y == 1 ) { F [ i , c_x ] += noOfAssignments ( S , n , i + 1 , c_x ) ; } return F [ i , c_x ] ; } public static void Main ( ) { string S = "" ( ) "" ; int n = S . Length ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { F [ i , j ] = - 1 ; } } C [ 0 ] = 0 ; for ( int i = 0 ; i < n ; ++ i ) { if ( S [ i ] == ' ( ' ) { C [ i + 1 ] = C [ i ] + 1 ; } else { C [ i + 1 ] = C [ i ] - 1 ; } } Console . WriteLine ( noOfAssignments ( S , n , 0 , 0 ) ) ; } }";"Number of ways to partition a string into two balanced subsequences | C # implementation of the approach ; For maximum length of input string ; Declaring the DP table ; Declaring the prefix array ; Function to calculate the number of valid assignments ; Return 1 if X is balanced . ; Increment the count if it an opening bracket ; Decrement the count if it a closing bracket ; Driver code ; Initializing the DP table ; Creating the prefix array ; Initial value for c_x and c_y is zero"
C#;"using System ; class GFG { static int n = 3 ; static int minFallingPathSum ( int [ , ] A ) { for ( int R = n - 2 ; R >= 0 ; -- R ) { for ( int C = 0 ; C < n ; ++ C ) { int best = A [ R + 1 , C ] ; if ( C > 0 ) best = Math . Min ( best , A [ R + 1 , C - 1 ] ) ; if ( C + 1 < n ) best = Math . Min ( best , A [ R + 1 , C + 1 ] ) ; A [ R , C ] = A [ R , C ] + best ; } } int ans = int . MaxValue ; for ( int i = 0 ; i < n ; ++ i ) ans = Math . Min ( ans , A [ 0 , i ] ) ; return ans ; } public static void Main ( ) { int [ , ] A = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; Console . WriteLine ( minFallingPathSum ( A ) ) ; } }";"Minimum sum falling path in a NxN grid | C # Program to minimum required sum ; Function to return minimum path falling sum ; R = Row and C = Column We begin from second last row and keep adding maximum sum . ; best = min ( A [ R + 1 , C - 1 ] , A [ R + 1 , C ] , A [ R + 1 , C + 1 ] ) ; Driver program ; function to print required answer"
C#;"using System ; class GFG { public static int N = 100 ; public static int n = 3 , m = 4 ; public static int maxPlus ( int [ , ] arr ) { int ans = int . MinValue ; int [ , ] left = new int [ N , N ] ; int [ , ] right = new int [ N , N ] ; int [ , ] up = new int [ N , N ] ; int [ , ] down = new int [ N , N ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { left [ i , j ] = Math . Max ( 0 , ( ( j != 0 ) ? left [ i , j - 1 ] : 0 ) ) + arr [ i , j ] ; up [ i , j ] = Math . Max ( 0 , ( ( i != 0 ) ? up [ i - 1 , j ] : 0 ) ) + arr [ i , j ] ; } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { right [ i , j ] = Math . Max ( 0 , ( j + 1 == m ? 0 : right [ i , j + 1 ] ) ) + arr [ i , j ] ; down [ i , j ] = Math . Max ( 0 , ( i + 1 == n ? 0 : down [ i + 1 , j ] ) ) + arr [ i , j ] ; } } for ( int i = 1 ; i < n - 1 ; ++ i ) for ( int j = 1 ; j < m - 1 ; ++ j ) ans = Math . Max ( ans , up [ i - 1 , j ] + down [ i + 1 , j ] + left [ i , j - 1 ] + right [ i , j + 1 ] + arr [ i , j ] ) ; return ans ; } static void Main ( ) { int [ , ] arr = new int [ , ] { { 1 , 1 , 1 , 1 } , { - 6 , 1 , 1 , - 4 } , { 1 , 1 , 1 , 1 } } ; Console . Write ( maxPlus ( arr ) ) ; } }";"Find the maximum sum of Plus shape pattern in a 2 | C # program to find the maximum value of a + shaped pattern in 2 - D array ; Function to return maximum Plus value ; Initializing answer with the minimum value ; Initializing all four arrays ; Initializing left and up array . ; Initializing right and down array . ; calculating value of maximum Plus ( + ) sign ; Driver code ; Function call to find maximum value"
C#;"using System ; class GFG { static int countStaircases ( int N ) { int [ , ] memo = new int [ N + 5 , N + 5 ] ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j <= N ; j ++ ) { memo [ i , j ] = 0 ; } } memo [ 3 , 2 ] = memo [ 4 , 2 ] = 1 ; for ( int i = 5 ; i <= N ; i ++ ) { for ( int j = 2 ; j <= i ; j ++ ) { if ( j == 2 ) { memo [ i , j ] = memo [ i - j , j ] + 1 ; } else { memo [ i , j ] = memo [ i - j , j ] + memo [ i - j , j - 1 ] ; } } } int answer = 0 ; for ( int i = 1 ; i <= N ; i ++ ) answer = answer + memo [ N , i ] ; return answer ; } public static void Main ( ) { int N = 7 ; Console . WriteLine ( countStaircases ( N ) ) ; } }";"Total number of different staircase that can made from N boxes | C # program to find the total number of different staircase that can made from N boxes ; Function to find the total number of different staircase that can made from N boxes ; DP table , there are two states . First describes the number of boxes and second describes the step ; Initialize all the elements of the table to zero ; Base case ; When step is equal to 2 ; When step is greater than 2 ; Count the total staircase from all the steps ; Driver Code"
C#;"using System ; class GFG { static int maxCost ( int [ ] a , int n , int l , int r ) { int mx = 0 , k ; for ( int i = 0 ; i < n ; ++ i ) mx = Math . Max ( mx , a [ i ] ) ; int [ ] count = new int [ mx + 1 ] ; for ( int i = 0 ; i < count . Length ; i ++ ) count [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; int [ ] res = new int [ mx + 1 ] ; res [ 0 ] = 0 ; l = Math . Min ( l , r ) ; for ( int num = 1 ; num <= mx ; num ++ ) { k = Math . Max ( num - l - 1 , 0 ) ; res [ num ] = Math . Max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) ; } return res [ mx ] ; } public static void Main ( ) { int [ ] a = { 2 , 1 , 2 , 3 , 2 , 2 , 1 } ; int l = 1 , r = 1 ; int n = a . Length ; Console . WriteLine ( maxCost ( a , n , l , r ) ) ; } }";"Find maximum points which can be obtained by deleting elements from array | C # program to find maximum cost after deleting all the elements form the array ; function to return maximum cost obtained ; find maximum element of the array . ; initialize count of all elements to zero . ; calculate frequency of all elements of array . ; stores cost of deleted elements . ; selecting minimum range from L and R . ; finds upto which elements are to be deleted when element num is selected . ; get maximum when selecting element num or not . ; Driver Code ; size of array ; function call to find maximum cost"
C#;"using System ; class GFG { public int countPaths ( int m , int n ) { if ( m == 1 n == 1 ) return 1 ; return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ; } public static void Main ( ) { GFG g = new GFG ( ) ; int n = 5 , m = 5 ; Console . WriteLine ( g . countPaths ( n , m ) ) ; Console . Read ( ) ; } }";"Count the number of ways to traverse a Matrix | C # program using recursive solution to count number of ways to reach mat [ m - 1 ] [ n - 1 ] from mat [ 0 ] [ 0 ] in a matrix mat [ ] [ ] ; Returns The number of way from top - left to mat [ m - 1 ] [ n - 1 ] ; Return 1 if it is the first row or first column ; Recursively find the no of way to reach the last cell . ; Driver Code"
C#;"using System ; class GFG { static int countPaths ( int m , int n ) { int [ , ] dp = new int [ m + 1 , n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( i == 1 j == 1 ) dp [ i , j ] = 1 ; else dp [ i , j ] = dp [ i - 1 , j ] + dp [ i , j - 1 ] ; } } return dp [ m , n ] ; } public static void Main ( ) { int n = 5 ; int m = 5 ; Console . WriteLine ( countPaths ( n , m ) ) ; } }";"Count the number of ways to traverse a Matrix | A simple recursive solution to count number of ways to reach mat [ m - 1 ] [ n - 1 ] from mat [ 0 ] [ 0 ] in a matrix mat [ ] [ ] ; Returns The number of way from top - left to mat [ m - 1 ] [ n - 1 ] ; Driver code"
C#;"using System ; class GFG { static long binomialCoeff ( int n , int k ) { long res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static long catalan ( int n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( catalan ( n ) ) ; } }";"Number of ways a convex polygon of n + 2 sides can split into triangles by connecting vertices | C # program to find the nth catalan number ; Returns value of Binomial Coefficient C ( n , k ) ; Since C ( n , k ) = C ( n , n - k ) ; Calculate value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] / [ k * ( k - 1 ) * -- - * 1 ] ; A Binomial coefficient based function to find nth catalan number in O ( n ) time ; Calculate value of 2 nCn ; return 2 nCn / ( n + 1 ) ; Driver code"
C#;"using System ; class GFG { static void alternateFib ( int n ) { if ( n < 0 ) return ; int f1 = 0 ; int f2 = 1 ; Console . Write ( f1 + "" ▁ "" ) ; for ( int i = 2 ; i <= n ; i ++ ) { int f3 = f2 + f1 ; if ( i % 2 == 0 ) Console . Write ( f3 + "" ▁ "" ) ; f1 = f2 ; f2 = f3 ; } } public static void Main ( ) { int N = 15 ; alternateFib ( N ) ; } }";"Alternate Fibonacci Numbers | Alternate Fibonacci Series using Dynamic Programming ; 0 th and 1 st number of the series are 0 and 1 ; Driver Code"
C#;"using System ; class GFG { static int totalWays ( int N , int M , int X ) { int [ , ] dp = new int [ N + 1 , 2 ] ; if ( X == 1 ) { dp [ 0 , 0 ] = 1 ; } else { dp [ 0 , 1 ] = 0 ; } if ( X == 1 ) { dp [ 1 , 0 ] = 0 ; dp [ 1 , 1 ] = M - 1 ; } else { dp [ 1 , 0 ] = 1 ; dp [ 1 , 1 ] = ( M - 2 ) ; } for ( int i = 2 ; i < N ; i ++ ) { dp [ i , 0 ] = dp [ i - 1 , 1 ] ; dp [ i , 1 ] = dp [ i - 1 , 0 ] * ( M - 1 ) + dp [ i - 1 , 1 ] * ( M - 2 ) ; } return dp [ N - 1 , 0 ] ; } public static void Main ( ) { int N = 4 , M = 3 , X = 2 ; Console . WriteLine ( totalWays ( N , M , X ) ) ; } }";"Number of ways to form an array with distinct adjacent elements | C # program to count the number of ways to form arrays of N numbers such that the first and last numbers are fixed and all consecutive numbers are distinct ; Returns the total ways to form arrays such that every consecutive element is different and each element except the first and last can take values from 1 to M ; define the dp [ ] [ ] array ; if the first element is 1 ; there is only one way to place a 1 at the first index ; the value at first index needs to be 1 , thus there is no way to place a non - one integer ; if the first element was 1 then at index 1 , only non one integer can be placed thus there are M - 1 ways to place a non one integer at index 2 and 0 ways to place a 1 at the 2 nd index ; Else there is one way to place a one at index 2 and if a non one needs to be placed here , there are ( M - 2 ) options , i . e neither the element at this index should be 1 , neither should it be equal to the previous element ; Build the dp array in bottom up manner ; f ( i , one ) = f ( i - 1 , non - one ) ; f ( i , non - one ) = f ( i - 1 , one ) * ( M - 1 ) + f ( i - 1 , non - one ) * ( M - 2 ) ; last element needs to be one , so return dp [ n - 1 ] [ 0 ] ; Driver Code"
C#;"using System ; class GFG { static int fib ( int n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; } static public void Main ( ) { int n = 6 ; Console . WriteLine ( fib ( n ) ) ; } }";"Memoization ( 1D , 2D and 3D ) | C # program to find the Nth term of Fibonacci series ; Fibonacci Series using Recursion ; Base case ; recursive calls ; Driver Code"
C#;"using System ; class GFG { static int fib ( int n ) { int [ ] term = new int [ 1000 ] ; if ( n <= 1 ) return n ; if ( term [ n ] != 0 ) return term [ n ] ; else { term [ n ] = fib ( n - 1 ) + fib ( n - 2 ) ; return term [ n ] ; } } public static void Main ( ) { int n = 6 ; Console . Write ( fib ( n ) ) ; } }";"Memoization ( 1D , 2D and 3D ) | C # program to find the Nth term of Fibonacci series ; Fibonacci Series using memoized Recursion ; base case ; if fib ( n ) has already been computed we do not do further recursive calls and hence reduce the number of repeated work ; store the computed value of fib ( n ) in an array term at index n to so that it does not needs to be precomputed again ; Driver Code"
C#;"using System ; class GFG { static int max ( int a , int b ) { return ( a > b ) ? a : b ; } static int lcs ( string X , string Y , int m , int n ) { if ( m == 0 n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; } public static void Main ( ) { string X = "" AGGTAB "" ; string Y = "" GXTXAYB "" ; int m = X . Length ; int n = Y . Length ; Console . Write ( "" Length ▁ of ▁ LCS ▁ is ▁ "" + lcs ( X , Y , m , n ) ) ; } }";"Memoization ( 1D , 2D and 3D ) | A Naive recursive implementation of LCS problem ; Utility function to get max of 2 integers ; Returns length of LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ] ; Driver Code"
C#;"using System ; public class GFG { static int [ , ] dp = new int [ 901 , 8101 ] ; static int minimumNumberOfDigits ( int a , int b ) { if ( a > b a < 0 b < 0 a > 900 b > 8100 ) { return - 1 ; } if ( a == 0 && b == 0 ) { return 0 ; } if ( dp [ a , b ] != - 1 ) { return dp [ a , b ] ; } int ans = 101 ; for ( int i = 9 ; i >= 1 ; i -- ) { int k = minimumNumberOfDigits ( a - i , b - ( i * i ) ) ; if ( k != - 1 ) { ans = Math . Min ( ans , k + 1 ) ; } } return dp [ a , b ] = ans ; } static void printSmallestNumber ( int a , int b ) { for ( int i = 0 ; i < dp . GetLength ( 0 ) ; i ++ ) for ( int j = 0 ; j < dp . GetLength ( 1 ) ; j ++ ) dp [ i , j ] = - 1 ; dp [ 0 , 0 ] = 0 ; int k = minimumNumberOfDigits ( a , b ) ; if ( k == - 1 k > 100 ) { Console . WriteLine ( "" - 1"" ) ; } else { while ( a > 0 && b > 0 ) { for ( int i = 1 ; i <= 9 ; i ++ ) { if ( a >= i && b >= i * i && 1 + dp [ a - i , b - i * i ] == dp [ a , b ] ) { Console . Write ( i ) ; a -= i ; b -= i * i ; break ; } } } } } public static void Main ( ) { int a = 18 , b = 162 ; printSmallestNumber ( a , b ) ; } }";"Smallest number with given sum of digits and sum of square of digits | C # program to find the Smallest number with given sum of digits and sum of square of digits ; Top down dp to find minimum number of digits with given sum of dits a and sum of square of digits as b ; Invalid condition ; Number of digits satisfied ; Memoization ; Initialize ans as maximum as we have to find the minimum number of digits ; Check for all possible combinations of digits ; recurrence call ; If the combination of digits cannot give sum as a and sum of square of digits as b ; Returns the minimum number of digits ; Function to print the digits that gives sum as a and sum of square of digits as b ; initialize the dp array as - 1 ; base condition ; function call to get the minimum number of digits ; When there does not exists any number ; Printing the digits from the most significant digit ; Trying all combinations ; checking conditions for minimum digits ; Driver Code ; Function call to print the smallest number"
C#;"using System ; class GFG { static int binomialCoeff ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . Min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } static int sumOfproduct ( int n ) { return binomialCoeff ( 2 * n , n - 1 ) ; } static public void Main ( ) { int n = 3 ; Console . WriteLine ( sumOfproduct ( n ) ) ; } }";"Sum of product of consecutive Binomial Coefficients | C # Program to find sum of product of consecutive Binomial Coefficient . ; Find the binomial coefficient up to nth term ; memset ( C , 0 , sizeof ( C ) ) ; C [ 0 ] = 1 ; nC0 is 1 ; Compute next row of pascal triangle using the previous row ; Return the sum of the product of consecutive binomial coefficient . ; Driver Code"
C#;"using System ; class GFG { static int MAX = 100 ; static int check ( int i , int sum , int n , int k , int [ ] a , int [ , ] dp ) { if ( sum <= 0 ) { return 0 ; } if ( i >= n ) { if ( sum == k ) { return 1 ; } return 0 ; } if ( dp [ i , sum ] != - 1 ) { return dp [ i , sum ] ; } dp [ i , sum ] = check ( i + 1 , sum - 2 * a [ i ] , n , k , a , dp ) | check ( i + 1 , sum , n , k , a , dp ) ; dp [ i , sum ] = check ( i + 1 , sum - ( i + 1 ) , n , k , a , dp ) | dp [ i , sum ] ; dp [ i , sum ] = check ( i + 1 , sum + i + 1 , n , k , a , dp ) | dp [ i , sum ] ; return dp [ i , sum ] ; } static int wrapper ( int n , int k , int [ ] a ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } int [ , ] dp = new int [ MAX , MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i , j ] = - 1 ; } } return check ( 0 , sum , n , k , a , dp ) ; } static public void Main ( ) { int [ ] a = { 1 , 2 , 3 , 4 } ; int n = 4 , k = 5 ; if ( wrapper ( n , k , a ) == 1 ) { Console . WriteLine ( "" Yes "" ) ; } else { Console . WriteLine ( "" No "" ) ; } } }";"Check if array sum can be made K by three operations on it | C # Program to find if Array can have a sum of K by applying three types of possible ; Check if it is possible to achieve a sum with three operation allowed . ; If sum is negative . ; If going out of bound . ; If sum is achieved . ; If the current state is not evaluated yet . ; Replacing element with negative value of the element . ; Substracting index number from the element . ; Adding index number to the element . ; Wrapper Function ; Driver Code"
C#;"using System ; class GFG { static void fib ( int n ) { int a = 0 , b = 1 , c ; if ( n >= 0 ) Console . Write ( a + "" ▁ "" ) ; if ( n >= 1 ) Console . Write ( b + "" ▁ "" ) ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; Console . Write ( c + "" ▁ "" ) ; a = b ; b = c ; } } public static void Main ( ) { fib ( 9 ) ; } }";"Print Fibonacci sequence using 2 variables | Simple C # Program to print Fibonacci sequence ; Driver code"
C#;"using System ; class GFG { static int pre_compute ( int [ ] a , int n , int index , int k ) { int [ , ] dp = new int [ n , n ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > a [ 0 ] ) dp [ 0 , i ] = a [ i ] + a [ 0 ] ; else dp [ 0 , i ] = a [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( a [ j ] > a [ i ] && j > i ) { if ( dp [ i - 1 , i ] + a [ j ] > dp [ i - 1 , j ] ) dp [ i , j ] = dp [ i - 1 , i ] + a [ j ] ; else dp [ i , j ] = dp [ i - 1 , j ] ; } else dp [ i , j ] = dp [ i - 1 , j ] ; } } return dp [ index , k ] ; } static public void Main ( ) { int [ ] a = { 1 , 101 , 2 , 3 , 100 , 4 , 5 } ; int n = a . Length ; int index = 4 , k = 6 ; Console . WriteLine ( pre_compute ( a , n , index , k ) ) ; } }";"Maximum sum increasing subsequence from a prefix and a given element after prefix is must | C # program to find maximum sum increasing subsequence till i - th index and including k - th index . ; Initializing the first row of the dp [ ] [ ] . ; Creating the dp [ ] [ ] matrix . ; To calculate for i = 4 and k = 6. ; Driver code"
C#;"using System ; class GFG { static int gen ( int n ) { int [ ] S = new int [ n + 1 ] ; S [ 0 ] = 0 ; if ( n != 0 ) S [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) S [ i ] = 4 * S [ i / 2 ] ; else S [ i ] = 4 * S [ i / 2 ] + 1 ; } return S [ n ] ; } static void moserDeBruijn ( int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( gen ( i ) + "" ▁ "" ) ; } public static void Main ( ) { int n = 15 ; Console . WriteLine ( "" First ▁ "" + n + "" ▁ terms ▁ of ▁ "" + "" Moser - de ▁ Bruijn ▁ Sequence ▁ : ▁ "" ) ; moserDeBruijn ( n ) ; } }";"Moser | C # code to generate first ' n ' terms of the Moser - de Bruijn Sequence ; Function to generate nth term of Moser - de Bruijn Sequence ; S ( 2 * n ) = 4 * S ( n ) ; S ( 2 * n + 1 ) = 4 * S ( n ) + 1 ; Generating the first ' n ' terms of Moser - de Bruijn Sequence ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { static int LCSubStr ( string X , string Y ) { int m = X . Length ; int n = Y . Length ; int result = 0 ; int [ , ] len = new int [ 2 , n ] ; int currRow = 0 ; for ( int i = 0 ; i < m ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == 0 j == 0 ) { len [ currRow , j ] = 0 ; } else if ( X [ i - 1 ] == Y [ j - 1 ] ) { len [ currRow , j ] = len [ ( 1 - currRow ) , ( j - 1 ) ] + 1 ; result = Math . Max ( result , len [ currRow , j ] ) ; } else { len [ currRow , j ] = 0 ; } } currRow = 1 - currRow ; } return result ; } public static void Main ( ) { string X = "" GeeksforGeeks "" ; string Y = "" GeeksQuiz "" ; Console . Write ( LCSubStr ( X , Y ) ) ; } }";"Longest Common Substring ( Space optimized DP solution ) | Space optimized C # implementation of longest common substring . ; Function to find longest common substring . ; Find length of both the strings . ; Variable to store length of longest common substring . ; Matrix to store result of two consecutive rows at a time . ; Variable to represent which row of matrix is current row . ; For a particular value of i and j , len [ currRow ] [ j ] stores length of longest common substring in string X [ 0. . i ] and Y [ 0. . j ] . ; Make current row as previous row and previous row as new current row . ; Driver Code"
C#;"using System ; class GFG { static int minimalSteps ( String s , int n ) { int [ ] dp = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] = int . MaxValue ; String s1 = "" "" , s2 = "" "" ; dp [ 0 ] = 1 ; s1 += s [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { s1 += s [ i ] ; s2 = s . Substring ( i , 1 ) ; dp [ i ] = Math . Min ( dp [ i ] , dp [ i - 1 ] + 1 ) ; if ( s1 == s2 ) dp [ i * 2 + 1 ] = Math . Min ( dp [ i ] + 1 , dp [ i * 2 + 1 ] ) ; } return dp [ n - 1 ] ; } public static void Main ( String [ ] args ) { String s = "" aaaaaaaa "" ; int n = s . Length ; Console . Write ( minimalSteps ( s , n ) / 2 ) ; } }";"Minimal moves to form a string by adding characters or appending string itself | C # program to print the Minimal moves to form a string by appending string and adding characters ; function to return the minimal number of moves ; initializing dp [ i ] to INT_MAX ; initialize both strings to null ; base case ; check if it can be appended ; addition of character takes one step ; appending takes 1 step , and we directly reach index i * 2 + 1 after appending so the number of steps is stord in i * 2 + 1 ; Driver Code ; function call to return minimal number of moves"
C#;"using System . Collections . Generic ; using System ; class GFG { static void func ( int n , int m , int [ ] A ) { List < int > ModArray = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) ModArray . Add ( 0 ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ModArray [ i ] = ( A [ i ] % m ) ; sum += ( ( int ) ModArray [ i ] ) ; } sum = sum % m ; if ( sum % m == 0 ) { Console . WriteLine ( "" True "" ) ; return ; } if ( sum % 2 != 0 ) { Console . WriteLine ( "" False "" ) ; } else { ModArray . Remove ( 0 ) ; int i = 0 ; int j = ModArray . Count - 1 ; ModArray . Sort ( ) ; sum = sum / 2 ; int i1 , i2 ; while ( i <= j ) { int s = ( int ) ModArray [ i ] + ( int ) ModArray [ j ] ; if ( s == sum ) { i1 = i ; i2 = j ; Console . WriteLine ( "" True "" ) ; break ; } else if ( s > sum ) j -- ; else i ++ ; } } } public static void Main ( ) { int m = 2 ; int [ ] a = { 1 , 3 , 9 } ; int n = a . Length ; func ( n , m , a ) ; } }";"Check if any valid sequence is divisible by M | C # program for the above approach ; Function to check if any valid sequence is divisible by M ; Declare mod array ; Calculate the mod array ; Check if sum is divisible by M ; Check if sum is not divisible by 2 ; Remove the first element from the ModArray since it is not possible to place minus on the first element ; Decrease the size of array ; Sort the array ; Loop until the pointer cross each other ; Check if sum becomes equal ; Increase and decrease the pointer accordingly ; Driver code ; Function call"
C#;"using System ; class GFG { static void printGolomb ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 1 ] = 1 ; Console . Write ( dp [ 1 ] + "" ▁ "" ) ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] = 1 + dp [ i - dp [ dp [ i - 1 ] ] ] ; Console . Write ( dp [ i ] + "" ▁ "" ) ; } } public static void Main ( ) { int n = 9 ; printGolomb ( n ) ; } }";"Golomb sequence | C # Program to find first n terms of Golomb sequence . ; Print the first n term of Golomb Sequence ; base cases ; Finding and printing first n terms of Golomb Sequence . ; Driver Code"
C#;"using System ; class GFG { static int N = 1000 ; public static long arrangeBraces ( int n , int [ ] pos , int k ) { bool [ ] h = new bool [ N ] ; int [ , ] dp = new int [ N , N ] ; for ( int i = 0 ; i < N ; i ++ ) h [ i ] = false ; for ( int i = 0 ; i < N ; i ++ ) for ( int j = 0 ; j < N ; j ++ ) dp [ i , j ] = 0 ; for ( int i = 0 ; i < k ; i ++ ) h [ pos [ i ] ] = true ; dp [ 0 , 0 ] = 1 ; for ( int i = 1 ; i <= 2 * n ; i ++ ) { for ( int j = 0 ; j <= 2 * n ; j ++ ) { if ( h [ i ] ) { if ( j != 0 ) dp [ i , j ] = dp [ i - 1 , j - 1 ] ; else dp [ i , j ] = 0 ; } else { if ( j != 0 ) dp [ i , j ] = dp [ i - 1 , j - 1 ] + dp [ i - 1 , j + 1 ] ; else dp [ i , j ] = dp [ i - 1 , j + 1 ] ; } } } return dp [ 2 * n , 0 ] ; } static void Main ( ) { int n = 3 ; int [ ] pos = new int [ ] { 2 } ; int k = pos . Length ; Console . Write ( arrangeBraces ( n , pos , k ) ) ; } }";"Balanced expressions such that given positions have opening brackets | C # code to find number of ways of arranging bracket with proper expressions ; function to calculate the number of proper bracket sequence ; hash array to mark the positions of opening brackets ; dp 2d array ; mark positions in hash array ; first position marked as 1 ; iterate and formulate the recurrences ; if position has a opening bracket ; return answer ; driver code ; positions where opening braces will be placed"
C#;"using System ; class GFG { public static int findLength ( string str , int n ) { int current_sum = 0 ; int max_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { current_sum += ( str [ i ] == '0' ? 1 : - 1 ) ; if ( current_sum < 0 ) { current_sum = 0 ; } max_sum = Math . Max ( current_sum , max_sum ) ; } return max_sum == 0 ? - 1 : max_sum ; } public static void Main ( string [ ] args ) { string str = ""11000010001"" ; int n = str . Length ; Console . WriteLine ( findLength ( str , n ) ) ; } }";"Maximum difference of zeros and ones in binary string | Set 2 ( O ( n ) time ) | C # Program to find the length of substring with maximum difference of zeroes and ones in binary string . ; Find the length of substring with maximum difference of zeros and ones in binary string ; traverse a binary string from left to right ; add current value to the current_sum according to the Character if it ' s ▁ ' 0 ' add 1 else -1 ; update maximum sum ; return - 1 if string does not contain any zero that means string contains all ones otherwise max_sum ; Driver Code"
C#;"using System ; class GFG { static int DP_s = 9 ; static int getNumStrictMonotone ( int len ) { int [ , ] DP = new int [ len , DP_s ] ; for ( int i = 0 ; i < DP_s ; ++ i ) DP [ 0 , i ] = i + 1 ; for ( int i = 1 ; i < len ; ++ i ) for ( int j = 1 ; j < DP_s ; ++ j ) DP [ i , j ] = DP [ i - 1 , j - 1 ] + DP [ i , j - 1 ] ; return DP [ len - 1 , DP_s - 1 ] ; } public static void Main ( ) { int n = 2 ; Console . WriteLine ( getNumStrictMonotone ( n ) ) ; } }";"Number of decimal numbers of length k , that are strict monotone | C # program to count numbers of k digits that are strictly monotone . ; DP [ i ] [ j ] is going to store monotone numbers of length i + 1 considering j + 1 digits ( 1 , 2 , 3 , . .9 ) ; Unit length numbers ; Building dp [ ] in bottom up ; Driver code"
C#;"using System ; class GFG { static int chordCnt ( int A ) { int n = 2 * A ; int [ ] dpArray = new int [ n + 1 ] ; dpArray [ 0 ] = 1 ; dpArray [ 2 ] = 1 ; for ( int i = 4 ; i <= n ; i += 2 ) { for ( int j = 0 ; j < i - 1 ; j += 2 ) { dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) ; } } return dpArray [ n ] ; } public static void Main ( ) { int N ; N = 2 ; Console . WriteLine ( chordCnt ( N ) ) ; N = 1 ; Console . WriteLine ( chordCnt ( N ) ) ; N = 4 ; Console . WriteLine ( chordCnt ( N ) ) ; } }";"Count ways to divide circle using N non | C # code to count ways to divide circle using N non - intersecting chords . ; n = no of points required ; dp array containing the sum ; returning the required number ; Driver code"
C#;"using System ; class GFG { static bool isPath ( int [ , ] arr ) { arr [ 0 , 0 ] = 1 ; for ( int i = 1 ; i < 5 ; i ++ ) if ( arr [ i , 0 ] != - 1 ) arr [ i , 0 ] = arr [ i - 1 , 0 ] ; for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ 0 , j ] != - 1 ) arr [ 0 , j ] = arr [ 0 , j - 1 ] ; for ( int i = 1 ; i < 5 ; i ++ ) for ( int j = 1 ; j < 5 ; j ++ ) if ( arr [ i , j ] != - 1 ) arr [ i , j ] = Math . Max ( arr [ i , j - 1 ] , arr [ i - 1 , j ] ) ; return ( arr [ 5 - 1 , 5 - 1 ] == 1 ) ; } public static void Main ( ) { int [ , ] arr = { { 0 , 0 , 0 , - 1 , 0 } , { - 1 , 0 , 0 , - 1 , - 1 } , { 0 , 0 , 0 , - 1 , 0 } , { - 1 , 0 , - 1 , 0 , - 1 } , { 0 , 0 , - 1 , 0 , 0 } } ; if ( isPath ( arr ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Check for possible path in 2D matrix | C # program to find if there is path from top left to right bottom ; to find the path from top left to bottom right ; set arr [ 0 ] [ 0 ] = 1 ; Mark reachable ( from top left ) nodes in first row and first column . ; Mark reachable nodes in remaining matrix . ; return yes if right bottom index is 1 ; Driver code ; Given array ; path from arr [ 0 ] [ 0 ] to arr [ row ] [ col ]"
C#;"using System ; class GFG { static int nswp ( int n ) { if ( n == 0 n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( nswp ( n ) ) ; } }";"Newmanâ €“ Shanksâ €“ Williams prime | C # Program to find Newman - Shanks - Williams prime ; return nth Newman - Shanks - Williams prime ; Base case ; Recursive step ; Driver code"
C#;"using System ; class GFG { static int nswp ( int n ) { int [ ] dp = new int [ n + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) dp [ i ] = 2 * dp [ i - 1 ] + dp [ i - 2 ] ; return dp [ n ] ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( nswp ( n ) ) ; } }";"Newman Shanks Williams prime | C # Program to find Newman Shanks Williams prime ; return nth Newman Shanks Williams prime ; Base case ; Finding nth Newman Shanks Williams prime ; Driver Program"
C#;"using System ; using System . Collections . Generic ; class GFG { static readonly int MAX = 256 ; static int numberofways ( String A , String B , int N , int M ) { List < int > [ ] pos = new List < int > [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) pos [ i ] = new List < int > ( ) ; for ( int i = 0 ; i < M ; i ++ ) pos [ B [ i ] ] . Add ( i + 1 ) ; int [ , ] dpl = new int [ N + 2 , M + 2 ] ; for ( int i = 1 ; i <= N ; i ++ ) { for ( int j = 1 ; j <= M ; j ++ ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpl [ i , j ] = dpl [ i - 1 , j - 1 ] + 1 ; else dpl [ i , j ] = Math . Max ( dpl [ i - 1 , j ] , dpl [ i , j - 1 ] ) ; } } int LCS = dpl [ N , M ] ; int [ , ] dpr = new int [ N + 2 , M + 2 ] ; for ( int i = N ; i >= 1 ; i -- ) { for ( int j = M ; j >= 1 ; j -- ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpr [ i , j ] = dpr [ i + 1 , j + 1 ] + 1 ; else dpr [ i , j ] = Math . Max ( dpr [ i + 1 , j ] , dpr [ i , j + 1 ] ) ; } } int ans = 0 ; for ( int i = 0 ; i <= N ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { foreach ( int x in pos [ j ] ) { if ( dpl [ i , x - 1 ] + dpr [ i + 1 , x + 1 ] == LCS ) { ans ++ ; break ; } } } } return ans ; } public static void Main ( String [ ] args ) { String A = "" aa "" , B = "" baaa "" ; int N = A . Length , M = B . Length ; Console . WriteLine ( numberofways ( A , B , N , M ) ) ; } }";"Number of ways to insert a character to increase the LCS by one | C # Program for Number of ways to insert a character to increase LCS by one ; Return the Number of ways to insert a character to increase the longest Common Subsequence by one ; Insert all positions of all characters in string B . ; longest Common Subsequence ; longest Common Subsequence from reverse ; inserting character between position i and i + 1 ; Driver Code"
C#;"using System ; public class GfG { static int lcs ( string X , string Y , int m , int n ) { int [ , ] L = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= m ; ++ i ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i , j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i , j ] = L [ i - 1 , j - 1 ] + 2 * ( X [ i - 1 ] - '0' ) ; else L [ i , j ] = L [ i - 1 , j ] > L [ i , j - 1 ] ? L [ i - 1 , j ] : L [ i , j - 1 ] ; } } return L [ m , n ] ; } static int findMinCost ( string X , string Y ) { int m = X . Length , n = Y . Length ; int cost = 0 ; for ( int i = 0 ; i < m ; ++ i ) cost += X [ i ] - '0' ; for ( int i = 0 ; i < n ; ++ i ) cost += Y [ i ] - '0' ; return cost - lcs ( X , Y , m , n ) ; } public static void Main ( ) { string X = ""3759"" ; string Y = ""9350"" ; Console . WriteLine ( "" Minimum ▁ Cost ▁ to ▁ make ▁ two ▁ strings "" + "" ▁ identical ▁ is ▁ = ▁ "" + findMinCost ( X , Y ) ) ; } }";"Minimum cost to make two strings identical by deleting the digits | C # code to find minimum cost to make two strings identical ; Function to returns cost of removing the identical characters in LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ] ; Following steps build L [ m + 1 ] [ n + 1 ] in bottom up fashion . Note that L [ i ] [ j ] contains cost of removing identical characters in LCS of X [ 0. . i - 1 ] and Y [ 0. . j - 1 ] ; If both characters are same , add both of them ; Otherwise find the maximum cost among them ; Returns cost of making X [ ] and Y [ ] identical ; Find LCS of X [ ] and Y [ ] ; Initialize the cost variable ; Find cost of all characters in both strings ; Driver function"
C#;"using System ; class GFG { static bool isSubSeqDivisible ( string str ) { int i , j , k , l = str . Length ; int [ ] arr = new int [ l ] ; for ( i = 0 ; i < n ; i ++ ) arr [ i ] = str [ i ] - '0' ; for ( i = 0 ; i < l ; i ++ ) { for ( j = i ; j < l ; j ++ ) { for ( k = j ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; } public static void Main ( ) { string str = ""3144"" ; if ( isSubSeqDivisible ( str ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Given a large number , check if a subsequence of digits is divisible by 8 | C # program to check if a subsequence of digits is divisible by 8. ; Function to calculate any permutation divisible by 8. If such permutation exists , the function will return that permutation else it will return - 1 ; Converting string to integer array for ease of computations ( Indexing in arr [ ] is considered to be starting from 1 ) ; Generating all possible permutations and checking if any such permutation is divisible by 8 ; Driver function"
C#;"using System ; class GFG { static bool isSubSeqDivisible ( String str ) { int n = str . Length ; int [ , ] dp = new int [ n + 1 , 10 ] ; int [ ] arr = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) arr [ i ] = ( int ) ( str [ i - 1 ] - '0' ) ; for ( int i = 1 ; i <= n ; i ++ ) { dp [ i , arr [ i ] % 8 ] = 1 ; for ( int j = 0 ; j < 8 ; j ++ ) { if ( dp [ i - 1 , j ] > dp [ i , ( j * 10 + arr [ i ] ) % 8 ] ) dp [ i , ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 , j ] ; if ( dp [ i - 1 , j ] > dp [ i , j ] ) dp [ i , j ] = dp [ i - 1 , j ] ; } } for ( int i = 1 ; i <= n ; i ++ ) { if ( dp [ i , 0 ] == 1 ) return true ; } return false ; } public static void Main ( ) { string str = ""3144"" ; if ( isSubSeqDivisible ( str ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Given a large number , check if a subsequence of digits is divisible by 8 | C # program to find if there is a subsequence of digits divisible by 8. ; Function takes in an array of numbers , dynamically goes on the location and makes combination of numbers . ; Converting string to integer array for ease of computations ( Indexing in arr [ ] is considered to be starting from 1 ) ; If we consider the number in our combination , we add it to the previous combination ; If we exclude the number from our combination ; If at dp [ i ] [ 0 ] , we find value 1 / true , it shows that the number exists at the value of ' i ' ; Driver function"
C#;"using System ; using System . Collections . Generic ; class GFG { public static void Main ( String [ ] args ) { String str = ""129365"" ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; int no = 8 ; while ( no < 100 ) { no = no + 8 ; if ( mp . ContainsKey ( ( no / 10 ) % 10 ) ) mp [ ( no / 10 ) % 10 ] = no % 10 ; else mp . Add ( ( no / 10 ) % 10 , no % 10 ) ; } bool [ ] visited = new bool [ 10 ] ; int i ; for ( i = str . Length - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == '8' ) { Console . Write ( "" Yes "" ) ; break ; } if ( visited [ mp [ str [ i ] - '0' ] ] ) { Console . Write ( "" Yes "" ) ; break ; } visited [ str [ i ] - '0' ] = true ; } if ( i == - 1 ) Console . Write ( "" No "" ) ; } }";"Given a large number , check if a subsequence of digits is divisible by 8 | C # program to check if given String has a subsequence divisible by 8 ; Driver code ; Map key will be tens place digit of number that is divisible by 8 and value will be units place digit ; For filling the map let start with initial value 8 ; Key is digit at tens place and value is digit at units place mp . Add ( { key , value } ) ; Create a hash to check if we visited a number ; Iterate from last index to 0 th index ; If 8 is present in String then 8 divided 8 hence print yes ; Considering present character as the second digit of two digits no we check if the value of this key is marked in hash or not If marked then we a have a number divisible by 8 ; If no subsequence divisible by 8"
C#;"using System ; class GFG { static int maxLength ( String s , int n ) { int [ , ] dp = new int [ n , n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( s [ i ] == ' ( ' && s [ i + 1 ] == ' ) ' ) dp [ i , i + 1 ] = 2 ; for ( int l = 2 ; l < n ; l ++ ) { for ( int i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s [ i ] == ' ( ' && s [ j ] == ' ) ' ) dp [ i , j ] = 2 + dp [ i + 1 , j - 1 ] ; for ( int k = i ; k < j ; k ++ ) dp [ i , j ] = Math . Max ( dp [ i , j ] , dp [ i , k ] + dp [ k + 1 , j ] ) ; } } return dp [ 0 , n - 1 ] ; } public static void Main ( ) { string s = "" ( ) ( ( ( ( ( ( ) "" ; int n = s . Length ; Console . WriteLine ( maxLength ( s , n ) ) ; } }";"Length of Longest Balanced Subsequence | C # program to find length of the longest balanced subsequence . ; Considering all balanced substrings of length 2 ; Considering all other substrings ; Driver Code"
C#;"using System ; class GFG { static int find_partial_sum ( int [ ] arr , int start , int end ) { int sum = 0 ; for ( int i = start ; i < end ; i ++ ) sum += arr [ i ] ; return sum ; } static int maxSumBitonicSubArr ( int [ ] arr , int n ) { int max_sum = - 1000000 ; int i = 0 ; while ( i < n ) { int j = i ; while ( j + 1 < n && arr [ j ] < arr [ j + 1 ] ) j ++ ; while ( i < j && arr [ i ] <= 0 ) i ++ ; int k = j ; while ( k + 1 < n && arr [ k ] > arr [ k + 1 ] ) k ++ ; int last = k ; while ( k > j && arr [ k ] <= 0 ) k -- ; int sum_inc = find_partial_sum ( arr , i , j + 1 ) ; int sum_dec = find_partial_sum ( arr , j , k + 1 ) ; int sum_all = sum_inc + sum_dec - arr [ j ] ; max_sum = Math . Max ( Math . Max ( max_sum , sum_inc ) , Math . Max ( sum_dec , sum_all ) ) ; i = Math . Max ( last , i + 1 ) ; } return max_sum ; } public static void Main ( ) { int [ ] arr = { 5 , 3 , 9 , 2 , 7 , 6 , 4 } ; int n = arr . Length ; Console . WriteLine ( "" Maximum ▁ sum ▁ = ▁ "" + maxSumBitonicSubArr ( arr , n ) ) ; int [ ] arr2 = { 1 , 2 , 3 , 4 , 5 } ; int n2 = arr2 . Length ; Console . WriteLine ( "" Maximum ▁ sum ▁ = ▁ "" + maxSumBitonicSubArr ( arr2 , n2 ) ) ; int [ ] arr3 = { 5 , 4 , 3 , 2 , 1 } ; int n3 = arr3 . Length ; Console . WriteLine ( "" Maximum ▁ sum ▁ = ▁ "" + maxSumBitonicSubArr ( arr3 , n3 ) ) ; int [ ] arr4 = { 5 , 5 , 5 , 5 } ; int n4 = arr4 . Length ; Console . WriteLine ( "" Maximum ▁ sum ▁ = ▁ "" + maxSumBitonicSubArr ( arr4 , n4 ) ) ; int [ ] arr5 = { - 1 , 0 , 1 , 2 , 3 , 1 , 0 , - 1 , - 10 } ; int n5 = arr5 . Length ; Console . WriteLine ( "" Maximum ▁ sum ▁ = ▁ "" + maxSumBitonicSubArr ( arr5 , n5 ) ) ; int [ ] arr6 = { - 1 , 0 , 1 , 2 , 0 , - 1 , - 2 , 0 , 1 , 3 } ; int n6 = arr6 . Length ; Console . WriteLine ( "" Maximum ▁ sum ▁ = ▁ "" + maxSumBitonicSubArr ( arr6 , n6 ) ) ; } }";"Maximum sum bitonic subarray | C # implementation to find the maximum sum bitonic subarray ; Function to find the maximum sum bitonic subarray . ; To store the maximum sum bitonic subarray ; Find the longest increasing subarray starting at i . ; Now we know that a [ i . . j ] is an increasing subarray . Remove non - positive elements from the left side as much as possible . ; Find the longest decreasing subarray starting at j . ; Now we know that a [ j . . k ] is a decreasing subarray . Remove non - positive elements from the right side as much as possible . last is needed to keep the last seen element . ; Compute the max sum of the increasing part . ; Compute the max sum of the decreasing part . ; The overall max sum is the sum of both parts minus the peak element , because it was counted twice . ; If the next element is equal to the current , i . e . arr [ i + 1 ] == arr [ i ] , last == i . To ensure the algorithm has progress , get the max of last and i + 1. ; Required maximum sum ; Driver code ; The example from the article , the answer is 19. ; Always increasing , the answer is 15. ; Always decreasing , the answer is 15. ; All are equal , the answer is 5. ; The whole array is bitonic , but the answer is 7. ; The answer is 4 ( the tail ) ."
C#;"using System ; class GFG { static int smallestSumSubarr ( int [ ] arr , int n ) { int min_ending_here = 2147483647 ; int min_so_far = 2147483647 ; for ( int i = 0 ; i < n ; i ++ ) { if ( min_ending_here > 0 ) min_ending_here = arr [ i ] ; else min_ending_here += arr [ i ] ; min_so_far = Math . Min ( min_so_far , min_ending_here ) ; } return min_so_far ; } public static void Main ( ) { int [ ] arr = { 3 , - 4 , 2 , - 3 , - 1 , 7 , - 5 } ; int n = arr . Length ; Console . Write ( "" Smallest ▁ sum : ▁ "" + smallestSumSubarr ( arr , n ) ) ; } }";"Smallest sum contiguous subarray | C # implementation to find the smallest sum contiguous subarray ; function to find the smallest sum contiguous subarray ; to store the minimum value that is ending up to the current index ; to store the minimum value encountered so far ; traverse the array elements ; if min_ending_here > 0 , then it could not possibly contribute to the minimum sum further ; else add the value arr [ i ] to min_ending_here ; update min_so_far ; required smallest sum contiguous subarray value ; Driver method"
C#;"using System ; public class GFG { static int ans ( int n ) { if ( n < 6 ) { return n ; } return n % 6 + 10 * ( ans ( n / 6 ) ) ; } static int getSpecialNumber ( int N ) { return ans ( -- N ) ; } public static void Main ( String [ ] args ) { int N = 17 ; int answer = getSpecialNumber ( N ) ; Console . WriteLine ( answer ) ; } }";"n | C # code to find nth number with digits 0 , 1 , 2 , 3 , 4 , 5 ; If the Number is less than 6 return the number as it is . ; Call the function again and again the get the desired result . And convert the number to base 6. ; Decrease the Number by 1 and Call ans function to convert N to base 6 ; Driver code"
C#;"using System ; class GFG { static int [ , ] dp = new int [ 300 , 300 ] ; static int minimumSquare ( int m , int n ) { int vertical_min = int . MaxValue ; int horizontal_min = int . MaxValue ; if ( n == 13 && m == 11 ) return 6 ; if ( m == 13 && n == 11 ) return 6 ; if ( m == n ) return 1 ; if ( dp [ m , n ] != 0 ) return dp [ m , n ] ; for ( int i = 1 ; i <= m / 2 ; i ++ ) { horizontal_min = Math . Min ( minimumSquare ( i , n ) + minimumSquare ( m - i , n ) , horizontal_min ) ; } for ( int j = 1 ; j <= n / 2 ; j ++ ) { vertical_min = Math . Min ( minimumSquare ( m , j ) + minimumSquare ( m , n - j ) , vertical_min ) ; } dp [ m , n ] = Math . Min ( vertical_min , horizontal_min ) ; return dp [ m , n ] ; } public static void Main ( ) { int m = 30 , n = 35 ; Console . WriteLine ( minimumSquare ( m , n ) ) ; } }";"Paper Cut into Minimum Number of Squares | Set 2 | C # program to find minimum number of squares to cut a paper using Dynamic Programming ; Returns min number of squares needed ; Initializing max values to vertical_min and horizontal_min ; N = 11 & M = 13 is a special case ; If the given rectangle is already a square ; If the answer for the given rectangle is previously calculated return that answer ; The rectangle is cut horizontally and vertically into two parts and the cut with minimum value is found for every recursive call . ; Calculating the minimum answer for the rectangles with width equal to n and length less than m for finding the cut point for the minimum answer ; Calculating the minimum answer for the rectangles with width less than n and length equal to m for finding the cut point for the minimum answer ; Minimum of the vertical cut or horizontal cut to form a square is the answer ; Driver code ; Function call"
C#;"using System ; class GFG { static long fact ( int n ) { long res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } static long nCr ( int n , int r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } public static void Main ( String [ ] args ) { int n = 2 ; Console . Write ( "" Number ▁ of ▁ Non - Decreasing ▁ digits : ▁ "" + nCr ( n + 9 , 9 ) ) ; } }";"Number of n | C # program To calculate Number of n - digits non - decreasing integers ; Returns factorial of n ; returns nCr ; Driver code"
C#;"using System ; class GFG { static long countWays ( int n , int k ) { long total = k ; int mod = 1000000007 ; long same = 0 , diff = k ; for ( int i = 2 ; i <= n ; i ++ ) { same = diff ; diff = total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; } static void Main ( ) { int n = 3 , k = 2 ; Console . Write ( countWays ( n , k ) ) ; } }";"Painting Fence Algorithm | C # program for Painting Fence Algorithm ; Returns count of ways to color k posts using k colors ; There are k ways to color first post ; There are 0 ways for single post to violate ( same color_ and k ways to not violate ( different color ) ; Fill for 2 posts onwards ; Current same is same as previous diff ; We always have k - 1 choices for next post ; Total choices till i . ; Driver code"
C#;"using System ; public class GFG { public static long sumOfSubstrings ( string num ) { long sum = 0 ; long mf = 1 ; for ( int i = num . Length - 1 ; i >= 0 ; i -- ) { sum += ( num [ i ] - '0' ) * ( i + 1 ) * mf ; mf = mf * 10 + 1 ; } return sum ; } public static void Main ( ) { string num = ""6759"" ; Console . WriteLine ( sumOfSubstrings ( num ) ) ; } }";"Sum of all substrings of a string representing a number | Set 2 ( Constant Extra Space ) | C # program to print sum of all substring of a number represented as a string ; Returns sum of all substring of num ; Initialize result ; Here traversing the array in reverse order . Initializing loop from last element . mf is multiplying factor . ; Each time sum is added to its previous sum . Multiplying the three factors as explained above . s [ i ] - '0' is done to convert char to int . ; Making new multiplying factor as explained above . ; Driver code to test above methods"
C#;"using System ; class Test { static int maxSumWithK ( int [ ] a , int n , int k ) { int [ ] maxSum = new int [ n ] ; maxSum [ 0 ] = a [ 0 ] ; int curr_max = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { curr_max = Math . Max ( a [ i ] , curr_max + a [ i ] ) ; maxSum [ i ] = curr_max ; } int sum = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum += a [ i ] ; int result = sum ; for ( int i = k ; i < n ; i ++ ) { sum = sum + a [ i ] - a [ i - k ] ; result = Math . Max ( result , sum ) ; result = Math . Max ( result , sum + maxSum [ i - k ] ) ; } return result ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , - 10 , - 3 } ; int k = 4 ; Console . Write ( maxSumWithK ( arr , arr . Length , k ) ) ; ; } }";"Largest sum subarray with at | C # program to find largest subarray sum with at - least k elements in it . ; Returns maximum sum of a subarray with at - least k elements . ; maxSum [ i ] is going to store maximum sum till index i such that a [ i ] is part of the sum . ; We use Kadane 's algorithm to fill maxSum[]  Below code is taken from method 3 of  https:www.geeksforgeeks.org/largest-sum-contiguous-subarray/ ; Sum of first k elements ; Use the concept of sliding window ; Compute sum of k elements ending with a [ i ] . ; Update result if required ; Include maximum sum till [ i - k ] also if it increases overall max . ; Driver method"
C#;"using System ; class Gfg { static int [ ] arr = { 1 , 5 , 6 } ; static int countWays ( int N ) { int [ ] count = new int [ N + 1 ] ; count [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) for ( int j = 0 ; j < arr . Length ; j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr [ j ] ] ; return count [ N ] ; } public static void Main ( ) { int N = 7 ; Console . Write ( "" Total ▁ number ▁ of ▁ ways ▁ = ▁ "" + countWays ( N ) ) ; } }";"Ways to sum to N using array elements with repetition allowed | C # implementation to count ways to sum up to a given value N ; method to count the total number of ways to sum up to ' N ' ; base case ; count ways for all values up to ' N ' and store the result ; if i >= arr [ j ] then accumulate count for value ' i ' as ways to form value ' i - arr [ j ] ' ; required number of ways ; Driver code"
C#;"using System ; class GFG { static int getTotalNumberOfSequences ( int m , int n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; } public static void Main ( ) { int m = 10 ; int n = 4 ; Console . Write ( "" Total ▁ number ▁ of ▁ possible ▁ sequences ▁ "" + getTotalNumberOfSequences ( m , n ) ) ; } }";"Sequences of given length where every element is more than or equal to twice of previous | C # program to count total number of special sequences of length n where every element is more than or equal to twice of previous ; Recursive function to find the number of special sequences ; A special sequence cannot exist if length n is more than the maximum value m . ; If n is 0 , found an empty special sequence ; There can be two possibilities : ( 1 ) Reduce last element value ( 2 ) Consider last element as m and reduce number of terms ; Driver code"
C#;"using System ; class Sequences { static int getTotalNumberOfSequences ( int m , int n ) { int [ , ] T = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 j == 0 ) T [ i , j ] = 0 ; else if ( i < j ) T [ i , j ] = 0 ; else if ( j == 1 ) T [ i , j ] = i ; else T [ i , j ] = T [ i - 1 , j ] + T [ i / 2 , j - 1 ] ; } } return T [ m , n ] ; } public static void Main ( ) { int m = 10 ; int n = 4 ; Console . WriteLine ( "" Total ▁ number ▁ of ▁ possible ▁ sequences ▁ "" + getTotalNumberOfSequences ( m , n ) ) ; } }";"Sequences of given length where every element is more than or equal to twice of previous | Efficient C # program to count total number of special sequences of length n where ; DP based function to find the number of special sequences ; define T and build in bottom manner to store number of special sequences of length n and maximum value m ; Base case : If length of sequence is 0 or maximum value is 0 , there cannot exist any special sequence ; if length of sequence is more than the maximum value , special sequence cannot exist ; If length of sequence is 1 then the number of special sequences is equal to the maximum value For example with maximum value 2 and length 1 , there can be 2 special sequences { 1 } , { 2 } ; otherwise calculate ; Driver Code"
C#;"using System ; class GFG { static int lcs ( string str1 , string str2 , int m , int n ) { int [ , ] L = new int [ m + 1 , n + 1 ] ; int i , j ; for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i , j ] = 0 ; else if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) L [ i , j ] = L [ i - 1 , j - 1 ] + 1 ; else L [ i , j ] = Math . Max ( L [ i - 1 , j ] , L [ i , j - 1 ] ) ; } } return L [ m , n ] ; } static void printMinDelAndInsert ( string str1 , string str2 ) { int m = str1 . Length ; int n = str2 . Length ; int len = lcs ( str1 , str2 , m , n ) ; Console . Write ( "" Minimum ▁ number ▁ of ▁ "" + "" deletions ▁ = ▁ "" ) ; Console . WriteLine ( m - len ) ; Console . Write ( "" Minimum ▁ number ▁ of ▁ "" + "" insertions ▁ = ▁ "" ) ; Console . Write ( n - len ) ; } public static void Main ( ) { string str1 = new string ( "" heap "" ) ; string str2 = new string ( "" pea "" ) ; printMinDelAndInsert ( str1 , str2 ) ; } }";"Minimum number of deletions and insertions to transform one string into another | Dynamic Programming C # implementation to find minimum number of deletions and insertions ; Returns length of length common subsequence for str1 [ 0. . m - 1 ] , str2 [ 0. . n - 1 ] ; Following steps build L [ m + 1 ] [ n + 1 ] in bottom up fashion . Note that L [ i ] [ j ] contains length of LCS of str1 [ 0. . i - 1 ] and str2 [ 0. . j - 1 ] ; L [ m ] [ n ] contains length of LCS for X [ 0. . n - 1 ] and Y [ 0. . m - 1 ] ; function to find minimum number of deletions and insertions ; Driver code ; Function Call"
C#;"using System ; class GfG { static int lis ( int [ ] arr , int n ) { int result = 0 ; int [ ] lis = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( result < lis [ i ] ) result = lis [ i ] ; return result ; } static int minimumNumberOfDeletions ( int [ ] arr , int n ) { int len = lis ( arr , n ) ; return ( n - len ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 30 , 40 , 2 , 5 , 1 , 7 , 45 , 50 , 8 } ; int n = arr . Length ; Console . Write ( "" Minimum ▁ number ▁ of "" + "" ▁ deletions ▁ = ▁ "" + minimumNumberOfDeletions ( arr , n ) ) ; } }";"Minimum number of deletions to make a sorted sequence | C # implementation to find minimum number of deletions to make a sorted sequence ; lis ( ) returns the length of the longest increasing subsequence in arr [ ] of size n ; Initialize LIS values for all indexes ; Compute optimized LIS values in bottom up manner ; Pick resultimum of all LIS values ; function to calculate minimum number of deletions ; Find longest increasing subsequence ; After removing elements other than the lis , we get sorted sequence . ; Driver Code"
C#;"using System ; class GFG { static int inf = 1000000000 ; static int minCost ( int [ ] a , int n , int k ) { int [ , ] dp = new int [ n + 1 , k + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= k ; j ++ ) dp [ i , j ] = inf ; dp [ 0 , 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 1 ; j <= k ; j ++ ) for ( int m = i - 1 ; m >= 0 ; m -- ) dp [ i , j ] = Math . Min ( dp [ i , j ] , dp [ m , j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; return dp [ n , k ] ; } public static void Main ( ) { int k = 2 ; int [ ] a = { 1 , 5 , 8 , 10 } ; int n = a . Length ; Console . Write ( minCost ( a , n , k ) ) ; } }";"Clustering / Partitioning an array such that sum of square differences is minimum | C # program to find minimum cost k partitions of array . ; Returns minimum cost of partitioning a [ ] in k clusters . ; Create a dp [ ] [ ] table and initialize all values as infinite . dp [ i ] [ j ] is going to store optimal partition cost for arr [ 0. . i - 1 ] and j partitions ; Fill dp [ ] [ ] in bottom up manner ; Current ending position ( After i - th iteration result for a [ 0. . i - 1 ] is computed . ; j is number of partitions ; Picking previous partition for current i . ; Driver code"
C#;"using System ; class GFG { static int lps ( String str ) { int n = str . Length ; int [ , ] L = new int [ n , n ] ; for ( int i = 0 ; i < n ; i ++ ) L [ i , i ] = 1 ; for ( int cl = 2 ; cl <= n ; cl ++ ) { for ( int i = 0 ; i < n - cl + 1 ; i ++ ) { int j = i + cl - 1 ; if ( str [ i ] == str [ j ] && cl == 2 ) L [ i , j ] = 2 ; else if ( str [ i ] == str [ j ] ) L [ i , j ] = L [ i + 1 , j - 1 ] + 2 ; else L [ i , j ] = Math . Max ( L [ i , j - 1 ] , L [ i + 1 , j ] ) ; } } return L [ 0 , n - 1 ] ; } static int minimumNumberOfDeletions ( string str ) { int n = str . Length ; int len = lps ( str ) ; return ( n - len ) ; } public static void Main ( ) { string str = "" geeksforgeeks "" ; Console . Write ( "" Minimum ▁ number ▁ of "" + "" ▁ deletions ▁ = ▁ "" + minimumNumberOfDeletions ( str ) ) ; } }";"Minimum number of deletions to make a string palindrome | C # implementation to find minimum number of deletions to make a string palindromic ; Returns the length of the longest palindromic subsequence in ' str ' ; Create a table to store results of subproblems ; Strings of length 1 are palindrome of length 1 ; Build the table . Note that the lower diagonal values of table are useless and not filled in the process . c1 is length of substring ; length of longest palindromic subsequence ; function to calculate minimum number of deletions ; Find longest palindromic subsequence ; After removing characters other than the lps , we get palindrome . ; Driver Code"
C#;"using System ; class GFG { static int offeringNumber ( int n , int [ ] templeHeight ) { for ( int i = 0 ; i < n ; ++ i ) { int left = 0 , right = 0 ; for ( int j = i - 1 ; j >= 0 ; -- j ) { if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) ++ left ; else break ; } for ( int j = i + 1 ; j < n ; ++ j ) { if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) ++ right ; else break ; } sum += Math . Max ( right , left ) + 1 ; } return sum ; } static public void Main ( ) { int [ ] arr1 = { 1 , 2 , 2 } ; Console . WriteLine ( offeringNumber ( 3 , arr1 ) ) ; int [ ] arr2 = { 1 , 4 , 3 , 6 , 2 , 1 } ; Console . WriteLine ( offeringNumber ( 6 , arr2 ) ) ; } }";"Temple Offerings | Program to find minimum total offerings required ; Returns minimum offerings required ; Go through all temples one by one ; Go to left while height keeps increasing ; Go to right while height keeps increasing ; This temple should offer maximum of two values to follow the rule . ; Driver code"
C#;"using System ; class GFG { static bool modularSum ( int [ ] arr , int n , int m ) { if ( n > m ) return true ; bool [ ] DP = new bool [ m ] ; for ( int l = 0 ; l < DP . Length ; l ++ ) DP [ l ] = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; bool [ ] temp = new bool [ m ] ; for ( int l = 0 ; l < temp . Length ; l ++ ) temp [ l ] = false ; for ( int j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( int j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; } public static void Main ( ) { int [ ] arr = { 1 , 7 } ; int n = arr . Length ; int m = 5 ; if ( modularSum ( arr , n , m ) ) Console . Write ( "" YES STRNEWLINE "" ) ; else Console . Write ( "" NO STRNEWLINE "" ) ; } }";"Subset with sum divisible by m | C # program to check if there is a subset with sum divisible by m . ; Returns true if there is a subset of arr [ ] with sum divisible by m ; This array will keep track of all the possible sum ( after modulo m ) which can be made using subsets of arr [ ] initialising boolean array with all false ; we 'll loop through all the elements of arr[] ; anytime we encounter a sum divisible by m , we are done ; To store all the new encountered sum ( after modulo ) . It is used to make sure that arr [ i ] is added only to those entries for which DP [ j ] was true before current iteration . ; For each element of arr [ ] , we loop through all elements of DP table from 1 to m and we add current element i . e . , arr [ i ] to all those elements which are true in DP table ; if an element is true in DP table ; We update it in temp and update to DP once loop of j is over ; Updating all the elements of temp to DP table since iteration over j is over ; Also since arr [ i ] is a single element subset , arr [ i ] % m is one of the possible sum ; driver code"
C#;"using System ; class GFG { static int maxSum ( int [ , ] tri , int n ) { if ( n > 1 ) tri [ 1 , 1 ] = tri [ 1 , 1 ] + tri [ 0 , 0 ] ; tri [ 1 , 0 ] = tri [ 1 , 0 ] + tri [ 0 , 0 ] ; for ( int i = 2 ; i < n ; i ++ ) { tri [ i , 0 ] = tri [ i , 0 ] + tri [ i - 1 , 0 ] ; tri [ i , i ] = tri [ i , i ] + tri [ i - 1 , i - 1 ] ; for ( int j = 1 ; j < i ; j ++ ) { if ( tri [ i , j ] + tri [ i - 1 , j - 1 ] >= tri [ i , j ] + tri [ i - 1 , j ] ) tri [ i , j ] = tri [ i , j ] + tri [ i - 1 , j - 1 ] ; else tri [ i , j ] = tri [ i , j ] + tri [ i - 1 , j ] ; } } int max = tri [ n - 1 , 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( max < tri [ n - 1 , i ] ) max = tri [ n - 1 , i ] ; } return max ; } public static void Main ( ) { int [ , ] tri = { { 1 , 0 , 0 } , { 2 , 1 , 0 } , { 3 , 3 , 2 } } ; Console . Write ( maxSum ( tri , 3 ) ) ; } }";"Maximum sum of a path in a Right Number Triangle | C # program to print maximum sum in a right triangle of numbers ; function to find maximum sum path ; Adding the element of row 1 to both the elements of row 2 to reduce a step from the loop ; Traverse remaining rows ; Loop to traverse columns ; tri [ i ] would store the possible combinations of sum of the paths ; array at n - 1 index ( tri [ i ] ) stores all possible adding combination , finding the maximum one out of them ; Driver Code"
C#;"using System ; class GFG { static int maximumDifferenceSum ( int [ ] arr , int N ) { int [ , ] dp = new int [ N , 2 ] ; for ( int i = 0 ; i < N ; i ++ ) dp [ i , 0 ] = dp [ i , 1 ] = 0 ; for ( int i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 , 0 ] = Math . Max ( dp [ i , 0 ] , dp [ i , 1 ] + Math . Abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 , 1 ] = Math . Max ( dp [ i , 0 ] + Math . Abs ( arr [ i + 1 ] - 1 ) , dp [ i , 1 ] + Math . Abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return Math . Max ( dp [ N - 1 , 0 ] , dp [ N - 1 , 1 ] ) ; } public static void Main ( ) { int [ ] arr = { 3 , 2 , 1 , 4 , 5 } ; int N = arr . Length ; Console . Write ( maximumDifferenceSum ( arr , N ) ) ; } }";"Modify array to maximize sum of adjacent differences | C # program to get maximum consecutive element difference sum ; Returns maximum - difference - sum with array modifications allowed . ; Initialize dp [ ] [ ] with 0 values . ; for [ i + 1 ] [ 0 ] ( i . e . current modified value is 1 ) , choose maximum from dp [ i ] [ 0 ] + abs ( 1 - 1 ) = dp [ i ] [ 0 ] and dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ; for [ i + 1 ] [ 1 ] ( i . e . current modified value is arr [ i + 1 ] ) , choose maximum from dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) and dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ; Driver code"
C#;"using System ; class GFG { static int countStrUtil ( int [ , , ] dp , int n , int bCount = 1 , int cCount = 2 ) { if ( bCount < 0 cCount < 0 ) return 0 ; if ( n == 0 ) return 1 ; if ( bCount == 0 && cCount == 0 ) return 1 ; if ( dp [ n , bCount , cCount ] != - 1 ) return dp [ n , bCount , cCount ] ; int res = countStrUtil ( dp , n - 1 , bCount , cCount ) ; res += countStrUtil ( dp , n - 1 , bCount - 1 , cCount ) ; res += countStrUtil ( dp , n - 1 , bCount , cCount - 1 ) ; return ( dp [ n , bCount , cCount ] = res ) ; } static int countStr ( int n ) { int [ , , ] dp = new int [ n + 1 , 2 , 3 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) for ( int j = 0 ; j < 2 ; j ++ ) for ( int k = 0 ; k < 3 ; k ++ ) dp [ i , j , k ] = - 1 ; return countStrUtil ( dp , n ) ; } static void Main ( ) { int n = 3 ; Console . Write ( countStr ( n ) ) ; } }";"Count of strings that can be formed using a , b and c under given constraints | C # program to count number of strings of n characters with ; n is total number of characters . bCount and cCount are counts of ' b ' and ' c ' respectively . ; Base cases ; if we had saw this combination previously ; Three cases , we choose , a or b or c In all three cases n decreases by 1. ; A wrapper over countStrUtil ( ) ; Driver code ; Total number of characters"
C#;"using System ; class GFG { static int N = 8 ; static int [ ] dx = { 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 } ; static int [ ] dy = { 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 } ; static bool inside ( int x , int y ) { return ( x >= 0 && x < N && y >= 0 && y < N ) ; } static double findProb ( int start_x , int start_y , int steps ) { double [ , , ] dp1 = new double [ N , N , steps + 1 ] ; for ( int i = 0 ; i < N ; ++ i ) for ( int j = 0 ; j < N ; ++ j ) dp1 [ i , j , 0 ] = 1 ; for ( int s = 1 ; s <= steps ; ++ s ) { for ( int x = 0 ; x < N ; ++ x ) { for ( int y = 0 ; y < N ; ++ y ) { double prob = 0.0 ; for ( int i = 0 ; i < 8 ; ++ i ) { int nx = x + dx [ i ] ; int ny = y + dy [ i ] ; if ( inside ( nx , ny ) ) prob += dp1 [ nx , ny , s - 1 ] / 8.0 ; } dp1 [ x , y , s ] = prob ; } } } return dp1 [ start_x , start_y , steps ] ; } static void Main ( ) { int K = 3 ; Console . WriteLine ( findProb ( 0 , 0 , K ) ) ; } }";"Probability of Knight to remain in the chessboard | C # program to find the probability of the Knight to remain inside the chessboard after taking exactly K number of steps ; size of the chessboard ; direction vector for the Knight ; returns true if the knight is inside the chessboard ; Bottom up approach for finding the probability to go out of chessboard . ; dp array ; for 0 number of steps , each position will have probability 1 ; for every number of steps s ; for every position ( x , y ) after s number of steps ; for every position reachable from ( x , y ) ; if this position lie inside the board ; store the result ; return the result ; Driver code ; number of steps ; Function Call"
C#;"using System ; class GFG { static int countSubarray ( int [ ] arr , int n , int k ) { int s = 0 ; int i = 0 ; while ( i < n ) { if ( arr [ i ] > k ) { i ++ ; continue ; } int count = 0 ; while ( i < n && arr [ i ] <= k ) { i ++ ; count ++ ; } s += ( ( count * ( count + 1 ) ) / 2 ) ; } return ( n * ( n + 1 ) / 2 - s ) ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 } ; int k = 2 ; int n = arr . Length ; Console . WriteLine ( countSubarray ( arr , n , k ) ) ; } }";"Count of subarrays whose maximum element is greater than k | C # program to count number of subarrays whose maximum element is greater than K . ; Return number of subarrays whose maximum element is less than or equal to K . ; To store count of subarrays with all elements less than or equal to k . ; Traversing the array . ; If element is greater than k , ignore . ; Counting the subarray length whose each element is less than equal to k . ; Suming number of subarray whose maximum element is less than equal to k . ; Driver code"
C#;"using System ; class GFG { static int nCr ( int n , int k ) { int [ , ] C = new int [ n + 1 , k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . Min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i , j ] = 1 ; else C [ i , j ] = C [ i - 1 , j - 1 ] + C [ i - 1 , j ] ; } } return C [ n , k ] ; } static double resultOfAllSubsets ( int [ ] arr , int N ) { double result = 0.0 ; int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; for ( int n = 1 ; n <= N ; n ++ ) result += ( double ) ( sum * ( nCr ( N - 1 , n - 1 ) ) ) / n ; return result ; } public static void Main ( ) { int [ ] arr = { 2 , 3 , 5 , 7 } ; int N = arr . Length ; Console . WriteLine ( resultOfAllSubsets ( arr , N ) ) ; } }";"Sum of average of all subsets | C # program to get sum of average of all subsets ; Returns value of Binomial Coefficient C ( n , k ) ; Calculate value of Binomial Coefficient in bottom up manner ; Base Cases ; Calculate value using previously stored values ; method returns sum of average of all subsets ; Initialize result ; Find sum of elements ; looping once for all subset of same size ; each element occurs nCr ( N - 1 , n - 1 ) times while considering subset of size n ; Driver code to test above methods"
C#;"using System ; class GFG { static int [ ] arr = { 100 , 1000 , 100 , 1000 , 1 } ; static int [ ] sum = new int [ 10000 ] ; static int maxSumWO3Consec ( int n ) { if ( sum [ n ] != - 1 ) return sum [ n ] ; if ( n == 0 ) return sum [ n ] = 0 ; if ( n == 1 ) return sum [ n ] = arr [ 0 ] ; if ( n == 2 ) return sum [ n ] = arr [ 1 ] + arr [ 0 ] ; return sum [ n ] = Math . Max ( Math . Max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n ] ) , arr [ n ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ; } public static void Main ( String [ ] args ) { int n = arr . Length ; for ( int i = 0 ; i < sum . Length ; i ++ ) sum [ i ] = - 1 ; Console . WriteLine ( maxSumWO3Consec ( n ) ) ; } }";"Maximum subsequence sum such that no three are consecutive | C # program to find the maximum sum such that no three are consecutive using recursion . ; Returns maximum subsequence sum such that no three elements are consecutive ; Base cases ( process first three elements ) ; Process rest of the elements We have three cases ; Driver code"
C#;"using System ; class GFG { static int maxSumPairWithDifferenceLessThanK ( int [ ] arr , int N , int k ) { int maxSum = 0 ; Array . Sort ( arr ) ; for ( int i = N - 1 ; i > 0 ; -- i ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ; -- i ; } } return maxSum ; } public static void Main ( ) { int [ ] arr = { 3 , 5 , 10 , 15 , 17 , 12 , 9 } ; int N = arr . Length ; int K = 4 ; Console . Write ( maxSumPairWithDifferenceLessThanK ( arr , N , K ) ) ; } }";"Maximum sum of pairs with specific difference | C # program to find maximum pair sum whose difference is less than K ; Method to return maximum sum we can get by finding less than K difference pairs ; Sort elements to ensure every i and i - 1 is closest possible pair ; To get maximum possible sum , iterate from largest to smallest , giving larger numbers priority over smaller numbers . ; Case I : Diff of arr [ i ] and arr [ i - 1 ] is less then K , add to maxSum Case II : Diff between arr [ i ] and arr [ i - 1 ] is not less then K , move to next i since with sorting we know , arr [ i ] - arr [ i - 1 ] < arr [ i ] - arr [ i - 2 ] and so on . ; Assuming only positive numbers . ; When a match is found skip this pair ; Driver Code"
C#;"using System ; class GFG { static int countGroups ( int position , int previous_sum , int length , String num ) { if ( position == length ) return 1 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } return res ; } public static void Main ( ) { String num = ""1119"" ; int len = num . Length ; Console . Write ( countGroups ( 0 , 0 , len , num ) ) ; } }";"Count digit groupings of a number with given constraints | C # program to count number of ways to group digits of a number such that sum of digits in every subgroup is less than or equal to its immediate right subgroup . ; Function to find the subgroups ; Terminating Condition ; sum of digits ; Traverse all digits from current position to rest of the length of string ; If forward_sum is greater than the previous sum , then call the method again ; Note : We pass current sum as previous sum ; Total number of subgroups till current position ; Driver Code"
C#;"using System ; class GFG { static int MAX = 40 ; static int [ , ] dp = new int [ MAX , 9 * MAX + 1 ] ; static int countGroups ( int position , int previous_sum , int length , char [ ] num ) { if ( position == length ) return 1 ; if ( dp [ position , previous_sum ] != - 1 ) return dp [ position , previous_sum ] ; dp [ position , previous_sum ] = 0 ; int res = 0 ; int sum = 0 ; for ( int i = position ; i < length ; i ++ ) { sum += ( num [ i ] - '0' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } dp [ position , previous_sum ] = res ; return res ; } static void Main ( ) { char [ ] num = { '1' , '1' , '1' , '9' } ; int len = num . Length ; for ( int i = 0 ; i < MAX ; i ++ ) for ( int j = 0 ; j < 9 * MAX + 1 ; j ++ ) dp [ i , j ] = - 1 ; Console . Write ( countGroups ( 0 , 0 , len , num ) ) ; } }";"Count digit groupings of a number with given constraints | C # program to count number of ways to group digits of a number such that sum of digits in every subgroup is less than or equal to its immediate right subgroup . ; Maximum length of input number string ; A memoization table to store results of subproblems length of string is 40 and maximum sum will be 9 * 40 = 360. ; Function to find the count of splits with given condition ; Terminating Condition ; If already evaluated for a given sub problem then return the value ; countGroups for current sub - group is 0 ; sum of digits ; Traverse all digits from current position to rest of the length of string ; If forward_sum is greater than the previous sum , then call the method again ; Note : We pass current sum as previous sum ; total number of subgroups till current position ; Driver Code ; Initialize dp table"
C#;"using System ; class GFG { static int KnapSack ( int [ ] val , int [ ] wt , int n , int W ) { int [ ] dp = new int [ W + 1 ] ; for ( int i = 0 ; i < W + 1 ; i ++ ) dp [ i ] = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = W ; j >= wt [ i ] ; j -- ) dp [ j ] = Math . Max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; return dp [ W ] ; } public static void Main ( String [ ] args ) { int [ ] val = { 7 , 8 , 4 } ; int [ ] wt = { 3 , 8 , 6 } ; int W = 10 , n = 3 ; Console . WriteLine ( KnapSack ( val , wt , n , W ) ) ; } }";"A Space Optimized DP solution for 0 | C # program of a space optimized DP solution for 0 - 1 knapsack problem . ; val [ ] is for storing maximum profit for each weight wt [ ] is for storing weights n number of item W maximum capacity of bag dp [ W + 1 ] to store final result ; array to store final result dp [ i ] stores the profit with KnapSack capacity "" i "" ; initially profit with 0 to W KnapSack capacity is 0 ; iterate through all items ; traverse dp array from right to left ; above line finds out maximum of dp [ j ] ( excluding ith element value ) and val [ i ] + dp [ j - wt [ i ] ] ( including ith element value and the profit with "" KnapSack ▁ capacity ▁ - ▁ ith ▁ element ▁ weight "" ) ; Driver code"
C#;"using System ; class GFG { static int count ( String a , String b ) { int m = a . Length ; int n = b . Length ; int [ , ] lookup = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= n ; ++ i ) lookup [ 0 , i ] = 0 ; for ( int i = 0 ; i <= m ; ++ i ) lookup [ i , 0 ] = 1 ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( a [ i - 1 ] == b [ j - 1 ] ) lookup [ i , j ] = lookup [ i - 1 , j - 1 ] + lookup [ i - 1 , j ] ; else lookup [ i , j ] = lookup [ i - 1 , j ] ; } } return lookup [ m , n ] ; } public static void Main ( ) { String a = "" GeeksforGeeks "" ; String b = "" Gks "" ; Console . WriteLine ( count ( a , b ) ) ; } }";"Find number of times a string occurs as a subsequence in given string | A Dynamic Programming based C # program to find the number of times the second string occurs in the first string , whether continuous or discontinuous ; Iterative DP function to find the number of times the second string occurs in the first string , whether continuous or discontinuous ; Create a table to store results of sub - problems ; If first string is empty ; If second string is empty ; Fill lookup [ ] [ ] in bottom up manner ; If last characters are same , we have two options - 1. consider last characters of both strings in solution 2. ignore last character of first string ; If last character are different , ignore last character of first string ; Driver Code"
C#;"using System ; class GFG { static int lenOfLongestGP ( int [ ] Set , int n ) { if ( n < 2 ) { return n ; } if ( n == 2 ) { return ( Set [ 1 ] % Set [ 0 ] == 0 ? 2 : 1 ) ; } Array . Sort ( Set ) ; int [ , ] L = new int [ n , n ] ; int llgp = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( Set [ n - 1 ] % Set [ i ] == 0 ) { L [ i , n - 1 ] = 2 ; if ( 2 > llgp ) llgp = 2 ; } else { L [ i , n - 1 ] = 1 ; } } L [ n - 1 , n - 1 ] = 1 ; for ( int j = n - 2 ; j >= 1 ; -- j ) { int i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( Set [ i ] * Set [ k ] < Set [ j ] * Set [ j ] ) { ++ k ; } else if ( Set [ i ] * Set [ k ] > Set [ j ] * Set [ j ] ) { if ( Set [ j ] % Set [ i ] == 0 ) { L [ i , j ] = 2 ; if ( 2 > llgp ) llgp = 2 ; } else { L [ i , j ] = 1 ; } -- i ; } else { if ( Set [ j ] % Set [ i ] == 0 ) { L [ i , j ] = L [ j , k ] + 1 ; if ( L [ i , j ] > llgp ) { llgp = L [ i , j ] ; } } else { L [ i , j ] = 1 ; } -- i ; ++ k ; } } while ( i >= 0 ) { if ( Set [ j ] % Set [ i ] == 0 ) { L [ i , j ] = 2 ; if ( 2 > llgp ) llgp = 2 ; } else { L [ i , j ] = 1 ; } -- i ; } } return llgp ; } public static void Main ( String [ ] args ) { int [ ] set1 = { 1 , 3 , 9 , 27 , 81 , 243 } ; int n1 = set1 . Length ; Console . Write ( lenOfLongestGP ( set1 , n1 ) + "" STRNEWLINE "" ) ; int [ ] set2 = { 1 , 3 , 4 , 9 , 7 , 27 } ; int n2 = set2 . Length ; Console . Write ( lenOfLongestGP ( set2 , n2 ) + "" STRNEWLINE "" ) ; int [ ] set3 = { 2 , 3 , 5 , 7 , 11 , 13 } ; int n3 = set3 . Length ; Console . Write ( lenOfLongestGP ( set3 , n3 ) + "" STRNEWLINE "" ) ; } }";"Longest Geometric Progression | C # program to find length of the longest geometric progression in a given Set ; Returns length of the longest GP subset of Set [ ] ; Base cases ; Let us sort the Set first ; An entry L [ i , j ] in this table stores LLGP with Set [ i ] and Set [ j ] as first two elements of GP and j > i . ; Initialize result ( A single element is always a GP ) ; Initialize values of last column ; Consider every element as second element of GP ; Search for i and k for j ; Two cases when i , j and k don 't form a GP. ; i , j and k form GP , LLGP with i and j as first two elements is equal to LLGP with j and k as first two elements plus 1. L [ j , k ] must have been filled before as we run the loop from right side ; Update overall LLGP ; Change i and k to fill more L [ i , j ] values for current j ; If the loop was stopped due to k becoming more than n - 1 , set the remaining entries in column j as 1 or 2 based on divisibility of Set [ j ] by Set [ i ] ; Return result ; Driver code"
C#;"using System ; using System . Linq ; using System . Collections . Generic ; class GFG { static void print ( List < int > arr , int size ) { for ( int i = 0 ; i < size ; i ++ ) Console . Write ( arr [ i ] + "" ▁ "" ) ; } static void printLBS ( int [ ] arr , int n ) { List < int > [ ] LIS = new List < int > [ n ] ; for ( int i = 0 ; i < n ; i ++ ) LIS [ i ] = new List < int > ( ) ; LIS [ 0 ] . Add ( arr [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( ( arr [ i ] > arr [ j ] ) && LIS [ j ] . Count > LIS [ i ] . Count ) { foreach ( int k in LIS [ j ] ) if ( ! LIS [ i ] . Contains ( k ) ) LIS [ i ] . Add ( k ) ; } } LIS [ i ] . Add ( arr [ i ] ) ; } List < int > [ ] LDS = new List < int > [ n ] ; for ( int i = 0 ; i < n ; i ++ ) LDS [ i ] = new List < int > ( ) ; LDS [ n - 1 ] . Add ( arr [ n - 1 ] ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { for ( int j = n - 1 ; j > i ; j -- ) { if ( arr [ j ] < arr [ i ] && LDS [ j ] . Count > LDS [ i ] . Count ) foreach ( int k in LDS [ j ] ) if ( ! LDS [ i ] . Contains ( k ) ) LDS [ i ] . Add ( k ) ; } LDS [ i ] . Add ( arr [ i ] ) ; } for ( int i = 0 ; i < n ; i ++ ) LDS [ i ] . Reverse ( ) ; int max = 0 ; int maxIndex = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( LIS [ i ] . Count + LDS [ i ] . Count - 1 > max ) { max = LIS [ i ] . Count + LDS [ i ] . Count - 1 ; maxIndex = i ; } } print ( LIS [ maxIndex ] , LIS [ maxIndex ] . Count - 1 ) ; print ( LDS [ maxIndex ] , LDS [ maxIndex ] . Count ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 11 , 2 , 10 , 4 , 5 , 2 , 1 } ; int n = arr . Length ; printLBS ( arr , n ) ; } }";"Printing Longest Bitonic Subsequence | Dynamic Programming solution to print longest Bitonic Subsequence ; Utility function to print longest Bitonic Subsequence ; Function to construct and print longest Bitonic Subsequence ; LIS [ i ] stores the length of the longest increasing subsequence ending with arr [ i ] ; initialize LIS [ 0 ] to arr [ 0 ] ; Compute LIS values from left to right ; for every j less than i ; LDS [ i ] stores the length of the longest decreasing subsequence starting with arr [ i ] ; initialize LDS [ n - 1 ] to arr [ n - 1 ] ; Compute LDS values from right to left ; for every j greater than i ; reverse as vector as we 're inserting at end ; * LDS [ i ] now stores Maximum Decreasing Subsequence * of arr [ i . . n ] that starts with arr [ i ] ; Find maximum value of size of LIS [ i ] + size of LDS [ i ] - 1 ; print all but last element of LIS [ maxIndex ] vector ; print all elements of LDS [ maxIndex ] vector ; Driver Code"
C#;"using System ; class GFG { static int isKPalDP ( string str1 , string str2 , int m , int n ) { int [ , ] dp = new int [ m + 1 , n + 1 ] ; for ( int i = 0 ; i <= m ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) { dp [ i , j ] = j ; } else if ( j == 0 ) { dp [ i , j ] = i ; } else if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) { dp [ i , j ] = dp [ i - 1 , j - 1 ] ; } else { dp [ i , j ] = 1 + Math . Min ( dp [ i - 1 , j ] , dp [ i , j - 1 ] ) ; } } } return dp [ m , n ] ; } static bool isKPal ( string str , int k ) { string revStr = str ; revStr = reverse ( revStr ) ; int len = str . Length ; return ( isKPalDP ( str , revStr , len , len ) <= k * 2 ) ; } static string reverse ( string str ) { char [ ] sb = str . ToCharArray ( ) ; Array . Reverse ( sb ) ; return new string ( sb ) ; } static void Main ( ) { string str = "" acdcb "" ; int k = 2 ; if ( isKPal ( str , k ) ) { Console . WriteLine ( "" Yes "" ) ; } else { Console . WriteLine ( "" No "" ) ; } } }";"Find if string is K | C # program to find if given string is K - Palindrome or not ; find if given string is K - Palindrome or not ; Create a table to store results of subproblems ; Fill dp [ ] [ ] in bottom up manner ; If first string is empty , only option is to remove all characters of second string ; Min . operations = j ; If second string is empty , only option is to remove all characters of first string ; Min . operations = i ; If last characters are same , ignore last character and recur for remaining string ; If last character are different , remove it and find minimum ; Remove from str1 Remove from str2 ; Returns true if str is k palindrome . ;  ; Driver program"
C#;"using System ; class GFG { public static int lcs ( string X , string Y ) { int m = X . Length , n = Y . Length ; int [ , ] L = new int [ 2 , n + 1 ] ; int bi = 0 ; for ( int i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ bi , j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ bi , j ] = L [ 1 - bi , j - 1 ] + 1 ; else L [ bi , j ] = Math . Max ( L [ 1 - bi , j ] , L [ bi , j - 1 ] ) ; } } return L [ bi , n ] ; } public static void Main ( ) { string X = "" AGGTAB "" ; string Y = "" GXTXAYB "" ; Console . Write ( "" Length ▁ of ▁ LCS ▁ is ▁ "" + lcs ( X , Y ) ) ; } }";"A Space Optimized Solution of LCS | C # Code for A Space Optimized Solution of LCS ; Returns length of LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ] ; Find lengths of two strings ; Binary index , used to index current row and previous row . ; Compute current binary index ; Last filled entry contains length of LCS for X [ 0. . n - 1 ] and Y [ 0. . m - 1 ] ; Driver Code"
C#;"using System ; class GFG { static int subsetXOR ( int [ ] arr , int n , int k ) { int max_ele = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; int m = ( 1 << ( int ) ( Math . Log ( max_ele , 2 ) + 1 ) ) - 1 ; if ( k > m ) { return 0 ; } int [ , ] dp = new int [ n + 1 , m + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i , j ] = 0 ; dp [ 0 , 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = 0 ; j <= m ; j ++ ) dp [ i , j ] = dp [ i - 1 , j ] + dp [ i - 1 , j ^ arr [ i - 1 ] ] ; return dp [ n , k ] ; } static public void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int k = 4 ; int n = arr . Length ; Console . WriteLine ( "" Count ▁ of ▁ subsets ▁ is ▁ "" + subsetXOR ( arr , n , k ) ) ; } }";"Count number of subsets having a particular XOR value | C # dynamic programming solution to finding the number of subsets having xor of their elements as k ; Returns count of subsets of arr [ ] with XOR value equals to k . ; Find maximum element in arr [ ] ; Maximum possible XOR value ; The value of dp [ i ] [ j ] is the number of subsets having XOR of their elements as j from the set arr [ 0. . . i - 1 ] ; Initializing all the values of dp [ i ] [ j ] as 0 ; The xor of empty subset is 0 ; Fill the dp table ; The answer is the number of subset from set arr [ 0. . n - 1 ] having XOR of elements as k ; Driver code"
C#;"using System ; class GFG { static int findMin ( int [ ] arr , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; bool [ , ] dp = new bool [ n + 1 , sum + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) dp [ i , 0 ] = true ; for ( int i = 1 ; i <= sum ; i ++ ) dp [ 0 , i ] = false ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= sum ; j ++ ) { dp [ i , j ] = dp [ i - 1 , j ] ; if ( arr [ i - 1 ] <= j ) dp [ i , j ] |= dp [ i - 1 , j - arr [ i - 1 ] ] ; } } int diff = int . MaxValue ; for ( int j = sum / 2 ; j >= 0 ; j -- ) { if ( dp [ n , j ] == true ) { diff = sum - 2 * j ; break ; } } return diff ; } public static void Main ( String [ ] args ) { int [ ] arr = { 3 , 1 , 4 , 2 , 2 , 1 } ; int n = arr . Length ; Console . WriteLine ( "" The ▁ minimum ▁ difference ▁ "" + "" between ▁ 2 ▁ sets ▁ is ▁ "" + findMin ( arr , n ) ) ; } }";"Partition a set into two subsets such that the difference of subset sums is minimum | A Recursive C # program to solve minimum sum partition problem . ; Returns the minimum value of the difference of the two sets . ; Calculate sum of all elements ; Create an array to store results of subproblems ; Initialize first column as true . 0 sum is possible with all elements . ; Initialize top row , except dp [ 0 , 0 ] , as false . With 0 elements , no other sum except 0 is possible ; Fill the partition table in bottom up manner ; If i 'th element is excluded ; If i 'th element is included ; Initialize difference of two sums . ; Find the largest j such that dp [ n , j ] is true where j loops from sum / 2 t0 0 ; Driver code"
C#;"using System ; class GFG { static int MAX = 100 ; static int [ , , , ] dp = new int [ MAX , MAX , MAX , 2 ] ; static int countPathsUtil ( int i , int j , int k , int d ) { if ( i < 0 j < 0 ) return 0 ; if ( i == 0 && j == 0 ) return 1 ; if ( k == 0 ) { if ( d == 0 && i == 0 ) return 1 ; if ( d == 1 && j == 0 ) return 1 ; return 0 ; } if ( dp [ i , j , k , d ] != - 1 ) return dp [ i , j , k , d ] ; if ( d == 0 ) return dp [ i , j , k , d ] = countPathsUtil ( i , j - 1 , k , d ) + countPathsUtil ( i - 1 , j , k - 1 , d == 1 ? 0 : 1 ) ; return dp [ i , j , k , d ] = countPathsUtil ( i - 1 , j , k , d ) + countPathsUtil ( i , j - 1 , k - 1 , d == 1 ? 0 : 1 ) ; } static int countPaths ( int i , int j , int k ) { if ( i == 0 && j == 0 ) return 1 ; for ( int p = 0 ; p < MAX ; p ++ ) { for ( int q = 0 ; q < MAX ; q ++ ) { for ( int r = 0 ; r < MAX ; r ++ ) for ( int s = 0 ; s < 2 ; s ++ ) dp [ p , q , r , s ] = - 1 ; } } } public static void Main ( String [ ] args ) { int m = 3 , n = 3 , k = 2 ; Console . WriteLine ( "" Number ▁ of ▁ paths ▁ is ▁ "" + countPaths ( m - 1 , n - 1 , k ) ) ; } }";"Count number of paths with at | C # program to count number of paths with maximum k turns allowed ; table to store to store results of subproblems ; Returns count of paths to reach ( i , j ) from ( 0 , 0 ) using at - most k turns . d is current direction d = 0 indicates along row , d = 1 indicates along column . ; If invalid row or column indexes ; If current cell is top left itself ; If 0 turns left ; If direction is row , then we can reach here only if direction is row and row is 0. ; If direction is column , then we can reach here only if direction is column and column is 0. ; If this subproblem is already evaluated ; If current direction is row , then count paths for two cases 1 ) We reach here through previous row . 2 ) We reach here through previous column , so number of turns k reduce by 1. ; Similar to above if direction is column ; This function mainly initializes ' dp ' array as - 1 and calls countPathsUtil ( ) ; If ( 0 , 0 ) is target itself ; Initialize ' dp ' array ; Recur for two cases : moving along row and along column return countPathsUtil ( i - 1 , j , k , 1 ) + Moving along row countPathsUtil ( i , j - 1 , k , 0 ) ; Moving along column ; Driver Code"
C#;"using System ; class GFG { static int MAX = 1000 ; static int [ , ] dp = new int [ MAX , MAX ] ; static int minSizeRec ( int [ ] arr , int low , int high , int k ) { if ( dp [ low , high ] != - 1 ) { return dp [ low , high ] ; } if ( ( high - low + 1 ) < 3 ) { return high - low + 1 ; } int res = 1 + minSizeRec ( arr , low + 1 , high , k ) ; for ( int i = low + 1 ; i <= high - 1 ; i ++ ) { for ( int j = i + 1 ; j <= high ; j ++ ) { if ( arr [ i ] == ( arr [ low ] + k ) && arr [ j ] == ( arr [ low ] + 2 * k ) && minSizeRec ( arr , low + 1 , i - 1 , k ) == 0 && minSizeRec ( arr , i + 1 , j - 1 , k ) == 0 ) { res = Math . Min ( res , minSizeRec ( arr , j + 1 , high , k ) ) ; } } } return ( dp [ low , high ] = res ) ; } static int minSize ( int [ ] arr , int n , int k ) { for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = 0 ; j < MAX ; j ++ ) { dp [ i , j ] = - 1 ; } } return minSizeRec ( arr , 0 , n - 1 , k ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 4 , 5 , 6 , 4 } ; int n = arr . Length ; int k = 1 ; Console . WriteLine ( minSize ( arr , n , k ) ) ; } }";"Find minimum possible size of array with given rules for removing elements | C # program to find size of minimum possible array after removing elements according to given rules ; dp [ i , j ] denotes the minimum number of elements left in the subarray arr [ i . . j ] . ; If already evaluated ; If size of array is less than 3 ; Initialize result as the case when first element is separated ( not removed using given rules ) ; Now consider all cases when first element forms a triplet and removed . Check for all possible triplets ( low , i , j ) ; Check if this triplet follows the given rules of removal . And elements between ' low ' and ' i ' , and between ' i ' and ' j ' can be recursively removed . ; Insert value in table and return result ; This function mainly initializes dp table and calls recursive function minSizeRec ; Driver code"
C#;"using System ; class GFG { static int countSol ( int [ ] coeff , int start , int end , int rhs ) { if ( rhs == 0 ) return 1 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; } public static void Main ( ) { int [ ] coeff = { 2 , 2 , 5 } ; int rhs = 4 ; int n = coeff . Length ; Console . Write ( countSol ( coeff , 0 , n - 1 , rhs ) ) ; } }";"Find number of solutions of a linear equation of n variables | A naive recursive C # program to find number of non - negative solutions for a given linear equation ; Recursive function that returns count of solutions for given RHS value and coefficients coeff [ start . . end ] ; Base case ; Initialize count of solutions ; One by subtract all smaller or equal coefficiants and recur ; Driver Code"
C#;"using System ; class GFG { static int getMaxRec ( string str , int i , int n , int [ ] lookup ) { if ( i >= n ) return 0 ; if ( lookup [ i ] != - 1 ) return lookup [ i ] ; int ans = 1 + getMaxRec ( str , i + 1 , n , lookup ) ; if ( i + 1 < n ) { if ( str [ i ] != str [ i + 1 ] ) ans = Math . Max ( 4 + getMaxRec ( str , i + 2 , n , lookup ) , ans ) ; else ans = Math . Max ( 3 + getMaxRec ( str , i + 2 , n , lookup ) , ans ) ; } return lookup [ i ] = ans ; } static int getMaxWeight ( string str ) { int n = str . Length ; int [ ] lookup = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) lookup [ i ] = - 1 ; return getMaxRec ( str , 0 , str . Length , lookup ) ; } public static void Main ( ) { string str = "" AAAAABB "" ; Console . Write ( "" Maximum ▁ weight ▁ of ▁ a "" + "" ▁ transformation ▁ of ▁ "" + str + "" ▁ is ▁ "" + getMaxWeight ( str ) ) ; } }";"Maximum weight transformation of a given string | C # program to find maximum weight transformation of a given string ; Returns weight of the maximum weight transformation ; Base case ; If this subproblem is already solved ; Don 't make pair, so  weight gained is 1 ; If we can make pair ; If elements are dissimilar , weight gained is 4 ; if elements are similar so for making a pair we toggle any of them . Since toggle cost is 1 so overall weight gain becomes 3 ; save and return maximum of above cases ; Initializes lookup table and calls getMaxRec ( ) ; Create and initialize lookup table ; Call recursive function ; Driver Code"
C#;"using System ; class GFG { static int steps ( int source , int step , int dest ) { if ( Math . Abs ( source ) > ( dest ) ) return int . MaxValue ; if ( source == dest ) return step ; int pos = steps ( source + step + 1 , step + 1 , dest ) ; int neg = steps ( source - step - 1 , step + 1 , dest ) ; return Math . Min ( pos , neg ) ; } public static void Main ( ) { int dest = 11 ; Console . WriteLine ( "" No . ▁ of ▁ steps ▁ required "" + "" ▁ to ▁ reach ▁ "" + dest + "" ▁ is ▁ "" + steps ( 0 , 0 , dest ) ) ; } }";"Minimum steps to reach a destination | C # program to count number of steps to reach a point ; source -> source vertex step -> value of last step taken dest -> destination vertex ; base cases ; if we go on positive side ; if we go on negative side ; minimum of both cases ; Driver Code"
C#;"using System ; public class GFG { static int LCSubStr ( string s , string t , int n , int m ) { int [ , ] dp = new int [ 2 , m + 1 ] ; int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = 1 ; j <= m ; j ++ ) { if ( s [ i - 1 ] == t [ j - 1 ] ) { dp [ i % 2 , j ] = dp [ ( i - 1 ) % 2 , j - 1 ] + 1 ; if ( dp [ i % 2 , j ] > res ) res = dp [ i % 2 , j ] ; } else dp [ i % 2 , j ] = 0 ; } } return res ; } static public void Main ( ) { string X = "" OldSite : GeeksforGeeks . org "" ; string Y = "" NewSite : GeeksQuiz . com "" ; int m = X . Length ; int n = Y . Length ; Console . WriteLine ( LCSubStr ( X , Y , m , n ) ) ; } }";"Longest Common Substring | DP | C # implementation of the above approach ; Function to find the length of the longest LCS ; Create DP table ; Driver Code ; Function call"
C#;"using System ; class GFG { static String X , Y ; static int lcs ( int i , int j , int count ) { if ( i == 0 j == 0 ) { return count ; } if ( X [ i - 1 ] == Y [ j - 1 ] ) { count = lcs ( i - 1 , j - 1 , count + 1 ) ; } count = Math . Max ( count , Math . Max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) ; return count ; } public static void Main ( ) { int n , m ; X = "" abcdxyz "" ; Y = "" xyzabcd "" ; n = X . Length ; m = Y . Length ; Console . Write ( lcs ( n , m , 0 ) ) ; } }";"Longest Common Substring | DP | C # program using to find length of the longest common substring recursion ; Returns length of function for longest common substring of X [ 0. . m - 1 ] and Y [ 0. . n - 1 ] ; Driver code"
C#;"using System ; class GFG { static void possibleEqualArray ( int [ ] A , int N ) { int tot_XOR = 0 ; for ( int i = 0 ; i < N ; i ++ ) { tot_XOR ^= A [ i ] ; } if ( tot_XOR == 0 ) { Console . Write ( "" YES "" ) ; return ; } int cur_XOR = 0 ; int cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { cur_XOR ^= A [ i ] ; if ( cur_XOR == tot_XOR ) { cnt ++ ; cur_XOR = 0 ; } } if ( cnt > 2 ) { Console . Write ( "" YES "" ) ; } else { Console . Write ( "" NO "" ) ; } } public static void Main ( String [ ] args ) { int [ ] A = { 0 , 2 , 2 } ; int N = ( A . Length ) ; possibleEqualArray ( A , N ) ; } }";"Make Array elements equal by replacing adjacent elements with their XOR | C # Program of the above approach ; Function to check if it is possible to make all the array elements equal using the given operation ; Stores the XOR of all elements of array A [ ] ; Case 1 , check if the XOR of the array A [ ] is 0 ; Maintains the XOR till the current element ; Iterate over the array ; If the current XOR is equal to the total XOR increment the count and initialize current XOR as 0 ; Print Answer ; Driver Code ; Function Call"
C#;"using System ; public class GFG { static int countPalindromes ( String S ) { int N = ( int ) S . Length ; int [ ] Z = new int [ ( N ) ] ; int l = 0 , r = 0 ; for ( int i = 1 ; i < N ; i ++ ) { if ( i <= r ) Z [ i ] = Math . Min ( r - i + 1 , Z [ i - l ] ) ; while ( i + Z [ i ] < N && S [ Z [ i ] ] == S [ i + Z [ i ] ] ) { Z [ i ] ++ ; } if ( i + Z [ i ] - 1 > r ) { l = i ; r = i + Z [ i ] - 1 ; } } int sum = 0 ; for ( int i = 0 ; i < Z . Length ; i ++ ) { sum += Z [ i ] + 1 ; } return sum ; } public static void Main ( String [ ] args ) { String S = "" abab "" ; Console . WriteLine ( countPalindromes ( S ) ) ; } }";"Count of palindromes that can be obtained by concatenating equal length prefix and substrings | C # program for the above approach ; Function to calculate the number of palindromes ; Calculation of Z - array ; Calculation of sigma ( Z [ i ] + 1 ) ; Return the count ; Driver Code ; Given String"
C#;"using System ; using System . Collections ; class GFG { static void printSubsInDelimeters ( string str ) { Stack dels = new Stack ( ) ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == ' [ ' ) { dels . Push ( i ) ; } else if ( str [ i ] == ' ] ' && dels . Count > 0 ) { int pos = ( int ) dels . Peek ( ) ; dels . Pop ( ) ; int len = i - 1 - pos ; string ans = str . Substring ( pos + 1 , len ) ; Console . WriteLine ( ans ) ; } } } static void Main ( ) { string str = "" [ This ▁ is ▁ first ] ▁ ignored ▁ text ▁ [ This ▁ is ▁ second ] "" ; printSubsInDelimeters ( str ) ; } }";"Extract substrings between any pair of delimiters | C # program to implement the above approach ; Function to print strings present between any pair of delimeters ; Stores the indices of ; If opening delimeter is encountered ; If closing delimeter is encountered ; Extract the position of opening delimeter ; Length of substring ; Extract the substring ; Driver Code"
C#;"using System ; using System . Collections . Generic ; public class GFG { class pair { public int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static void printDiagonalTraversal ( int [ , ] nums ) { int m = nums . GetLength ( 0 ) ; Queue < pair > q = new Queue < pair > ( ) ; q . Enqueue ( new pair ( 0 , 0 ) ) ; while ( q . Count != 0 ) { pair p = q . Peek ( ) ; q . Dequeue ( ) ; Console . Write ( nums [ p . first , p . second ] + "" ▁ "" ) ; if ( p . second == 0 && p . first + 1 < m ) { q . Enqueue ( new pair ( p . first + 1 , p . second ) ) ; } if ( p . second + 1 < nums . GetLength ( 1 ) ) q . Enqueue ( new pair ( p . first , p . second + 1 ) ) ; } } public static void Main ( String [ ] args ) { int [ , ] arr = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; printDiagonalTraversal ( arr ) ; } }";"Print matrix elements from top | C # program for the above approach ; Function to traverse the matrix diagonally upwards ; Store the number of rows ; Initialize queue ; Push the index of first element i . e . , ( 0 , 0 ) ; Get the front element ; Pop the element at the front ; Insert the element below if the current element is in first column ; Insert the right neighbour if it exists ; Driver Code ; Given vector of vectors arr ; Function call"
C#;"using System ; using System . Collections . Generic ; class GFG { static List < int > restore ( int [ ] arr , int N ) { List < int > result = new List < int > ( ) ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . ContainsKey ( arr [ i ] ) && mp [ arr [ i ] ] == 0 ) { result . Add ( arr [ i ] ) ; if ( mp . ContainsKey ( arr [ i ] ) ) { mp [ arr [ i ] ] = mp [ arr [ i ] ] + 1 ; } else { mp . Add ( arr [ i ] , 1 ) ; } } else mp . Add ( arr [ i ] , 0 ) ; } return result ; } static void print_result ( List < int > result ) { for ( int i = 0 ; i < result . Count ; i ++ ) Console . Write ( result [ i ] + "" ▁ "" ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 13 , 1 , 24 , 13 , 24 , 2 , 2 } ; int N = arr . Length ; print_result ( restore ( arr , N ) ) ; } }";"Find original sequence from Array containing the sequence merged many times in order | C # program for the above approach ; Function that returns the restored permutation ; List to store the result ; Map to mark the elements which are taken in result ; Check if the element is coming first time ; Push in result vector ; Mark it in the map ; Return the answer ; Function to print the result ; Driver Code ; Given Array ; Function call"
C#;"using System ; using System . Collections . Generic ; class GFG { static List < int > restore ( int [ ] arr , int N ) { List < int > result = new List < int > ( ) ; int count1 = 1 ; HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { s . Add ( arr [ i ] ) ; if ( s . Count == count1 ) { result . Add ( arr [ i ] ) ; count1 ++ ; } } return result ; } static void print_result ( List < int > result ) { for ( int i = 0 ; i < result . Count ; i ++ ) Console . Write ( result [ i ] + "" ▁ "" ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 13 , 1 , 24 , 13 , 24 , 2 , 2 } ; int N = arr . Length ; print_result ( restore ( arr , N ) ) ; } }";"Find original sequence from Array containing the sequence merged many times in order | C # program for the above approach ; Function that returns the restored permutation ; List to store the result ; Set to insert unique elements ; Check if the element is coming first time ; Push in result vector ; Function to print the result ; Driver Code ; Given Array ; Function call"
C#;"using System ; class GFG { static int sum ( int n ) { return n * ( n - 1 ) / 2 ; } static void BSpattern ( int N ) { int Val = 0 , Pthree = 0 , cnt = 0 , initial = - 1 ; String s = "" * * "" ; for ( int i = 0 ; i < N ; i ++ ) { cnt = 0 ; if ( i > 0 ) { Console . Write ( s ) ; s += "" * * "" ; } for ( int j = i ; j < N ; j ++ ) { if ( i > 0 ) { cnt ++ ; } Console . Write ( ++ Val ) ; Console . Write ( ""0"" ) ; } if ( i == 0 ) { int Sumbeforelast = sum ( Val ) * 2 ; Pthree = Val + Sumbeforelast + 1 ; initial = Pthree ; } initial = initial - cnt ; Pthree = initial ; for ( int k = i ; k < N ; k ++ ) { Console . Write ( Pthree ++ ) ; if ( k != N - 1 ) { Console . Write ( ""0"" ) ; } } Console . WriteLine ( ) ; } } public static void Main ( String [ ] args ) { int N = 5 ; BSpattern ( N ) ; } }";"Program to print the pattern 1020304017018019020 * * 50607014015016 * * * * 809012013 * * * * * * 10011. . . | C # implementation to print the given pattern ; Function to find the sum of N integers from 1 to N ; Function to print the given pattern ; Iterate over [ 0 , N - 1 ] ; Sub - Pattern - 1 ; Sub - Pattern - 2 ; Count the number of element in rows and sub - pattern 2 and 3 will have same rows ; Increment Val to print the series 1 , 2 , 3 , 4 , 5 ... ; Finally , add the ( N - 1 ) th element i . e . , 5 and increment it by 1 ; Initial is used to give the initial value of the row in Sub - Pattern 3 ; Sub - Pattern 3 ; Skip printing zero at the last ; Driver code ; Given N ; Function call"
C#;"using System ; class GFG { static bool checkprefix ( int A , int B ) { String s1 = A . ToString ( ) ; String s2 = B . ToString ( ) ; int n1 = s1 . Length ; int n2 = s2 . Length ; if ( n1 < n2 ) { return false ; } for ( int i = 0 ; i < n2 ; i ++ ) { if ( s1 [ i ] != s2 [ i ] ) { return false ; } } return true ; } static public void Main ( ) { int A = 12345 , B = 12 ; bool result = checkprefix ( A , B ) ; if ( result ) { Console . Write ( "" Yes "" ) ; } else { Console . Write ( "" No "" ) ; } } }";"Check if a number starts with another number or not | C # program for the above approach ; Function to check if B is a prefix of A or not ; Convert numbers into Strings ; Find the lengths of Strings s1 and s2 ; Base Case ; Traverse the Strings s1 & s2 ; If at any index characters are unequals then return false ; Return true ; Driver Code ; Given numbers ; Function call ; If B is a prefix of A , then print "" Yes """
C#;"using System ; class GFG { static void possibleToReach ( int x , int y , int z ) { if ( z < Math . Abs ( x ) + Math . Abs ( y ) || ( z - Math . Abs ( x ) - Math . Abs ( y ) ) % 2 == 1 ) { Console . Write ( "" Not ▁ Possible "" + "" STRNEWLINE "" ) ; } else Console . Write ( "" Possible "" + "" STRNEWLINE "" ) ; } public static void Main ( String [ ] args ) { int x = 5 , y = 5 ; int z = 11 ; possibleToReach ( x , y , z ) ; } }";"Check if it is possible to reach ( x , y ) from origin in exactly Z steps using only plus movements | C # program for the above approach ; Function to check if it is possible to reach ( x , y ) from origin in exactly z steps ; Condition if we can 't reach in Z steps ; Driver Code ; Destination point coordinate ; Number of steps allowed ; Function Call"
C#;"using System ; class GFG { static int nCycle ( int N ) { return ( N ) * ( N - 1 ) + 1 ; } public static void Main ( String [ ] args ) { int N = 4 ; Console . Write ( nCycle ( N ) ) ; } }";"Number of cycles in a Polygon with lines from Centroid to Vertices | C # program to find number of cycles in a Polygon with lines from Centroid to Vertices ; Function to find the Number of Cycles ; Driver code"
C#;"using System ; class GFG { static int [ ] a = new int [ 65 ] ; static int Count ( int i ) { if ( i == 0 ) return 1 ; else if ( i < 0 ) return 0 ; if ( a [ i ] == 0 ) { a [ i ] = ( i + 1 ) + 2 * Count ( i - 1 ) ; return a [ i ] ; } else return a [ i ] ; } static int solve ( int n ) { int i , sum = 0 ; while ( n > 0 ) { i = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) ; n = n - ( int ) Math . Pow ( 2 , i ) ; sum = sum + ( i + 1 ) + Count ( i - 1 ) ; } return sum ; } public static void Main ( String [ ] args ) { int n = 7 ; Console . Write ( solve ( n ) ) ; } }";"Sum of consecutive bit differences of first N non | C # program for the above problem ; Recursive function to count the sum of bit differences of numbers from 1 to pow ( 2 , ( i + 1 ) ) - 1 ; base cases ; Recursion call if the sum of bit difference of numbers around i are not calculated ; return the sum of bit differences if already calculated ; Function to calculate the sum of bit differences up to N ; nearest smaller power of 2 ; remaining numbers ; calculate the count of bit diff ; Driver code"
C#;"using System ; class GFG { public static Tuple < int , int > count_ht ( char s , int N ) { Tuple < int , int > p = Tuple . Create ( 0 , 0 ) ; if ( s == ' H ' ) { p = Tuple . Create ( ( int ) Math . Floor ( N / 2.0 ) , ( int ) Math . Ceiling ( N / 2.0 ) ) ; } else if ( s == ' T ' ) { p = Tuple . Create ( ( int ) Math . Ceiling ( N / 2.0 ) , ( int ) Math . Floor ( N / 2.0 ) ) ; } return p ; } static void Main ( ) { char C = ' H ' ; int N = 5 ; Tuple < int , int > p = count_ht ( C , N ) ; Console . WriteLine ( "" Head ▁ = ▁ "" + p . Item1 ) ; Console . WriteLine ( "" Tail ▁ = ▁ "" + p . Item2 ) ; } }";"Count of total Heads and Tails after N flips in a coin | C # program to count total heads and tails after N flips in a coin ; Function to find count of head and tail ; Check if initially all the coins are facing towards head ; Check if initially all the coins are facing towards tail ; Driver Code"
C#;"using System ; class GFG { static String findPalindrome ( String C ) { String S = C ; S = reverse ( S ) ; C = C + "" & "" + S ; int n = C . Length ; int [ ] longestPalindrome = new int [ n ] ; longestPalindrome [ 0 ] = 0 ; int len = 0 ; int i = 1 ; while ( i < n ) { if ( C [ i ] == C [ len ] ) { len ++ ; longestPalindrome [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = longestPalindrome [ len - 1 ] ; } else { longestPalindrome [ i ] = 0 ; i ++ ; } } } String ans = C . Substring ( 0 , longestPalindrome [ n - 1 ] ) ; return ans ; } static String findAns ( String s ) { String A = "" "" ; String B = "" "" ; String F = "" "" ; int i = 0 ; int j = s . Length - 1 ; int len = s . Length ; while ( i < j && s [ i ] == s [ j ] ) { i = i + 1 ; j = j - 1 ; } if ( i > 0 ) { A = s . Substring ( 0 , i ) ; B = s . Substring ( len - i , i ) ; } if ( len > 2 * i ) { String C = s . Substring ( i , ( s . Length - 2 * i ) ) ; String D = findPalindrome ( C ) ; C = reverse ( C ) ; String E = findPalindrome ( C ) ; if ( D . Length > E . Length ) { F = D ; } else { F = E ; } } String answer = A + F + B ; return answer ; } static String reverse ( String input ) { char [ ] a = input . ToCharArray ( ) ; int l , r = a . Length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { char temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return String . Join ( "" "" , a ) ; } public static void Main ( String [ ] args ) { String str = "" abcdefghiedcba "" ; Console . Write ( findAns ( str ) + "" STRNEWLINE "" ) ; } }";"Longest palindromic string possible after removal of a substring | C # Implementation of the above approach ; Function to find the longest palindrome from the start of the String using KMP match ; Append S ( reverse of C ) to C ; Use KMP algorithm ; Function to return longest palindromic String possible from the given String after removal of any subString ; Initialize three Strings A , B AND F ; Loop to find longest subStrings from both ends which are reverse of each other ; Proceed to third step of our approach ; Remove the subStrings A and B ; Find the longest palindromic subString from beginning of C ; Find the longest palindromic subString from end of C ; Store the maximum of D and E in F ; Find the readonly answer ; Driver Code"
C#;"using System ; class GFG { static int nthTerm ( int N ) { int nth = 0 ; if ( N % 2 == 1 ) nth = ( N * N ) + 1 ; else nth = ( N * N ) - 1 ; return nth ; } public static void Main ( String [ ] args ) { int N = 5 ; Console . Write ( nthTerm ( N ) + "" STRNEWLINE "" ) ; } }";"Find Nth term of the series 2 , 3 , 10 , 15 , 26. ... | C # program to find Nth term of the series 2 , 3 , 10 , 15 , 26. ... ; Function to find Nth term ; Nth term ; Driver code"
C#;"using System ; class GFG { static int nthTerm ( int N ) { int nth = 0 , first_term = 12 ; nth = ( int ) ( ( first_term * ( Math . Pow ( 2 , N - 1 ) ) ) + 11 * ( ( Math . Pow ( 2 , N - 1 ) ) - 1 ) ) ; return nth ; } public static void Main ( String [ ] args ) { int N = 5 ; Console . Write ( nthTerm ( N ) + "" STRNEWLINE "" ) ; } }";"Find the Nth term in series 12 , 35 , 81 , 173 , 357 , ... | C # program to find the Nth term in series 12 , 35 , 81 , 173 , 357 , ... ; Function to find Nth term ; Nth term ; Driver code"
C#;"using System ; class GFG { static int nthTerm ( int N ) { int nth = 0 , first_term = 4 ; int pi = 1 , po = 1 ; int n = N ; while ( n > 1 ) { pi *= n - 1 ; n -- ; po *= 2 ; } nth = ( first_term * pi ) / po ; return nth ; } public static void Main ( String [ ] args ) { int N = 5 ; Console . Write ( nthTerm ( N ) + "" STRNEWLINE "" ) ; } }";"Find Nth term of the series 4 , 2 , 2 , 3 , 6 , ... | C # program to find Nth term of the series 4 , 2 , 2 , 3 , 6 , ... ; Function to find Nth term ; Nth term ; Driver code"
C#;"using System ; class GFG { static int finalNum ( int [ ] arr , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { result = __gcd ( result , arr [ i ] ) ; } return result ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 3 , 9 , 6 , 36 } ; int n = arr . Length ; Console . Write ( finalNum ( arr , n ) ) ; } }";"Find the final number obtained after performing the given operation | C # implementation of the approach ; Function to return the readonly number obtained after performing the given operation ; Find the gcd of the array elements ; Driver code"
C#;"using System ; class GFG { static bool isVowel ( char ch ) { switch ( ch ) { case ' a ' : case ' e ' : case ' i ' : case ' o ' : case ' u ' : return true ; } return false ; } static bool isSatisfied ( char [ ] str , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( ! isVowel ( str [ i ] ) && ! isVowel ( str [ i - 1 ] ) ) { return false ; } } for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( isVowel ( str [ i ] ) && ! isVowel ( str [ i - 1 ] ) && ! isVowel ( str [ i + 1 ] ) ) { return false ; } } return true ; } public static void Main ( String [ ] args ) { String str = "" acaba "" ; int n = str . Length ; if ( isSatisfied ( str . ToCharArray ( ) , n ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Check whether all the substrings have number of vowels atleast as that of consonants | C # implementation of the approach ; Function that returns true if character ch is a vowel ; Compares two integers according to their digit sum ; Check if there are two consecutive consonants ; Check if there is any vowel surrounded by two consonants ; Driver code"
C#;"using System ; class GfG { static int LengthlongestPrefixSuffix ( string s ) { int n = s . Length ; int [ ] lps = new int [ n ] ; lps [ 0 ] = 0 ; int len = 0 ; int i = 1 ; while ( i < n ) { if ( s [ i ] == s [ len ] ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } int res = lps [ n - 1 ] ; return ( res > n / 2 ) ? n / 2 : res ; } static String longestPrefixSuffix ( string s ) { int len = LengthlongestPrefixSuffix ( s ) ; string prefix = "" "" ; for ( int i = 0 ; i < len ; i ++ ) prefix += s [ i ] ; return prefix ; } public static void Main ( ) { string s = "" abcab "" ; string ans = longestPrefixSuffix ( s ) ; if ( ans == "" "" ) Console . WriteLine ( "" - 1"" ) ; else Console . WriteLine ( ans ) ; } }";"Print the longest prefix of the given string which is also the suffix of the same string | C # implementation of the approach ; Returns length of the longest prefix which is also suffix and the two do not overlap . This function mainly is copy of computeLPSArray ( ) in KMP Algorithm ; lps [ 0 ] is always 0 ; Length of the previous longest prefix suffix ; Loop to calculate lps [ i ] for i = 1 to n - 1 ; This is tricky . Consider the example . AAACAAAA and i = 7. The idea is similar to search step . ; Also , note that we do not increment i here ; If len = 0 ; Since we are looking for non overlapping parts ; Function that returns the prefix ; Get the length of the longest prefix ; Stores the prefix ; Traverse and add characters ; Returns the prefix ; Driver code"
C#;"using System ; class GFG { static int no_of_characters ( int M ) { int k = 1 ; while ( true ) { if ( ( int ) Math . Pow ( 2 , k + 1 ) - 2 < M ) k ++ ; else break ; } return k ; } static void print_string ( int M ) { int k , num , N ; k = no_of_characters ( M ) ; N = M - ( ( int ) Math . Pow ( 2 , k ) - 2 ) ; while ( k > 0 ) { num = ( int ) Math . Pow ( 2 , k - 1 ) ; if ( num >= N ) Console . Write ( "" A "" ) ; else { Console . Write ( "" B "" ) ; N -= num ; } k -- ; } Console . WriteLine ( ) ; } public static void Main ( ) { int M ; M = 30 ; print_string ( M ) ; M = 55 ; print_string ( M ) ; M = 100 ; print_string ( M ) ; } }";"Print a number as string of ' A ' and ' B ' in lexicographic order | C # implementation of the approach ; Function to calculate number of characters in corresponding string of ' A ' and ' B ' ; Since the minimum number of characters will be 1 ; Calculating number of characters ; Since k length string can represent at most pow ( 2 , k + 1 ) - 2 that is if k = 4 , it can represent at most pow ( 2 , 4 + 1 ) - 2 = 30 so we have to calculate the length of the corresponding string ; return the length of the corresponding string ; Function to print corresponding string of ' A ' and ' B ' ; Find length of string ; Since the first number that can be represented by k length string will be ( pow ( 2 , k ) - 2 ) + 1 and it will be AAA ... A , k times , therefore , N will store that how much we have to print ; At a particular time , we have to decide whether we have to print ' A ' or ' B ' , this can be check by calculating the value of pow ( 2 , k - 1 ) ; Print new line ; Driver code"
C#;"using System ; class GFG { static string updateString ( string S , string A , string B ) { int l = A . Length ; for ( int i = 0 ; i + l <= S . Length ; i ++ ) { string curr = S . Substring ( i , l ) ; if ( curr . Equals ( A ) ) { string new_string = S . Substring ( 0 , i ) + B + S . Substring ( i + l ) ; S = new_string ; i += l - 1 ; } else { string new_string = S . Substring ( 0 , i ) + A + S . Substring ( i + l ) ; S = new_string ; i += l - 1 ; } } return S ; } public static void Main ( ) { string S = "" aab "" ; string A = "" aa "" ; string B = "" bb "" ; Console . WriteLine ( updateString ( S , A , B ) ) ; } }";"Replace two substrings ( of a string ) with each other | C # implementation of the approach ; Function to return the resultant string ; Iterate through all positions i ; Current sub - string of length = len ( A ) = len ( B ) ; If current sub - string gets equal to A or B ; Update S after replacing A ; Update S after replacing B ; Return the updated string ; Driver code"
C#;"using System ; class GFG { static void printPattern ( int n , int m ) { if ( m > 2 * ( n + 1 ) m < n - 1 ) { Console . Write ( "" - 1"" ) ; } else if ( Math . Abs ( n - m ) <= 1 ) { while ( n > 0 && m > 0 ) { Console . Write ( ""01"" ) ; n -- ; m -- ; } if ( n != 0 ) { Console . Write ( ""0"" ) ; } if ( m != 0 ) { Console . Write ( ""1"" ) ; } } else { while ( m - n > 1 && n > 0 ) { Console . Write ( ""110"" ) ; m = m - 2 ; n = n - 1 ; } while ( n > 0 ) { Console . Write ( ""10"" ) ; n -- ; m -- ; } while ( m > 0 ) { Console . Write ( ""1"" ) ; m -- ; } } } public static void Main ( ) { int n = 4 , m = 8 ; printPattern ( n , m ) ; } }";"Print n 0 s and m 1 s such that no two 0 s and no three 1 s are together | C # implementation of the above approach ; Function to print the required pattern ; When condition fails ; When m = n - 1 ; Driver code"
C#;"using System ; class GFG { static int countDecreasing ( int [ ] A , int n ) { int len = 1 ; for ( int i = 0 ; i < n - 1 ; ++ i ) { if ( A [ i + 1 ] < A [ i ] ) len ++ ; else { cnt += ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; } static void Main ( ) { int [ ] A = { 100 , 3 , 1 , 13 } ; int n = A . Length ; Console . WriteLine ( countDecreasing ( A , n ) ) ; } }";"Find the count of Strictly decreasing Subarrays | C # program to count number of strictly decreasing subarrays in O ( n ) time . ; Function to count the number of strictly decreasing subarrays ; Initialize length of current decreasing subarray ; Traverse through the array ; If arr [ i + 1 ] is less than arr [ i ] , then increment length ; Else Update count and reset length ; If last length is more than 1 ; Driver code"
C#;"using System ; class GFG { static int minimumChar ( String S1 , String S2 ) { int n = S1 . Length ; int m = S2 . Length ; int ans = Int32 . MaxValue ; for ( int i = 0 ; i < m - n + 1 ; i ++ ) { int minRemovedChar = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( S1 [ j ] != S2 [ i + j ] ) { minRemovedChar ++ ; } } ans = Math . Min ( minRemovedChar , ans ) ; } return ans ; } public static void Main ( ) { String S1 = "" abc "" ; String S2 = "" paxzk "" ; Console . WriteLine ( minimumChar ( S1 , S2 ) ) ; } }";"Minimum changes required to make first string substring of second string | C # program to find the minimum number of characters to be replaced in string S2 , such that S1 is a substring of S2 ; Function to find the minimum number of characters to be replaced in string S2 , such that S1 is a substring of S2 ; Get the sizes of both strings ; Traverse the string S2 ; From every index in S2 , check the number of mis - matching characters in substring of length of S1 ; Take minimum of prev and current mis - match ; return answer ; Driver Code"
C#;"using System ; public class GFG { static int countFreq ( String pat , String txt ) { int M = pat . Length ; int N = txt . Length ; int res = 0 ; for ( int i = 0 ; i <= N - M ; i ++ ) { int j ; for ( j = 0 ; j < M ; j ++ ) { if ( txt [ i + j ] != pat [ j ] ) { break ; } } if ( j == M ) { res ++ ; j = 0 ; } } return res ; } static public void Main ( ) { String txt = "" dhimanman "" ; String pat = "" man "" ; Console . Write ( countFreq ( pat , txt ) ) ; } }";"Frequency of a substring in a string | Simple C # program to count occurrences of pat in txt . ; A loop to slide pat [ ] one by one ; For current index i , check for pattern match ; if pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; Driver program to test above function"
C#;"using System ; class GFG { static void search ( string pat , string txt ) { int M = pat . Length ; int N = txt . Length ; int i = 0 ; while ( i <= N - M ) { int j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; { Console . WriteLine ( "" Pattern ▁ found ▁ at ▁ index ▁ "" + i ) ; i = i + M ; } else if ( j = = 0 ) i = i + 1 ; else i = i + j ; } } static void Main ( ) { string txt = "" ABCEABCDABCEABCD "" ; string pat = "" ABCD "" ; search ( pat , txt ) ; } }";"Optimized Naive Algorithm for Pattern Searching | C # program for A modified Naive Pattern Searching algorithm that is optimized for the cases when all characters of pattern are different ; A modified Naive Pattern Searching algorithm that is optimized for the cases when all characters of pattern are different ; For current index i , check for pattern match ; if ( j == M ) if pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; slide the pattern by j ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { static int findMissingDigit ( string a , string b , string c ) { int w = 1 ; int a_mod_11 = 0 ; for ( int i = a . Length - 1 ; i >= 0 ; i -- ) { a_mod_11 = ( a_mod_11 + w * ( ( int ) a [ i ] - 48 ) ) % 11 ; w = w * - 1 ; } int b_mod_11 = 0 ; w = 1 ; for ( int i = b . Length - 1 ; i >= 0 ; i -- ) { b_mod_11 = ( b_mod_11 + w * ( ( int ) b [ i ] - 48 ) ) % 11 ; w = w * - 1 ; } int c_mod_11 = 0 ; bool xSignIsPositive = true ; w = 1 ; for ( int i = c . Length - 1 ; i >= 0 ; i -- ) { if ( c [ i ] == ' x ' ) { xSignIsPositive = ( w == 1 ) ; } else { c_mod_11 = ( c_mod_11 + w * ( ( int ) c [ i ] - '0' ) ) % 11 ; } w = w * - 1 ; } int x = ( ( a_mod_11 * b_mod_11 ) - c_mod_11 ) % 11 ; if ( xSignIsPositive == false ) { x = - x ; } return ( x % 11 + 11 ) % 11 ; } public static void Main ( ) { string A = ""123456789"" ; string B = ""987654321"" ; string C = ""12193263111x635269"" ; Console . Write ( findMissingDigit ( A , B , C ) ) ; } }";"Find the missing digit in given product of large positive integers | C # program for the above approach ; Function to find the replaced digit in the product of a * b ; Keeps track of the sign of the current digit ; Stores the value of a % 11 ; Find the value of a mod 11 for large value of a as per the derived formula ; Stores the value of b % 11 ; Find the value of b mod 11 for large value of a as per the derived formula ; Stores the value of c % 11 ; Keeps track of the sign of x ; If the current digit is the missing digit , then keep the track of its sign ; Find the value of x using the derived equation ; Check if x has a negative sign ; Return positive equivaluent of x mod 11 ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { static void findIfPossible ( int N , string str ) { int countG = 0 , countF = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' G ' ) countG ++ ; else countF ++ ; } if ( 2 * countF != countG ) { Console . WriteLine ( "" NO "" ) ; } else { int id = 0 ; bool flag = true ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' G ' ) { countG -- ; id ++ ; } else { countF -- ; id -- ; } if ( id < 0 ) { flag = false ; break ; } if ( countG < countF ) { flag = false ; break ; } } if ( flag ) { Console . WriteLine ( "" YES "" ) ; } else { Console . WriteLine ( "" NO "" ) ; } } } public static void Main ( ) { int n = 6 ; string str = "" GFGFGG "" ; findIfPossible ( n , str ) ; } }";"Check if a string can be made empty by repeatedly removing given subsequence | C # program for the above approach ; Function to check if a string can be made empty by removing all subsequences of the form "" GFG "" or not ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { static void isPossible ( string str1 , string str2 ) { int [ ] arr = new int [ 256 ] ; Array . Clear ( arr , 0 , 256 ) ; int l1 = str1 . Length ; int l2 = str2 . Length ; int i ; bool possible = true ; for ( i = 0 ; i < l1 ; i ++ ) { arr [ str1 [ i ] ] = 1 ; } for ( i = 0 ; i < l2 ; i ++ ) { if ( str2 [ i ] != ' ▁ ' ) { if ( arr [ str2 [ i ] ] == 1 ) continue ; else { possible = false ; break ; } } } if ( possible ) { Console . Write ( "" Yes "" ) ; } else { Console . Write ( "" No "" ) ; } } public static void Main ( ) { string str1 = "" we ▁ all ▁ love ▁ geeksforgeeks "" ; string str2 = "" we ▁ all ▁ love ▁ geeks "" ; isPossible ( str1 , str2 ) ; } }";"Check whether second string can be formed from characters of first string used any number of times | C # implementation of the above approach ; Function to check if str2 can be made by characters of str1 or not ; To store the occurrence of every character ; Length of the two strings ; Assume that it is possible to compose the string str2 from str1 ; Iterate over str1 ; Store the presence of every character ; Iterate over str2 ; Ignore the spaces ; Check for the presence of character in str1 ; If it is possible to make str2 from str1 ; Driver Code ; Given strings ; Function Call"
C#;"using System ; using System . Collections . Generic ; class GFG { static int findSubsequence ( string S , char ch ) { int N = S . Length ; int ans = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == ch ) { ans ++ ; ch ++ ; } } return ans ; } static int findMaxSubsequence ( string S ) { int ans = 0 ; for ( char ch = ' a ' ; ch <= ' z ' ; ch ++ ) { ans = Math . Max ( ans , findSubsequence ( S , ch ) ) ; } return ans ; } public static void Main ( ) { string S = "" abcabefghijk "" ; Console . Write ( findMaxSubsequence ( S ) ) ; } }";"Longest subsequence with consecutive English alphabets | C # program for the above approach ; Function to find the length of subsequence starting with character ch ; Length of the string ; Stores the maximum length ; Traverse the given string ; If s [ i ] is required character ch ; Increment ans by 1 ; Increment character ch ; Return the current maximum length with character ch ; Function to find the maximum length of subsequence of consecutive characters ; Stores the maximum length of consecutive characters ; Update ans ; Return the maximum length of subsequence ; Driver Code ; Input ; Function Call"
C#;"using System ; using System . Collections . Generic ; class GFG { static void minOpsToEmptyString ( string s ) { int ans = 0 ; int cn0 = 0 ; int cn1 = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '0' ) { if ( cn1 > 0 ) cn1 -- ; cn0 ++ ; } else { if ( cn0 > 0 ) cn0 -- ; cn1 ++ ; } ans = Math . Max ( ans , Math . Max ( cn0 , cn1 ) ) ; } Console . Write ( ans ) ; } public static void Main ( ) { string S = ""010101"" ; minOpsToEmptyString ( S ) ; } }";"Minimum number of alternate subsequences required to be removed to empty a Binary String | C # program for the above approach ; Function to find the minimum number of operations to empty a binary string ; Stores the resultant number of operations ; Stores the number of 0 s ; Stores the number of 1 s ; Traverse the given string ; To balance 0 with 1 if possible ; Increment the value of cn0 by 1 ; To balance 1 with 0 if possible ; Increment the value of cn1 ; Update the maximum number of unused 0 s and 1 s ; Print the resultant count ; Driver Code"
C#;"using System ; public class GFG_JAVA { static int shortestString ( string S , int N ) { int st = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( st > 0 && S [ i ] == '1' ) { st -- ; } else { st ++ ; } } return st ; } public static void Main ( string [ ] args ) { string S = ""1010"" ; int N = S . Length ; Console . WriteLine ( shortestString ( S , N ) ) ; } }";"Smallest string obtained by removing all occurrences of 01 and 11 from Binary String | Set 2 | C # program for the above approach ; Function to find the length of the smallest string possible by removing substrings ""01"" and ""11"" ; Stores the length of the smallest string ; Traverse the string S ; If st is greater than 0 and S [ i ] is '1' ; Delete the last character and decrement st by 1 ; Otherwise ; Increment st by 1 ; Return the answer in st ; Driver code ; Input ; Function call"
C#;"using System ; class GFG { static int findLength ( String str , int n ) { int [ ] pre = new int [ n ] ; int [ ] post = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { pre [ i ] = 0 ; post [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { if ( i != 0 ) { pre [ i ] += pre [ i - 1 ] ; } if ( str [ i ] == '1' ) { pre [ i ] += 1 ; } } for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( i != n - 1 ) post [ i ] += post [ i + 1 ] ; if ( str [ i ] == '0' ) post [ i ] += 1 ; } int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { ans = Math . Max ( ans , pre [ i ] + post [ i ] ) ; } return ans ; } public static void Main ( String [ ] args ) { String S = ""0101110110100001011"" ; Console . WriteLine ( findLength ( S , S . Length ) ) ; } }";"Longest Non | C # program for the above approach ; Function to find the length of the longest non - increasing subsequence ; Stores the prefix and suffix count of 1 s and 0 s respectively ; Initialize the array ; Store the number of '1' s up to current index i in pre ; Find the prefix sum ; If the current element is '1' , update the pre [ i ] ; Store the number of '0' s over the range [ i , N - 1 ] ; Find the suffix sum ; If the current element is '0' , update post [ i ] ; Stores the maximum length ; Find the maximum value of pre [ i ] + post [ i ] ; Return the answer ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { static int countSubstring ( String S , int N ) { Dictionary < int , int > prevSum = new Dictionary < int , int > ( ) ; int res = 0 ; int currentSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] >= ' A ' && S [ i ] <= ' Z ' ) { currentSum ++ ; } else currentSum -- ; if ( currentSum == 0 ) res ++ ; if ( prevSum . ContainsKey ( currentSum ) ) { res += prevSum [ currentSum ] ; prevSum [ currentSum ] = prevSum [ currentSum ] + 1 ; } else prevSum . Add ( currentSum , 1 ) ; } return res ; } public static void Main ( String [ ] args ) { String S = "" gEEk "" ; Console . WriteLine ( countSubstring ( S , S . Length ) ) ; } }";"Number of substrings having an equal number of lowercase and uppercase letters | C # program for the above approach ; Function to find the count of substrings having an equal number of uppercase and lowercase characters ; Stores the count of prefixes having sum S considering uppercase and lowercase characters as 1 and - 1 ; Stores the count of substrings having equal number of lowercase and uppercase characters ; Stores the sum obtained so far ; If the character is uppercase ; Otherwise ; If currsum is 0 ; If the current sum exists in the Dictionary prevSum ; Increment the resultant count by 1 ; Update the frequency of the current sum by 1 ; Return the resultant count of the subarrays ; Driver Code"
C#;"using System ; using System . Collections . Generic ; public class GFG { static int subString ( string s , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int len = i + 1 ; len <= n ; len ++ ) { string test_str = s . Substring ( i , len - i ) ; Dictionary < char , int > res = new Dictionary < char , int > ( ) ; foreach ( char keys in test_str . ToCharArray ( ) ) { if ( ! res . ContainsKey ( keys ) ) res . Add ( keys , 0 ) ; res [ keys ] ++ ; } int flag = 0 ; foreach ( KeyValuePair < char , int > keys in res ) { if ( keys . Value % 2 != 0 ) { flag = 1 ; break ; } } if ( flag == 0 ) count += 1 ; } } return count ; } static public void Main ( ) { string S = "" abbaa "" ; int N = S . Length ; Console . WriteLine ( subString ( S , N ) ) ; } }";"Number of substrings with each character occurring even times | C # program for the above approach ; Function to count substrings having even frequency of each character ; Stores the total count of substrings ; Traverse the range [ 0 , N ] : ; Traverse the range [ i + 1 , N ] ; Stores the substring over the range of indices [ i , len ] ; Stores the frequency of characters ; Count frequency of each character ; Traverse the dictionary ; If any of the keys have odd count ; Otherwise ; Return count ; Driver Code"
C#;"using System ; class GFG { static void countStringPairs ( string [ ] a , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { char [ ] p = a [ i ] . ToCharArray ( ) ; char [ ] q = a [ j ] . ToCharArray ( ) ; if ( p [ 0 ] != q [ 0 ] ) { char temp = p [ 0 ] ; p [ 0 ] = q [ 0 ] ; q [ 0 ] = temp ; int flag1 = 0 ; int flag2 = 0 ; for ( int k = 0 ; k < n ; k ++ ) { if ( a [ k ] . Equals ( new string ( p ) ) ) { flag1 = 1 ; } if ( a [ k ] . Equals ( new string ( q ) ) ) { flag2 = 1 ; } } if ( flag1 == 0 && flag2 == 0 ) { ans = ans + 1 ; } } } } Console . WriteLine ( ans ) ; } public static void Main ( string [ ] args ) { string [ ] arr = { "" good "" , "" bad "" , "" food "" } ; int N = arr . Length ; countStringPairs ( arr , N ) ; } }";"Count new pairs of strings that can be obtained by swapping first characters of pairs of strings from given array | C # program for the above approach ; Function to count new pairs of strings that can be obtained by swapping first characters of any pair of strings ; Stores the count of pairs ; Generate all possible pairs of strings from the array arr [ ] ; Stores the current pair of strings ; Swap the first characters ; Check if they are already present in the array or not ; If both the strings are not present ; Increment the ans by 1 ; Print the resultant count ; Driver Code"
C#;"using System ; class GFG { static void addFrequencyToCharacter ( char [ ] s ) { int [ ] frequency = new int [ 26 ] ; int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) { frequency [ s [ i ] - ' a ' ] += 1 ; } for ( int i = 0 ; i < n ; i ++ ) { int add = frequency [ s [ i ] - ' a ' ] % 26 ; if ( ( int ) ( s [ i ] ) + add <= ( int ) ( ' z ' ) ) s [ i ] = ( char ) ( ( int ) ( s [ i ] ) + add ) ; else { add = ( ( int ) ( s [ i ] ) + add ) - ( ( int ) ( ' z ' ) ) ; s [ i ] = ( char ) ( ( int ) ( ' a ' ) + add - 1 ) ; } } Console . WriteLine ( s ) ; } public static void Main ( string [ ] args ) { string str = "" geeks "" ; addFrequencyToCharacter ( str . ToCharArray ( ) ) ; } }";"Modify string by replacing characters by alphabets whose distance from that character is equal to its frequency | C # program for the above approach ; Function to modify string by replacing characters by the alphabet present at distance equal to frequency of the string ; Stores frequency of characters ; Stores length of the string ; Traverse the given string S ; Increment frequency of current character by 1 ; Traverse the string ; Store the value to be added to the current character ; Check if after adding the frequency , the character is less than ' z ' or not ; Otherwise , update the value of add so that s [ i ] doesn ' t ▁ exceed ▁ ' z ' ; Print the modified string ; Driver Code"
C#;"using System ; using System . Collections . Generic ; public class GFG { static string isPossible ( string S , int R , int N ) { int cntl = 0 , cntr = 0 ; int cntu = 0 , cntd = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == ' L ' ) cntl ++ ; else if ( S [ i ] == ' R ' ) cntr ++ ; else if ( S [ i ] == ' U ' ) cntu ++ ; else cntd ++ ; } if ( Math . Max ( Math . Max ( cntl , cntr ) , Math . Max ( cntu , cntd ) ) >= R ) return "" Yes "" ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; int r_square = R * R ; for ( int i = 1 ; i * i <= r_square ; i ++ ) { mp . Add ( i * i , i ) ; if ( mp . ContainsKey ( r_square - i * i ) ) { if ( Math . Max ( cntl , cntr ) >= mp [ r_square - i * i ] && Math . Max ( cntu , cntd ) >= i ) return "" Yes "" ; if ( Math . Max ( cntl , cntr ) >= i && Math . Max ( cntu , cntd ) >= mp [ r_square - i * i ] ) return "" Yes "" ; } } return "" No "" ; } static public void Main ( ) { string S = "" RDLLDDLDU "" ; int R = 5 ; int N = S . Length ; Console . WriteLine ( isPossible ( S , R , N ) ) ; } }";"Check if it is possible to reach any point on the circumference of a given circle from origin | C # program for the above approach ; Function to check if it is possible to reach any point on circumference of the given circle from ( 0 , 0 ) ; Stores the count of ' L ' , ' R ' ; Stores the count of ' U ' , ' D ' ; Traverse the string S ; Update the count of L ; Update the count of R ; Update the count of U ; Update the count of D ; Condition 1 for reaching the circumference ; Store the the value of ( i * i ) in the Map ; Check if ( r_square - i * i ) already present in HashMap ; If it is possible to reach the point ( mp [ r_square - i * i ] , i ) ; If it is possible to reach the point ( i , mp [ r_square - i * i ] ) ; If it is impossible to reach ; Driver Code"
C#;"using System ; public class GFG { static void addASCII ( char [ ] S , char [ ] N ) { for ( int i = 0 ; i < S . Length ; i ++ ) { int a = ( int ) ( N [ i ] ) - '0' ; int b = ( int ) ( S [ i ] ) + a ; if ( b > 122 ) b -= 26 ; S [ i ] = ( char ) ( b ) ; } Console . Write ( S ) ; } public static void Main ( String [ ] args ) { String S = "" sun "" , N = ""966"" ; addASCII ( S . ToCharArray ( ) , N . ToCharArray ( ) ) ; } }";"Modify characters of a string by adding integer values of same | C # program for the above approach ; Function to modify a given String by adding ASCII value of characters from a String S to integer values of same indexed characters in String N ; Traverse the String ; Stores integer value of character in String N ; Stores ASCII value of character in String S ; If b exceeds 122 ; Replace the character ; Print resultant String ; Driver Code ; Given Strings ; Function call to modify String S by given operations"
C#;"using System ; using System . Collections . Generic ; class GFG { static int findMinimumChairs ( string s ) { int count = 0 ; int i = 0 ; int mini = Int32 . MinValue ; while ( i < s . Length ) { if ( s [ i ] == ' E ' ) count ++ ; else count -- ; mini = Math . Max ( count , mini ) ; i ++ ; } return mini ; } public static void Main ( ) { string s = "" EELEE "" ; Console . WriteLine ( findMinimumChairs ( s ) ) ; } }";"Minimum number of chairs required to ensure that every worker is seated at any instant | C # program to implement the above approach ; Function to find the minimum number of chairs required to ensure that every worker is seated at any time ; Stores the number of chairs required ; Pointer to iterate ; Stores minimum number of chairs required ; Iterate over every character ; If character is ' E ' ; Increase the count ; Otherwise ; Update maximum value of count obtained at any given time ; Return mini ; Driver code ; Given String ; Function call to find the minimum number of chairs"
C#;"using System ; using System . Collections . Generic ; class GFG { static void fillString ( string str , int k ) { char [ ] s = str . ToCharArray ( ) ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] != ' ? ' ) { mp [ i % k ] = s [ i ] ; } } for ( int i = 0 ; i < s . Length ; i ++ ) { if ( ! mp . ContainsKey ( i % k ) ) { Console . WriteLine ( - 1 ) ; return ; } s [ i ] = ( char ) mp [ i % k ] ; } Console . WriteLine ( new string ( s ) ) ; } static void Main ( ) { string S = "" ? ? ? ? abcd "" ; int K = 4 ; fillString ( S , K ) ; } }";"Modify string by inserting characters such that every K | C # program for the above approach ; Function to replace all ' ? ' characters in a string such that the given conditions are satisfied ; Traverse the string to Map the characters with respective positions ; Traverse the string again and replace all unknown characters ; If i % k is not found in the Map M , then return - 1 ; Update S [ i ] ; Print the string S ; Driver code"
C#;"using System ; class GFG { static void rearrangeString ( char [ ] s1 , char [ ] s2 ) { int [ ] cnt = new int [ 26 ] ; for ( int i = 0 ; i < s2 . Length ; i ++ ) cnt [ s2 [ i ] - ' a ' ] ++ ; int unique = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) if ( cnt [ i ] != 0 ) unique ++ ; if ( unique == 1 ) { int count_in_s2 = s2 . Length ; int count_in_s1 = 0 ; for ( int i = 0 ; i < s1 . Length ; i ++ ) if ( s1 [ i ] == s2 [ 0 ] ) count_in_s1 ++ ; if ( count_in_s1 < count_in_s2 ) { Console . Write ( new string ( s1 ) ) ; return ; } Console . Write ( - 1 ) ; } else { int inc = 1 ; for ( int i = 0 ; i < s2 . Length - 1 ; i ++ ) if ( s2 [ i ] > s2 [ i + 1 ] ) inc = 0 ; if ( inc == 1 ) { Array . Sort ( s1 ) ; Array . Reverse ( s1 ) ; Console . Write ( new string ( s1 ) ) ; } else { Array . Sort ( s1 ) ; Console . Write ( new string ( s1 ) ) ; } } } static void Main ( ) { char [ ] s1 = "" abcd "" . ToCharArray ( ) ; char [ ] s2 = "" ab "" . ToCharArray ( ) ; rearrangeString ( s1 , s2 ) ; } }";"Rearrange a string S1 such that another given string S2 is not its subsequence | C # program for the above approach ; Function to rearrange characters in string S1 such that S2 is not a subsequence of it ; Store the frequencies of characters of string s2 ; Traverse the string s2 ; Update the frequency ; Find the number of unique characters in s2 ; Increment unique by 1 if the condition satisfies ; Check if the number of unique characters in string s2 is 1 ; Store the unique character frequency ; Store occurence of it in s1 ; Find count of that character in the string s1 ; Increment count by 1 if that unique character is same as current character ; If count count_in_s1 is less than count_in_s2 , then print s1 and return ; Otherwise , there is no possible arrangement ; Checks if any character in s2 is less than its next character ; Iterate the string , s2 ; If s [ i ] is greater than the s [ i + 1 ] ; Set inc to 0 ; If inc = 1 , print s1 in decreasing order ; Otherwise , print s1 in increasing order ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { static bool isReducible ( string str ) { int N = str . Length ; List < char > s = new List < char > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( str [ i ] == '1' ) s . Add ( str [ i ] ) ; else if ( s . Count > 0 ) s . RemoveAt ( s . Count - 1 ) ; else return false ; } if ( s . Count == 0 ) { return true ; } else { return false ; } } static void Main ( ) { string str = ""11011000"" ; if ( isReducible ( str ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Check if a string can be emptied by removing all subsequences of the form ""10"" | C # program for the above approach ; Function to find if string is reducible to NULL ; Length of string ; Stack to store all 1 s ; Iterate over the characters of the string ; If current character is 1 ; Push it into the stack ; Pop from the stack ; If the stack is empty ; Driver code"
C#;"using System ; class GFG { static int cntMinOperation ( char [ ] S , int N ) { int cntOp = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { if ( S [ i ] == '0' && S [ i + 1 ] == '0' ) { S [ i + 1 ] = '1' ; cntOp += 1 ; } } return cntOp ; } public static void Main ( string [ ] args ) { string S = ""10001"" ; int N = S . Length ; Console . WriteLine ( cntMinOperation ( S . ToCharArray ( ) , N ) ) ; } }";"Minimize flips required such that string does not any pair of consecutive 0 s | C # program for the above approach ; Function to find minimum flips required such that a String does not contain any pair of consecutive 0 s ; Stores minimum count of flips ; Iterate over the characters of the String ; If two consecutive characters are equal to '0' ; Update S [ i + 1 ] ; Update cntOp ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { static String solution ( string s ) { List < char > vowel = new List < char > ( ) ; List < char > consonant = new List < char > ( ) ; foreach ( char i in s . ToCharArray ( ) ) { if ( i == ' a ' i == ' e ' i == ' i ' i == ' o ' i == ' u ' ) { vowel . Add ( i ) ; } else { consonant . Add ( i ) ; } } int Nc , Nv ; Nv = vowel . Count ; Nc = consonant . Count ; int M = Nc / ( Nv - 1 ) ; string ans = "" "" ; int consotnant_till = 0 ; foreach ( char i in vowel ) { ans += i ; int temp = 0 ; for ( int j = consotnant_till ; j < Math . Min ( Nc , consotnant_till + M ) ; j ++ ) { ans += consonant [ j ] ; temp ++ ; } consotnant_till += temp ; } return ans ; } static public void Main ( ) { String str = "" aaaabbbcc "" ; Console . WriteLine ( solution ( str ) ) ; } }";"Rearrange a string to maximize the minimum distance between any pair of vowels | C # program for the above approach ; Function to rearrange the String such that the minimum distance between any of vowels is maximum . ; Store vowels and consonants ; Iterate over the characters of String ; If current character is a vowel ; If current character is a consonant ; Stores count of vowels and consonants respectively ; Stores the resultant String ; Stores count of consonants appended into ans ; Append vowel to ans ; Append consonants ; Append consonant to ans ; Update temp ; Remove the taken elements of consonant ; Return final ans ; Driver Code ; Function Call"
C#;"using System ; using System . Collections . Generic ; class GFG { static void smallestlexicographicstring ( char [ ] s , int k ) { int n = s . Length ; if ( k >= n ) { for ( int i = 0 ; i < n ; i ++ ) { s [ i ] = ' a ' ; } Console . Write ( s ) ; return ; } for ( int i = 0 ; i < n ; i ++ ) { if ( k == 0 ) { break ; } if ( s [ i ] == ' a ' ) continue ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( s [ j ] > s [ i ] ) { s [ j ] = s [ i ] ; break ; } else if ( j == n - 1 ) s [ j ] = s [ i ] ; } s [ i ] = ' a ' ; k -- ; } Console . Write ( s ) ; } static void Main ( ) { char [ ] s = ( "" geeksforgeeks "" ) . ToCharArray ( ) ; int k = 6 ; smallestlexicographicstring ( s , k ) ; } }";"Lexicographically smallest string possible by performing K operations on a given string | C # program to implement the above approach ; Function to find the lexicographically smallest possible string by performing K operations on string S ; Store the size of string , s ; Check if k >= n , if true , convert every character to ' a ' ; Iterate in range [ 0 , n - 1 ] using i ; When k reaches 0 , break the loop ; If current character is ' a ' , continue ; Otherwise , iterate in the range [ i + 1 , n - 1 ] using j ; Check if s [ j ] > s [ i ] ; If true , set s [ j ] = s [ i ] and break out of the loop ; Check if j reaches the last index ; Update S [ i ] ; Decrement k by 1 ; Print string ; Driver code ; Given String , s ; Given k ; Function Call"
C#;"using System ; class GFG { static void canReduceString ( String S , int N ) { int count_1 = 0 ; int count_2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( S [ i ] == ' ( ' ) { count_1 ++ ; } else { count_2 ++ ; } } if ( count_1 == 0 count_2 == 0 ) { Console . Write ( "" - 1"" + "" STRNEWLINE "" ) ; } else if ( count_1 == count_2 ) { Console . Write ( ""0"" + "" STRNEWLINE "" ) ; } else if ( N % 2 != 0 ) { Console . Write ( "" - 1"" ) ; } else { Console . Write ( Math . Abs ( count_1 - count_2 ) / 2 ) ; } } public static void Main ( String [ ] args ) { String S = "" ) ) ) ( ( ( "" ; int N = S . Length ; canReduceString ( S , N ) ; } }";"Minimize removal of non | C # program for the above approach ; Function to find minimum count of steps required ot make String S an empty String ; Stores count of occurences ' ( ' ; Stores count of occurences ' ) ' ; Traverse the String , str ; If current character is ' ( ' ; Update count_1 ; Update count_2 ; If all the characters are same , then print - 1 ; If the count of occurence of ' ) ' and ' ( ' are same then print 0 ; If length of String is Odd ; Driver Code ; Given String ; Size of the String ; Function Call"
C#;"using System ; class GFG { static void isAcceptedDFA ( String s , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( s [ i ] == ' a ' ) count ++ ; } if ( count == N && count != 0 ) { Console . Write ( "" Accepted "" ) ; } else { Console . Write ( "" Not ▁ Accepted "" ) ; } } public static void Main ( String [ ] args ) { String S = "" aaaaa "" ; isAcceptedDFA ( S , S . Length ) ; } }";"Program to construct a DFA which accepts the language L = { aN | N â ‰¥ 1 } | C # program for the above approach ; Function to check whether the String S satisfy the given DFA or not ; Stores the count of characters ; Iterate over the range [ 0 , N ] ; Count and check every element for ' a ' ; If String matches with DFA ; If not matches ; Driver Code ; Function Call"
C#;"using System ; public class GFG { static void maximum_pallindromic ( int [ ] arr ) { int res = 0 ; int c1 = 0 , c2 = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { res += arr [ i ] / 3 ; arr [ i ] = arr [ i ] % 3 ; if ( arr [ i ] == 1 ) c1 ++ ; else if ( arr [ i ] == 2 ) c2 ++ ; } res += Math . Min ( c1 , c2 ) ; int t = Math . Min ( c1 , c2 ) ; c1 -= t ; c2 -= t ; res += 2 * ( c2 / 3 ) ; c2 %= 3 ; res += c2 / 2 ; Console . Write ( res ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 4 , 5 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; maximum_pallindromic ( arr ) ; } }";"Maximize palindromic strings of length 3 possible from given count of alphabets | C # program for the above approach ; Function to count maximum number of palindromic String of length 3 ; Stores the readonly count of palindromic Strings ; Traverse the array ; Increment res by arr [ i ] / 3 , i . e forming String of only i + ' a ' character ; Store remainder ; Increment c1 by one , if current frequency is 1 ; Increment c2 by one , if current frequency is 2 ; Count palindromic Strings of length 3 having the character at the ends different from that present in the middle ; Update c1 and c2 ; Increment res by 2 * c2 / 3 ; Finally print the result ; Driver Code ; Given array ; Function Call"
C#;"using System ; using System . Collections . Generic ; class GFG { static void find_Winner ( String [ ] arr , int N ) { List < char > [ ] Q = new List < char > [ N ] ; for ( int i = 0 ; i < Q . Length ; i ++ ) Q [ i ] = new List < char > ( ) ; int M = arr . Length ; for ( int i = 0 ; i < M ; i ++ ) { int len = arr [ i ] . Length ; for ( int j = 0 ; j < len ; j ++ ) { Q [ i ] . Add ( arr [ i ] [ j ] ) ; } } int player = 0 ; while ( Q [ player ] . Count > 0 ) { int nextPlayer = Q [ player ] [ 0 ] - '0' - 1 ; Q [ player ] . RemoveAt ( 0 ) ; player = nextPlayer ; } Console . Write ( "" Player ▁ "" + ( player + 1 ) ) ; } public static void Main ( String [ ] args ) { int N = 3 ; String [ ] arr = { ""323"" , ""2"" , ""2"" } ; find_Winner ( arr , N ) ; } }";"Find the winner of game of repeatedly removing the first character to empty given string | C # program to implement the above approach ; Function to find the winner of a game of repeatedly removing the first character to empty a String ; Store characters of each String of the array [ ] arr ; Stores count of Strings in [ ] arr ; Traverse the array [ ] arr ; Stores length of current String ; Traverse the String ; Insert arr [ i , j ] ; 1 st Player starts the game ; Stores the player number for the next turn ; Remove 1 st character of current String ; Update player number for the next turn ; Driver Code"
C#;"using System ; class GFG { public static int longestSubstring ( string s ) { int [ ] dp = new int [ 1024 ] ; for ( int i = 0 ; i < 1024 ; ++ i ) { dp [ i ] = s . Length ; } int res = 0 , mask = 0 ; dp [ 0 ] = - 1 ; for ( int i = 0 ; i < s . Length ; i ++ ) { mask = mask ^ ( 1 << ( s [ i ] - '0' ) ) ; res = Math . Max ( res , i - dp [ mask ] ) ; for ( int j = 0 ; j < 10 ; j ++ ) { res = Math . Max ( res , i - dp [ mask ^ ( 1 << j ) ] ) ; } dp [ mask ] = Math . Min ( dp [ mask ] , i ) ; } return res ; } public static void Main ( string [ ] args ) { string s = ""3242415"" ; Console . WriteLine ( longestSubstring ( s ) ) ; } }";"Longest Substring that can be made a palindrome by swapping of characters | C # program for the above approach ; Function to find the Longest substring that can be made a palindrome by swapping of characters ; Initialize dp array of size 1024 ; Initializeing dp array with length of s ; Initializing mask and res ; Traverse the string ; Find the mask of the current character ; Finding the length of the longest substring in s which is a palindrome for even count ; Finding the length of the longest substring in s which is a palindrome for one odd count ; Finding maximum length of substring having one odd count ; dp [ mask ] is minimum of current i and dp [ mask ] ; Return longest length of the substring which forms a palindrome with swaps ; Driver Code ; Input String ; Function Call"
C#;"using System ; class GFG { static void Validate ( string M ) { int len = M . Length ; string temp = "" "" ; for ( int i = 0 ; i < len ; i ++ ) { if ( Char . IsDigit ( M [ i ] ) ) temp += M [ i ] ; } int nwlen = temp . Length ; if ( nwlen != 10 ) { Console . Write ( "" Invalid STRNEWLINE "" ) ; return ; } string res = "" "" ; string x = temp . Substring ( 0 , 3 ) ; res += "" ( "" + x + "" ) - "" ; x = temp . Substring ( 3 , 3 ) ; res += "" ( "" + x + "" ) - "" ; x = temp . Substring ( 6 , 3 ) ; res += "" ( "" + x + "" ) - "" ; x = temp . Substring ( 9 , 1 ) ; res += "" ( "" + x + "" ) "" ; Console . WriteLine ( res ) ; } public static void Main ( string [ ] args ) { string M = ""91 ▁ 234rt5%34*0 ▁ 3"" ; Validate ( M ) ; } }";"Convert given string to a valid mobile number | C # program for the above approach ; Function to print the valid and formatted phone number ; Length of given String ; Store digits in temp ; Iterate given M ; If any digit , append it to temp ; Find new length of String ; If length is not equal to 10 ; Store final result ; Make groups of 3 digits and enclose them within ( ) and separate them with "" - "" 0 to 2 index 1 st group ; 3 to 5 index 2 nd group ; 6 to 8 index 3 rd group ; 9 to 9 index last group ; Print final result ; Driver Code ; Given String ; Function Call"
C#;"using System ; using System . Collections . Generic ; class GFG { static void hexaModK ( String N , String k ) { Dictionary < char , int > map = new Dictionary < char , int > ( ) ; for ( char i = '0' ; i <= '9' ; i ++ ) { map . Add ( i , i - '0' ) ; } map . Add ( ' A ' , 10 ) ; map . Add ( ' B ' , 11 ) ; map . Add ( ' C ' , 12 ) ; map . Add ( ' D ' , 13 ) ; map . Add ( ' E ' , 14 ) ; map . Add ( ' F ' , 15 ) ; long m = long . Parse ( k ) ; long Base = 1 ; long ans = 0 ; for ( int i = N . Length - 1 ; i >= 0 ; i -- ) { long n = map [ N [ i ] ] % m ; ans = ( ans + ( Base % m * n % m ) % m ) % m ; Base = ( Base % m * 16 % m ) % m ; } Console . WriteLine ( ans . ToString ( "" X "" ) ) ; } public static void Main ( String [ ] args ) { String n = ""3E8"" ; String k = ""13"" ; hexaModK ( n , k ) ; } }";"Modulus of two Hexadecimal Numbers | C # program to implement the above approach ; Function to calculate modulus of two Hexadecimal numbers ; Store all possible hexadecimal digits ; Iterate over the range [ '0' , '9' ] ; Convert given string to long ; Base to get 16 power ; Store N % K ; Iterate over the digits of N ; Stores i - th digit of N ; Update ans ; Update base ; Print the answer converting into hexadecimal ; Driver Code ; Given string N and K ; Function Call"
C#;"using System ; using System . Collections . Generic ; class GFG { static String combination = "" "" ; static SortedSet < String > combinations = new SortedSet < String > ( ) ; static void printSequences ( SortedSet < String > combinations ) { foreach ( String s in combinations ) { Console . Write ( s + "" ▁ "" ) ; } } static void generateCombinations ( String s , int n ) { for ( int i = 0 ; i < s . Length ; i ++ ) { combination += ( s [ i ] ) ; long x = Int32 . Parse ( combination ) ; if ( x <= n ) { combinations . Add ( combination ) ; generateCombinations ( s , n ) ; } combination = combination . Substring ( 0 , combination . Length - 1 ) ; } } public static void Main ( String [ ] args ) { String S = ""124"" ; int N = 100 ; generateCombinations ( S , N ) ; printSequences ( combinations ) ; } }";"Print all combinations generated by characters of a numeric string which does not exceed N | C # program for the above approach ; Store the current sequence of s ; Store the all the required sequences ; Function to print all sequences of S satisfying the required condition ; Print all Strings in the set ; Function to generate all sequences of String S that are at most N ; Iterate over String s ; Push ith character to combination ; Convert the String to number ; Check if the condition is true ; Push the current String to the readonly set of sequences ; Recursively call function ; Backtrack to its previous state ; Driver Code ; Function Call ; Print required sequences"
C#;"using System ; class GFG { static int compute_hash ( string str ) { int p = 31 ; int MOD = ( int ) 1e9 + 7 ; int hash_val = 0 ; int mul = 1 ; for ( int i = 0 ; i < str . Length ; i ++ ) { char ch = str [ i ] ; hash_val = ( hash_val + ( ch - ' a ' + 1 ) * mul ) % MOD ; mul = ( mul * p ) % MOD ; } return hash_val ; } static int distinct_str ( string [ ] arr , int n ) { int [ ] hash = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { hash [ i ] = compute_hash ( arr [ i ] ) ; } Array . Sort ( hash ) ; int cntElem = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( hash [ i ] != hash [ i - 1 ] ) { cntElem ++ ; } } return cntElem ; } public static void Main ( String [ ] args ) { string [ ] arr = { "" abcde "" , "" abcce "" , "" abcdf "" , "" abcde "" } ; int N = arr . Length ; Console . WriteLine ( distinct_str ( arr , N ) ) ; } }";"Count Distinct Strings present in an array using Polynomial rolling hash function | C # program to implement the above approach ; Function to find the hash value of a string ; Traverse the string ; Update hash_val ; Update mul ; Return hash_val of str ; Function to find the count of distinct strings present in the given array ; Store the hash values of the strings ; Traverse the array ; Stores hash value of arr [ i ] ; Sort hash [ ] array ; Stores count of distinct strings in the array ; Traverse hash [ ] array ; Update cntElem ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { static void SieveOfEratosthenes ( bool [ ] prime , int n ) { for ( int i = 0 ; i <= n ; i ++ ) { prime [ i ] = true ; } prime [ 0 ] = prime [ 1 ] = false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( prime [ i ] == true ) { for ( int j = 2 ; i * j <= n ; j ++ ) { prime [ i * j ] = false ; } } } } static void removePrimeFrequencies ( char [ ] s ) { int n = s . Length ; bool [ ] prime = new bool [ n + 1 ] ; SieveOfEratosthenes ( prime , n ) ; Dictionary < char , int > m = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( m . ContainsKey ( s [ i ] ) ) { m [ s [ i ] ] ++ ; } else { m . Add ( s [ i ] , 1 ) ; } } String new_String = "" "" ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( prime [ m [ s [ i ] ] ] ) continue ; new_String += s [ i ] ; } Console . Write ( new_String ) ; } public static void Main ( String [ ] args ) { String str = "" geeksforgeeks "" ; removePrimeFrequencies ( str . ToCharArray ( ) ) ; } }";"Remove characters from given string whose frequencies are a Prime Number | C # program for the above approach ; Function to perform the seive of eratosthenes algorithm ; Initialize all entries in prime [ ] as true ; Initialize 0 and 1 as non prime ; Traversing the prime array ; If i is prime ; All multiples of i must be marked false as they are non prime ; Function to remove characters which have prime frequency in the String ; Length of the String ; Create a bool array prime ; Sieve of Eratosthenes ; Stores the frequency of character ; Storing the frequencies ; New String that will be formed ; Removing the characters which have prime frequencies ; If the character has prime frequency then skip ; Else concatenate the character to the new String ; Print the modified String ; Driver Code ; Function Call"
C#;"using System ; class GFG { static String rearrange ( String s ) { String s1 = "" "" , s2 = "" "" , ans = "" "" ; char [ ] s3 = s . ToCharArray ( ) ; foreach ( char x in s3 ) { if ( x >= ' a ' && x <= ' z ' ) s1 += x ; else s2 += x ; } int n = s1 . Length ; int m = s2 . Length ; if ( Math . Abs ( n - m ) > 1 ) return "" - 1"" ; int i = 0 , j = 0 , k = 0 ; int flag = ( n >= m ) ? 1 : 0 ; while ( i < n && j < m ) { if ( flag != 0 ) ans += s1 [ i ++ ] ; else ans += s2 [ j ++ ] ; if ( flag == 1 ) flag = 0 ; else flag = 1 ; } return ans ; } public static void Main ( String [ ] args ) { String str = "" geeks2020"" ; Console . Write ( rearrange ( str ) + "" STRNEWLINE "" ) ; } }";"Rearrange string such that no pair of adjacent characters are of the same type | C # program to implement the above approach ; Function to rearrange given alphanumeric String such that no two adjacent characters are of the same type ; Stores alphabets and digits ; Store the alphabets and digits separately in the Strings ; Stores the count of alphabets and digits ; If respective counts differ by 1 ; Desired arrangement not possible ; Stores the indexes ; Check if first character should be alphabet or digit ; Place alphabets and digits alternatively ; If current character needs to be alphabet ; If current character needs to be a digit ; Flip flag for alternate arrangement ; Return resultant String ; Driver Code ; Given String ; Function Call"
C#;"using System ; class GFG { static void charactersCount ( String str , int n ) { int count = 0 ; while ( n > 0 ) { char cur = str [ 0 ] ; int ind = 0 ; for ( int j = 1 ; j < n ; j ++ ) { if ( str [ j ] < cur ) { cur = str [ j ] ; ind = j ; } } str = str . Substring ( 0 , ind ) + str . Substring ( ind + 1 ) ; n -- ; count += ind + 1 ; } Console . Write ( count + "" STRNEWLINE "" ) ; } public static void Main ( String [ ] args ) { String str = "" aabbc "" ; int n = 5 ; charactersCount ( str , n ) ; } }";"Find value after N operations to remove N characters of string S with given constraints | C # program for the above approach ; Function to find the value after N operations to remove all the N characters of String S ; Iterate till N ; Remove character at ind and decrease n ( size of String ) ; Increase count by ind + 1 ; Driver Code ; Given String str ; Function call"
C#;"using System ; class GFG { public static void printMiddlechar ( String str ) { int len = str . Length ; int middle = len / 2 ; Console . WriteLine ( str [ middle ] ) ; } public static void Main ( String [ ] args ) { String str = "" GeeksForGeeks "" ; printMiddlechar ( str ) ; } }";"Print the middle character of a string | C # program for the above approach ; Function that prints the middle character of a string ; Finding string length ; Finding middle index of string ; Print the middle character of the string ; Driver Code ; Given string str ; Function call"
C#;"using System ; using System . Collections ; using System . Collections . Generic ; using System . Text ; class GFG { static bool check ( string s ) { HashSet < char > a = new HashSet < char > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( a . Contains ( s [ i ] ) ) { return false ; } a . Add ( s [ i ] ) ; } return true ; } static ArrayList helper ( ArrayList arr , int ind ) { if ( ind == arr . Count ) return new ArrayList ( ) { "" "" } ; ArrayList tmp = helper ( arr , ind + 1 ) ; ArrayList ret = new ArrayList ( tmp ) ; for ( int i = 0 ; i < tmp . Count ; i ++ ) { string test = ( string ) tmp [ i ] + ( string ) arr [ ind ] ; if ( check ( test ) ) ret . Add ( test ) ; } return ret ; } static int maxLength ( ArrayList arr ) { ArrayList tmp = helper ( arr , 0 ) ; int len = 0 ; for ( int i = 0 ; i < tmp . Count ; i ++ ) { len = len > ( ( string ) tmp [ i ] ) . Length ? len : ( ( string ) tmp [ i ] ) . Length ; } return len ; } public static void Main ( string [ ] args ) { ArrayList s = new ArrayList ( ) ; s . Add ( "" abcdefgh "" ) ; Console . Write ( maxLength ( s ) ) ; } }";"Maximize length of the String by concatenating characters from an Array of Strings | C # program to implement the above approach ; Function to check if all the string characters are unique ; Check for repetition in characters ; Function to generate all possible strings from the given array ; Base case ; Consider every string as a starting substring and store the generated string ; Add current string to result of other strings and check if characters are unique or not ; Function to find the maximum possible length of a string ; Return max length possible ; Return the answer ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { class pair { public int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static void Range_sum_query ( String S , List < pair > Query ) { int N = S . Length ; int [ ] A = new int [ N ] ; A [ 0 ] = S [ 0 ] - ' a ' + 1 ; for ( int i = 1 ; i < N ; i ++ ) { A [ i ] = S [ i ] - ' a ' + 1 ; A [ i ] = A [ i ] + A [ i - 1 ] ; } for ( int i = 0 ; i < Query . Count ; i ++ ) { if ( Query [ i ] . first == 1 ) { Console . Write ( A [ ( Query [ i ] . second ) - 1 ] + "" STRNEWLINE "" ) ; } else { Console . Write ( A [ ( Query [ i ] . second ) - 1 ] - A [ ( Query [ i ] . first ) - 2 ] + "" STRNEWLINE "" ) ; } } } public static void Main ( String [ ] args ) { String S = "" abcd "" ; List < pair > Query = new List < pair > ( ) ; Query . Add ( new pair ( 2 , 4 ) ) ; Query . Add ( new pair ( 1 , 3 ) ) ; Range_sum_query ( S , Query ) ; } }";"Perform range sum queries on string as per given condition | C # program for the above approach ; Function to perform range sum queries on String as per the given condition ; Initialize N by String size ; Create array [ ] A for prefix sum ; Iterate till N ; Traverse the queries ; Check if if L == 1 range sum will be A [ R - 1 ] ; Condition if L > 1 range sum will be A [ R - 1 ] - A [ L - 2 ] ; Driver Code ; Given String ; Given Queries ; Function call"
C#;"using System ; class GFG { static void swap_ ( char [ ] a , int l , int i ) { char temp ; temp = a [ l ] ; a [ l ] = a [ i ] ; a [ i ] = temp ; } static void permute ( char [ ] str , int l , int r , int n ) { int i ; if ( l == r ) { int j = Int32 . Parse ( new string ( str ) ) ; if ( j % n == 0 ) Console . Write ( new string ( str ) + "" STRNEWLINE "" ) ; return ; } for ( i = l ; i < r ; i ++ ) { swap_ ( str , l , i ) ; permute ( str , l + 1 , r , n ) ; swap_ ( str , l , i ) ; } } public static void Main ( string [ ] args ) { string str = ""125"" ; int n = 5 ; int len = str . Length ; if ( len > 0 ) permute ( str . ToCharArray ( ) , 0 , len , n ) ; } }";"Generate all possible permutations of a Number divisible by N | C # program to implement the above approach ; Function to Swap two characters ; Function to generate all permutations and print the ones that are divisible by the N ; Convert String to integer ; Check for divisibility and print it ; Print all the permutations ; Swap characters ; Permute remaining characters ; Revoke the swaps ; Driver Code"
C#;"using System ; class GFG { static String decimalToBinary ( int N ) { String ans = "" "" ; while ( N > 0 ) { if ( N % 2 == 1 ) { ans = '1' + ans ; } else { ans = '0' + ans ; } N /= 2 ; } return ans ; } static String checkBinaryString ( String str , int N ) { int [ ] map = new int [ N + 10 ] ; int cnt = 0 ; for ( int i = N ; i > 0 ; i -- ) { if ( map [ i ] == 0 ) { int t = i ; String s = decimalToBinary ( t ) ; if ( str . Contains ( s ) ) { while ( t > 0 && map [ t ] == 0 ) { map [ t ] = 1 ; cnt ++ ; t >>= 1 ; } } } } for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == '0' ) { cnt ++ ; break ; } } if ( cnt == N + 1 ) return "" True "" ; else return "" False "" ; } public static void Main ( String [ ] args ) { String str = ""0110"" ; int N = 3 ; Console . Write ( checkBinaryString ( str , N ) ) ; } }";"Check if binary representations of 0 to N are present as substrings in given binary string | C # program for the above approach ; Function to convert decimal to binary representation ; Iterate over all bits of N ; If bit is 1 ; Return binary representation ; Function to check if binary conversion of numbers from N to 1 exists in the String as a subString or not ; To store the count of number exists as a subString ; Traverse from N to 1 ; If current number is not present in map ; Store current number ; Find binary of t ; If the String s is a subString of str ; Mark t as true ; Increment the count ; Update for t / 2 ; Special judgment '0' ; If the count is N + 1 , return "" yes "" ; Driver Code ; Given String ; Given number ; Function call"
C#;"using System ; using System . Collections . Generic ; class GFG { private static String largestAnagramGrp ( String [ ] arr ) { int [ ] prime = { 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , 73 , 79 , 83 , 89 , 97 , 101 } ; int max = - 1 ; long maxpdt = - 1 ; Dictionary < long , String > W = new Dictionary < long , String > ( ) ; Dictionary < long , int > P = new Dictionary < long , int > ( ) ; foreach ( String temp in arr ) { char [ ] c = temp . ToCharArray ( ) ; long pdt = 1 ; foreach ( char t in c ) { pdt *= prime [ t - ' a ' ] ; } if ( P . ContainsKey ( pdt ) ) { P [ pdt ] = P [ pdt ] + 1 ; } else { W . Add ( pdt , temp ) ; P . Add ( pdt , 1 ) ; } } foreach ( KeyValuePair < long , int > e in P ) { if ( max < e . Value ) { max = e . Value ; maxpdt = e . Key ; } } return W [ maxpdt ] ; } public static void Main ( String [ ] args ) { String S = "" please ▁ be ▁ silent ▁ and ▁ listen "" + "" ▁ to ▁ what ▁ the ▁ professor ▁ says ▁ "" ; String [ ] arr = S . Split ( ' ▁ ' ) ; Console . WriteLine ( largestAnagramGrp ( arr ) ) ; } }";"Find the word with most anagrams in a given sentence | C # program to find the word with most anagrams in a sentence ; Function to find the word with maximum number of anagrams ; Primes assigned to 26 alphabets ; Stores the product and word mappings ; Stores the frequencies of products ; Calculate the product of primes assigned ; If product already exists ; Otherwise ; Fetch the most frequent product ; Return a string with that product ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { static String print_next_vovel_String ( char [ ] str ) { Dictionary < char , int > m = new Dictionary < char , int > ( ) ; m . Add ( ' a ' , 0 ) ; m . Add ( ' e ' , 1 ) ; m . Add ( ' i ' , 2 ) ; m . Add ( ' o ' , 3 ) ; m . Add ( ' u ' , 4 ) ; char [ ] arr = { ' a ' , ' e ' , ' i ' , ' o ' , ' u ' } ; int N = str . Length ; for ( int i = 0 ; i < N ; i ++ ) { char c = str [ i ] ; if ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) { int index = m + 1 ; int newindex = index % 5 ; str [ i ] = arr [ newindex ] ; } } return String . Join ( "" "" , str ) ; } public static void Main ( String [ ] args ) { String str = "" geeksforgeeks "" ; Console . Write ( print_next_vovel_String ( str . ToCharArray ( ) ) ) ; } }";"Replace every vowels with lexicographically next vowel in a String | C # program to convert all the vowels in in the String to the next vowel ; Function to replace every vowel with next vowel lexicographically ; Storing the vowels in the map with custom numbers showing their index ; Iterate over the String ; If the current character is a vowel Find the index in Hash and Replace it with next vowel from Hash ; Driver code"
C#;"using System ; class GFG { static bool isPalindrome ( String str ) { int len = str . Length ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] != str [ len - i - 1 ] ) return false ; } return true ; } static bool isCompressablePalindrome ( String str ) { int len = str . Length ; String compressed = "" "" ; compressed = String . Join ( "" "" , str [ 0 ] ) ; for ( int i = 1 ; i < len ; i ++ ) { if ( str [ i ] != str [ i - 1 ] ) compressed += str [ i ] ; } return isPalindrome ( compressed ) ; } public static void Main ( String [ ] args ) { String str = "" abbcbbbaaa "" ; if ( isCompressablePalindrome ( str ) ) Console . Write ( "" Yes STRNEWLINE "" ) ; else Console . Write ( "" No STRNEWLINE "" ) ; } }";"Check if string is palindrome after removing all consecutive duplicates | C # program for the above approach ; Function to check if a String is palindrome or not ; Length of the String ; Check if its a palindrome ; If the palindromic condition is not met ; Return true as str is palindromic ; Function to check if String str is palindromic after removing every consecutive characters from the str ; Length of the String str ; Create an empty compressed String ; The first character will always be included in the readonly String ; Check all the characters of the String ; If the current character is not same as its previous one , then insert it in the readonly String ; Check if the compressed String is a palindrome ; Driver Code ; Given String ; Function call"
C#;"using System ; class GFG { static bool isvowel ( char x ) { return ( x == ' a ' x == ' e ' x == ' i ' x == ' o ' x == ' u ' ) ; } static int CountTotal ( string str ) { int ans = 0 ; int n = str . Length ; char [ ] s = str . ToCharArray ( ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isvowel ( s [ i ] ) ) cnt += 1 ; else { ans += ( cnt * ( cnt + 1 ) / 2 ) ; cnt = 0 ; } } if ( cnt != 0 ) ans += ( cnt * ( cnt + 1 ) / 2 ) ; return ans ; } static public void Main ( string [ ] args ) { string s = "" geeksforgeeks "" ; Console . Write ( CountTotal ( s ) ) ; } }";"Count of substrings consisting only of vowels | C # program to count all substrings in a string which contains only vowels ; Function to check vowel or not ; Function to find largest string which satisfy condition ; Check if current character is vowel ; Increment count ; Count all possible substrings of calculated length ; Reset the length ; Add remaining possible substrings consisting of vowels occupying last indices of the string ; Driver code"
C#;"using System ; class GFG { static int totCount ; static int firstCount ; static void getTotCount ( int num ) { totCount = 1 ; firstCount = 1 ; int temp = 1 ; while ( ( num & temp ) == 0 ) { temp = temp << 1 ; totCount += 1 ; } firstCount = totCount ; temp = num >> totCount ; while ( temp != 0 ) { totCount += 1 ; temp = temp >> 1 ; } } static int flipBitsFromRightMostSetBit ( int num ) { getTotCount ( num ) ; int num1 = num ^ ( ( 1 << totCount ) - 1 ) ; num1 = num1 ^ ( ( 1 << firstCount ) - 1 ) ; return num1 ; } public static void Main ( string [ ] args ) { int n = 120 ; Console . Write ( flipBitsFromRightMostSetBit ( n ) ) ; } }";"Number formed by flipping all bits to the left of rightmost set bit | C # program to find the integer formed after flipping all bits to the left of the rightmost set bit ; Function to get the total count ; Moving until we get the rightmost set bit ; To get total number of bits in a number ; Function to find the integer formed after flipping all bits to the left of the rightmost set bit ; Find the total count of bits and the rightmost set bit ; XOR given number with the number which has is made up of only totbits set ; To avoid flipping the bits to the right of the set bit , take XOR with the number made up of only set firstbits ; Driver Code"
C#;"using System ; public class GFG { public static bool isVowel ( char x ) { return ( x == ' a ' x == ' e ' x == ' i ' x == ' o ' x == ' u ' ) ; } public static int findMaxLen ( string s ) { int maxLen = 0 ; int cur ; if ( isVowel ( s [ 0 ] ) ) maxLen = 1 ; cur = maxLen ; for ( int i = 1 ; i < s . Length ; i ++ ) { if ( isVowel ( s [ i ] ) ) { if ( s [ i ] != s [ i - 1 ] ) cur += 1 ; else cur = 1 ; } else { cur = 0 ; } maxLen = Math . Max ( cur , maxLen ) ; } return maxLen ; } public static void Main ( string [ ] args ) { string Str = "" aeoibsddaeiouudb "" ; Console . WriteLine ( findMaxLen ( Str ) ) ; } }";"Longest substring of vowels with no two adjacent alphabets same | C # implementation of the above approach ; Function to check a character is vowel or not ; Function to find length of longest substring consisting only of vowels and no similar adjacent alphabets ; Stores max length of valid subString ; Stores length of current valid subString ; If curr and prev character are not same , include it ; If same as prev one , start new subString from here ; Store max in maxLen ; Driver code"
C#;"using System ; class GFG { static long power ( long Base , long pow ) { long res = 1 ; while ( pow > 0 ) { if ( ( pow & 1 ) == 1 ) res = ( res * Base ) ; Base = ( Base * Base ) ; pow >>= 1 ; } return res ; } static long countNonPalindromicString ( long n , long m ) { long total = power ( n , m ) ; long palindrome = power ( n , m / 2 + m % 2 ) ; long count = total - palindrome ; return count ; } public static void Main ( String [ ] args ) { int n = 3 , m = 5 ; Console . WriteLine ( countNonPalindromicString ( n , m ) ) ; } }";"Count of non | C # program to count non - palindromic strings of length M using N distinct characters ; Iterative Function to calculate base ^ pow in O ( log y ) ; Function to return the count of non palindromic strings ; Count of strings using n characters with repetitions allowed ; Count of palindromic strings ; Count of non - palindromic strings ; Driver code"
C#;"using System ; class GFG { static int [ ] freq = new int [ 26 ] ; static bool checkPalindrome ( ) { int oddCnt = 0 ; foreach ( int x in freq ) { if ( x % 2 == 1 ) oddCnt ++ ; } return oddCnt <= 1 ; } static int countPalindromePermutation ( char [ ] s , int k ) { int i = 0 ; for ( i = 0 ; i < k ; i ++ ) { freq [ s [ i ] - 97 ] ++ ; } int ans = 0 ; if ( checkPalindrome ( ) ) { ans ++ ; } int j = k ; i = 0 ; while ( j < s . Length ) { freq [ s [ i ++ ] - 97 ] -- ; freq [ s [ j ++ ] - 97 ] ++ ; if ( checkPalindrome ( ) ) { ans ++ ; } } return ans ; } public static void Main ( String [ ] args ) { String str = "" abbaca "" ; int K = 3 ; Console . Write ( countPalindromePermutation ( str . ToCharArray ( ) , K ) + "" STRNEWLINE "" ) ; } }";"Count of K | C # program for the above approach ; To store the frequency array ; Function to check palindromic of of any subString using frequency array ; Initialise the odd count ; Traversing frequency array to compute the count of characters having odd frequency ; Returns true if odd count is atmost 1 ; Function to count the total number subString whose any permutations are palindromic ; Computing the frequency of first K character of the String ; To store the count of palindromic permutations ; Checking for the current window if it has any palindromic permutation ; Start and end point of window ; Decrementing count of first element of the window ; Incrementing count of next element of the window ; Checking current window character frequency count ; Return the final count ; Driver Code ; Given String str ; Window of size K ; Function Call"
C#;"using System ; class GFG { public static int minFlips ( String target ) { char curr = '1' ; int count = 0 ; for ( int i = 0 ; i < target . Length ; i ++ ) { if ( target [ i ] == curr ) { count ++ ; curr = ( char ) ( 48 + ( curr + 1 ) % 2 ) ; } } return count ; } public static void Main ( String [ ] args ) { String S = ""011000"" ; Console . WriteLine ( minFlips ( S ) ) ; } }";"Minimum flips required to form given binary string where every flip changes all bits to its right as well | C # program for the above approach ; Function to return the count of minimum flips required ; If curr occurs in the readonly string ; Switch curr to '0' if '1' or vice - versa ; Driver code"
C#;"using System ; class GFG { static bool checkSuffix ( int A , int B ) { int digit_B = ( int ) ( Math . Log10 ( B ) + 1 ) ; A -= B ; return ( A % ( int ) ( Math . Pow ( 10 , digit_B ) ) > 0 ) ; } public static void Main ( ) { int A = 12345 , B = 45 ; bool result = checkSuffix ( A , B ) ; if ( ! result ) { Console . Write ( "" Yes "" ) ; } else { Console . Write ( "" No "" ) ; } } }";"Check if a number ends with another number or not | C # program for the above approach ; Function to check if B is a suffix of A or not ; Find the number of digit in B ; Subtract B from A ; Returns true , if B is a suffix of A ; Driver code ; Given numbers ; Function call ; If B is a suffix of A , then print "" Yes """
C#;"using System ; class GFG { static int count_min_length ( string s ) { int [ ] hash = new int [ 26 ] ; int ans = int . MaxValue ; for ( int i = 0 ; i < 26 ; i ++ ) hash [ i ] = - 1 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( hash [ s [ i ] - ' a ' ] == - 1 ) hash [ s [ i ] - ' a ' ] = i ; else { if ( hash [ s [ i ] - ' a ' ] == i - 1 hash [ s [ i ] - ' a ' ] == i - 2 ) return 0 ; ans = Math . Min ( ans , i - hash [ s [ i ] - ' a ' ] - 1 ) ; hash [ s [ i ] - ' a ' ] = i ; } } if ( ans == int . MaxValue ) return - 1 ; return ans ; } public static void Main ( string [ ] args ) { string str = "" abcdeba "" ; Console . WriteLine ( count_min_length ( str ) ) ; } }";"Minimum length of substring whose rotation generates a palindromic substring | C # Program to find the minimum length of substring whose rotation generates a palindromic substring ; Function to return the minimum length of substring ; Store the index of previous occurrence of the character ; Variable to store the maximum length of substring ; If the current character hasn 't appeared yet ; If the character has occured within one or two previous index , a palindromic substring already exists ; Update the maximum ; Replace the previous index of the character by the current index ; If character appeared at least twice ; Driver code"
C#;"using System ; class GFG { static void RemoveHTMLTags ( String str ) { System . Text . RegularExpressions . Regex rx = new System . Text . RegularExpressions . Regex ( "" < [ ^ > ] * > "" ) ; str = rx . Replace ( str , "" "" ) ; Console . WriteLine ( str ) ; } public static void Main ( String [ ] args ) { String str ; str = "" < div > < b > Geeks ▁ for ▁ Geeks < / b > < / div > "" ; RemoveHTMLTags ( str ) ; } }";"Program to remove HTML tags from a given String | C # program for the above approach ; Function to remove the HTML tags from the given tags ; Use replaceAll function in regex to erase every tags enclosed in < > str = Regex . Replace ( str , "" < . * ? > "" , String . Empty ) ; Print string after removing tags ; Driver code ; Given String ; Function call to print the HTML string after removing tags"
C#;"using System ; using System . Collections ; class GFG { class TreeNode { public TreeNode parent = null ; public ArrayList children = new ArrayList ( ) ; public void addChild ( TreeNode node ) { children . Add ( node ) ; } public void setParent ( TreeNode node ) { parent = node ; } public TreeNode getParent ( ) { return parent ; } public int computeScore ( ) { if ( children . Count == 0 ) return 1 ; int res = 0 ; foreach ( TreeNode curr in children ) res += curr . computeScore ( ) ; if ( parent == null ) return res ; else return 2 * res ; } } ; static TreeNode computeTree ( string s ) { TreeNode current = new TreeNode ( ) ; TreeNode root = current ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == ' ( ' ) { TreeNode child = new TreeNode ( ) ; child . setParent ( current ) ; current . addChild ( child ) ; current = child ; } else { current = current . getParent ( ) ; } } return root ; } public static void Main ( ) { string s = "" ( ( ) ( ( ) ) ) "" ; TreeNode root = computeTree ( s ) ; Console . Write ( root . computeScore ( ) ) ; } }";"Score of Parentheses using Tree | C # program to find the score of parentheses using Tree ; Customized tree class or struct , contains all required methods . ; Function to add a child into the list of children ; Function to change the parent pointer to the node passed ; Function to return the parent of the current node ; Function to compute the score recursively . ; Base case ; Adds scores of all children ; Function to create the tree structure ; Creating a node for every "" ( ) "" ; If we find "" ( "" we add a node as a child ; On finding "" ) "" which confirms that a pair is closed , we go back to the parent ; Driver code ; Generating the tree ; Computing the score"
C#;"using System ; class GFG { static void rec ( char [ ] a , int i ) { if ( i == 0 ) { Console . WriteLine ( a ) ; return ; } if ( a [ i ] == ' x ' ) { int j = i ; while ( a [ j ] != ' \0' && a [ j + 1 ] != ' \0' ) { char temp = a [ j ] ; a [ j ] = a [ j + 1 ] ; a [ j + 1 ] = temp ; j ++ ; } } rec ( a , i - 1 ) ; } static void Main ( ) { char [ ] a = { ' g ' , ' e ' , ' e ' , ' k ' , ' x ' , ' s ' , ' x ' , ' x ' , ' k ' , ' s ' , ' \0' } ; int n = 10 ; rec ( a , n - 1 ) ; } }";"Move all occurrence of letter ' x ' from the string s to the end using Recursion | C # program for the above approach ; Recursive program to bring ' x ' to the end ; When the string is completed from reverse direction end of recursion ; If the character x is found ; Transverse the whole string ; Swap the x so that it moves to the last ; call to the smaller problem now ; Driver code ; Size of a ; Call to rec"
C#;"using System ; class GFG { public static String largestchar ( String str ) { bool [ ] uppercase = new bool [ 26 ] ; bool [ ] lowercase = new bool [ 26 ] ; char [ ] arr = str . ToCharArray ( ) ; foreach ( char c in arr ) { if ( char . IsLower ( c ) ) lowercase = true ; if ( char . IsUpper ( c ) ) uppercase = true ; } for ( int i = 25 ; i >= 0 ; i -- ) { if ( uppercase [ i ] && lowercase [ i ] ) return ( char ) ( i + ' A ' ) + "" "" ; } return "" - 1"" ; } public static void Main ( String [ ] args ) { String str = "" admeDCAB "" ; Console . WriteLine ( largestchar ( str ) ) ; } }";"Find the largest Alphabetic character present in the string | C # program to Find the Largest Alphabetic char present in the string of both uppercase and lowercase English characters ; Function to find the Largest Alphabetic char ; Array for keeping track of both uppercase and lowercase english alphabets ; Iterate from right side of array to get the largest index character ; Check for the character if both its uppercase and lowercase exist or not ; Return - 1 if no such character whose uppercase and lowercase present in string str ; Driver code"
C#;"using System ; class GFG { static String generateString ( int N , int M , int K ) { String s = "" "" ; int cnt1 = 0 ; int cnt2 = 0 ; for ( int i = 0 ; i < N ; i ++ ) { cnt1 ++ ; cnt2 ++ ; if ( cnt1 <= M ) { if ( cnt2 <= K ) { s = s + ( char ) ( 96 + cnt1 ) ; } else { s = s + ' a ' ; } } else { cnt1 = 1 ; cnt2 = 1 ; s = s + ' a ' ; } } return s ; } public static void Main ( String [ ] args ) { int N = 7 , M = 5 , K = 3 ; Console . WriteLine ( generateString ( N , M , K ) ) ; } }";"Generate a string of size N whose each substring of size M has exactly K distinct characters | C # program to generate a String of size N whose each subString of size M has exactly K distinct characters ; Function to generate the String ; Declare empty String ; Counter for M ; Counter for K ; Loop to generate String size of N ; Generating K distinct letters one by one ; After generating b distinct letters , append rest a - b letters as ' a ' ; Reset the counter value and repeat the process ; Return readonly result String ; Driver code"
C#;"using System ; class GFG { static void finalString ( String str ) { int x = 0 , y = 0 ; int left ; int n = str . Length ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '1' ) x ++ ; else y ++ ; } if ( x > y ) left = 1 ; else left = 0 ; int length = n - 2 * Math . Min ( x , y ) ; for ( int i = 0 ; i < length ; i ++ ) { Console . Write ( left ) ; } } public static void Main ( String [ ] args ) { String str = ""010110100100000"" ; finalString ( str ) ; } }";"Print string after removing all ( “ 10 ” or “ 01 ” ) from the binary string | C # program to print the readonly String after removing all the occurrences of ""10"" and ""01"" from the given binary String ; Function to print the readonly String after removing all the occurrences of ""10"" and ""01"" from the given binary String ; Variables to store the count of 1 ' s ▁ and ▁ 0' s ; Variable left will store whether 0 ' s ▁ or ▁ 1' s is left in the readonly String ; Length of the String ; For loop to count the occurrences of 1 ' s ▁ and ▁ 0' s in the String ; To check if the count of 1 ' s ▁ is ▁ ▁ greater ▁ than ▁ the ▁ count ▁ of ▁ 0' s or not . If x is greater , then those many 1 's  are printed. ; Length of the readonly remaining String after removing all the occurrences ; Printing the readonly String ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { static void printPalindrome ( List < String > left , String mid , List < String > right ) { foreach ( String x in left ) Console . Write ( x ) ; Console . Write ( mid ) ; right . Reverse ( ) ; foreach ( String x in right ) Console . Write ( x ) ; Console . WriteLine ( ) ; } static void findPalindrome ( List < String > S , int N , int M ) { HashSet < String > dict = new HashSet < String > ( ) ; for ( int i = 0 ; i < M ; i ++ ) { dict . Add ( S [ i ] ) ; } List < String > left = new List < String > ( ) , right = new List < String > ( ) ; String mid = "" "" ; for ( int i = 0 ; i < N ; i ++ ) { String t = S [ i ] ; t = reverse ( t ) ; if ( t == S [ i ] ) mid = t ; else if ( dict . Contains ( t ) ) { left . Add ( S [ i ] ) ; right . Add ( t ) ; dict . Remove ( S [ i ] ) ; dict . Remove ( t ) ; } } printPalindrome ( left , mid , right ) ; } static String reverse ( String input ) { char [ ] a = input . ToCharArray ( ) ; int l , r = a . Length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { char temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return String . Join ( "" "" , a ) ; } public static void Main ( String [ ] args ) { String [ ] arr = { "" tab "" , "" one "" , "" bat "" } ; List < String > S = new List < String > ( arr ) ; int M = 3 ; int N = S . Count ; findPalindrome ( S , N , M ) ; } }";"Longest palindrome formed by concatenating and reordering strings of equal length | C # program to find the longest palindrome that can be formed by concatenating and reordering given N Strings of equal length ; Function to print the longest palindrome ; Printing every String in left vector ; Printing the palindromic String in the middle ; Printing the reverse of the right vector to make the readonly output palindromic ; Function to find and print the longest palindrome that can be formed ; Inserting each String in the set ; Lists to add the Strings in the left and right side ; To add the already present palindrome String in the middle of the solution ; Iterating through all the given Strings ; If the String is a palindrome it is added in the middle ; Checking if the reverse of the String is already present in the set ;  ; Driver code"
C#;"using System ; class GFG { static string swap ( string str , int i , int j ) { char [ ] tempArr = str . ToCharArray ( ) ; char temp = tempArr [ i ] ; tempArr [ i ] = tempArr [ j ] ; tempArr [ j ] = temp ; return new string ( tempArr ) ; } static bool IsLexicographicallySmaller ( string A , string B ) { if ( A . CompareTo ( B ) < 0 ) { return true ; } string temp = A ; char [ ] p = temp . ToCharArray ( ) ; Array . Sort ( p ) ; temp = new string ( p ) ; int index = - 1 ; for ( int i = 0 ; i < A . Length ; i ++ ) { if ( A [ i ] != temp [ i ] ) { index = i ; break ; } } if ( index == - 1 ) { return false ; } int j = 0 ; for ( int i = 0 ; i < A . Length ; i ++ ) { if ( A [ i ] == temp [ index ] ) j = i ; } A = swap ( A , index , j ) ; if ( A . CompareTo ( B ) < 0 ) { return true ; } else { return false ; } } public static void Main ( string [ ] args ) { string A = "" AGAIN "" ; string B = "" ACTION "" ; if ( IsLexicographicallySmaller ( A , B ) ) { Console . Write ( "" Yes "" ) ; } else { Console . Write ( "" No "" ) ; } } }";"Lexicographically smaller string by swapping at most one character pair | C # program check whether is it possible to make String A lexicographically smaller than String B ; Swap function ; Function that finds whether is it possible to make String A lexicographically smaller than String B ; Condition if String A is already smaller than B ; Sorting temp String ; Condition for first changed character of String A and temp ; Condition if String A is already sorted ; Finding first changed character from last of String A ; Swap the two characters ; Condition if String A is smaller than B ; Driver Code"
C#;"using System ; class GFG { static int max ( int x , int y ) { return ( x > y ) ? x : y ; } static int longestPalindromic ( String str , int i , int j , int count ) { if ( i > j ) return count ; if ( i == j ) return ( count + 1 ) ; if ( str [ i ] == str [ j ] ) { count = longestPalindromic ( str , i + 1 , j - 1 , count + 2 ) ; return max ( count , max ( longestPalindromic ( str , i + 1 , j , 0 ) , longestPalindromic ( str , i , j - 1 , 0 ) ) ) ; } return Math . Max ( longestPalindromic ( str , i + 1 , j , 0 ) , longestPalindromic ( str , i , j - 1 , 0 ) ) ; } static int longest_palindromic_substr ( String str ) { return longestPalindromic ( str , 0 , str . Length - 1 , 0 ) ; } public static void Main ( String [ ] args ) { String str = "" aaaabbaa "" ; Console . Write ( longest_palindromic_substr ( str ) ) ; } }";"Length of longest palindromic sub | C # implementation to find the length of longest palindromic sub - String using Recursion ; Function to find maximum of the two variables ; Function to find the longest palindromic subString : Recursion ; Base condition when the start index is greater than end index ; Base condition when both the start and end index are equal ; Condition when corner characters are equal in the String ; Recursive call to find the longest Palindromic String by excluding the corner characters ; Recursive call to find the longest Palindromic String by including one corner character at a time ; Function to find the longest palindromic sub - String ; Utility function call ; Driver Code ; Function Call"
C#;"using System ; using System . Collections ; using System . Collections . Generic ; using System . Linq ; class GFG { static void MaxPrefix ( string s ) { Dictionary < char , int > Dict = new Dictionary < char , int > ( ) ; foreach ( char i in s ) { if ( Dict . ContainsKey ( i ) ) { Dict [ i ] ++ ; } else { Dict [ i ] = 1 ; } } int minfrequency = Int32 . MaxValue ; foreach ( int x in Dict . Values . ToList ( ) ) { minfrequency = Math . Min ( minfrequency , x ) ; } int countminFrequency = 0 ; foreach ( char x in Dict . Keys . ToList ( ) ) { if ( Dict [ x ] == minfrequency ) countminFrequency += 1 ; } Dictionary < char , int > mapper = new Dictionary < char , int > ( ) ; int indi = 0 ; foreach ( char i in s ) { if ( mapper . ContainsKey ( i ) ) { mapper [ i ] ++ ; } else { mapper [ i ] = 1 ; } if ( mapper [ i ] > countminFrequency ) break ; indi += 1 ; } Console . Write ( s . Substring ( 0 , indi ) ) ; } public static void Main ( string [ ] args ) { string str = "" aabcdaab "" ; MaxPrefix ( str ) ; } }";"Maximum length prefix such that frequency of each character is atmost number of characters with minimum frequency | C # implementation to find the prefix of the s such that occurrence of each character is atmost the count of minimum frequency in the s ; Function to find the maximum possible prefix of the s ; Hash map to store the frequency of the characters in the s ; Iterate over the s to find the occurence of each Character ; Minimum frequency of the Characters ; Loop to find the count of minimum frequency in the hash - map ; Loop to find the maximum possible length of the prefix in the s ; Condition to check if the frequency is greater than minimum possible freq ; maxprefix s and its length . ; Driver Code ; s is initialize . ; str is passed in MaxPrefix function ."
C#;"using System ; class GFG { static int countSubString ( char [ ] S , char [ ] L , int n ) { int [ ] freq = new int [ 26 ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ ( int ) ( L [ i ] - ' a ' ) ] = 1 ; } int count = 0 ; foreach ( int x in S ) { if ( freq [ ( int ) ( x - ' a ' ) ] > 0 ) { ans += ( count * count + count ) / 2 ; count = 0 ; } else count ++ ; } ans += ( count * count + count ) / 2 ; return ans ; } public static void Main ( ) { string S = "" abcpxyz "" ; char [ ] L = { ' a ' , ' p ' , ' q ' } ; int n = L . Length ; Console . WriteLine ( countSubString ( S . ToCharArray ( ) , L , n ) ) ; } }";"Count of Substrings that can be formed without using the given list of Characters | C # implementation of the above approach ; Function to find the Number of sub - Strings without using given character ; Mark the given characters in the freq array ; Count variable to store the count of the characters until a character from given L is encountered ; If a character from L is encountered , then the answer variable is incremented by the value obtained by using the mentioned formula and count is set to 0 ; For last remaining characters ; Driver code"
C#;"using System ; class GFG { static int checkIfStartsWithVowels ( char [ ] str ) { if ( ! ( str [ 0 ] == ' A ' str [ 0 ] == ' a ' str [ 0 ] == ' E ' str [ 0 ] == ' e ' str [ 0 ] == ' I ' str [ 0 ] == ' i ' str [ 0 ] == ' O ' str [ 0 ] == ' o ' str [ 0 ] == ' U ' str [ 0 ] == ' u ' ) ) return 1 ; else return 0 ; } static void check ( String str ) { if ( checkIfStartsWithVowels ( str . ToCharArray ( ) ) == 1 ) Console . Write ( "" Not ▁ Accepted STRNEWLINE "" ) ; else Console . Write ( "" Accepted STRNEWLINE "" ) ; } public static void Main ( String [ ] args ) { String str = "" animal "" ; check ( str ) ; str = "" zebra "" ; check ( str ) ; } }";"Program to accept Strings starting with a Vowel | C # program to accept String starting with Vowel ; Function to check if first character is vowel ; Function to check ; Driver code"
C#;"using System ; class GFG { static int findNthOccur ( String str , char ch , int N ) { int occur = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == ch ) { occur += 1 ; } if ( occur == N ) return i ; } return - 1 ; } public static void Main ( String [ ] args ) { String str = "" geeks "" ; char ch = ' e ' ; int N = 2 ; Console . Write ( findNthOccur ( str , ch , N ) ) ; } }";"Find the Nth occurrence of a character in the given String | C # implementation to find the Nth occurrence of a character ; Function to find the Nth occurrence of a character ; Loop to find the Nth occurrence of the character ; Driver Code"
C#;"using System ; class GFG { static int solve ( string X , string Y , int N , int K ) { int [ ] count = new int [ N + 1 ] ; int sol = 0 ; count [ 0 ] = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { count [ i ] = count [ i - 1 ] + Math . Abs ( X [ i - 1 ] - Y [ i - 1 ] ) ; } int j = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { while ( ( count [ i ] - count [ j ] ) > K ) { j ++ ; } sol = Math . Max ( sol , i - j ) ; } return sol ; } public static void Main ( ) { int N = 4 ; string X = "" abcd "" , Y = "" bcde "" ; int K = 3 ; Console . WriteLine ( solve ( X , Y , N , K ) + "" STRNEWLINE "" ) ; } }";"Longest equal substring with cost less than K | C # program to find the maximum length of equal subString within a given cost ; Function to find the maximum length ; Fill the prefix array with the difference of letters ; Update the maximum length ; Driver code"
C#;"using System ; class GFG { static double jaro_distance ( string s1 , string s2 ) { if ( s1 == s2 ) return 1.0 ; int len1 = s1 . Length , len2 = s2 . Length ; if ( len1 == 0 len2 == 0 ) return 0.0 ; int max_dist = ( int ) Math . Floor ( ( double ) Math . Max ( len1 , len2 ) / 2 ) - 1 ; int match = 0 ; int [ ] hash_s1 = new int [ s1 . Length ] ; int [ ] hash_s2 = new int [ s2 . Length ] ; for ( int i = 0 ; i < len1 ; i ++ ) { for ( int j = Math . Max ( 0 , i - max_dist ) ; j < Math . Min ( len2 , i + max_dist + 1 ) ; j ++ ) if ( s1 [ i ] == s2 [ j ] && hash_s2 [ j ] == 0 ) { hash_s1 [ i ] = 1 ; hash_s2 [ j ] = 1 ; match ++ ; break ; } } if ( match == 0 ) return 0.0 ; double t = 0 ; int point = 0 ; for ( int i = 0 ; i < len1 ; i ++ ) if ( hash_s1 [ i ] == 1 ) { while ( hash_s2 [ point ] == 0 ) point ++ ; if ( s1 [ i ] != s2 [ point ++ ] ) t ++ ; } t /= 2 ; return ( ( ( double ) match ) / ( ( double ) len1 ) + ( ( double ) match ) / ( ( double ) len2 ) + ( ( double ) match - t ) / ( ( double ) match ) ) / 3.0 ; } static double jaro_Winkler ( string s1 , string s2 ) { double jaro_dist = jaro_distance ( s1 , s2 ) ; if ( jaro_dist > 0.7 ) { int prefix = 0 ; for ( int i = 0 ; i < Math . Min ( s1 . Length , s2 . Length ) ; i ++ ) { if ( s1 [ i ] == s2 [ i ] ) prefix ++ ; else break ; } prefix = Math . Min ( 4 , prefix ) ; jaro_dist += 0.1 * prefix * ( 1 - jaro_dist ) ; } return jaro_dist ; } public static void Main ( ) { string s1 = "" TRATE "" , s2 = "" TRACE "" ; Console . WriteLine ( "" Jaro - Winkler ▁ Similarity ▁ = "" + jaro_Winkler ( s1 , s2 ) ) ; } }";"Jaro and Jaro | C # implementation of above approach ; Function to calculate the Jaro Similarity of two strings ; If the strings are equal ; Length of two strings ; Maximum distance upto which matching is allowed ; Count of matches ; Hash for matches ; Traverse through the first string ; Check if there is any matches ; If there is a match ; If there is no match ; Number of transpositions ; Count number of occurrences where two characters match but there is a third matched character in between the indices ; Find the next matched character in second string ; Return the Jaro Similarity ; Jaro Winkler Similarity ; If the jaro Similarity is above a threshold ; Find the length of common prefix ; If the characters match ; Else break ; Maximum of 4 characters are allowed in prefix ; Calculate jaro winkler Similarity ; Driver code ; Print Jaro - Winkler Similarity of two strings"
C#;"using System ; class GFG { static bool isWordPresent ( String sentence , String word ) { String [ ] s = sentence . Split ( ' ▁ ' ) ; foreach ( String temp in s ) { if ( temp . CompareTo ( word ) == 0 ) { return true ; } } return false ; } public static void Main ( String [ ] args ) { String s = "" Geeks ▁ for ▁ Geeks "" ; String word = "" Geeks "" ; if ( isWordPresent ( s , word ) ) Console . Write ( "" Yes "" ) ; else Console . Write ( "" No "" ) ; } }";"Check if a word is present in a sentence | C # implementation of the approach ; Function that returns true if the word is found ; To break the sentence in words ; To temporarily store each individual word ; Comparing the current word with the word to be searched ; Driver code"
C#;"using System ; class GFG { static bool isWordPresent ( String sentence , String word ) { word = transform ( word ) ; sentence = transform ( sentence ) ; String [ ] s = sentence . Split ( ' ▁ ' ) ; foreach ( String temp in s ) { if ( temp . CompareTo ( word ) == 0 ) { return true ; } } return false ; } static String transform ( String word ) { return word . ToUpper ( ) ; } public static void Main ( String [ ] args ) { String s = "" Geeks ▁ for ▁ Geeks "" ; String word = "" geeks "" ; if ( isWordPresent ( s , word ) ) Console . Write ( "" Yes "" ) ; else Console . Write ( "" No "" ) ; } }";"Check if a word is present in a sentence | C # implementation of the approach ; Function that returns true if the word is found ; To convert the word in uppercase ; To convert the complete sentence in uppercase ; To break the sentence in words ; To store the individual words of the sentence ; Comparing the current word with the word to be searched ; Driver code"
C#;"using System ; class GFG { static int countChars ( string str , int n ) { int i = 0 , cnt = 0 ; while ( i < n ) { if ( str [ i ] == '0' ) i += 1 ; else i += 2 ; cnt += 1 ; } return cnt ; } public static void Main ( ) { string str = ""11010"" ; int n = str . Length ; Console . WriteLine ( countChars ( str , n ) ) ; } }";"Count of 1 | C # implementation of the above approach ; Function to return the count of required characters ; While there are characters left ; Single bit character ; Two - bit character ; Update the count ; Driver code"
C#;"using System ; class GFG { static int MAX = 26 ; static void compressString ( string s , int n ) { int [ ] freq = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) { freq [ s [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] == 0 ) continue ; Console . Write ( ( char ) ( i + ' a ' ) + "" "" + freq [ i ] ) ; } } public static void Main ( ) { string s = "" geeksforgeeks "" ; int n = s . Length ; compressString ( s , n ) ; } }";"Print the frequency of each character in Alphabetical order | C # implementation of the approach ; Function to print the frequency of each of the characters of s in alphabetical order ; To store the frequency of the characters ; Update the frequency array ; Print the frequency in alphatecial order ; If the current alphabet doesn 't  appear in the string ; Driver code"
C#;"using System ; class GFG { static void decBinary ( int [ ] arr , int n ) { int k = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n /= 2 ; } } static int binaryDec ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; } static int concat ( int m , int n ) { int k = ( int ) ( Math . Log ( m ) / Math . Log ( 2 ) ) + 1 ; int l = ( int ) ( Math . Log ( n ) / Math . Log ( 2 ) ) + 1 ; int [ ] a = new int [ k ] ; int [ ] b = new int [ l ] ; int [ ] c = new int [ k + l ] ; decBinary ( a , m ) ; decBinary ( b , n ) ; int iN = 0 ; for ( int i = 0 ; i < k ; i ++ ) c [ iN ++ ] = a [ i ] ; for ( int i = 0 ; i < l ; i ++ ) c [ iN ++ ] = b [ i ] ; return ( binaryDec ( c , k + l ) ) ; } public static void Main ( String [ ] args ) { int m = 4 , n = 5 ; Console . WriteLine ( concat ( m , n ) ) ; } }";"Find the number obtained after concatenation of binary representation of M and N | C # implementation of the approach ; Function to convert decimal number n to its binary representation stored as an array [ ] arr ; Funtion to convert the number represented as a binary array [ ] arr into its decimal equivalent ; Function to concatenate the binary numbers and return the decimal result ; Number of bits in both the numbers ; Convert the bits in both the integers to the arrays [ ] a and [ ] b ; c [ ] will be the binary array for the result ; Update the c [ ] array ; Return the decimal equivalent of the result ; Driver code"
C#;"using System ; class GFG { static int getBinaryLength ( int n ) { int length = 0 ; while ( n > 0 ) { length += 1 ; n /= 2 ; } return length ; } static int concat ( int m , int n ) { int length = getBinaryLength ( n ) ; return ( m << length ) + n ; } static void Main ( ) { int m = 4 , n = 5 ; Console . WriteLine ( concat ( m , n ) ) ; } }";"Find the number obtained after concatenation of binary representation of M and N | C # implementation of the approach ; Utility function to calculate binary length of a number . ; Function to concatenate the binary numbers and return the decimal result ; Find binary length of n ; left binary shift m and then add n ; Driver code"
C#;"using System ; class GFG { static String addZeros ( String str , int n ) { for ( int i = 0 ; i < n ; i ++ ) { str = ""0"" + str ; } return str ; } static String getXOR ( String a , String b ) { int aLen = a . Length ; int bLen = b . Length ; if ( aLen > bLen ) { a = addZeros ( b , aLen - bLen ) ; } else if ( bLen > aLen ) { a = addZeros ( a , bLen - aLen ) ; } int len = Math . Max ( aLen , bLen ) ; String res = "" "" ; for ( int i = 0 ; i < len ; i ++ ) { if ( a [ i ] == b [ i ] ) res += ""0"" ; else res += ""1"" ; } return res ; } public static void Main ( String [ ] args ) { String a = ""11001"" , b = ""111111"" ; Console . WriteLine ( getXOR ( a , b ) ) ; } }";"XOR two binary strings of unequal lengths | C # implementation of the approach ; Function to insert n 0 s in the beginning of the given string ; Function to return the XOR of the given strings ; Lengths of the given strings ; Make both the strings of equal lengths by inserting 0 s in the beginning ; Updated length ; To store the resultant XOR ; Driver code"
C#;"using System ; using System . Collections . Generic ; public class Node { public int [ ] soln ; public int level ; public List < Node > child ; public Node parent ; public Node ( Node parent , int level , int N ) { this . parent = parent ; this . level = level ; this . soln = new int [ N ] ; } } class GFG { static int N ; public static Queue < Node > Q ; public static void generate ( Node n ) { if ( n . level == N ) { for ( int i = 0 ; i <= N - 1 ; i ++ ) { Console . Write ( n . soln [ i ] ) ; } Console . WriteLine ( ) ; } else { n . child = new List < Node > ( ) ; int l = n . level ; for ( int i = 0 ; i <= 1 ; i ++ ) { Node x = new Node ( n , l + 1 , N ) ; for ( int k = 0 ; k < l ; k ++ ) { x . soln [ k ] = n . soln [ k ] ; } x . soln [ l ] = i ; n . child . Add ( x ) ; Q . Enqueue ( x ) ; } } } public static void Main ( String [ ] args ) { N = 3 ; Node root = new Node ( null , 0 , N ) ; Q = new Queue < Node > ( ) ; Q . Enqueue ( root ) ; while ( Q . Count != 0 ) { Node E = Q . Dequeue ( ) ; generate ( E ) ; } } }";"Generate Binary Strings of length N using Branch and Bound | C # Program to generate Binary Strings using Branch and Bound ; Creating a Node class ; Queue that maintains the list of live Nodes ; Utility function to generate binary strings of length n ; If list is full print combination ; Create a new vector for new combination ; iterate while length is not equal to n ; Driver code ; Initiate Generation Create a root Node ; Instantiate the Queue"
C#;"using System ; class GFG { readonly static int MAX = 26 ; static int minOperation ( String str , int len ) { int [ ] first = new int [ MAX ] ; int [ ] last = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) { first [ i ] = - 1 ; last [ i ] = - 1 ; } for ( int i = 0 ; i < len ; i ++ ) { int index = ( str [ i ] - ' a ' ) ; if ( first [ index ] == - 1 ) first [ index ] = i ; last [ index ] = i ; } int minOp = - 1 ; for ( int i = 0 ; i < MAX ; i ++ ) { if ( first [ i ] == - 1 first [ i ] == last [ i ] ) continue ; int cnt = len - ( last [ i ] - first [ i ] + 1 ) ; if ( minOp == - 1 cnt < minOp ) minOp = cnt ; } return minOp ; } public static void Main ( String [ ] args ) { String str = "" abcda "" ; int len = str . Length ; Console . WriteLine ( minOperation ( str , len ) ) ; } }";"Minimum operations required to make the string satisfy the given condition | C # implementation of the approach ; Function to return the minimum operations required ; To store the first and the last occurrence of all the characters ; Set the first and the last occurrence of all the characters to - 1 ; Update the occurrences of the characters ; Only set the first occurrence if it hasn 't already been set ; To store the minimum operations ; If the frequency of the current character in the string is less than 2 ; Count of characters to be removed so that the string starts and ends at the current character ; Driver code"
C#;"using System ; class GFG { static int N = 2 ; static Boolean isVowel ( char ch ) { return ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) ; } static int countVowels ( String str , int l , int r ) { int cnt = 0 ; for ( int i = l ; i <= r ; i ++ ) { if ( isVowel ( str [ i ] ) ) cnt ++ ; } return cnt ; } static void performQueries ( String str , int [ , ] queries , int q ) { for ( int i = 0 ; i < q ; i ++ ) { Console . WriteLine ( countVowels ( str , queries [ i , 0 ] , queries [ i , 1 ] ) ) ; } } public static void Main ( String [ ] args ) { String str = "" geeksforgeeks "" ; int [ , ] queries = { { 1 , 3 } , { 2 , 4 } , { 1 , 9 } } ; int q = queries . GetLength ( 0 ) ; performQueries ( str , queries , q ) ; } }";"Queries to find the count of vowels in the substrings of the given string | C # implementation of the approach ; Function that returns true if ch is a vowel ; Function to return the count of vowels in the substring str [ l ... r ] ; To store the count of vowels ; For every character in the index range [ l , r ] ; If the current character is a vowel ; For every query ; Find the count of vowels for the current query ; Driver code"
C#;"using System ; class GFG { class node { public char data ; public node next ; } ; static node add ( char data ) { node newnode = new node ( ) ; newnode . data = data ; newnode . next = null ; return newnode ; } static node string_to_SLL ( String text , node head ) { head = add ( text [ 0 ] ) ; node curr = head ; for ( int i = 1 ; i < text . Length ; i ++ ) { curr . next = add ( text [ i ] ) ; curr = curr . next ; } return head ; } static void print ( node head ) { node curr = head ; while ( curr != null ) { Console . Write ( curr . data + "" ▁ - > ▁ "" ) ; curr = curr . next ; } } public static void Main ( String [ ] args ) { String text = "" GEEKS "" ; node head = null ; head = string_to_SLL ( text , head ) ; print ( head ) ; } }";"Convert a String to a Singly Linked List | C # program to Convert a String to a Singly Linked List ; Structure for a Singly Linked List ; Function to add a new node to the Linked List ; Function to convert the string to Linked List . ; curr pointer points to the current node where the insertion should take place ; Function to print the data present in all the nodes ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { static int minLength ( String str , int len ) { Stack < char > s = new Stack < char > ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( s . Count == 0 ) { s . Push ( str [ i ] ) ; } else { char c = s . Peek ( ) ; if ( c != str [ i ] && char . ToUpper ( c ) == char . ToUpper ( ( str [ i ] ) ) ) { s . Pop ( ) ; } else { s . Push ( str [ i ] ) ; } } } return s . Count ; } public static void Main ( String [ ] args ) { String str = "" ASbBsd "" ; int len = str . Length ; Console . WriteLine ( minLength ( str , len ) ) ; } }";"Reduce the string to minimum length with the given operation | C # implementation of the approach ; Function to return the minimum possible length str can be reduced to with the given operation ; Stack to store the characters of the given string ; For every character of the string ; If the stack is empty then push the current character in the stack ; Get the top character ; If the top element is not equal to the current element and it only differs in the case ; Pop the top element from stack ; Else push the current element ; Driver code"
C#;"using System ; class GFG { static int MAX = 26 ; static Boolean canBeMadeEqual ( String str1 , String str2 ) { int len1 = str1 . Length ; int len2 = str2 . Length ; if ( len1 == len2 ) { int [ ] freq = new int [ MAX ] ; for ( int i = 0 ; i < len1 ; i ++ ) { freq [ str1 [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < len2 ; i ++ ) { if ( freq [ str2 [ i ] - ' a ' ] > 0 ) return true ; } } return false ; } public static void Main ( String [ ] args ) { String str1 = "" abc "" , str2 = "" defa "" ; if ( canBeMadeEqual ( str1 , str2 ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Check whether two strings can be made equal by copying their characters with the adjacent ones | C # implementation of the above approach ; Function that returns true if both the strings can be made equal with the given operation ; Lengths of both the strings have to be equal ; To store the frequency of the characters of str1 ; For every character of str2 ; If current character of str2 also appears in str1 ; Driver code"
C#;"using System ; class GFG { static int getCount ( string str , int n ) { int cnt = 0 ; int i = 0 ; while ( i < n - 2 ) { if ( str [ i ] == str [ i + 1 ] && str [ i ] == str [ i + 2 ] ) { cnt ++ ; i = i + 2 ; } else { i ++ ; } } return cnt ; } static public void Main ( ) { string str = "" aabbbcc "" ; int n = str . Length ; Console . WriteLine ( getCount ( str , n ) ) ; } }";"Minimum characters that are to be inserted such that no three consecutive characters are same | C # implementation of the above approach ; Function to return the count of characters that are to be inserted in str such that no three consecutive characters are same ; To store the count of operations required ; A character needs to be inserted after str [ i + 1 ] ; Current three consecutive characters are not same ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { static int fact ( int n ) { int fact = 1 ; for ( int i = 1 ; i <= n ; i ++ ) fact *= i ; return fact ; } static int countStrings ( String str , int n ) { HashSet < char > distinct_char = new HashSet < char > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { distinct_char . Add ( str [ i ] ) ; } return fact ( distinct_char . Count ) ; } public static void Main ( String [ ] args ) { String str = "" geeksforgeeks "" ; int n = str . Length ; Console . WriteLine ( countStrings ( str , n ) ) ; } }";"Find the number of strings formed using distinct characters of a given string | C # implementation of the approach ; Function to return the factorial of n ; Function to return the count of all possible strings that can be formed with the characters of the given string without repeating characters ; To store the distinct characters of the string str ; Driver code"
C#;"using System ; class GFG { static char getChar ( String str ) { int sum = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { sum += ( str [ i ] - ' a ' + 1 ) ; } if ( sum % 26 == 0 ) return ' z ' ; else { sum = sum % 26 ; return ( char ) ( ' a ' + sum - 1 ) ; } } public static void Main ( String [ ] args ) { String str = "" gfg "" ; Console . WriteLine ( getChar ( str ) ) ; } }";"Find the character made by adding all the characters of the given string | C # implementation of the approach ; Function to return the required character ; To store the sum of the characters of the given string ; Add the current character to the sum ; Return the required character ; Driver code"
C#;"using System ; class GFG { static String reverse ( char [ ] str , int len , int l , int r ) { if ( l < 0 r >= len l > r ) return "" Invalid ▁ range ! "" ; while ( l < r ) { char c = str [ l ] ; str [ l ] = str [ r ] ; str [ r ] = c ; l ++ ; r -- ; } return String . Join ( "" "" , str ) ; } public static void Main ( String [ ] args ) { String str = "" geeksforgeeks "" ; int len = str . Length ; int l = 5 , r = 7 ; Console . WriteLine ( reverse ( str . ToCharArray ( ) , len , l , r ) ) ; } }";"Reverse the given string in the range [ L , R ] | C # implementation of the approach ; Function to return the string after reversing characters in the range [ L , R ] ; Invalid range ; While there are characters to swap ; Swap ( str [ l ] , str [ r ] ) ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { static void encrypt ( char [ ] input ) { char evenPos = ' @ ' , oddPos = ' ! ' ; int repeat , ascii ; for ( int i = 0 ; i < input . Length ; i ++ ) { ascii = input [ i ] ; repeat = ascii >= 97 ? ascii - 96 : ascii - 64 ; for ( int j = 0 ; j < repeat ; j ++ ) { if ( i % 2 == 0 ) Console . Write ( "" { 0 } "" , oddPos ) ; else Console . Write ( "" { 0 } "" , evenPos ) ; } } } public static void Main ( String [ ] args ) { char [ ] input = { ' A ' , ' b ' , ' C ' , ' d ' } ; encrypt ( input ) ; } }";"Program to Encrypt a String using ! and @ | C # program to Encrypt the String using ! and @ ; Function to encrypt the string ; evenPos is for storing encrypting char at evenPosition oddPos is for storing encrypting char at oddPosition ; Get the number of times the character is to be repeated ; if i is odd , print ' ! ' else print ' @ ' ; Driver code ; Encrypt the String"
C#;"using System ; class GFG { static bool IsRedundantBraces ( string A ) { int a = 0 , b = 0 ; for ( int i = 0 ; i < A . Length ; i ++ ) { if ( A [ i ] == ' ( ' && A [ i + 2 ] == ' ) ' ) return true ; if ( A [ i ] == ' * ' A [ i ] == ' + ' A [ i ] == ' - ' A [ i ] == ' / ' ) a ++ ; if ( A [ i ] == ' ( ' ) b ++ ; } if ( b > a ) return true ; return false ; } public static void Main ( String [ ] args ) { String A = "" ( ( ( a + b ) ▁ + ▁ c ) ▁ + ▁ d ) "" ; if ( IsRedundantBraces ( A ) ) { Console . WriteLine ( "" YES "" ) ; } else { Console . WriteLine ( "" NO "" ) ; } } }";"Check if expression contains redundant bracket or not | Set 2 | C # program to check for redundant braces in the string ; Function to check for redundant braces ; count of no of signs ; Driver Code"
C#;"using System ; class GFG { static string balancedBrackets ( string str ) { int dep = 0 ; int minDep = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == ' ( ' ) dep ++ ; else dep -- ; if ( minDep > dep ) minDep = dep ; } if ( minDep < 0 ) { for ( int i = 0 ; i < Math . Abs ( minDep ) ; i ++ ) str = ' ( ' + str ; } dep = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] == ' ( ' ) dep ++ ; else dep -- ; } if ( dep != 0 ) { for ( int i = 0 ; i < dep ; i ++ ) str = str + ' ) ' ; } return str ; } public static void Main ( ) { String str = "" ) ) ) ( ) "" ; Console . WriteLine ( balancedBrackets ( str ) ) ; } }";"Convert an unbalanced bracket sequence to a balanced sequence | C # implementation of the approach ; Function to return balancedBrackets string ; Initializing dep to 0 ; Stores maximum negative depth ; if dep is less than minDep ; if minDep is less than 0 then there is need to add ' ( ' at the front ; Reinitializing to check the updated string ; if dep is not 0 then there is need to add ' ) ' at the back ; Driver code"
C#;"using System ; class GFG { static int minOperations ( string str , int n ) { int count = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( str [ ( i ) ] != str [ ( i + 1 ) ] ) count ++ ; } return ( count + 1 ) / 2 ; } public static void Main ( ) { string str = ""000111"" ; int n = str . Length ; Console . WriteLine ( minOperations ( str , n ) ) ; } }";"Minimum operations required to convert a binary string to all 0 s or all 1 s | C # implementation of the approach ; Function to return the count of minimum operations required ; Increment count when consecutive characters are different ; Answer is rounding off the ( count / 2 ) to lower ; Driver code"
C#;"using System ; class GFG { static int find_digit ( String s , int n ) { int first_digit = - 1 , i ; for ( i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] < '0' s [ i ] > '9' ) { first_digit = i ; break ; } } first_digit ++ ; int s_len = first_digit ; int num = 0 , pw = 1 ; i = n - 1 ; while ( i >= 0 ) { if ( s [ i ] >= '0' && s [ i ] <= '9' ) { int digit = s [ i ] - '0' ; num = num + ( pw * digit ) ; if ( num >= s_len ) return - 1 ; pw = pw * 10 ; } i -- ; } num = num * 10 ; int req = s_len - num ; if ( req > 9 req < 0 ) return - 1 ; return req ; } public static void Main ( String [ ] args ) { String s = "" abcd0"" ; int n = s . Length ; Console . Write ( find_digit ( s , n ) ) ; } }";"Append a digit in the end to make the number equal to the length of the remaining string | C # implementation of the approach ; Function to return the required digit ; To store the position of the first numeric digit in the string ; To store the length of the string without the numeric digits in the end ; pw stores the current power of 10 and num is to store the number which is appended in the end ; If current character is a numeric digit ; Get the current digit ; Build the number ; If number exceeds the length ; Next power of 10 ; Append 0 in the end ; Required number that must be added ; If number is not a single digit ; Driver code"
C#;"using System ; class GFG { static bool canConvert ( string str1 , string str2 ) { int i = 0 , j = 0 ; while ( i < str1 . Length && j < str2 . Length ) { if ( str1 [ i ] != str2 [ j ] ) { if ( str1 [ i ] == '0' && str2 [ j ] == '1' && i + 1 < str1 . Length && str1 [ i + 1 ] == '0' ) { i += 2 ; j ++ ; } else { return false ; } } else { i ++ ; j ++ ; } } if ( i == str1 . Length && j == str2 . Length ) return true ; return false ; } public static void Main ( ) { string str1 = ""00100"" , str2 = ""111"" ; if ( canConvert ( str1 , str2 ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Check whether str1 can be converted to str2 with the given operations | C # implementation of the approach ; Function that returns true if str1 can be converted to str2 with the given operations ; Traverse from left to right ; If the two characters do not match ; If possible to combine ; If not possible to combine ; If the two characters match ; If possible to convert one string to another ; Driver code"
C#;"using System ; using System . Collections ; class GFG { static void reverse ( string s ) { Stack stc = new Stack ( ) ; string temp = "" "" ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == ' ▁ ' ) { stc . Push ( temp ) ; temp = "" "" ; } else { temp = temp + s [ i ] ; } } stc . Push ( temp ) ; while ( stc . Count != 0 ) { temp = ( string ) stc . Peek ( ) ; Console . Write ( temp + "" ▁ "" ) ; stc . Pop ( ) ; } Console . WriteLine ( ) ; } static void Main ( ) { string s = "" I ▁ Love ▁ To ▁ Code "" ; reverse ( s ) ; } }";"Reverse the Words of a String using Stack | C # implementation of the above approach ; Function to reverse the words of the given String without using strtok ( ) . ; Create an empty String stack ; Create an empty temporary String ; Traversing the entire String ; Push the temporary variable into the stack ; Assigning temporary variable as empty ; For the last word of the String ; Get the words in reverse order ; Driver code"
C#;"using System ; class GFG { static void printMatrix ( int n , int m ) { if ( n < 5 m < 5 ) { Console . Write ( - 1 ) ; return ; } char [ ] s = "" aeiou "" . ToCharArray ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < m ; j ++ ) { Console . Write ( s [ j % 5 ] + "" ▁ "" ) ; } Console . WriteLine ( ) ; char c = s [ 0 ] ; for ( int k = 0 ; k < 4 ; k ++ ) { s [ k ] = s [ k + 1 ] ; } s [ 4 ] = c ; } } public static void Main ( String [ ] args ) { int n = 5 , m = 5 ; printMatrix ( n , m ) ; } }";"Print an N x M matrix such that each row and column has all the vowels in it | C # implementation of the approach ; Function to print the required matrix ; Impossible to generate the required matrix ; Store all the vowels ; Print the matrix ; Print vowels for every index ; Shift the vowels by one ; Driver code"
C#;"using System ; class GFG { static bool isTwoAlter ( string s ) { for ( int i = 0 ; i < s . Length - 2 ; i ++ ) { if ( s [ i ] != s [ i + 2 ] ) { return false ; } } if ( s [ 0 ] == s [ 1 ] ) return false ; return true ; } public static void Main ( ) { string str = "" ABAB "" ; if ( isTwoAlter ( str ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Check if a given string is made up of two alternating characters | C # implementation of the approach ; Function that returns true if the string is made up of two alternating characters ; Check if ith character matches with the character at index ( i + 2 ) ; If string consists of a single character repeating itself ; Driver code"
C#;"using System ; class GFG { static int minOperations ( int n , string a , string b , string c ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { char x = a [ i ] ; char y = b [ i ] ; char z = c [ i ] ; if ( x == y && y == z ) { ; } else if ( x == y y == z x == z ) { ans ++ ; } else { ans += 2 ; } } return ans ; } public static void Main ( ) { string a = "" place "" ; string b = "" abcde "" ; string c = "" plybe "" ; int n = a . Length ; Console . Write ( minOperations ( n , a , b , c ) ) ; } }";"Number of character corrections in the given strings to make them equal | C # implementation of the approach ; Function to return the count of operations required ; To store the count of operations ; No operation required ; One operation is required when any two characters are equal ; Two operations are required when none of the characters are equal ; Return the minimum count of operations required ; Driver code"
C#;"using System ; class GFG { static bool check ( String s ) { int n = s . Length ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] > s [ i + 1 ] ) return true ; } return false ; } public static void Main ( String [ ] args ) { String s = "" geeksforgeeks "" ; if ( check ( s ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Check if string can be made lexicographically smaller by reversing any substring | C # implementation of the approach ; Function that returns true if s can be made lexicographically smaller by reversing a sub - string in s ; Traverse in the string ; Check if s [ i + 1 ] < s [ i ] ; Not possible ; Driver code"
C#;"using System ; class GFG { static int countSubStr ( String str , int n , char x ) { int res = 0 , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == x ) { res += ( ( count + 1 ) * ( n - i ) ) ; count = 0 ; } else count ++ ; } return res ; } public static void Main ( String [ ] args ) { String str = "" abcabc "" ; int n = str . Length ; char x = ' c ' ; Console . WriteLine ( countSubStr ( str , n , x ) ) ; } }";"Count of sub | C # implementation of the approach ; Function to return the count of required sub - strings ; Number of sub - strings from position of current x to the end of str ; To store the number of characters before x ; Driver code"
C#;"using System ; class GFG { static int countSubStr ( string str , int n ) { int len = str . Length ; return ( len - n + 1 ) ; } public static void Main ( ) { string str = "" geeksforgeeks "" ; int n = 5 ; Console . WriteLine ( countSubStr ( str , n ) ) ; } }";"Count of sub | C # implementation of the approach ; Function to return the count of possible sub - strings of length n ; Driver code"
C#;"using System ; class GFG { static int countSubstrings ( string s , char c ) { int n = s . Length ; int cnt = 0 ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] != c ) cnt ++ ; else { sum += ( cnt * ( cnt + 1 ) ) / 2 ; cnt = 0 ; } } sum += ( cnt * ( cnt + 1 ) ) / 2 ; return sum ; } public static void Main ( ) { string s = "" baa "" ; char c = ' b ' ; Console . Write ( countSubstrings ( s , c ) ) ; } }";"Count of sub | C # implementation of the approach ; Function to return the number of sub - strings that do not contain the given character c ; Length of the string ; Traverse in the string ; If current character is different from the given character ; Update the number of sub - strings ; Reset count to 0 ; For the characters appearing after the last occurrence of c ; Driver code"
C#;"using System ; class GfG { static int getMinimizedSum ( string str , int len ) { int i , maxVal = Int32 . MinValue , sum = 0 ; int [ ] occurrences = new int [ 26 ] ; for ( i = 0 ; i < len ; i ++ ) { occurrences [ str [ i ] - ' a ' ] ++ ; sum += ( int ) str [ i ] ; } for ( i = 0 ; i < 26 ; i ++ ) maxVal = Math . Max ( maxVal , occurrences [ i ] * ( i + ' a ' ) ) ; return ( sum - maxVal ) ; } public static void Main ( ) { string str = "" geeksforgeeks "" ; int len = str . Length ; Console . WriteLine ( getMinimizedSum ( str , len ) ) ; } }";"Minimize ASCII values sum after removing all occurrences of one character | C # implementation of the approach ; Function to return the minimized sum ; To store the occurrences of each character of the string ; Update the occurrence ; Calculate the sum ; Get the character which is contributing the maximum value to the sum ; Count of occurrence of the character multiplied by its ASCII value ; Return the minimized sum ; Driver code"
C#;"using System ; class GFG { static bool isPalindrome ( string s ) { int i = 0 ; int j = s . Length - 1 ; while ( i < j ) { if ( s [ i ] != s [ j ] ) return false ; i ++ ; j -- ; } return true ; } static int getIndex ( string S1 , string S2 , int n ) { string S = "" "" ; for ( int i = 0 ; i < n ; i ++ ) { S = S + S1 [ i ] ; string Temp = "" "" ; for ( int j = i + 1 ; j < n ; j ++ ) Temp += S2 [ j ] ; if ( isPalindrome ( S + Temp ) ) { return i ; } } return - 1 ; } public static void Main ( ) { string S1 = "" abcdf "" , S2 = "" sfgba "" ; int n = S1 . Length ; Console . WriteLine ( getIndex ( S1 , S2 , n ) ) ; } }";"Find index i such that prefix of S1 and suffix of S2 till i form a palindrome when concatenated | C # implementation of the approach ; Function that returns true if s is palindrome ; Function to return the required index ; Copy the ith character in S ; Copy all the character of string s2 in Temp ; Check whether the string is palindrome ; Driver code"
C#;"using System ; class GFG { static bool isPalindrome ( string s , int i , int j ) { while ( i < j ) { if ( s [ i ] != s [ j ] ) return false ; i ++ ; j -- ; } return true ; } static int getIndex ( string s1 , string s2 , int len ) { int i = 0 , j = len - 1 ; while ( i < j ) { if ( s1 [ i ] != s2 [ j ] ) { break ; } i ++ ; j -- ; } if ( i == j ) { return i - 1 ; } else if ( isPalindrome ( s2 , i , j ) ) return i - 1 ; else if ( isPalindrome ( s1 , i , j ) ) return j ; return - 1 ; } public static void Main ( ) { string s1 = "" abcdf "" , s2 = "" sfgba "" ; int len = s1 . Length ; Console . WriteLine ( getIndex ( s1 , s2 , len ) ) ; } }";"Find index i such that prefix of S1 and suffix of S2 till i form a palindrome when concatenated | C # implementation of the above approach ; Function that returns true if the sub - String starting from index i and ending at index j is a palindrome ; Function to get the required index ; Start comparing the two Strings from both ends . ; Break from the loop at first mismatch ; If it is possible to concatenate the Strings to form palindrome , return index ; If remaining part for s2 is palindrome ; If remaining part for s1 is palindrome ; If not possible , return - 1 ; Driver Code"
C#;"using System ; class GFG { static int count_acronym ( int n , string [ ] arr ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ arr [ i ] [ 0 ] - ' a ' ] ++ ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { string st = arr [ i ] ; int [ ] num = new int [ 26 ] ; for ( int j = 0 ; j < st . Length ; j ++ ) num [ st [ j ] - ' a ' ] ++ ; bool flag = true ; for ( int j = 1 ; j < 26 ; j ++ ) { if ( num [ j ] > freq [ j ] ) { flag = false ; break ; } } int x = st [ 0 ] - ' a ' ; if ( freq [ x ] - 1 < num [ x ] ) flag = false ; if ( flag ) cnt ++ ; } return cnt ; } public static void Main ( ) { string [ ] arr = { "" abc "" , "" bcad "" , "" cabd "" , "" cba "" , "" dzzz "" } ; int n = arr . Length ; Console . WriteLine ( count_acronym ( n , arr ) ) ; } }";"Acronym words | C # implementation of the approach ; Function to return the number of strings that can be an acronym for other strings ; Frequency array to store the frequency of the first character of every string in the array ; To store the count of required strings ; Current word ; Frequency array to store the frequency of each of the character of the current string ; Check if the frequency of every character in the current string is <= its value in freq [ ] ; First character of the current string ; Driver code"
C#;"using System ; class GFG { static bool valid ( int [ ] cnt ) { for ( int i = 0 ; i < 26 ; i ++ ) { if ( cnt [ i ] >= 2 ) return false ; } return true ; } static string getGoodString ( string ss , int n ) { char [ ] s = ss . ToCharArray ( ) ; if ( n < 26 ) return "" - 1"" ; int [ ] cnt = new int [ 27 ] ; for ( int i = 25 ; i < n ; i ++ ) { for ( int j = i ; j >= i - 25 ; j -- ) { if ( s [ j ] != ' ? ' ) cnt [ ( ( int ) s [ j ] - ( int ) ' a ' ) ] ++ ; } if ( valid ( cnt ) ) { int cur = 0 ; while ( cnt [ cur ] > 0 ) cur ++ ; for ( int j = i - 25 ; j <= i ; j ++ ) { if ( s [ j ] == ' ? ' ) { s [ j ] = ( char ) ( cur + ( int ) ( ' a ' ) ) ; cur ++ ; while ( cnt [ cur ] > 0 ) cur ++ ; } } return new String ( s ) ; } } return "" - 1"" ; } static void Main ( ) { string s = "" abcdefghijkl ? nopqrstuvwxy ? "" ; int n = s . Length ; Console . WriteLine ( getGoodString ( s , n ) ) ; } }";"Sub | C # implementation of the approach ; Function that returns true if every lowercase character appears atmost once ; every character frequency must be not greater than one ; Function that returns the modified good string if possible ; If the length of the string is less than n ; To store frequency of each character ; Sub - strings of length 26 ; Get the frequency of each character in the current sub - string ; Check if we can get sub - string containing all the 26 characters ; Find which character is missing ; Fill with missing characters ; Find the next missing character ; Return the modified good string ; Driver code"
C#;"using System ; class GFG { static bool isVowel ( char c ) { c = char . ToLower ( c ) ; if ( c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) { return true ; } return false ; } static String swapRepeated ( char [ ] str ) { for ( int i = 0 ; i < str . Length - 1 ; i ++ ) { char c = ( char ) 0 ; if ( ( isVowel ( str [ i ] ) && isVowel ( str [ i + 1 ] ) ) || ( ! isVowel ( str [ i ] ) && ! isVowel ( str [ i + 1 ] ) ) ) { c = str [ i ] ; str [ i ] = str [ i + 1 ] ; str [ i + 1 ] = c ; } } return String . Join ( "" "" , str ) ; } public static void Main ( String [ ] args ) { String str = "" geeksforgeeks "" ; Console . WriteLine ( swapRepeated ( str . ToCharArray ( ) ) ) ; } }";"Modify the string by swapping continuous vowels or consonants | C # implementation of the above approach ; Function to check if a character is a vowel ; Function to swap two consecutively repeated vowels or consonants ; Traverse through the length of the string ; Check if the two consecutive characters are vowels or consonants ; swap the two characters ; Driver code"
C#;"using System ; class GFG { static string largestPalinSub ( string s ) { string res = "" "" ; char mx = s [ 0 ] ; for ( int i = 1 ; i < s . Length ; i ++ ) mx = ( char ) Math . Max ( ( int ) mx , ( int ) s [ i ] ) ; for ( int i = 0 ; i < s . Length ; i ++ ) if ( s [ i ] == mx ) res += s [ i ] ; return res ; } public static void Main ( ) { string s = "" geeksforgeeks "" ; Console . WriteLine ( largestPalinSub ( s ) ) ; } }";"Find the lexicographically largest palindromic Subsequence of a String | C # program to find the largest palindromic subsequence ; Function to find the largest palindromic subsequence ; Find the largest character ; Append all occurrences of largest character to the resultant string ; Driver Code"
C#;"using System ; class GFG { static void printString ( char [ ] str , int n ) { int ones = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) ones ++ ; bool used = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '2' && ! used ) { used = true ; for ( int j = 0 ; j < ones ; j ++ ) Console . Write ( ""1"" ) ; } if ( str [ i ] != '1' ) Console . Write ( str [ i ] ) ; } if ( ! used ) for ( int j = 0 ; j < ones ; j ++ ) Console . Write ( ""1"" ) ; } public static void Main ( String [ ] args ) { String str = ""100210"" ; int n = str . Length ; printString ( str . ToCharArray ( ) , n ) ; } }";"Generate lexicographically smallest string of 0 , 1 and 2 with adjacent swaps allowed | C # implementation of the approach ; Function to print the required string ; count number of 1 s ; To check if the all the 1 s have been used or not ; Print all the 1 s if any 2 is encountered ; If str [ i ] = 0 or str [ i ] = 2 ; If 1 s are not printed yet ; Driver code"
C#;"using System ; class solution { static int findPermutation ( string str , int k ) { bool [ ] has = new bool [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) has [ i ] = false ; int cnt = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( ! has [ str [ i ] - ' a ' ] ) { cnt ++ ; has [ str [ i ] - ' a ' ] = true ; } } int ans = 1 ; for ( int i = 2 ; i <= cnt ; i ++ ) ans *= i ; for ( int i = cnt - k ; i > 1 ; i -- ) ans /= i ; return ans ; } public static void Main ( ) { string str = "" geeksforgeeks "" ; int k = 4 ; Console . WriteLine ( findPermutation ( str , k ) ) ; } }";"K length words that can be formed from given characters without repetition | C # implementation of the approach ; Function to return the required count ; To store the count of distinct characters in str ; Traverse str character by character ; If current character is appearing for the first time in str ; Increment the distinct character count ; Update the appearance of the current character ; Since P ( n , r ) = n ! / ( n - r ) ! ; Return the answer ; Driver code"
C#;"using System ; class GFG { static int product ( int x ) { int prod = 1 ; while ( x > 0 ) { prod *= ( x % 10 ) ; x /= 10 ; } return prod ; } static int findNumber ( int l , int r ) { string b = r . ToString ( ) ; int ans = r ; for ( int i = 0 ; i < b . Length ; i ++ ) { if ( b [ i ] == '0' ) continue ; char [ ] curr = b . ToCharArray ( ) ; curr [ i ] = ( char ) ( ( ( int ) ( curr [ i ] - ( int ) '0' ) - 1 ) + ( int ) ( '0' ) ) ; for ( int j = i + 1 ; j < curr . Length ; j ++ ) curr [ j ] = '9' ; int num = 0 ; for ( int j = 0 ; j < curr . Length ; j ++ ) num = num * 10 + ( curr [ j ] - '0' ) ; if ( num >= l && product ( ans ) < product ( num ) ) ans = num ; } return ans ; } static void Main ( ) { int l = 1 , r = 10 ; Console . WriteLine ( findNumber ( l , r ) ) ; l = 51 ; r = 62 ; Console . WriteLine ( findNumber ( l , r ) ) ; } }";"Find the number in a range having maximum product of the digits | C # Program to find the number in a range having maximum product of the digits ; Returns the product of digits of number x ; This function returns the number having maximum product of the digits ; Converting both integers to strings string a = l . ToString ( ) ; ; Let the current answer be r ; Stores the current number having current digit one less than current digit in b ; Replace all following digits with 9 to maximise the product ; Convert string to number ; Check if it lies in range and its product is greater than max product ; Driver Code"
C#;"using System ; class GFG { static void printExpansion ( String str ) { for ( int i = ( int ) str . Length - 1 ; i >= 0 ; i -- ) { String subStr = str . Substring ( i ) ; Console . Write ( subStr ) ; } } static public void Main ( String [ ] args ) { String str = "" geeks "" ; printExpansion ( str ) ; } }";"Concatenate suffixes of a String | C # implementation of the approach ; Function to print the expansion of the string ; Take sub - string from i to n - 1 ; Print the sub - string ; Driver code"
C#;"using System ; class GFG { static void constructBinString ( int a , int b , int x ) { int d , i ; d = x / 2 ; if ( x % 2 == 0 && x / 2 != a ) { d -- ; Console . Write ( ""0"" ) ; a -- ; } for ( i = 0 ; i < d ; i ++ ) Console . Write ( ""10"" ) ; a = a - d ; b = b - d ; for ( i = 0 ; i < b ; i ++ ) { Console . Write ( ""1"" ) ; } for ( i = 0 ; i < a ; i ++ ) { Console . Write ( ""0"" ) ; } } public static void Main ( ) { int a = 4 , b = 3 , x = 2 ; constructBinString ( a , b , x ) ; } }";"Construct a binary string following the given constraints | C # implementation of the approach ; Function to print a binary string which has ' a ' number of 0 ' s , ▁ ' b ' ▁ number ▁ of ▁ 1' s and there are at least ' x ' indices such that s [ i ] != s [ i + 1 ] ; Divide index value by 2 and store it into d ; If index value x is even and x / 2 is not equal to a ; Loop for d for each d print 10 ; subtract d from a and b ; Loop for b to print remaining 1 's ; Loop for a to print remaining 0 's ; Driver code"
C#;"using System ; public class GFG { static bool matchPattern ( string s ) { int count = 0 ; int n = s . Length ; int i = 0 ; while ( i < n ) { while ( i < n && s [ i ] == ' a ' ) { count ++ ; i ++ ; } while ( i < n && s [ i ] == ' b ' ) { count -- ; i ++ ; } if ( count != 0 ) return false ; } return true ; } public static void Main ( ) { string s = "" bb "" ; if ( matchPattern ( s ) == true ) Console . Write ( "" Yes "" ) ; else Console . Write ( "" No "" ) ; } }";"Check If every group of a ' s ▁ is ▁ followed ▁ by ▁ a ▁ group ▁ of ▁ b ' s of same length | C # implementation of the above approach ; Function to match whether there are always n consecutive b ' s ▁ followed ▁ by ▁ n ▁ consecutive ▁ a ' s throughout the string ; Traverse through the string ; Count a 's in current segment ; Count b 's in current segment ; If both counts are not same . ; Driver code"
C#;"using System ; class GFG { static int maximum_one ( string s , int n ) { int cnt_one = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) cnt_one ++ ; } int [ ] left = new int [ n ] ; int [ ] right = new int [ n ] ; if ( s [ 0 ] == '1' ) left [ 0 ] = 1 ; else left [ 0 ] = 0 ; if ( s [ n - 1 ] == '1' ) right [ n - 1 ] = 1 ; else right [ n - 1 ] = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) left [ i ] = left [ i - 1 ] + 1 ; else left [ i ] = 0 ; } for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( s [ i ] == '1' ) right [ i ] = right [ i + 1 ] + 1 ; else right [ i ] = 0 ; } int cnt = 0 , max_cnt = 0 ; for ( int i = 1 ; i < n - 1 ; i ++ ) { if ( s [ i ] == '0' ) { int sum = left [ i - 1 ] + right [ i + 1 ] ; if ( sum < cnt_one ) cnt = sum + 1 ; else cnt = sum ; max_cnt = Math . Max ( max_cnt , cnt ) ; cnt = 0 ; } } return max_cnt ; } public static void Main ( ) { string s = ""111011101"" ; Console . WriteLine ( maximum_one ( s , s . Length ) ) ; } }";"Length of longest consecutive ones by at most one swap in a Binary String | C # program to find length of longest consecutive ones by at most one swap in a Binary String ; Function to calculate the length of the longest consecutive 1 's ; To count all 1 's in the string ; To store cumulative 1 's ; Counting cumulative 1 's from left ; If 0 then start new cumulative one from that i ; perform step 3 of the approach ; step 3 ; Driver Code ; string"
C#;"using System ; using System . Collections . Generic ; class GFG { static string MaxFreq ( string str ) { int n = str . Length ; Dictionary < string , int > m = new Dictionary < string , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { string sp = "" "" ; for ( int j = i ; j < n ; j ++ ) { sp += str [ j ] ; if ( m . ContainsKey ( sp ) ) { m [ sp ] ++ ; } else { m [ sp ] = 1 ; } } } int maxi = 0 ; string s = "" "" ; foreach ( KeyValuePair < string , int > i in m ) { if ( i . Value > maxi ) { maxi = i . Value ; s = i . Key ; } else if ( i . Value == maxi ) { string ss = i . Key ; if ( ss . Length > s . Length ) s = ss ; } } return s ; } public static void Main ( string [ ] args ) { string str = "" ababecdecd "" ; Console . Write ( MaxFreq ( str ) ) ; } }";"Maximum length substring with highest frequency in a string | C # program to find maximum occurred substring of a string ; Function to return maximum occurred substring of a string ; Size of the string ; To store maximum frequency ; To store string which has maximum frequency ; Return substring which has maximum frequency ; Driver Code ; Function call"
C#;"using System ; class GFG { static int maxFreq ( string s , int a , int b ) { int [ ] fre = new int [ 10 ] ; int n = s . Length ; if ( a > b ) { int temp = a ; a = b ; b = temp ; } for ( int i = 0 ; i < n ; i ++ ) fre [ s [ i ] - '0' ] ++ ; if ( fre [ a ] == 0 && fre [ b ] == 0 ) return - 1 ; else if ( fre [ a ] >= fre [ b ] ) return a ; else return b ; } public static void Main ( ) { int a = 4 , b = 7 ; string s = ""47744"" ; Console . WriteLine ( maxFreq ( s , a , b ) ) ; } }";"Lexicographically smallest substring with maximum occurrences containing a ' s ▁ and ▁ b ' s only | C # program to Find the lexicographically smallest substring in a given string with maximum frequency and contains a ' s ▁ and ▁ b ' s only ; Function to Find the lexicographically smallest substring in a given string with maximum frequency and contains a ' s ▁ and ▁ b ' s only . ; To store frequency of digits ; size of string ; Take lexicographically larger digit in b ; get frequency of each character ; If no such string exits ; Maximum frequency ; Driver program"
C#;"using System ; class GFG { static void convert ( int n , String a , String b ) { int [ ] l = new int [ n ] ; int i ; for ( i = 0 ; i < n ; i ++ ) l [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] ) l [ i ] = 1 ; } int cc = 0 ; int vl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( l [ i ] == 0 ) { if ( vl != 0 ) cc += 1 ; vl = 0 ; } else vl += 1 ; } if ( vl != 0 ) cc += 1 ; Console . WriteLine ( cc ) ; } static public void Main ( ) { String a = ""101010"" ; String b = ""110011"" ; int n = a . Length ; convert ( n , a , b ) ; } }";"Minimum steps to convert one binary string to other only using negation | C # implementation of the above approach ; Function to find the minimum steps to convert string a to string b ; array to mark the positions needed to be negated ; If two character are not same then they need to be negated ; To count the blocks of 1 ; To count the number of 1 ' s ▁ in ▁ ▁ each ▁ block ▁ of ▁ 1' s ; For the last block of 1 's ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { static void StringMatch ( String s ) { int lo = 0 , hi = s . Length , len = s . Length ; List < int > ans = new List < int > ( ) ; for ( int x = 0 ; x < len ; x ++ ) { if ( s [ x ] == ' I ' ) { ans . Add ( lo ) ; lo += 1 ; } else { ans . Add ( hi ) ; hi -= 1 ; } } ans . Add ( lo ) ; Console . Write ( "" [ "" ) ; for ( int i = 0 ; i < ans . Count ; i ++ ) { Console . Write ( ans [ i ] ) ; if ( i != ans . Count - 1 ) Console . Write ( "" , "" ) ; } Console . Write ( "" ] "" ) ; } public static void Main ( String [ ] args ) { String S = "" IDID "" ; StringMatch ( S ) ; } }";"Generate a sequence with the given operations | C # Implementation of above approach ; function to find minimum required permutation ; Driver code"
C#;"using System ; class GFG { static int countWays ( string s1 , string s2 , int n ) { int a , b , c , d ; a = b = c = d = 0 ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s2 [ i ] == '0' ) { if ( s1 [ i ] == '0' ) { c ++ ; } else { d ++ ; } } else { if ( s1 [ i ] == '0' ) { a ++ ; } else { b ++ ; } } } result = a * d + b * c + c * d ; return result ; } public static void Main ( ) { int n = 5 ; string s1 = ""01011"" ; string s2 = ""11001"" ; Console . WriteLine ( countWays ( s1 , s2 , n ) ) ; } }";"Number of ways to swap two bit of s1 so that bitwise OR of s1 and s2 changes | C # program to find no of ways to swap bits of s1 so that bitwise OR of s1 and s2 changes ; Function to find number of ways ; initialise result that store No . of swaps required ; Traverse both strings and check the bits as explained ; calculate result ; Driver code"
C#;"using System ; class GfG { static int returnWinner ( String s , int l ) { int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < l ; i ++ ) { freq [ s [ i ] - ' a ' ] ++ ; } int cnt = 0 ; for ( int i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] % 2 != 0 ) cnt ++ ; } if ( ( cnt == 0 ) || ( cnt & 1 ) == 1 ) return 1 ; else return 2 ; } public static void Main ( String [ ] args ) { String s = "" abaaab "" ; int l = s . Length ; int winner = returnWinner ( s , l ) ; Console . WriteLine ( "" Player - "" + winner ) ; } }";"Find the player who rearranges the characters to get a palindrome string first | C # program to print the winner of the game ; Function that returns the winner of the game ; Initialize the freq array to 0 ; Iterate and count the frequencies of each character in the string ; Count the odd occurring character ; If odd occurrence ; Check condition for Player - 1 winning the game ; Driver code ; Function call that returns the winner"
C#;"using System ; class GFG { static void maxProductSum ( string str , int m ) { int n = str . Length ; int maxProd = int . MinValue , maxSum = int . MinValue ; for ( int i = 0 ; i <= n - m ; i ++ ) { int product = 1 , sum = 0 ; for ( int j = i ; j < m + i ; j ++ ) { product = product * ( str [ j ] - '0' ) ; sum = sum + ( str [ j ] - '0' ) ; } maxProd = Math . Max ( maxProd , product ) ; maxSum = Math . Max ( maxSum , sum ) ; } Console . WriteLine ( "" Maximum ▁ Product ▁ = ▁ "" + maxProd ) ; Console . Write ( "" STRNEWLINE Maximum ▁ Sum ▁ = ▁ "" + maxSum ) ; } public static void Main ( ) { string str = ""3605356297"" ; int m = 3 ; maxProductSum ( str , m ) ; } }";"Maximum sum and product of the M consecutive digits in a number | C # implementation of the above approach ; Function to find the maximum product ; Driver code"
C#;"using System ; public class Solution { static bool isVowel ( char ch ) { if ( ch != ' a ' && ch != ' e ' && ch != ' i ' && ch != ' o ' && ch != ' u ' ) return false ; return true ; } static String replacingConsonants ( String s ) { for ( int i = 0 ; i < s . Length ; i ++ ) { if ( isVowel ( s [ i ] ) ) continue ; else { if ( s [ i ] > ' a ' && s [ i ] < ' e ' ) { if ( Math . Abs ( s [ i ] - ' a ' ) > Math . Abs ( s [ i ] - ' e ' ) ) s = s . Substring ( 0 , i ) + ' e ' + s . Substring ( i + 1 ) ; else s = s . Substring ( 0 , i ) + ' a ' + s . Substring ( i + 1 ) ; } else if ( s [ i ] > ' e ' && s [ i ] < ' i ' ) { if ( Math . Abs ( s [ i ] - ' e ' ) > Math . Abs ( s [ i ] - ' i ' ) ) s = s . Substring ( 0 , i ) + ' i ' + s . Substring ( i + 1 ) ; else s = s . Substring ( 0 , i ) + ' e ' + s . Substring ( i + 1 ) ; } else if ( s [ i ] > ' i ' && s [ i ] < ' o ' ) { if ( Math . Abs ( s [ i ] - ' i ' ) > Math . Abs ( s [ i ] - ' o ' ) ) s = s . Substring ( 0 , i ) + ' o ' + s . Substring ( i + 1 ) ; else s = s . Substring ( 0 , i ) + ' i ' + s . Substring ( i + 1 ) ; } else if ( s [ i ] > ' o ' && s [ i ] < ' u ' ) { if ( Math . Abs ( s [ i ] - ' o ' ) > Math . Abs ( s [ i ] - ' u ' ) ) s = s . Substring ( 0 , i ) + ' u ' + s . Substring ( i + 1 ) ; else s = s . Substring ( 0 , i ) + ' o ' + s . Substring ( i + 1 ) ; } else if ( s [ i ] > ' u ' ) s = s . Substring ( 0 , i ) + ' u ' + s . Substring ( i + 1 ) ; } } return s ; } public static void Main ( ) { String s = "" geeksforgeeks "" ; Console . WriteLine ( replacingConsonants ( s ) ) ; } }";"Replace all consonants with nearest vowels in a string | C # program to replace all consonants with nearest vowels in a string ; Function to check if a character is vowel or not ; Function to replace consonant with nearest vowels ; if , string element is vowel , jump to next element ; check if consonant lies between two vowels , if it lies , than replace it with nearest vowel ; here the bsolute difference of ascii value is considered ; when s [ i ] is equal to either ' v ' , ' w ' , ' x ' , ' y ' , ' z ' ; Driver code"
C#;"using System ; class GFG { static int maxLength ( string s , int n ) { int right = 0 , left = 0 ; int coun = 0 , max_length = int . MinValue ; s = s + '1' ; for ( int i = 0 ; i <= n ; i ++ ) { if ( s [ i ] == ' o ' ) coun ++ ; else { if ( coun > max_length ) { right = 0 ; left = 0 ; if ( s [ i ] == ' x ' ) right = 1 ; if ( ( ( i - coun ) > 0 ) && ( s [ i - coun - 1 ] == ' x ' ) ) left = 1 ; coun = ( int ) Math . Ceiling ( ( double ) coun / ( right + left ) ) ; max_length = Math . Max ( max_length , coun ) ; } coun = 0 ; } } return max_length ; } public static void Main ( ) { string s = "" oooxoooooooooxooo "" ; int n = s . Length ; Console . Write ( maxLength ( s , n ) ) ; } }";"Find time taken for signal to reach all positions in a string | C # program to Find time taken for signal to reach all positions in a string ; Returns time needed for signal to traverse through complete string . ; for the calculation of last index ; for strings like oxoooo , xoxxoooo . . ; if coun is greater than max_length ; if ' x ' is present at the right side of max_length ; if ' x ' is present at left side of max_length ; We use ceiling function to handle odd number ' o ' s ; Driver code"
C#;"using System ; class GFG { static String printLargestString ( String s , int l , int r ) { int [ ] freq = new int [ 26 ] ; l -- ; r -- ; for ( int i = Math . Min ( l , r ) ; i <= Math . Max ( l , r ) ; i ++ ) { freq [ s [ i ] - ' a ' ] ++ ; } String ans = "" "" ; for ( int i = 25 ; i >= 0 ; i -- ) { while ( freq [ i ] > 0 ) { ans += ( char ) ( ' a ' + i ) ; freq [ i ] -- ; } } return ans ; } public static void Main ( ) { String s = "" striver "" ; int l = 3 , r = 5 ; Console . Write ( printLargestString ( s , l , r ) ) ; } }";"Lexicographically largest string formed from the characters in range L and R | C # program to print the lexicographically largest String that can be formed from the characters in range L and R ; Function to return the lexicographically largest String ; hash array ; make 0 - based indexing ; iterate and count frequencies of character ; ans String ; iterate in frequency array ; add til all characters are added ; Driver Code"
C#;"using System ; class GFG { static void arrange ( String s ) { int cc = 0 ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( s [ i ] == '1' ) cc ++ ; } int [ ] a = new int [ s . Length + 1 ] ; int [ , ] qq = { { 2 , 3 } , { 5 , 5 } } ; int n = qq . GetLength ( 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { int l = qq [ i , 0 ] , r = qq [ i , 1 ] ; l -- ; r -- ; a [ l ] ++ ; a [ r + 1 ] -- ; } int len_a = a . Length ; for ( int i = 1 ; i < len_a ; i ++ ) { a [ i ] += a [ i - 1 ] ; } int [ ] zz = new int [ s . Length ] ; for ( int i = 0 ; i < len_a - 1 ; i ++ ) { if ( a [ i ] > 0 ) { if ( cc > 0 ) { zz [ i ] = 1 ; cc -- ; } else break ; } if ( cc == 0 ) break ; } if ( cc > 0 ) { for ( int i = 0 ; i < s . Length ; i ++ ) { if ( zz [ i ] == 0 ) { zz [ i ] = 1 ; cc -- ; } if ( cc == 0 ) break ; } } for ( int i = 0 ; i < s . Length ; i ++ ) Console . Write ( zz [ i ] ) ; Console . WriteLine ( ) ; } public static void Main ( String [ ] args ) { String str = ""11100"" ; arrange ( str ) ; } }";"Arrange a binary string to get maximum value within a range of indices | C # implementation of the approach ; Storing the count of 1 's in the String ; Query of l and r ; Applying range update technique . ; Taking prefix sum to get the range update values ; Final array which will store the arranged String ; if after maximizing the ranges any 1 is left then we maximize the String lexicographically . ; Driver Code"
C#;"using System ; class GFG { public static bool areVowelsInOrder ( string s ) { int n = s . Length ; char c = ( char ) 64 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' a ' s [ i ] == ' e ' s [ i ] == ' i ' s [ i ] == ' o ' s [ i ] == ' u ' ) { if ( s [ i ] < c ) { return false ; } else { c = s [ i ] ; } } } return true ; } public static void Main ( string [ ] args ) { string s = "" aabbbddeecc "" ; if ( areVowelsInOrder ( s ) ) { Console . Write ( "" Yes "" ) ; } else { Console . Write ( "" No "" ) ; } } }";"Check whether the vowels in a string are in alphabetical order or not | C # implementation of above approach ; Function that checks whether the vowel characters in a string are in alphabetical order or not ; ASCII Value 64 is less than all the alphabets so using it as a default value ; check if the vowels in the string are sorted or not ; if the vowel is smaller than the previous vowel ; store the vowel ; Driver code ; check whether the vowel characters in a string are in alphabetical order or not"
C#;"using System ; class GFG { static String newString ( string s ) { int l = s . Length ; int [ ] freq = new int [ 26 ] ; for ( int i = 0 ; i < l ; i ++ ) { freq [ s [ i ] - ' a ' ] += 1 ; } string ans = "" "" ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 0 ; j < freq [ i ] ; j ++ ) { ans += ( char ) ( 97 + i ) ; } } return ans ; } public static void Main ( ) { string s = "" aabab "" ; Console . Write ( newString ( s ) ) ; } }";"Rearrange the string to maximize the number of palindromic substrings | C # program to rearrange the string such to maximize the number of palindromic substrings ; Function to return the newString ; length of string ; hashing array ; iterate and count ; resulting string ; form the resulting string ; number of times character appears ; append to resulting string ; Driver code"
C#;"using System ; class GFG { static int Remainder ( String str , int R ) { int len = str . Length ; int Num , Rem = 0 ; for ( int i = 0 ; i < len ; i ++ ) { Num = Rem * 10 + ( str [ i ] - '0' ) ; Rem = Num % R ; } return Rem ; } public static void Main ( ) { String str = ""13589234356546756"" ; int R = 13 ; Console . WriteLine ( Remainder ( str , R ) ) ; } }";"Program to find remainder when large number is divided by r | C # implementation to find Remainder when a large Number is divided by R ; Function to Return Remainder ; len is variable to store the length of Number string . ; loop that find Remainder ; Return the remainder ; Driver code ; Get the large number as string ; Get the divisor R ; Find and print the remainder"
C#;"using System ; class GFG { public static void countWays ( int [ ] a , int n ) { int i , j ; long [ ] suff = new long [ n ] ; if ( a [ n - 1 ] == 2 ) suff [ n - 1 ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] == 2 ) suff [ i ] = suff [ i + 1 ] + 1 ; else suff [ i ] = suff [ i + 1 ] ; } long ss = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ss += suff [ i ] ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ i ] == 1 && a [ j ] == 1 && suff [ j ] >= 2 ) { ss += ( suff [ j ] ) * ( suff [ j ] - 1 ) / 2 ; } } } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ i ] == 1 && a [ j ] == 1 && ( suff [ i ] - suff [ j ] ) >= 1 && suff [ j ] >= 1 ) { ss += ( suff [ i ] - suff [ j ] ) * suff [ j ] ; } } } Console . WriteLine ( ss ) ; } public static void Main ( ) { int [ ] a = { 1 , 2 , 1 , 1 , 2 , 2 } ; int n = 6 ; countWays ( a , n ) ; } }";"Number of balanced bracket subsequence of length 2 and 4 | C # implementation of above approach ; Taking the frequency suffix sum of the number of 2 's  present after every index ; Storing the count of subsequence ; Subsequence of length 2 ; Subsequence of length 4 of type 1 1 2 2 ; Subsequence of length 4 of type 1 2 1 2 ; Driver Code"
C#;"using System ; class GFG { static int count_carry ( string a , string b ) { int carry = 0 ; int count = 0 ; int len_a = a . Length , len_b = b . Length ; while ( len_a != 0 len_b != 0 ) { int x = 0 , y = 0 ; if ( len_a > 0 ) { x = a [ len_a - 1 ] - '0' ; len_a -- ; } if ( len_b > 0 ) { y = b [ len_b - 1 ] - '0' ; len_b -- ; } int sum = x + y + carry ; if ( sum >= 10 ) { carry = 1 ; count ++ ; } else carry = 0 ; } return count ; } public static void Main ( ) { string a = ""9555"" , b = ""555"" ; int count = count_carry ( a , b ) ; if ( count == 0 ) Console . Write ( ""0 STRNEWLINE "" ) ; else if ( count == 1 ) Console . Write ( ""1 STRNEWLINE "" ) ; else Console . Write ( count ) ; } }";"Count the number of carry operations required to add two numbers | C # implementation of above approach ; Function to count the number of carry operations ; Initialize the value of carry to 0 ; Counts the number of carry operations ; Initialize len_a and len_b with the sizes of strings ; Assigning the ascii value of the character ; Add both numbers / digits ; If sum > 0 , increment count and set carry to 1 ; Else , set carry to 0 ; Driver code"
C#;"using System ; class GFG { static bool isInGivenBase ( String str , int bas ) { if ( bas > 16 ) return false ; else if ( bas <= 10 ) { for ( int i = 0 ; i < str . Length ; i ++ ) if ( ! ( str [ i ] >= '0' && str [ i ] < ( '0' + bas ) ) ) return false ; } else { for ( int i = 0 ; i < str . Length ; i ++ ) if ( ! ( ( str [ i ] >= '0' && str [ i ] < ( '0' + bas ) ) || ( str [ i ] >= ' A ' && str [ i ] < ( ' A ' + bas - 10 ) ) ) ) return false ; } return true ; } public static void Main ( String [ ] args ) { String str = "" AF87"" ; if ( isInGivenBase ( str , 16 ) == true ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Check if a number is in given base or not | C # program to check if given number is in given base or not . ; Allowed base are till 16 ( Hexadecimal ) ; If bas is below or equal to 10 , then all digits should be from 0 to 9. ; If base is below or equal to 16 , then all digits should be from 0 to 9 or from ' A ' ; Driver Code"
C#;"using System ; class GFG { static void printIndex ( String str , String s ) { bool flag = false ; for ( int i = 0 ; i < str . Length - s . Length + 1 ; i ++ ) { if ( str . Substring ( i , s . Length ) . Equals ( s ) ) { Console . Write ( i + "" ▁ "" ) ; flag = true ; } } if ( flag == false ) { Console . WriteLine ( "" NONE "" ) ; } } public static void Main ( String [ ] args ) { String str1 = "" GeeksforGeeks "" ; String str2 = "" Geeks "" ; printIndex ( str1 , str2 ) ; } }";"Find indices of all occurrence of one string in other | C # program to find indices of all occurrences of one String in other . ; Driver code"
C#;"using System ; class GFG { static string merge ( string s1 , string s2 ) { string result = "" "" ; for ( int i = 0 ; i < s1 . Length < s2 . Length ; i ++ ) { if ( i < s1 . Length ) result += s1 [ i ] ; if ( i < s2 . Length ) result += s2 [ i ] ; } return result ; } static void Main ( ) { string s1 = "" geeks "" ; string s2 = "" forgeeks "" ; Console . WriteLine ( merge ( s1 , s2 ) ) ; } }";"Alternatively Merge two Strings in Java | C # code to alternatively merge two strings ; Function for alternatively merging two strings ; To store the final string ; For every index in the strings ; First choose the ith character of the first string if it exists ; Then choose the ith character of the second string if it exists ; Driver code"
C#;"using System ; class GFG { static char getMaxOccurringChar ( string str ) { int [ ] freq = new int [ 26 ] ; int max = - 1 ; char result = ( char ) 0 ; int len = str . Length ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] != ' ▁ ' ) { freq [ str [ i ] - ' a ' ] ++ ; } } for ( int i = 0 ; i < 26 ; i ++ ) { if ( max < freq [ i ] ) { max = freq [ i ] ; result = ( char ) ( i + ' a ' ) ; } } return result ; } public static void Main ( ) { string str = "" sample ▁ program "" ; Console . WriteLine ( "" Maximum ▁ occurring ▁ character ▁ = ▁ "" + getMaxOccurringChar ( str ) ) ; } }";"Maximum occurring character in an input string | Set | C # implementation to find the maximum occurring character in an input string which is lexicographically first ; function to find the maximum occurring character in an input string which is lexicographically first ; freq [ ] used as hash table ; to store maximum frequency ; to store the maximum occurring character ; length of ' str ' ; get frequency of each character of ' str ' ; for each character , where character is obtained by ( i + ' a ' ) check whether it is the maximum character so far and accodingly update ' result ' ; maximum occurring character ; Driver Code"
C#;"using System ; public class new_file { static bool isGreaterThanEqual ( String s1 , String s2 ) { if ( s1 . Length > s2 . Length ) return true ; if ( s1 . CompareTo ( s2 ) == 0 ) return true ; return false ; } static String multiply ( String s1 , String s2 ) { int n = s1 . Length ; int m = s2 . Length ; int i = 0 ; int [ ] result = new int [ n + m ] ; for ( i = n - 1 ; i >= 0 ; i -- ) for ( int j = m - 1 ; j >= 0 ; j -- ) result [ i + j + 1 ] += ( s1 [ i ] - '0' ) * ( s2 [ j ] - '0' ) ; int size = result . Length ; for ( i = size - 1 ; i > 0 ; i -- ) { if ( result [ i ] >= 10 ) { result [ i - 1 ] += result [ i ] / 10 ; result [ i ] = result [ i ] % 10 ; } } i = 0 ; while ( i < size && result [ i ] == 0 ) i ++ ; if ( i == size ) return ""0"" ; String temp = "" "" ; while ( i < size ) { temp += ( result [ i ] ) . ToString ( ) ; i ++ ; } return temp ; } static String removeLeadingZeores ( String s ) { int n = s . Length ; int i = 0 ; while ( i < n && s [ i ] == '0' ) i ++ ; if ( i == n ) return ""0"" ; String temp = "" "" ; while ( i < n ) { temp += s [ i ] ; i ++ ; } return temp ; } static bool isPower ( String s1 , String s2 ) { s1 = removeLeadingZeores ( s1 ) ; s2 = removeLeadingZeores ( s2 ) ; if ( s1 == ""0"" s2 == ""0"" ) return false ; if ( s1 == ""1"" && s2 == ""1"" ) return true ; if ( s1 == ""1"" s2 == ""1"" ) return true ; if ( s1 . Length > s2 . Length ) return isPower ( s2 , s1 ) ; String temp = s1 ; while ( ! isGreaterThanEqual ( s1 , s2 ) ) s1 = multiply ( s1 , temp ) ; if ( s1 . CompareTo ( s2 ) == 0 ) return true ; return false ; } public static void Main ( String [ ] args ) { String s1 = ""374747"" , s2 = ""52627712618930723"" ; if ( isPower ( s1 , s2 ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; s1 = ""4099"" ; s2 = ""2"" ; if ( isPower ( s1 , s2 ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Given two numbers as strings , find if one is a power of other | C # program to check if one number is power of other ; Multiply the numbers . It multiplies each digit of second string to each digit of first and stores the result . ; If the digit exceeds 9 , add the cumulative carry to previous digit . ; if all zeroes , return ""0"" . ; Remove starting zeroes . ; Removes Extra zeroes from front of a string . ; Make sure there are no leading zeroes in the string . ; Making sure that s1 is smaller . If it is greater , we recur we reversed parameters . ; Driver Code"
C#;"using System ; public class GFG { static int matchClosing ( char [ ] X , int start , int end , char open , char close ) { int c = 1 ; int i = start + 1 ; while ( i <= end ) { if ( X [ i ] == open ) { c ++ ; } else if ( X [ i ] == close ) { c -- ; } if ( c == 0 ) { return i ; } i ++ ; } return i ; } static int matchingOpening ( char [ ] X , int start , int end , char open , char close ) { int c = - 1 ; int i = end - 1 ; while ( i >= start ) { if ( X [ i ] == open ) { c ++ ; } else if ( X [ i ] == close ) { c -- ; } if ( c == 0 ) { return i ; } i -- ; } return - 1 ; } static bool isBalanced ( char [ ] X , int n ) { int i , j = 0 , k , x , start , end ; for ( i = 0 ; i < n ; i ++ ) { if ( X [ i ] == ' ( ' ) { j = matchClosing ( X , i , n - 1 , ' ( ' , ' ) ' ) ; } else if ( X [ i ] == ' { ' ) { j = matchClosing ( X , i , n - 1 , ' { ' , ' } ' ) ; } else if ( X [ i ] == ' [ ' ) { j = matchClosing ( X , i , n - 1 , ' [ ' , ' ] ' ) ; } else { if ( X [ i ] == ' ) ' ) { j = matchingOpening ( X , 0 , i , ' ( ' , ' ) ' ) ; } else if ( X [ i ] == ' } ' ) { j = matchingOpening ( X , 0 , i , ' { ' , ' } ' ) ; } else if ( X [ i ] == ' ] ' ) { j = matchingOpening ( X , 0 , i , ' [ ' , ' ] ' ) ; } if ( j < 0 j >= i ) { return false ; } continue ; } if ( j >= n j < 0 ) { return false ; } start = i ; end = j ; for ( k = start + 1 ; k < end ; k ++ ) { if ( X [ k ] == ' ( ' ) { x = matchClosing ( X , k , end , ' ( ' , ' ) ' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ' ) ' ) { x = matchingOpening ( X , start , k , ' ( ' , ' ) ' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } if ( X [ k ] == ' { ' ) { x = matchClosing ( X , k , end , ' { ' , ' } ' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ' } ' ) { x = matchingOpening ( X , start , k , ' { ' , ' } ' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } if ( X [ k ] == ' [ ' ) { x = matchClosing ( X , k , end , ' [ ' , ' ] ' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ' ] ' ) { x = matchingOpening ( X , start , k , ' [ ' , ' ] ' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } } } return true ; } public static void Main ( ) { char [ ] X = "" [ ( ) ] ( ) "" . ToCharArray ( ) ; int n = 6 ; if ( isBalanced ( X , n ) ) Console . Write ( "" Yes STRNEWLINE "" ) ; else Console . Write ( "" No STRNEWLINE "" ) ; char [ ] Y = "" [ [ ( ) ] ] ) "" . ToCharArray ( ) ; n = 7 ; if ( isBalanced ( Y , n ) ) Console . Write ( "" Yes STRNEWLINE "" ) ; else Console . Write ( "" No STRNEWLINE "" ) ; } }";"Check for balanced parentheses in an expression | O ( 1 ) space | C # code to check balanced parentheses with O ( 1 ) space . ; Function1 to match closing bracket ; Function1 to match opening bracket ; Function to check balanced parentheses ; helper variables ; Handling case of opening parentheses ; } Handling case of closing parentheses ; If corresponding matching opening parentheses doesn 't  lie in given interval return 0 ; else continue ; If corresponding closing parentheses doesn 't lie in given interval  return 0 ; if found , now check for each opening and closing parentheses in this interval ; Driver Code"
C#;"using System ; class GFG { static string possibleToSort ( int [ ] arr , int n , string str ) { int max_element = - 1 ; for ( int i = 0 ; i < str . Length ; i ++ ) { max_element = Math . Max ( max_element , arr [ i ] ) ; if ( str [ i ] == '0' ) { if ( max_element > i + 1 ) return "" No "" ; } } return "" Yes "" ; } static public void Main ( ) { int [ ] arr = { 1 , 2 , 5 , 3 , 4 , 6 } ; int n = arr . Length ; string str = ""01110"" ; Console . WriteLine ( possibleToSort ( arr , n , str ) ) ; } }";"Sorting array with conditional swapping | C # program to Check if it is possible to sort the array in ascending order ; Function to check if it is possible to sort the array ; Calculating max_element at each iteration . ; if we can not swap the i - th element . ; if it is impossible to swap the max_element then we can not sort the array . ; Otherwise , we can sort the array . ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { static void findSubstring ( String str , int power ) { Dictionary < int , int > map = new Dictionary < int , int > ( ) ; int curr_power = 0 ; int len = str . Length ; for ( int i = 0 ; i < len ; i ++ ) { curr_power = curr_power + ( str [ i ] - ' a ' + 1 ) ; if ( curr_power == power ) { Console . WriteLine ( "" Substring ▁ from ▁ index ▁ 0"" + "" ▁ to ▁ "" + i + "" ▁ has ▁ power ▁ "" + power ) ; return ; } if ( map . ContainsKey ( curr_power - power ) ) { Console . WriteLine ( "" Substring ▁ from ▁ index ▁ "" + ( map [ curr_power - power ] + 1 ) + "" ▁ to ▁ "" + i + "" ▁ has ▁ power ▁ "" + power ) ; return ; } if ( ! map . ContainsKey ( curr_power ) ) map . Add ( curr_power , i ) ; else map [ curr_power ] = i ; } Console . WriteLine ( "" No ▁ substring ▁ with ▁ "" + "" given ▁ power ▁ exists "" ) ; } public static void Main ( String [ ] args ) { String str = "" geeksforgeeks "" ; int power = 36 ; findSubstring ( str , power ) ; } }";"Find sub | C # program to find substring with given power ; Function to print indexes of substring with power as given power . ; Create an empty map ; Maintains sum of powers of characters so far . ; Add current character power to curr_power . ; If curr_power is equal to target power we found a substring starting from index 0 and ending at index i . ; If curr_power - power already exists in map then we have found a subarray with target power . ; If we reach here , then no substring exists . ; Driver Code"
C#;"using System ; class GFG { public static bool isPrimeString ( string str ) { int len = str . Length , n = 0 ; for ( int i = 0 ; i < len ; i ++ ) { n += ( int ) str [ i ] ; } if ( n <= 1 ) { return false ; } if ( n <= 3 ) { return true ; } if ( n % 2 == 0 n % 3 == 0 ) { return false ; } for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } public static void Main ( string [ ] args ) { string str = "" geekRam "" ; if ( isPrimeString ( str ) ) { Console . WriteLine ( "" Yes "" ) ; } else { Console . WriteLine ( "" No "" ) ; } } }";"Prime String | C # program to find if string is a Prime or not ; Function that checks if sum is prime or not ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Driver code"
C#;"using System ; class GFG { static int countWays ( string s ) { int [ ] count = new int [ 26 ] ; for ( int i = 0 ; i < s . Length ; i ++ ) count [ s [ i ] - ' a ' ] ++ ; count [ s [ 0 ] - ' a ' ] = 1 ; int ans = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ; return ans ; } public static void Main ( ) { string s = "" acbbcc "" ; Console . WriteLine ( countWays ( s ) ) ; } }";"Ways to split string such that each partition starts with distinct character | C # Program to find number of way to split string such that each partition starts with distinct character with maximum number of partitions . ; Returns the number of we can split the string ; Finding the frequency of each character . ; making frequency of first character of string equal to 1. ; Finding the product of frequency of occurrence of each character . ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { static void lexoString ( char [ ] s , int k ) { int n = s . Length ; List < char > v = new List < char > ( ) ; Dictionary < char , int > mp = new Dictionary < char , int > ( ) ; for ( int i = 0 ; i < s . Length ; i ++ ) { if ( ! mp . ContainsKey ( s [ i ] ) ) { mp . Add ( s [ i ] , 1 ) ; v . Add ( s [ i ] ) ; } } v . Sort ( ) ; if ( k > n ) { Console . Write ( String . Join ( "" "" , s ) ) ; for ( int i = n ; i < k ; i ++ ) { Console . Write ( v [ 0 ] ) ; } } for ( int i = k - 1 ; i >= 0 ; i -- ) { if ( s [ i ] != v [ v . Count - 1 ] ) { for ( int j = 0 ; j < i ; j ++ ) { Console . Write ( s [ j ] ) ; } for ( int j = 0 ; j < v . Count ; j ++ ) { if ( v [ j ] > s [ i ] ) { Console . Write ( v [ j ] ) ; break ; } } for ( int j = i + 1 ; j < k ; j ++ ) { Console . Write ( v [ 0 ] ) ; } return ; } } Console . Write ( "" No ▁ lexicographically ▁ greater ▁ "" + "" string ▁ of ▁ length ▁ "" + k + "" ▁ possible ▁ here . "" ) ; } public static void Main ( String [ ] arr ) { String s = "" gi "" ; int k = 3 ; lexoString ( s . ToCharArray ( ) , k ) ; } }";"Lexicographically next greater string using same character set | C # implementation of above algorithm . ; function to print output ; to store unique characters of the string ; to check uniqueness ; if mp [ s [ i ] ] = 0 then it is first time ; sort the unique characters ; simply add n - k smallest characters ; return ; end the program ; searching the first character left of index k and not equal to greatest character of the string ; finding the just next greater character than s [ i ] ; suffix with smallest character ; if we reach here then all indices to the left of k had the greatest character ; Driver code ; Function call"
C#;"using System ; class GFG { static int MAX = 256 ; static long fact ( int n ) { long res = 1 ; for ( int i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } static int countPalinPermutations ( string str ) { int n = str . Length ; int [ ] freq = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str [ i ] ] ++ ; long res = fact ( n / 2 ) ; bool oddFreq = false ; for ( int i = 0 ; i < MAX ; i ++ ) { int half = freq [ i ] / 2 ; if ( freq [ i ] % 2 != 0 ) { if ( oddFreq == true ) return 0 ; oddFreq = true ; } res = res / fact ( half ) ; } return ( int ) res ; } public static void Main ( ) { string str = "" gffg "" ; Console . WriteLine ( countPalinPermutations ( str ) ) ; } }";"Number of palindromic permutations | Set 1 | C # program to find number of palindromic permutations of a given string ; Returns factorial of n ; Returns count of palindromic permutations of str . ; Count frequencies of all characters ; Since half of the characters decide count of palindromic permutations , we take ( n / 2 ) ! ; To make sure that there is at most one odd occurring char ; Traverse through all counts ; To make sure that the string can permute to form a palindrome ; If there are more than one odd occurring chars ; Divide all permutations with repeated characters ; Driver code"
C#;"using System ; class GFG { static Boolean isVowel ( char ch ) { return ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) ; } static Boolean isCons ( char ch ) { return ( ch != ' a ' && ch != ' e ' && ch != ' i ' && ch != ' o ' && ch != ' u ' ) ; } static int countSpecial ( char [ ] str ) { int len = str . Length ; if ( len == 0 ) return 0 ; int [ ] co = new int [ len + 1 ] ; int [ ] vo = new int [ len + 1 ] ; if ( isCons ( str [ len - 1 ] ) == true ) co [ len - 1 ] = 1 ; else vo [ len - 1 ] = 1 ; for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( isCons ( str [ i ] ) == true ) { co [ i ] = co [ i + 1 ] + 1 ; vo [ i ] = vo [ i + 1 ] ; } else { co [ i ] = co [ i + 1 ] ; vo [ i ] = vo [ i + 1 ] + 1 ; } } long ans = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( isVowel ( str [ i ] ) ) ans = ans + co [ i + 1 ] ; else ans = ans + vo [ i + 1 ] ; } return ( int ) ans ; } public static void Main ( String [ ] args ) { String str = "" adceba "" ; Console . WriteLine ( countSpecial ( str . ToCharArray ( ) ) ) ; } }";"Substrings starting with vowel and ending with consonants and vice versa | C # program to count special strings ; Returns true if ch is vowel ; function to check consonant ; in case of empty string , we can 't fullfill the  required condition, hence we return ans as 0. ; co [ i ] is going to store counts of consonants from str [ len - 1 ] to str [ i ] . vo [ i ] is going to store counts of vowels from str [ len - 1 ] to str [ i ] . ; Counting consonants and vowels from end of string . ; Now we traverse string from beginning ; If vowel , then count of substrings starting with str [ i ] is equal to count of consonants after it . ; If consonant , then count of substrings starting with str [ i ] is equal to count of vowels after it . ; Driver program"
C#;"using System ; class GFG { static bool checkPalindrome ( string str ) { int n = str . Length ; int count = 0 ; for ( int i = 0 ; i < n / 2 ; ++ i ) if ( str [ i ] != str [ n - i - 1 ] ) ++ count ; return ( count <= 1 ) ; } public static void Main ( ) { string str = "" abccaa "" ; if ( checkPalindrome ( str ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Convert the string into palindrome string by changing only one character | C # program to Check if it is possible to convert the string into palindrome string by changing only one character . ; Function to check if it is possible to convert the string into palindrome ; Counting number of characters that should be changed . ; If count of changes is less than or equal to 1 ; Driver Function"
C#;"using System ; class GFG { static int evenDecimalValue ( string str , int n ) { int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) { result += ( n - i ) ; } } return result ; } public static void Main ( ) { string str = ""10010"" ; int n = 5 ; Console . WriteLine ( evenDecimalValue ( str , n ) ) ; } }";"Counting even decimal value substrings in a binary string | C # Program to count all even decimal value substring . ; function return count of even decimal value substring ; store the count of even decimal value substring ; substring started with '0' ; increment result by ( n - i ) because all substring which are generate by this character produce even decimal value . ; Driver code"
C#;"using System ; class GFG { static int countSubstr ( string s ) { int n = s . Length ; int [ ] auxArr = new int [ n ] ; if ( s [ 0 ] == '1' ) auxArr [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s [ i ] == '1' ) auxArr [ i ] = auxArr [ i - 1 ] + 1 ; else auxArr [ i ] = auxArr [ i - 1 ] ; } int count = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) if ( s [ i ] == '1' ) count += auxArr [ i ] ; return count ; } public static void Main ( ) { string s = ""1101"" ; Console . WriteLine ( countSubstr ( s ) ) ; } }";"Number of substrings with odd decimal value in a binary string | C # program to count substrings with odd decimal value ; Function to count number of substrings with odd decimal representation ; auxiliary array to store count of 1 's before ith index ; store count of 1 's before  i-th index ; variable to store answer ; Traverse the string reversely to calculate number of odd substrings before i - th index ; Driver Code"
C#;"using System ; class GFG { static int MAX = 256 ; static bool canMakeStr2 ( string str1 , string str2 ) { int [ ] count = new int [ MAX ] ; for ( int i = 0 ; i < str1 . Length ; i ++ ) count [ str1 [ i ] ] ++ ; for ( int i = 0 ; i < str2 . Length ; i ++ ) { if ( count [ str2 [ i ] ] == 0 ) return false ; count [ str2 [ i ] ] -- ; } return true ; } static public void Main ( ) { string str1 = "" geekforgeeks "" ; string str2 = "" for "" ; if ( canMakeStr2 ( str1 , str2 ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Check whether second string can be formed from characters of first string | C # program to check whether second string can be formed from first string ; Create a count array and count frequencies characters in str1 . ; Now traverse through str2 to check if every character has enough counts ; Driver Code"
C#;"using System ; class GFG { static void finalPosition ( String move ) { int l = move . Length ; int countUp = 0 , countDown = 0 ; int countLeft = 0 , countRight = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( move [ i ] == ' U ' ) countUp ++ ; else if ( move [ i ] == ' D ' ) countDown ++ ; else if ( move [ i ] == ' L ' ) countLeft ++ ; else if ( move [ i ] == ' R ' ) countRight ++ ; } Console . WriteLine ( "" Final ▁ Position : ▁ ( "" + ( countRight - countLeft ) + "" , ▁ "" + ( countUp - countDown ) + "" ) "" ) ; } public static void Main ( ) { String move = "" UDDLLRUUUDUURUDDUULLDRRRR "" ; finalPosition ( move ) ; } }";"Position of robot after given movements | C # implementation to find final position of robot after the complete movement ; function to find final position of robot after the complete movement ; traverse the instruction string ' move ' ; for each movement increment its respective counter ; required final position of robot ; Driver code"
C#;"using System ; class GFG { static int maxbalancedprefix ( string str , int n ) { int sum = 0 ; int maxi = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ( ' ) sum += 1 ; else sum -= 1 ; if ( sum < 0 ) break ; if ( sum == 0 ) maxi = i + 1 ; } return maxi ; } public static void Main ( ) { string str = "" ( ( ( ) ( ) ) ( ) ) ( ( "" ; int n = str . Length ; Console . WriteLine ( maxbalancedprefix ( str , n ) ) ; } }";"Length of longest balanced parentheses prefix | C # Program to find length of longest balanced parentheses prefix . ; Return the length of longest balanced parentheses prefix . ; Traversing the string . ; If open bracket add 1 to sum . ; If closed bracket subtract 1 from sum ; if first bracket is closing bracket then this condition would help ; If sum is 0 , store the index value . ; Driven Program"
C#;"using System ; class GFG { static int cost ( String str ) { int len = str . Length ; int res = 0 ; for ( int i = 0 , j = len - 1 ; i < j ; i ++ , j -- ) if ( str [ i ] != str [ j ] ) res += Math . Min ( str [ i ] , str [ j ] ) - ' a ' + 1 ; return res ; } public static void Main ( ) { string str = "" abcdef "" ; Console . WriteLine ( cost ( str ) ) ; } }";"Minimum cost to convert string into palindrome | C # program to find minimum cost to make a palindrome . ; Function to return cost ; length of string ; Iterate from both sides of string . If not equal , a cost will be there ; Driver code"
C#;"using System ; class GFG { static bool isVowel ( char c ) { return ( c == ' A ' c == ' E ' c == ' I ' c == ' O ' c == ' U ' c == ' a ' c == ' e ' c == ' i ' c == ' o ' c == ' u ' ) ; } static string pigLatin ( string s ) { int len = s . Length ; int index = - 1 ; for ( int i = 0 ; i < len ; i ++ ) { if ( isVowel ( s [ i ] ) ) { index = i ; break ; } } if ( index == - 1 ) return "" - 1"" ; return s . Substring ( index ) + s . Substring ( 0 , index ) + "" ay "" ; } public static void Main ( ) { string str = pigLatin ( "" graphic "" ) ; if ( str == "" - 1"" ) Console . WriteLine ( "" No ▁ vowels "" + "" found . ▁ Pig ▁ Latin "" + "" ▁ not ▁ possible "" ) ; else Console . WriteLine ( str ) ; } }";"Encoding a word into Pig Latin | C # program to encode a word to a Pig Latin . ; the index of the first vowel is stored . ; Pig Latin is possible only if vowels is present ; Take all characters after index ( including index ) . Append all characters which are before index . Finally append "" ay "" ; Driver code"
C#;"using System ; public class GFG { static int MAX_CHAR = 256 ; static bool isPresent ( string s , string q ) { int [ ] freq = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < s . Length ; i ++ ) freq [ s [ i ] ] ++ ; for ( int i = 0 ; i < q . Length ; i ++ ) { freq [ q [ i ] ] -- ; if ( freq [ q [ i ] ] < 0 ) return false ; } return true ; } static public void Main ( ) { string s = "" abctd "" ; string q = "" cat "" ; if ( isPresent ( s , q ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Possibility of a word from a given set of characters | C # program to check if a query string is present is given set . ; Count occurrences of all characters in s . ; Check if number of occurrences of every character in q is less than or equal to that in s . ; driver program"
C#;"using System ; class GFG { static int countReduce ( string str ) { int n = str . Length ; int res = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) res += Math . Abs ( str [ i ] - str [ n - i - 1 ] ) ; return res ; } public static void Main ( ) { string str = "" abcd "" ; Console . WriteLine ( countReduce ( str ) ) ; } }";"Minimum reduce operations to convert a given string into a palindrome | C # program to count minimum reduce operations to make a palindrome ; Returns count of minimum character reduce operations to make palindrome . ; Compare every character of first half with the corresponding character of second half and add difference to result . ; Driver code"
C#;"using System ; class GFG { static int calculate ( string s ) { int ans = 6 ; for ( int i = 0 ; i < 10 ; ++ i ) { for ( int j = 0 ; j < 10 ; ++ j ) { for ( int k = 0 ; k < 10 ; ++ k ) { for ( int l = 0 ; l < 10 ; ++ l ) { for ( int m = 0 ; m < 10 ; ++ m ) { for ( int n = 0 ; n < 10 ; ++ n ) { if ( i + j + k == l + m + n ) { int c = 0 ; if ( i != s [ 0 ] - '0' ) c ++ ; if ( j != s [ 1 ] - '0' ) c ++ ; if ( k != s [ 2 ] - '0' ) c ++ ; if ( l != s [ 3 ] - '0' ) c ++ ; if ( m != s [ 4 ] - '0' ) c ++ ; if ( n != s [ 5 ] - '0' ) c ++ ; if ( c < ans ) ans = c ; } } } } } } } return ans ; } static public void Main ( ) { string s = ""123456"" ; Console . WriteLine ( calculate ( s ) ) ; } }";"Minimal operations to make a number magical | C # program to make a number magical ; function to calculate the minimal changes ; maximum digits that can be changed ; nested loops to generate all 6 digit numbers ; counter to count the number of change required ; if first digit is equal ; if 2 nd digit is equal ; if 3 rd digit is equal ; if 4 th digit is equal ; if 5 th digit is equal ; if 6 th digit is equal ; checks if less then the previous calculate changes ; returns the answer ; Driver code ; number stored in string ; prints the minimum operations"
C#;"using System ; using System . Collections . Generic ; class GFG { static bool makeAndCheckString ( List < String > words , String str ) { int n = words . Count ; bool first = false , second = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( words [ i ] == str ) return true ; if ( str [ 0 ] == words [ i ] [ 1 ] ) first = true ; if ( str [ 1 ] == words [ i ] [ 0 ] ) second = true ; if ( first && second ) return true ; } return false ; } public static void Main ( String [ ] args ) { String str = "" ya "" ; String [ ] array = { "" ah "" , "" oy "" , "" to "" , "" ha "" } ; List < String > words = new List < String > ( array ) ; if ( makeAndCheckString ( words , str ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Check if a two character string can be made using given words | C # code to check if a two character string can be made using given strings ; Function to check if str can be made using given words ; If str itself is present ; Match first character of str with second of word and vice versa ; If both characters found . ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { static string getBinaryRep ( int N , int num_of_bits ) { string r = "" "" ; num_of_bits -- ; while ( num_of_bits >= 0 ) { if ( ( N & ( 1 << num_of_bits ) ) != 0 ) r += ""1"" ; else r += ""0"" ; num_of_bits -- ; } return r ; } static List < string > NBitBinary ( int N ) { List < string > r = new List < string > ( ) ; int first = 1 << ( N - 1 ) ; int last = first * 2 ; for ( int i = last - 1 ; i >= first ; -- i ) { int zero_cnt = 0 ; int one_cnt = 0 ; int t = i ; int num_of_bits = 0 ; while ( t > 0 ) { if ( ( t & 1 ) != 0 ) one_cnt ++ ; else zero_cnt ++ ; num_of_bits ++ ; t = t >> 1 ; } if ( one_cnt >= zero_cnt ) { bool all_prefix_match = true ; int msk = ( 1 << num_of_bits ) - 2 ; int prefix_shift = 1 ; while ( msk > 0 ) { int prefix = ( msk & i ) >> prefix_shift ; int prefix_one_cnt = 0 ; int prefix_zero_cnt = 0 ; while ( prefix > 0 ) { if ( ( prefix & 1 ) != 0 ) prefix_one_cnt ++ ; else prefix_zero_cnt ++ ; prefix = prefix >> 1 ; } if ( prefix_zero_cnt > prefix_one_cnt ) { all_prefix_match = false ; break ; } prefix_shift ++ ; msk = msk & ( msk << 1 ) ; } if ( all_prefix_match ) { r . Add ( getBinaryRep ( i , num_of_bits ) ) ; } } } return r ; } static public void Main ( ) { int n = 4 ; List < string > results = NBitBinary ( n ) ; for ( int i = 0 ; i < results . Count ; ++ i ) Console . Write ( results [ i ] + "" ▁ "" ) ; Console . WriteLine ( ) ; } }";"Print N | C # program to print all N - bit binary ; Function to get the binary representation of the number N ; loop for each bit ; Generate numbers in the range of ( 2 ^ N ) - 1 to 2 ^ ( N - 1 ) inclusive ; longest prefix check ; If counts of 1 is greater than counts of zero ; Do sub - prefixes check ; Driver code ; Function call"
C#;"using System ; using System . Collections . Generic ; public class ElectoralVotingBallot { public static void findWinner ( String [ ] votes ) { Dictionary < String , int > map = new Dictionary < String , int > ( ) ; foreach ( String str in votes ) { if ( map . ContainsKey ( str ) ) map [ str ] = map [ str ] + 1 ; else map . Add ( str , 1 ) ; } int maxValueInMap = 0 ; String winner = "" "" ; foreach ( KeyValuePair < String , int > entry in map ) { String key = entry . Key ; int val = entry . Value ; if ( val > maxValueInMap ) { maxValueInMap = val ; winner = key ; } else if ( val == maxValueInMap && winner . CompareTo ( key ) > 0 ) winner = key ; } Console . WriteLine ( winner ) ; } public static void Main ( String [ ] args ) { String [ ] votes = { "" john "" , "" johnny "" , "" jackie "" , "" johnny "" , "" john "" , "" jackie "" , "" jamie "" , "" jamie "" , "" john "" , "" johnny "" , "" jamie "" , "" johnny "" , "" john "" } ; findWinner ( votes ) ; } }";"Find winner of an election where votes are represented as candidate names | C # program to find winner in an election . ; We have four Candidates with name as ' John ' , ' Johnny ' , ' jamie ' , ' jackie ' . The votes in String array are as per the votes casted . Print the name of candidates received Max vote . ; Insert all votes in a hashmap ; Traverse through map to find the candidate with maximum votes . ; If there is a tie , pick lexicographically smaller . ; Driver code"
C#;"using System ; class GFG { static bool checkLuhn ( String cardNo ) { int nDigits = cardNo . Length ; int nSum = 0 ; bool isSecond = false ; for ( int i = nDigits - 1 ; i >= 0 ; i -- ) { int d = cardNo [ i ] - '0' ; if ( isSecond == true ) d = d * 2 ; nSum += d / 10 ; nSum += d % 10 ; isSecond = ! isSecond ; } return ( nSum % 10 == 0 ) ; } static public void Main ( ) { String cardNo = ""79927398713"" ; if ( checkLuhn ( cardNo ) ) Console . WriteLine ( "" This ▁ is ▁ a ▁ valid ▁ card "" ) ; else Console . WriteLine ( "" This ▁ is ▁ not ▁ a ▁ valid ▁ card "" ) ; } }";"Luhn algorithm | C # program to implement Luhn algorithm ; Returns true if given card number is valid ; We add two digits to handle cases that make two digits after doubling ; Driver code"
C#;"using System ; public class GFG { static int MAX_CHAR = 26 ; static bool distributingBalls ( long k , long n , string str ) { int [ ] a = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ str [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( a [ i ] > k ) return false ; return true ; } static public void Main ( ) { long n = 6 , k = 3 ; string str = "" aacaab "" ; if ( distributingBalls ( k , n , str ) ) Console . WriteLine ( "" YES "" ) ; else Console . WriteLine ( "" NO "" ) ; } }";"Distributing all balls without repetition | C # program to find if its possible to distribute balls without repitiion ; function to find if its possible to distribute balls or not ; count array to count how many times each color has occurred ; increasing count of each color every time it appears ; to check if any color appears more than K times if it does we will print NO ; Driver code"
C#;"using System ; using System . Collections . Generic ; public class GFG { public static bool isVowel ( char x ) { return ( x == ' a ' x == ' e ' x == ' i ' x == ' o ' x == ' u ' ) ; } public static void findSubstring ( string str ) { HashSet < char > hash = new HashSet < char > ( ) ; int n = str . Length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i ; j < n ; j ++ ) { if ( isVowel ( str [ j ] ) == false ) { break ; } hash . Add ( str [ j ] ) ; if ( hash . Count == 5 ) { Console . Write ( str . Substring ( i , ( j + 1 ) - i ) + "" ▁ "" ) ; } } hash . Clear ( ) ; } } public static void Main ( string [ ] args ) { string str = "" aeoibsddaeiouudb "" ; findSubstring ( str ) ; } }";"Find substrings that contain all vowels | C # program to find all substring that contain all vowels ; Returns true if x is vowel . ; Function to check whether a character is vowel or not ; To store vowels Outer loop picks starting character and inner loop picks ending character . ; If current character is not vowel , then no more result substrings possible starting from str [ i ] . ; If vowel , then we insert it in hash ; If all vowels are present in current substring ; Driver code"
C#;"using System ; using System . Collections . Generic ; public class GFG { static bool check ( List < String > list , String s ) { int n = ( int ) list . Count ; if ( n == 0 ) { return false ; } for ( int i = 0 ; i < n ; i ++ ) { if ( list [ i ] . Length != s . Length ) { continue ; } bool diff = false ; for ( int j = 0 ; j < ( int ) list [ i ] . Length ; j ++ ) { if ( list [ i ] [ j ] != s [ j ] ) { if ( ! diff ) { diff = true ; } else { diff = false ; break ; } } } if ( diff ) { return true ; } } return false ; } public static void Main ( String [ ] args ) { List < String > s = new List < String > ( ) ; s . Add ( "" bana "" ) ; s . Add ( "" apple "" ) ; s . Add ( "" banacb "" ) ; s . Add ( "" bonanza "" ) ; s . Add ( "" banamf "" ) ; Console . WriteLine ( check ( s , "" banana "" ) == true ? 1 : 0 ) ; } }";"Find if an array contains a string with one mismatch | C # program to find if given string is present with one mismatch . ; If the array is empty ; If sizes are same ; If first mismatch ; Second mismatch ; Driver code"
C#;"using System ; public class GFG { static bool sentencePalindrome ( String str ) { int l = 0 ; int h = str . Length - 1 ; str = str . ToLower ( ) ; while ( l <= h ) { char getAtl = str [ l ] ; char getAth = str [ h ] ; if ( ! ( getAtl >= ' a ' && getAtl <= ' z ' ) ) l ++ ; else if ( ! ( getAth >= ' a ' && getAth <= ' z ' ) ) h -- ; else if ( getAtl == getAth ) { l ++ ; h -- ; } else return false ; } return true ; } public static void Main ( ) { String str = "" Too ▁ hot ▁ to ▁ hoot . "" ; if ( sentencePalindrome ( str ) ) Console . Write ( "" Sentence ▁ is ▁ palindrome "" ) ; else Console . Write ( "" Sentence ▁ is ▁ not "" + "" ▁ "" + "" palindrome "" ) ; } }";"Sentence Palindrome ( Palindrome after removing spaces , dots , . . etc ) | C # program to find if a sentence is palindrome ; To check sentence is palindrome or not ; Lowercase string ; Compares character until they are equal ; If there is another symbol in left of sentence ; If there is another symbol in right of sentence ; If characters are equal ; If characters are not equal then sentence is not palindrome ; Returns true if sentence is palindrome ; Driver Code"
C#;"using System ; class GFG { static int xorZero ( string s ) { int one_count = 0 , zero_count = 0 ; int n = s . Length ; for ( int i = 0 ; i < n ; i ++ ) if ( s [ i ] == '1' ) one_count ++ ; else zero_count ++ ; if ( one_count % 2 == 0 ) return zero_count ; return one_count ; } public static void Main ( ) { string s = ""11111"" ; Console . WriteLine ( xorZero ( s ) ) ; } }";"Ways to remove one element from a binary string so that XOR becomes zero | C # program to count number of ways to remove an element so that XOR of remaining string becomes 0. ; Returns number of ways in which XOR become ZERO by remove 1 element ; Counting number of 0 and 1 ; If count of ones is even then return count of zero else count of one ; Driver Code"
C#;"using System ; class GFG { static String encoder ( char [ ] key ) { String encoded = "" "" ; Boolean [ ] arr = new Boolean [ 26 ] ; for ( int i = 0 ; i < key . Length ; i ++ ) { if ( key [ i ] >= ' A ' && key [ i ] <= ' Z ' ) { if ( arr [ key [ i ] - 65 ] == false ) { encoded += ( char ) key [ i ] ; arr [ key [ i ] - 65 ] = true ; } } else if ( key [ i ] >= ' a ' && key [ i ] <= ' z ' ) { if ( arr [ key [ i ] - 97 ] == false ) { encoded += ( char ) ( key [ i ] - 32 ) ; arr [ key [ i ] - 97 ] = true ; } } } for ( int i = 0 ; i < 26 ; i ++ ) { if ( arr [ i ] == false ) { arr [ i ] = true ; encoded += ( char ) ( i + 65 ) ; } } return encoded ; } static String cipheredIt ( String msg , String encoded ) { String cipher = "" "" ; for ( int i = 0 ; i < msg . Length ; i ++ ) { if ( msg [ i ] >= ' a ' && msg [ i ] <= ' z ' ) { int pos = msg [ i ] - 97 ; cipher += encoded [ pos ] ; } else if ( msg [ i ] >= ' A ' && msg [ i ] <= ' Z ' ) { int pos = msg [ i ] - 65 ; cipher += encoded [ pos ] ; } else { cipher += msg [ i ] ; } } return cipher ; } public static void Main ( String [ ] args ) { String key ; key = "" Computer "" ; Console . WriteLine ( "" Keyword ▁ : ▁ "" + key ) ; String encoded = encoder ( key . ToCharArray ( ) ) ; String message = "" GeeksforGeeks "" ; Console . WriteLine ( "" Message ▁ before ▁ Ciphering ▁ : ▁ "" + message ) ; Console . WriteLine ( "" Ciphered ▁ Text ▁ : ▁ "" + cipheredIt ( message , encoded ) ) ; } }";"Keyword Cipher | C # program for encoding the string using classical cipher ; Function generates the encoded text ; This array represents the 26 letters of alphabets ; This loop inserts the keyword at the start of the encoded string ; To check whether the character is inserted earlier in the encoded string or not ; This loop inserts the remaining characters in the encoded string . ; Function that generates encodes ( cipher ) the message ; This loop ciphered the message . Spaces , special characters and numbers remain same . ; Driver code ; Hold the Keyword ; Function call to generate encoded text ; Message that need to encode ; Function call to print ciphered text"
C#;"using System ; public class GFG { static int MAX_CHAR = 26 ; static bool checkCorrectOrNot ( String s ) { int [ ] count = new int [ MAX_CHAR ] ; int n = s . Length ; if ( n == 1 ) return true ; for ( int i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count [ s [ i ] - ' a ' ] ++ ; count [ s [ j ] - ' a ' ] -- ; } for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( count [ i ] != 0 ) return false ; return true ; } public static void Main ( String [ ] args ) { String s = "" abab "" ; if ( checkCorrectOrNot ( s ) ) Console . Write ( "" Yes "" ) ; else Console . Write ( "" No "" ) ; } }";"Check if both halves of the string have same set of characters | C # program to check if it two half of string contain same Character set or not ; function to check both halves for equality ; Counter array initialized with 0 ; Length of the string ; traverse till the middle element is reached ; First half ; Second half ; Checking if values are different set flag to 1 ; Driver program to test above function ; String to be checked"
C#;"using System ; public class GFG { static bool check_isogram ( String str ) { int length = str . Length ; int [ ] mapHash = new int [ 26 ] ; for ( int i = 0 ; i < length ; i ++ ) { mapHash [ str [ i ] - ' a ' ] ++ ; if ( mapHash [ str [ i ] - ' a ' ] > 1 ) { return false ; } } return true ; } public static void Main ( String [ ] args ) { String str = "" geeks "" ; String str2 = "" computer "" ; if ( check_isogram ( str ) ) Console . WriteLine ( "" True "" ) ; else Console . WriteLine ( "" False "" ) ; if ( check_isogram ( str2 ) ) Console . WriteLine ( "" True "" ) ; else Console . WriteLine ( "" False "" ) ; } }";"Check if a string is Isogram or not | C # code to check string is isogram or not ; function to check isogram ; loop to store count of chars and check if it is greater than 1 ; if count > 1 , return false ; Driver code ; checking str as isogram ; checking str2 as isogram"
C#;"using System ; class GFG { static bool checkString ( String s ) { int len = s . Length ; int first = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( s [ i ] == '1' ) { first = i ; break ; } } int last = 0 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '1' ) { last = i ; break ; } } for ( int i = first ; i <= last ; i ++ ) if ( s [ i ] == '0' ) return false ; return true ; } public static void Main ( ) { string s = ""00011111111100000"" ; Console . WriteLine ( checkString ( s ) ? "" VALID "" : "" NOT ▁ VALID "" ) ; } }";"Check if a binary string has a 0 between 1 s or not | Set 1 ( General approach ) | C # program to check if a string is valid or not . ; Method returns 1 when string is valid else returns 0 ; Find first occurrence of 1 in s [ ] ; Find last occurrence of 1 in s [ ] ; Check if there is any 0 in range ; Driver method"
C#;"using System ; class GFG { public static void printAllSubStrings ( String s , int n ) { for ( int i = 0 ; i < n ; i ++ ) { char [ ] temp = new char [ n - i + 1 ] ; int tempindex = 0 ; for ( int j = i ; j < n ; j ++ ) { temp [ tempindex ++ ] = s [ j ] ; temp [ tempindex ] = ' \0' ; Console . WriteLine ( temp ) ; } } } public static void Main ( ) { String s = "" Geeky "" ; printAllSubStrings ( s , s . Length ) ; } }";"Program to print all substrings of a given string | C # program to print all possible subStrings of a given String without checking for duplication . ; Function to print all ( n * ( n + 1 ) ) / 2 subStrings of a given String s of length n . ; Fix start index in outer loop . Reveal new character in inner loop till end of String . Print till - now - formed String . ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { static void preserveSpace ( string str ) { int n = str . Length ; int start = 0 ; int end = n - 1 ; char [ ] Str = str . ToCharArray ( ) ; while ( start < end ) { if ( Str [ start ] == ' ▁ ' ) { start ++ ; continue ; } else if ( Str [ end ] == ' ▁ ' ) { end -- ; continue ; } else { char temp = Str [ start ] ; Str [ start ] = Str [ end ] ; Str [ end ] = temp ; start ++ ; end -- ; } } Console . Write ( new string ( Str ) ) ; } static void Main ( ) { string str = "" internship ▁ at ▁ geeks ▁ for ▁ geeks "" ; preserveSpace ( str ) ; } }";"Reverse a string preserving space positions | C # program to implement the above approach ; Initialize two pointers as two corners ; Move both pointers toward each other ; If character at start or end is space , ignore it ; If both are not spaces , do swap ; Driver code"
C#;"using System ; public class GFG { public static void amendSentence ( string sstr ) { char [ ] str = sstr . ToCharArray ( ) ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( str [ i ] >= ' A ' && str [ i ] <= ' Z ' ) { str [ i ] = ( char ) ( str [ i ] + 32 ) ; if ( i != 0 ) Console . Write ( "" ▁ "" ) ; Console . Write ( str [ i ] ) ; } else Console . Write ( str [ i ] ) ; } } public static void Main ( ) { string str = "" BruceWayneIsBatman "" ; amendSentence ( str ) ; } }";"Put spaces between words starting with capital letters | C # program to put spaces between words starting with capital letters . ; Function to amend the sentence ; Traverse the string ; Convert to lowercase if its an uppercase character ; Print space before it if its an uppercase character ; Print the character ; if lowercase character then just print ; Driver Code"
C#;"using System ; class GFG { static String repeat ( String s , int n ) { String s1 = s ; for ( int i = 1 ; i < n ; i ++ ) s += s1 ; return s ; } public static void Main ( ) { String s = "" geeks "" ; int n = 3 ; Console . Write ( repeat ( s , n ) ) ; } }";"C ++ program to concatenate a string given number of times | C # program to concatenate given string n number of times ; Function which return string by concatenating it . ; Copying given string to temporary string . ; Concatenating strings ; Driver code"
C#;"using System ; public class GFG { static int MAX_CHAR = 26 ; static int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; } static int countDistinctPermutations ( String str ) { int length = str . Length ; int [ ] freq = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < length ; i ++ ) if ( str [ i ] >= ' a ' ) freq [ str [ i ] - ' a ' ] ++ ; int fact = 1 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) fact = fact * factorial ( freq [ i ] ) ; return factorial ( length ) / fact ; } public static void Main ( String [ ] args ) { String str = "" fvvfhvgv "" ; Console . Write ( countDistinctPermutations ( str ) ) ; } }";"Number of distinct permutation a String can have | C # program to find number of distinct permutations of a string . ; Utility function to find factorial of n . ; Returns count of distinct permutations of str . ; finding frequency of all the lower case alphabet and storing them in array of integer ; finding factorial of number of appearances and multiplying them since they are repeating alphabets ; finding factorial of size of string and dividing it by factorial found after multiplying ; Driver code"
C#;"using System ; class GFG { public virtual bool uniqueCharacters ( string str ) { int checker = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { int bitAtIndex = str [ i ] - ' a ' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } return true ; } public static void Main ( string [ ] args ) { GFG obj = new GFG ( ) ; string input = "" geekforgeeks "" ; if ( obj . uniqueCharacters ( input ) ) { Console . WriteLine ( "" The ▁ String ▁ "" + input + "" ▁ has ▁ all ▁ unique ▁ characters "" ) ; } else { Console . WriteLine ( "" The ▁ String ▁ "" + input + "" ▁ has ▁ duplicate ▁ characters "" ) ; } } }";"Determine if a string has all Unique Characters | C # program to illustrate String with unique characters without using any data structure ; Assuming string can have characters a - z this has 32 bits set to 0 ; if that bit is already set in checker , return false ; otherwise update and continue by setting that bit in the checker ; no duplicates encountered , return true ; Driver Code"
C#;"using System ; class GFG { static Boolean isVowel ( char ch ) { if ( ch == ' a ' ch == ' e ' ch == ' i ' ch == ' o ' ch == ' u ' ) return true ; return false ; } static String createAltStr ( String str1 , String str2 , int start , int l ) { String finalStr = "" "" ; for ( int i = 0 , j = start ; j < l ; i ++ , j ++ ) finalStr = ( finalStr + str1 [ i ] ) + str2 [ j ] ; return finalStr ; } static String findAltStr ( String str ) { int nv = 0 , nc = 0 ; String vstr = "" "" , cstr = "" "" ; int l = str . Length ; for ( int i = 0 ; i < l ; i ++ ) { char ch = str [ i ] ; if ( isVowel ( ch ) ) { nv ++ ; vstr = vstr + ch ; } else { nc ++ ; cstr = cstr + ch ; } } if ( Math . Abs ( nv - nc ) >= 2 ) return "" no ▁ such ▁ string "" ; if ( nv > nc ) return ( vstr [ 0 ] + createAltStr ( cstr , vstr , 1 , nv ) ) ; if ( nc > nv ) return ( cstr [ 0 ] + createAltStr ( vstr , cstr , 1 , nc ) ) ; if ( cstr [ 0 ] < vstr [ 0 ] ) return createAltStr ( cstr , vstr , 0 , nv ) ; return createAltStr ( vstr , cstr , 0 , nc ) ; } public static void Main ( String [ ] args ) { String str = "" geeks "" ; Console . WriteLine ( findAltStr ( str ) ) ; } }";"Alternate vowel and consonant string | C # implementation of alternate vowel and consonant string ; ' ch ' is vowel or not ; create alternate vowel and consonant string str1 [ 0. . . l1 - 1 ] and str2 [ start ... l2 - 1 ] ; first adding character of vowel / consonant then adding character of consonant / vowel ; function to find the required alternate vowel and consonant string ; count vowels and update vowel string ; count consonants and update consonant string ; no such string can be formed ; remove first character of vowel string then create alternate string with cstr [ 0. . . nc - 1 ] and vstr [ 1. . . nv - 1 ] ; remove first character of consonant string then create alternate string with vstr [ 0. . . nv - 1 ] and cstr [ 1. . . nc - 1 ] ; if both vowel and consonant strings are of equal length start creating string with consonant ; start creating string with vowel ; Driver code"
C#;"using System ; class GFG { public static void isKthBitSet ( int n , int k ) { if ( ( n & ( 1 << ( k - 1 ) ) ) > 0 ) Console . Write ( "" SET "" ) ; else Console . Write ( "" NOT ▁ SET "" ) ; } public static void Main ( ) { int n = 5 , k = 1 ; isKthBitSet ( n , k ) ; } }";"Check whether K | C # program to check if k - th bit of a given number is set or not . ; Driver code"
C#;"using System ; using System . Linq ; class GFG { public static void Main ( String [ ] args ) { String str = "" geeksforgeeks "" ; str = new string ( str . Reverse ( ) . ToArray ( ) ) ; Console . WriteLine ( str ) ; } }";"Reverse string without using any temporary variable | Reversing a string using reverse ( ) ; Reverse str [ beign . . end ]"
C#;"using System ; class GFG { static bool isPalRec ( String str , int s , int e ) { if ( s == e ) return true ; if ( ( str [ s ] ) != ( str [ e ] ) ) return false ; if ( s < e + 1 ) return isPalRec ( str , s + 1 , e - 1 ) ; return true ; } static bool isPalindrome ( String str ) { int n = str . Length ; if ( n == 0 ) return true ; return isPalRec ( str , 0 , n - 1 ) ; } public static void Main ( ) { String str = "" geeg "" ; if ( isPalindrome ( str ) ) Console . Write ( "" Yes "" ) ; else Console . Write ( "" No "" ) ; } }";"Recursive function to check if a string is palindrome | A recursive C # program to check whether a given number is palindrome or not ; A recursive function that check a str ( s . . e ) is palindrome or not . ; If there is only one character ; If first and last character do not match ; If there are more than two characters , check if middle substring is also palindrome or not . ; An empty string is considered as palindrome ; Driver Code"
C#;"using System ; class GFG { static readonly int MAX_CHAR = 26 ; static int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . Length ; int [ ] count = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) count [ s [ i ] - ' a ' ] ++ ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; } public static void Main ( ) { String s = "" abcab "" ; Console . Write ( countSubstringWithEqualEnds ( s ) ) ; } }";"Count substrings with same first and last characters | Most efficient C # program to count all substrings with same first and last characters . ; assuming lower case only ; Calculating frequency of each character in the string . ; Computing result using counts ; Driver code"
C#;"using System ; class GFG { static char maxRepeating ( string str ) { int n = str . Length ; int count = 0 ; char res = str [ 0 ] ; int cur_count = 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str [ i ] == str [ i + 1 ] ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } cur_count = 1 ; } } return res ; } public static void Main ( ) { string str = "" aaaabbaaccde "" ; Console . Write ( maxRepeating ( str ) ) ; } }";"Maximum consecutive repeating character in string | C # program to find the maximum consecutive repeating character in given string ; function to find out the maximum repeating character in given string ; Traverse string except last character ; If current character matches with next ; If doesn 't match, update result  (if required) and reset count ; Driver code"
C#;"using System ; public class Query_Subsequence { static int MAX = 10000 ; static int CHAR_SIZE = 26 ; static void precompute ( int [ , ] mat , string str , int len ) { for ( int i = 0 ; i < CHAR_SIZE ; ++ i ) mat [ len , i ] = len ; for ( int i = len - 1 ; i >= 0 ; -- i ) { for ( int j = 0 ; j < CHAR_SIZE ; ++ j ) mat [ i , j ] = mat [ i + 1 , j ] ; mat [ i , str [ i ] - ' a ' ] = i ; } } static bool query ( int [ , ] mat , string str , int len ) { int pos = 0 ; for ( int i = 0 ; i < str . Length ; ++ i ) { if ( mat [ pos , str [ i ] - ' a ' ] >= len ) return false ; else pos = mat [ pos , str [ i ] - ' a ' ] + 1 ; } return true ; } public static void Main ( ) { string S = "" geeksforgeeks "" ; int len = S . Length ; int [ , ] mat = new int [ MAX , CHAR_SIZE ] ; precompute ( mat , S , len ) ; string get = query ( mat , "" gg "" , len ) ? "" Yes "" : "" No "" ; Console . WriteLine ( get ) ; get = query ( mat , "" gro "" , len ) ? "" Yes "" : "" No "" ; Console . WriteLine ( get ) ; get = query ( mat , "" gfg "" , len ) ? "" Yes "" : "" No "" ; Console . WriteLine ( get ) ; get = query ( mat , "" orf "" , len ) ? "" Yes "" : "" No "" ; Console . WriteLine ( get ) ; } }";"Queries on subsequence of string | C # program to answer subsequence queries for a given string ; Precompute the position of each character from each position of String S ; Computing position of each character from each position of String S ; Print "" Yes "" if T is subsequence of S , else "" No "" ; Traversing the string T ; If next position is greater than length of S set flag to false . ; Setting position of next character ; Driver Code"
C#;"using System ; public class GFG { static void query ( string s , int i , int j ) { int n = s . Length ; i %= n ; j %= n ; if ( s [ i ] == s [ j ] ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } static public void Main ( ) { string X = "" geeksforgeeks "" ; query ( X , 0 , 8 ) ; query ( X , 8 , 13 ) ; query ( X , 6 , 15 ) ; } }";"Queries for characters in a repeated string | C # Program to Queries for same characters in a repeated string ; Print whether index i and j have same element or not ; Finding relative position of index i , j . ; Checking is element are same at index i , j ; Driver Code"
C#;"using System ; class Test { static int countPairs ( string str ) { int result = 0 ; int n = str . Length ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) if ( Math . Abs ( str [ i ] - str [ j ] ) == Math . Abs ( i - j ) ) result ++ ; return result ; } public static void Main ( ) { string str = "" geeksforgeeks "" ; Console . WriteLine ( countPairs ( str ) ) ; } }";"Count of character pairs at same distance as in English alphabets | A Simple C # program to find pairs with distance equal to English alphabet distance ; Method to count pairs ; Increment count if characters are at same distance ; Driver method"
C#;"using System ; class GFG { static void longestString ( String str1 , String str2 ) { int [ ] count1 = new int [ 26 ] ; int [ ] count2 = new int [ 26 ] ; for ( int i = 0 ; i < str1 . Length ; i ++ ) { count1 [ str1 [ i ] - ' a ' ] ++ ; } for ( int i = 0 ; i < str2 . Length ; i ++ ) { count2 [ str2 [ i ] - ' a ' ] ++ ; } String result = "" "" ; for ( int i = 0 ; i < 26 ; i ++ ) { for ( int j = 1 ; j <= Math . Min ( count1 [ i ] , count2 [ i ] ) ; j ++ ) { result += ( char ) ( ' a ' + i ) ; } } Console . Write ( result ) ; } public static void Main ( ) { String str1 = "" geeks "" , str2 = "" cake "" ; longestString ( str1 , str2 ) ; } }";"Longest common subsequence with permutations allowed | C # program to find LCS with permutations allowed ; Function to calculate longest String str1 -- > first String str2 -- > second String count1 [ ] -- > hash array to calculate frequency of characters in str1 count [ 2 ] -- > hash array to calculate frequency of characters in str2 result -- > resultant longest String whose permutations are sub - sequence of given two strings ; calculate frequency of characters ; Now traverse hash array ; append character ( ' a ' + i ) in resultant String ' result ' by min ( count1 [ i ] , count2i ] ) times ; Driver Code"
C#;"using System ; class GFG { static Boolean checkPattern ( String str , String pattern ) { int len = pattern . Length ; if ( str . Length < len ) { return false ; } for ( int i = 0 ; i < len - 1 ; i ++ ) { char x = pattern [ i ] ; char y = pattern [ i + 1 ] ; int last = str . LastIndexOf ( x ) ; int first = str . IndexOf ( y ) ; if ( last == - 1 first == - 1 last > first ) { return false ; } } return true ; } public static void Main ( String [ ] args ) { String str = "" engineers ▁ rock "" ; String pattern = "" gsr "" ; Console . WriteLine ( checkPattern ( str , pattern ) ) ; } }";"Check if string follows order of characters defined by a pattern or not | Set 1 | C # program check if characters in the input string follows the same order as determined by characters present in the given pattern ; Function to check if characters in the input string follows the same order as determined by characters present in the given pattern ; len stores length of the given pattern ; if length of pattern is more than length of input string , return false ; ; x , y are two adjacent characters in pattern ; find index of last occurrence of character x in the input string ; find index of first occurrence of character y in the input string ; return false if x or y are not present in the input string OR last occurrence of x is after the first occurrence of y in the input string ; return true if string matches the pattern ; Driver code"
C#;"using System ; class GFG { static int findSum ( String str ) { String temp = ""0"" ; int sum = 0 ; for ( int i = 0 ; i < str . Length ; i ++ ) { char ch = str [ i ] ; if ( char . IsDigit ( ch ) ) temp += ch ; else { sum += int . Parse ( temp ) ; temp = ""0"" ; } } return sum + int . Parse ( temp ) ; } public static void Main ( String [ ] args ) { String str = ""12abc20yz68"" ; Console . WriteLine ( findSum ( str ) ) ; } }";"Calculate sum of all numbers present in a string | C # program to calculate sum of all numbers present in a string containing alphanumeric characters ; Function to calculate sum of all numbers present in a string containing alphanumeric characters ; A temporary string ; holds sum of all numbers present in the string ; read each character in input string ; if current character is a digit ; if current character is an alphabet ; increment sum by number found earlier ( if any ) ; reset temporary string to empty ; atoi ( temp . c_str ( ) ) takes care of trailing numbers ; Driver code ; input alphanumeric string ; Function call"
C#;"using System ; public class CountKSubStr { int countkDist ( string str , int k ) { int res = 0 ; int n = str . Length ; int [ ] cnt = new int [ 26 ] ; for ( int i = 0 ; i < n ; i ++ ) { int dist_count = 0 ; Array . Clear ( cnt , 0 , cnt . Length ) ; for ( int j = i ; j < n ; j ++ ) { if ( cnt [ str [ j ] - ' a ' ] == 0 ) dist_count ++ ; cnt [ str [ j ] - ' a ' ] ++ ; if ( dist_count == k ) res ++ ; } } return res ; } public static void Main ( ) { CountKSubStr ob = new CountKSubStr ( ) ; string ch = "" abcbaa "" ; int k = 3 ; Console . Write ( "" Total ▁ substrings ▁ with ▁ exactly ▁ "" + k + "" ▁ distinct ▁ characters ▁ : ▁ "" + ob . countkDist ( ch , k ) ) ; } }";"Count number of substrings with exactly k distinct characters | C # program to CountKSubStr number of substrings with exactly distinct characters in a given string ; Function to count number of substrings with exactly k unique characters ; Initialize result ; To store count of characters from ' a ' to ' z ' ; Consider all substrings beginning with str [ i ] ; Initializing count array with 0 ; Consider all substrings between str [ i . . j ] ; If this is a new character for this substring , increment dist_count . ; Increment count of current character ; If distinct character count becomes k , then increment result . ; Driver Program"
C#;"using System ; class GFG { static String to_upper ( char [ ] In ) { for ( int i = 0 ; i < In . Length ; i ++ ) { if ( ' a ' <= In [ i ] & In [ i ] <= ' z ' ) { In [ i ] = ( char ) ( In [ i ] - ' a ' + ' A ' ) ; } } return String . Join ( "" "" , In ) ; } public static void Main ( ) { String str = "" geeksforgeeks "" ; Console . WriteLine ( to_upper ( str . ToCharArray ( ) ) ) ; } }";"Lower case to upper case | C # program to convert a string to uppercase ; Converts a string to uppercase ; Driver code"
C#;"using System ; class GFG { static int findMinLength ( String [ ] arr , int n ) { int min = arr [ 0 ] . Length ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] . Length < min ) { min = arr [ i ] . Length ; } } return ( min ) ; } static String commonPrefix ( String [ ] arr , int n ) { int minlen = findMinLength ( arr , n ) ; String result = "" "" ; for ( int i = 0 ; i < minlen ; i ++ ) { current = arr [ 0 ] [ i ] ; for ( int j = 1 ; j < n ; j ++ ) { if ( arr [ j ] [ i ] != current ) { return result ; } } result += ( current ) ; } return ( result ) ; } public static void Main ( String [ ] args ) { String [ ] arr = { "" geeksforgeeks "" , "" geeks "" , "" geek "" , "" geezer "" } ; int n = arr . Length ; String ans = commonPrefix ( arr , n ) ; if ( ans . Length > 0 ) { Console . WriteLine ( "" The ▁ longest ▁ common ▁ prefix ▁ is ▁ "" + ans ) ; } else { Console . WriteLine ( "" There ▁ is ▁ no ▁ common ▁ prefix "" ) ; } } }";"Longest Common Prefix using Character by Character Matching | A C # Program to find the longest common prefix ; A Function to find the string having the minimum length and returns that length ; A Function that returns the longest common prefix from the array of strings ; Our resultant string char current ; The current character ; Current character ( must be same in all strings to be a part of result ) ; Append to result ; Driver code"
C#;"using System ; class GFG { static void printZigZagConcat ( string str , int n ) { if ( n == 1 ) { Console . Write ( str ) ; return ; } char [ ] str1 = str . ToCharArray ( ) ; int len = str . Length ; string [ ] arr = new string [ n ] ; int row = 0 ; bool down = true ; for ( int i = 0 ; i < len ; ++ i ) { arr [ row ] += ( str1 [ i ] ) ; if ( row == n - 1 ) down = false ; else if ( row == 0 ) down = true ; if ( down ) row ++ ; else row -- ; } for ( int i = 0 ; i < n ; ++ i ) Console . Write ( arr [ i ] ) ; } public static void Main ( ) { String str = "" GEEKSFORGEEKS "" ; int n = 3 ; printZigZagConcat ( str , n ) ; } }";"Print Concatenation of Zig | C # program to print string obtained by concatenation of different rows of Zig - Zag fashion ; Prints concatenation of all rows of str 's  Zig-Zag fashion ; Corner Case ( Only one row ) ; Find length of string ; Create an array of strings for all n rows ; Initialize index for array of strings arr [ ] ; True if we are moving down in rows , else false ; Traverse through given string ; append current character to current row ; If last row is reached , change direction to ' up ' ; If 1 st row is reached , change direction to ' down ' ; If direction is down , increment , else decrement ; Print concatenation of all rows ; Driver Code"
C#;"using System ; class GFG { static int size = 256 ; static bool areIsomorphic ( String str1 , String str2 ) { int m = str1 . Length ; int n = str2 . Length ; if ( m != n ) return false ; bool [ ] marked = new bool [ size ] ; for ( int i = 0 ; i < size ; i ++ ) marked [ i ] = false ; int [ ] map = new int [ size ] ; for ( int i = 0 ; i < size ; i ++ ) map [ i ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( map [ str1 [ i ] ] == - 1 ) { if ( marked [ str2 [ i ] ] == true ) return false ; marked [ str2 [ i ] ] = true ; map [ str1 [ i ] ] = str2 [ i ] ; } else if ( map [ str1 [ i ] ] != str2 [ i ] ) return false ; } return true ; } public static void Main ( ) { bool res = areIsomorphic ( "" aab "" , "" xxy "" ) ; Console . WriteLine ( res ) ; res = areIsomorphic ( "" aab "" , "" xyz "" ) ; Console . WriteLine ( res ) ; } }";"Check if two given strings are isomorphic to each other | C # program to check if two strings are isomorphic ; Function returns true if str1 and str2 are isomorphic ; Length of both strings must be same for one to one corresponance ; To mark visited characters in str2 ; To store mapping of every character from str1 to that of str2 and Initialize all entries of map as - 1. ; Process all characters one by on ; If current character of str1 is seen first time in it . ; If current character of str2 is already seen , one to one mapping not possible ; Mark current character of str2 as visited ; Store mapping of current characters ; If this is not first appearance of current character in str1 , then check if previous appearance mapped to same character of str2 ; Driver code"
C#;"using System ; class GFG { static int CHAR = 26 ; static bool isoMorphic ( string str1 , string str2 ) { int n = str1 . Length ; int m = str2 . Length ; if ( n != m ) return false ; int [ ] countChars1 = new int [ CHAR ] ; int [ ] countChars2 = new int [ CHAR ] ; for ( int i = 0 ; i < n ; i ++ ) { countChars1 [ str1 [ i ] - ' a ' ] ++ ; countChars2 [ str2 [ i ] - ' a ' ] ++ ; if ( countChars1 [ str1 [ i ] - ' a ' ] != countChars2 [ str2 [ i ] - ' a ' ] ) { return false ; } } return true ; } public static void Main ( string [ ] args ) { Console . WriteLine ( isoMorphic ( "" aab "" , "" xxy "" ) ? 1 : 0 ) ; Console . WriteLine ( isoMorphic ( "" aab "" , "" xyz "" ) ? 1 : 0 ) ; } }";"Check if two given strings are isomorphic to each other | C # program for the above approach ; This function returns true if str1 and str2 are isomorphic ; Length of both strings must be same for one to one correspondence ; For counting the previous appearances of character in both the strings ; Process all characters one by one ; For string to be isomorphic the previous counts of appearances of current character in both string must be same if it is not same we return false . ; Driver Code"
C#;"using System ; using System . Text ; class GFG { static bool isPalin ( char [ ] str , int st , int end ) { while ( st < end ) { if ( str [ st ] != str [ end ] ) return false ; st ++ ; end -- ; } return true ; } static int findMinInsert ( char [ ] str , int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( isPalin ( str , 0 , i ) ) return ( n - i - 1 ) ; } return 0 ; } public static void Main ( string [ ] args ) { char [ ] Input = "" JAVA "" . ToCharArray ( ) ; Console . Write ( findMinInsert ( Input , Input . Length ) ) ; } }";"Minimum insertions to form shortest palindrome | C # program to find minimum number of insertions on left side to form a palindrome . ; Returns true if a string str [ st . . end ] is palindrome ; Returns count of insertions on left side to make str [ ] a palindrome ; Find the largest prefix of given string that is palindrome . ; Characters after the palindromic prefix must be added at the beginning also to make the complete string palindrome ; Driver Code"
C#;"using System ; class GFG { static long removeRecur ( long n ) { long prev_digit = n % 10 ; long pow = 10 ; long res = prev_digit ; while ( n > 0 ) { long curr_digit = n % 10 ; if ( curr_digit != prev_digit ) { res += curr_digit * pow ; prev_digit = curr_digit ; pow *= 10 ; } n = n / 10 ; } return res ; } public static void Main ( ) { long n = 12224 ; Console . WriteLine ( removeRecur ( n ) ) ; } }";"Remove repeated digits in a given number | C # program to remove repeated digits ; Store first digits as previous digit ; Initialize power ; Iterate through all digits of n , note that the digits are processed from least significant digit to most significant digit . ; Store current digit ; Add the current digit to the beginning of result ; Update previous result and power ; Remove last digit from n ; Driver program"
C#;"using System ; class GfG { static void stringFilter ( char [ ] str ) { int n = str . Length ; int i = - 1 ; int j = 0 ; while ( j < n ) { if ( j < n - 1 && str [ j ] == ' a ' && str [ j + 1 ] == ' c ' ) j += 2 ; else if ( str [ j ] == ' b ' ) j ++ ; else if ( i >= 0 && str [ j ] == ' c ' && str [ i ] == ' a ' ) { i -- ; j ++ ; } else str [ ++ i ] = str [ j ++ ] ; } Console . WriteLine ( new String ( str ) ) ; } public static void Main ( ) { String str1 = "" ad "" ; stringFilter ( str1 . ToCharArray ( ) ) ; String str2 = "" acbac "" ; stringFilter ( str2 . ToCharArray ( ) ) ; String str3 = "" aaac "" ; stringFilter ( str3 . ToCharArray ( ) ) ; String str4 = "" react "" ; stringFilter ( str4 . ToCharArray ( ) ) ; String str5 = "" aa "" ; stringFilter ( str5 . ToCharArray ( ) ) ; String str6 = "" ababaac "" ; stringFilter ( str6 . ToCharArray ( ) ) ; } }";"Remove "" b "" and "" ac "" from a given string | C # program to remove "" b "" and ' ac ' from input string ; The main function that removes occurrences of "" a "" and "" bc "" in input string ; previous character ; current character ; check if current and next character forms ac ; if current character is b ; if current char is ' c ▁ & & ▁ last ▁ char ▁ in ▁ output ▁ ▁ ▁ is ▁ ' a ' so delete both  ; else copy curr char to output string ; Driver Code"
C#;"using System ; class GFG { static int myAtoi ( char [ ] str ) { int sign = 1 , Base = 0 , i = 0 ; while ( str [ i ] == ' ▁ ' ) { i ++ ; } if ( str [ i ] == ' - ' str [ i ] == ' + ' ) { sign = 1 - 2 * ( str [ i ++ ] == ' - ' ? 1 : 0 ) ; } while ( i < str . Length && str [ i ] >= '0' && str [ i ] <= '9' ) { if ( Base > int . MaxValue / 10 || ( Base == int . MaxValue / 10 && str [ i ] - '0' > 7 ) ) { if ( sign == 1 ) return int . MaxValue ; else return int . MinValue ; } Base = 10 * Base + ( str [ i ++ ] - '0' ) ; } return Base * sign ; } public static void Main ( String [ ] args ) { char [ ] str = "" ▁ - 123"" . ToCharArray ( ) ; int val = myAtoi ( str ) ; Console . Write ( "" { 0 } ▁ "" , val ) ; } }";"Write your own atoi ( ) | A simple C # program for implementation of atoi ; if whitespaces then ignore . ; sign of number ; checking for valid input ; handling overflow test case ; Driver code ; Function call"
C#;"using System ; class GFG { static int NO_OF_CHARS = 256 ; static bool areAnagram ( char [ ] str1 , char [ ] str2 ) { int [ ] count = new int [ NO_OF_CHARS ] ; int i ; for ( i = 0 ; i < str1 . Length ; i ++ ) { count [ str1 [ i ] - ' a ' ] ++ ; count [ str2 [ i ] - ' a ' ] -- ; } if ( str1 . Length != str2 . Length ) return false ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( count [ i ] != 0 ) { return false ; } return true ; } public static void Main ( String [ ] args ) { char [ ] str1 = "" geeksforgeeks "" . ToCharArray ( ) ; char [ ] str2 = "" forgeeksgeeks "" . ToCharArray ( ) ; if ( areAnagram ( str1 , str2 ) ) Console . Write ( "" The ▁ two ▁ strings ▁ are ▁ "" + "" anagram ▁ of ▁ each ▁ other "" ) ; else Console . Write ( "" The ▁ two ▁ strings ▁ are ▁ "" + "" not ▁ anagram ▁ of ▁ each ▁ other "" ) ; } }";"Check whether two strings are anagram of each other | C # program to check if two strings are anagrams of each other ; function to check if two strings are anagrams of each other ; Create a count array and initialize all values as 0 ; For each character in input strings , increment count in the corresponding count array ; If both strings are of different Length . Removing this condition will make the program fail for strings like "" aaca "" and "" aca "" ; See if there is any non - zero value in count array ; Driver code ; Function call"
C#;"using System ; class GFG { public static bool areDistinct ( string str , int i , int j ) { bool [ ] visited = new bool [ 26 ] ; for ( int k = i ; k <= j ; k ++ ) { if ( visited [ str [ k ] - ' a ' ] == true ) return false ; visited [ str [ k ] - ' a ' ] = true ; } return true ; } public static int longestUniqueSubsttr ( string str ) { int n = str . Length ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( areDistinct ( str , i , j ) ) res = Math . Max ( res , j - i + 1 ) ; return res ; } public static void Main ( ) { string str = "" geeksforgeeks "" ; Console . WriteLine ( "" The ▁ input ▁ string ▁ is ▁ "" + str ) ; int len = longestUniqueSubsttr ( str ) ; Console . WriteLine ( "" The ▁ length ▁ of ▁ the ▁ longest ▁ "" + "" non - repeating ▁ character ▁ "" + "" substring ▁ is ▁ "" + len ) ; } }";"Length of the longest substring without repeating characters | C # program to find the length of the longest substring without repeating characters ; This function returns true if all characters in str [ i . . j ] are distinct , otherwise returns false ; Note : Default values in visited are false ; Returns length of the longest substring with all distinct characters . ; Result ; Driver code"
C#;"using System ; public class GFG { public static int firstNonRepeating ( string str ) { int [ ] fi = new int [ 256 ] ; for ( int i = 0 ; i < 256 ; i ++ ) fi [ i ] = - 1 ; for ( int i = 0 ; i < str . Length ; i ++ ) { if ( fi [ str [ i ] ] == - 1 ) { fi [ str [ i ] ] = i ; } else { fi [ str [ i ] ] = - 2 ; } } int res = Int32 . MaxValue ; for ( int i = 0 ; i < 256 ; i ++ ) { if ( fi [ i ] >= 0 ) res = Math . Min ( res , fi [ i ] ) ; } if ( res == Int32 . MaxValue ) return - 1 ; else return res ; } public static void Main ( ) { string str ; str = "" geeksforgeeks "" ; int firstIndex = firstNonRepeating ( str ) ; if ( firstIndex == - 1 ) Console . WriteLine ( "" Either ▁ all ▁ characters ▁ are ▁ repeating ▁ or ▁ string ▁ is ▁ empty "" ) ; else Console . WriteLine ( "" First ▁ non - repeating ▁ character ▁ is ▁ "" + str [ firstIndex ] ) ; } }";"Given a string , find its first non | C # program to find first non - repeating character ; this function return the index of first non - repeating character if found , or else it returns - 1 ; initializing all elements to - 1 ; sets all repeating characters to - 2 and non - repeating characters contain the index where they occur ; If this character is not - 1 or - 2 then it means that this character occurred only once so find the min index of all characters that occur only once , that 's our first index ; if res remains Integer . MAX_VALUE , it means there are no characters that repeat only once or the string is empy"
C#;"using System ; public class IndexOf { public static String unique ( String s ) { String str = "" "" ; int len = s . Length ; for ( int i = 0 ; i < len ; i ++ ) { char c = s [ i ] ; if ( str . IndexOf ( c ) < 0 ) { str += c ; } } return str ; } public static void Main ( String [ ] args ) { String s = "" geeksforgeeks "" ; Console . WriteLine ( unique ( s ) ) ; } }";"Remove duplicates from a given string | C # program to create a unique string ; Function to make the string unique ; loop to traverse the string and check for repeating chars using IndexOf ( ) method in Java ; character at i 'th index of s ; if c is present in str , it returns the index of c , else it returns - 1 ; adding c to str if - 1 is returned ; Driver code ; Input string with repeating chars"
C#;"using System ; class GFG { static int isPerfect ( int x ) { int sum_div = 1 ; for ( int i = 2 ; i <= x / 2 ; ++ i ) { if ( x % i == 0 ) { sum_div += i ; } } if ( sum_div == x ) { return 1 ; } else return 0 ; } static void subsetSum ( int [ ] arr , int l , int r , int sum = 0 ) { if ( l > r ) { if ( isPerfect ( sum ) != 0 ) { Console . Write ( sum + "" ▁ "" ) ; } return ; } subsetSum ( arr , l + 1 , r , sum + arr [ l ] ) ; subsetSum ( arr , l + 1 , r , sum ) ; } static void Main ( ) { int [ ] arr = { 5 , 4 , 6 } ; int N = arr . Length ; subsetSum ( arr , 0 , N - 1 ) ; } }";"Sum of all subsets whose sum is a Perfect Number from a given array | C # program for the above approach ; Function to check is a given number is a perfect number or not ; Stores the sum of its divisors ; Add all divisors of x to sum_div ; If the sum of divisors is equal to the given number , return true ; Otherwise , return false ; Function to find sum of all subsets from an array whose sum is a perfect number ; Print the current subset sum if it is a perfect number ; Check if sum is a perfect number or not ; Calculate sum of the subset including arr [ l ] ; Calculate sum of the subset excluding arr [ l ] ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { static void PartitionSub ( int [ ] arr , int i , int N , int K , int nos , List < List < int > > v ) { if ( i >= N ) { if ( nos == K ) { for ( int x = 0 ; x < v . Count ; x ++ ) { Console . Write ( "" { ▁ "" ) ; for ( int y = 0 ; y < v [ x ] . Count ; y ++ ) { Console . Write ( v [ x ] [ y ] ) ; if ( y == v [ x ] . Count - 1 ) { Console . Write ( "" ▁ "" ) ; } else { Console . Write ( "" , ▁ "" ) ; } } if ( x == v . Count - 1 ) { Console . Write ( "" } "" ) ; } else { Console . Write ( "" } , ▁ "" ) ; } } Console . Write ( "" STRNEWLINE "" ) ; } return ; } for ( int j = 0 ; j < K ; j ++ ) { if ( v [ j ] . Count > 0 ) { v [ j ] . Add ( arr [ i ] ) ; PartitionSub ( arr , i + 1 , N , K , nos , v ) ; v [ j ] . RemoveAt ( v [ j ] . Count - 1 ) ; } else { v [ j ] . Add ( arr [ i ] ) ; PartitionSub ( arr , i + 1 , N , K , nos + 1 , v ) ; v [ j ] . RemoveAt ( v [ j ] . Count - 1 ) ; break ; } } } static void partKSubsets ( int [ ] arr , int N , int K ) { List < List < int > > v = new List < List < int > > ( ) ; for ( int i = 0 ; i < K ; i ++ ) v . Add ( new List < int > ( ) ) ; if ( K == 0 K > N ) { Console . WriteLine ( "" Not ▁ Possible "" ) ; } else { Console . WriteLine ( "" The ▁ Subset ▁ Combinations ▁ are : ▁ "" ) ; PartitionSub ( arr , 0 , N , K , 0 , v ) ; } } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 } ; int K = 2 ; int N = arr . Length ; partKSubsets ( arr , N , K ) ; } }";"Print all possible ways to split an array into K subsets | C # program for the above approach ; Utility function to find all possible ways to split array into K subsets ; If count of elements in K subsets are greater than or equal to N ; If count of subsets formed is equal to K ; Print K subsets by splitting array into K subsets ; Print current subset ; If current element is the last element of the subset ; Otherwise ; If any subset is occupied , then push the element in that first ; Recursively do the same for remaining elements ; Backtrack ; Otherwise , push it in an empty subset and increase the subset count by 1 ; Break to avoid the case of going in other empty subsets , if available , and forming the same combination ; Function to to find all possible ways to split array into K subsets ; Stores K subset by splitting array into K subsets ; Size of each subset must be less than the number of elements ; Driver Code ; Given array ; Given K ; Size of the array ; Prints all possible splits into subsets"
C#;"using System ; class GFG { static readonly int MAX = 100 ; static int [ ] store = new int [ MAX ] ; static int n ; static int [ , ] graph = new int [ MAX , MAX ] ; static int [ ] d = new int [ MAX ] ; static int ans ; static void SieveOfEratosthenes ( bool [ ] prime , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } static bool is_clique ( int b ) { for ( int i = 1 ; i < b ; i ++ ) { for ( int j = i + 1 ; j < b ; j ++ ) if ( graph [ store [ i ] , store [ j ] ] == 0 ) return false ; } return true ; } static void primeCliques ( int i , int l , bool [ ] prime ) { for ( int j = i + 1 ; j <= n ; j ++ ) { store [ l ] = j ; if ( is_clique ( l + 1 ) ) { if ( prime [ l ] ) ans ++ ; primeCliques ( j , l + 1 , prime ) ; } } } public static void Main ( String [ ] args ) { int [ , ] edges = { { 1 , 2 } , { 2 , 3 } , { 3 , 1 } , { 4 , 3 } , { 4 , 5 } , { 5 , 3 } } ; int size = edges . GetLength ( 0 ) ; n = 5 ; bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i < prime . Length ; i ++ ) prime [ i ] = true ; SieveOfEratosthenes ( prime , n ) ; for ( int i = 0 ; i < size ; i ++ ) { graph [ edges [ i , 0 ] , edges [ i , 1 ] ] = 1 ; graph [ edges [ i , 1 ] , edges [ i , 0 ] ] = 1 ; d [ edges [ i , 0 ] ] ++ ; d [ edges [ i , 1 ] ] ++ ; } ans = 0 ; primeCliques ( 0 , 1 , prime ) ; Console . WriteLine ( ans ) ; } }";"Count the number of Prime Cliques in an undirected graph | C # implementation to count the number of Prime Cliques in an undirected graph ; Stores the vertices ; Graph ; Degree of the vertices ; To store the count of prime cliques ; Function to create Sieve to check primes ; False here indicates that it is not prime ; Condition if prime [ p ] is not changed , then it is a prime ; Update all multiples of p , set them to non - prime ; Function to check if the given set of vertices in store array is a clique or not ; Run a loop for all set of edges ; If any edge is missing ; Function to find the count of all the cliques having prime size ; Check if any vertices from i + 1 can be inserted ; Add the vertex to store ; If the graph is not a clique of size k then it cannot be a clique by adding another edge ; Increase the count of prime cliques if the size of current clique is prime ; Check if another edge can be added ; Driver code"
C#;"using System ; class GFG { static int dim = 3 ; public class Node { public int data ; public Node next , prev , up , down ; } ; static Node createNode ( int data ) { Node temp = new Node ( ) ; temp . data = data ; temp . next = null ; temp . prev = null ; temp . up = null ; temp . down = null ; return temp ; } static Node constructDoublyListUtil ( int [ , ] mtrx , int i , int j , Node curr ) { if ( i >= dim j >= dim ) { return null ; } Node temp = createNode ( mtrx [ i , j ] ) ; temp . prev = curr ; temp . up = curr ; temp . next = constructDoublyListUtil ( mtrx , i , j + 1 , temp ) ; temp . down = constructDoublyListUtil ( mtrx , i + 1 , j , temp ) ; return temp ; } static Node constructDoublyList ( int [ , ] mtrx ) { return constructDoublyListUtil ( mtrx , 0 , 0 , null ) ; } static void display ( Node head ) { Node rPtr ; Node dPtr = head ; while ( dPtr != null ) { rPtr = dPtr ; while ( rPtr != null ) { Console . Write ( rPtr . data + "" ▁ "" ) ; rPtr = rPtr . next ; } Console . Write ( "" STRNEWLINE "" ) ; dPtr = dPtr . down ; } } public static void Main ( ) { int [ , ] mtrx = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; Node list = constructDoublyList ( mtrx ) ; display ( list ) ; } }";"Construct a Doubly linked linked list from 2D Matrix | C # program to construct a Doubly linked linked list from 2D Matrix ; define dimension of matrix ; struct node of doubly linked list with four pointer next , prev , up , down ; function to create a new node ; function to construct the doubly linked list ; Create Node with value contain in matrix at index ( i , j ) ; Assign address of curr into the prev pointer of temp ; Assign address of curr into the up pointer of temp ; Recursive call for next pointer ; Recursive call for down pointer ; Return newly constructed node whose all four node connected at it 's appropriate position ; Function to construct the doubly linked list ; function call for construct the doubly linked list ; function for displaying doubly linked list data ; pointer to move right ; pointer to move down ; loop till node . down is not null ; loop till node . right is not null ; driver code ; initialise matrix"
C#;"using System ; class GFG { public class Node { public int key ; public Node left , right ; } static Node newNode ( int key ) { Node temp = new Node ( ) ; temp . key = key ; temp . left = temp . right = null ; return ( temp ) ; } static int find_x ( int n ) { if ( n == 1 ) return 1 ; double num , den , p ; num = Math . Log10 ( n ) ; int x = 0 , no = 0 ; for ( int i = 2 ; i <= n ; i ++ ) { den = Math . Log10 ( i ) ; p = num / den ; no = ( int ) ( Math . Pow ( i , ( int ) p ) ) ; if ( Math . Abs ( no - n ) < 0.000001 ) { x = i ; break ; } } return x ; } static bool is_key ( int n , int x ) { double p ; p = Math . Log10 ( n ) / Math . Log10 ( x ) ; int no = ( int ) ( Math . Pow ( x , ( int ) p ) ) ; if ( n == no ) return true ; return false ; } static int evenPaths ( Node node , int count , int x ) { if ( node == null || ! is_key ( node . key , x ) ) { return count ; } if ( node . left == null && node . right == null ) { count ++ ; } count = evenPaths ( node . left , count , x ) ; return evenPaths ( node . right , count , x ) ; } static int countExpPaths ( Node node , int x ) { return evenPaths ( node , 0 , x ) ; } public static void Main ( string [ ] args ) { Node root = newNode ( 27 ) ; root . left = newNode ( 9 ) ; root . right = newNode ( 81 ) ; root . left . left = newNode ( 3 ) ; root . left . right = newNode ( 10 ) ; root . right . left = newNode ( 70 ) ; root . right . right = newNode ( 243 ) ; root . right . right . left = newNode ( 81 ) ; root . right . right . right = newNode ( 909 ) ; int x = find_x ( root . key ) ; Console . Write ( countExpPaths ( root , x ) ) ; } }";"Count of exponential paths in a Binary Tree | C # program to find the count exponential paths in Binary Tree ; Structure of a Tree node ; Function to create a new node ; Function to find x ; Take log10 of n ; Log ( n ) with base i ; Raising i to the power p ; Function to check whether the given node equals to x ^ y for some y > 0 ; Take logx ( n ) with base x ; Utility function to count the exponent path in a given Binary tree ; Base Condition , when node pointer becomes null or node value is not a number of pow ( x , y ) ; Increment count when encounter leaf node ; Left recursive call save the value of count ; Right recursive call and return value of count ; Function to count exponential paths ; Driver code ; Create Tree ; Retrieve the value of x ; Function call"
C#;"using System ; using System . Collections . Generic ; class GFG { static int N = 1000001 ; static int c , n , m , a , b ; static void dfs ( int a , int b , List < int > [ ] v , int [ ] vis ) { vis [ a ] = 1 ; c ++ ; foreach ( int i in v [ a ] ) { if ( vis [ i ] == 0 && i != b ) dfs ( i , b , v , vis ) ; } } static void Calculate ( List < int > [ ] v ) { int [ ] vis = new int [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) vis [ i ] = 0 ; c = 0 ; dfs ( a , b , v , vis ) ; int ans1 = n - c - 1 ; for ( int i = 0 ; i < n + 1 ; i ++ ) vis [ i ] = 0 ; c = 0 ; dfs ( b , a , v , vis ) ; int ans2 = n - c - 1 ; Console . Write ( ans1 * ans2 + "" STRNEWLINE "" ) ; } public static void Main ( String [ ] args ) { n = 7 ; m = 7 ; a = 3 ; b = 5 ; int [ , ] edges = { { 1 , 2 } , { 2 , 3 } , { 3 , 4 } , { 4 , 5 } , { 5 , 6 } , { 6 , 7 } , { 7 , 5 } } ; List < int > [ ] v = new List < int > [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { v [ i ] = new List < int > ( ) ; } for ( int i = 0 ; i < m ; i ++ ) { v [ edges [ i , 0 ] ] . Add ( edges [ i , 1 ] ) ; v [ edges [ i , 1 ] ] . Add ( edges [ i , 0 ] ) ; } Calculate ( v ) ; } }";"Number of pairs such that path between pairs has the two vertices A and B | C # program to find the number of pairs such that the path between every pair contains two given vertices ; Function to perform DFS on the given graph by fixing the a vertex ; To mark a particular vertex as visited ; Variable to store the count of the vertices which can be reached from a ; Performing the DFS by iterating over the visited array ; If the vertex is not visited and removing the vertex b ; Function to return the number of pairs such that path between any two pairs consists of the given two vertices A and B ; Initializing the visited array and assigning it with 0 's ; Initially , the count of vertices is 0 ; Performing DFS by removing the vertex B ; Count the vertices which cannot be reached after removing the vertex B ; Again reinitializing the visited array ; Setting the count of vertices to 0 to perform the DFS again ; Performing the DFS by removing the vertex A ; Count the vertices which cannot be reached after removing the vertex A ; Multiplying both the vertices set ; Driver code ; Loop to store the graph"
C#;"using System ; class GFG { static int tsp ( int [ , ] graph , bool [ ] v , int currPos , int n , int count , int cost , int ans ) { if ( count == n && graph [ currPos , 0 ] > 0 ) { ans = Math . Min ( ans , cost + graph [ currPos , 0 ] ) ; return ans ; } for ( int i = 0 ; i < n ; i ++ ) { if ( v [ i ] == false && graph [ currPos , i ] > 0 ) { v [ i ] = true ; ans = tsp ( graph , v , i , n , count + 1 , cost + graph [ currPos , i ] , ans ) ; v [ i ] = false ; } } return ans ; } static void Main ( ) { int n = 4 ; int [ , ] graph = { { 0 , 10 , 15 , 20 } , { 10 , 0 , 35 , 25 } , { 15 , 35 , 0 , 30 } , { 20 , 25 , 30 , 0 } } ; bool [ ] v = new bool [ n ] ; v [ 0 ] = true ; int ans = int . MaxValue ; ans = tsp ( graph , v , 0 , n , 1 , 0 , ans ) ; Console . Write ( ans ) ; } }";"Travelling Salesman Problem implementation using BackTracking | C # implementation of the approach ; Function to find the minimum weight Hamiltonian Cycle ; If last node is reached and it has a link to the starting node i . e the source then keep the minimum value out of the total cost of traversal and "" ans "" Finally return to check for more possible values ; BACKTRACKING STEP Loop to traverse the adjacency list of currPos node and increasing the count by 1 and cost by graph [ currPos , i ] value ; Mark as visited ; Mark ith node as unvisited ; Driver code ; n is the number of nodes i . e . V ; Boolean array to check if a node has been visited or not ; Mark 0 th node as visited ; Find the minimum weight Hamiltonian Cycle ; ans is the minimum weight Hamiltonian Cycle"
C#;"using System ; class GFG { static void printTheArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) { Console . Write ( arr [ i ] + "" ▁ "" ) ; } Console . WriteLine ( ) ; } static void generateAllBinaryStrings ( int n , int [ ] arr , int i ) { if ( i == n ) { printTheArray ( arr , n ) ; return ; } arr [ i ] = 0 ; generateAllBinaryStrings ( n , arr , i + 1 ) ; arr [ i ] = 1 ; generateAllBinaryStrings ( n , arr , i + 1 ) ; } public static void Main ( String [ ] args ) { int n = 4 ; int [ ] arr = new int [ n ] ; generateAllBinaryStrings ( n , arr , 0 ) ; } }";"Generate all the binary strings of N bits | C # implementation of the above approach : ; Function to print the output ; Function to generate all binary strings ; First assign ""0"" at ith position and try for all other permutations for remaining positions ; And then assign ""1"" at ith position and try for all other permutations for remaining positions ; Driver Code ; Print all binary strings"
C#;"using System ; using System . Collections . Generic ; class GFG { static void printResult ( char [ ] result , int len ) { for ( int i = 0 ; i <= len ; i ++ ) Console . Write ( result [ i ] ) ; Console . WriteLine ( ) ; } static void stringCombination ( char [ ] result , char [ ] str , int [ ] count , int level , int size , int length ) { if ( level == size ) return ; for ( int i = 0 ; i < length ; i ++ ) { if ( count [ i ] == 0 ) continue ; count [ i ] -- ; result [ level ] = str [ i ] ; printResult ( result , level ) ; stringCombination ( result , str , count , level + 1 , size , length ) ; count [ i ] ++ ; } } static void combination ( String str ) { int i ; Dictionary < char , int > mp = new Dictionary < char , int > ( ) ; for ( i = 0 ; i < str . Length ; i ++ ) if ( mp . ContainsKey ( str [ i ] ) ) mp [ str [ i ] ] = mp [ str [ i ] ] + 1 ; else mp . Add ( str [ i ] , 1 ) ; char [ ] input = new char [ mp . Count ] ; int [ ] count = new int [ mp . Count ] ; char [ ] result = new char [ str . Length ] ; i = 0 ; foreach ( KeyValuePair < char , int > entry in mp ) { input [ i ] = entry . Key ; count [ i ] = entry . Value ; i ++ ; } int length = mp . Count ; int size = str . Length ; stringCombination ( result , input , count , 0 , size , length ) ; } public static void Main ( String [ ] args ) { String str = "" ABC "" ; combination ( str ) ; } }";"Print all the combinations of a string in lexicographical order | C # program to find all combinations of a string in lexicographical order ; function to print string ; Method to found all combination of string it is based in tree ; return if level is equal size of string ; if occurrence of char is 0 then skip the iteration of loop ; decrease the char occurrence by 1 ; store the char in result ; print the string till level ; call the function from level + 1 ; backtracking ; declare the map for store each char with occurrence ; initialize the input array with all unique char ; initialize the count array with occurrence the unique char ; temporary char array for store the result ; store the element of input array ; store the element of count array ; size of map ( no of unique char ) ; size of original string ; call function for print string combination ; Driver code"
C#;"using System ; using System . Collections . Generic ; class Test { static void allCombinationsRec ( List < int > arr , int elem , int n ) { if ( elem > n ) { foreach ( int i in arr ) Console . Write ( i + "" ▁ "" ) ; Console . WriteLine ( ) ; return ; } for ( int i = 0 ; i < 2 * n ; i ++ ) { if ( arr [ i ] == - 1 && ( i + elem + 1 ) < 2 * n && arr [ i + elem + 1 ] == - 1 ) { arr [ i ] = elem ; arr [ i + elem + 1 ] = elem ; allCombinationsRec ( arr , elem + 1 , n ) ; arr [ i ] = - 1 ; arr [ i + elem + 1 ] = - 1 ; } } } static void allCombinations ( int n ) { List < int > arr = new List < int > ( ) ; for ( int i = 0 ; i < 2 * n ; i ++ ) { arr . Add ( - 1 ) ; } int elem = 1 ; allCombinationsRec ( arr , elem , n ) ; } public static void Main ( string [ ] args ) { int n = 3 ; allCombinations ( n ) ; } }";"Combinations where every element appears twice and distance between appearances is equal to the value | C # program to find all combinations where every element appears twice and distance between appearances is equal to the value ; Find all combinations that satisfies given constraints ; If all elements are filled , print the solution ; Try all possible combinations for element elem ; If position i and ( i + elem + 1 ) are not occupied in the vector ; Place elem at position i and ( i + elem + 1 ) ; Recurse for next element ; Backtrack ( remove elem from position i and ( i + elem + 1 ) ) ; Create a vector of double the size of given number with ; All its elements initialized by 1 ; Start from element 1 ; Driver Code ; Given number"
C#;"using System ; class GFG { static bool fillUtil ( int [ ] res , int curr , int n ) { if ( curr == 0 ) return true ; int i ; for ( i = 0 ; i < 2 * n - curr - 1 ; i ++ ) { if ( res [ i ] == 0 && res [ i + curr + 1 ] == 0 ) { res [ i ] = res [ i + curr + 1 ] = curr ; if ( fillUtil ( res , curr - 1 , n ) ) return true ; res [ i ] = res [ i + curr + 1 ] = 0 ; } } return false ; } static void fill ( int n ) { int [ ] res = new int [ 2 * n ] ; int i ; for ( i = 0 ; i < ( 2 * n ) ; i ++ ) res [ i ] = 0 ; if ( fillUtil ( res , n , n ) ) { for ( i = 0 ; i < 2 * n ; i ++ ) Console . Write ( res [ i ] + "" ▁ "" ) ; } else Console . Write ( "" Not ▁ Possible "" ) ; } static public void Main ( ) { fill ( 7 ) ; } }";"Fill two instances of all numbers from 1 to n in a specific way | A backtracking based C # Program to fill two instances of all numbers from 1 to n in a specific way ; A recursive utility function to fill two instances of numbers from 1 to n in res [ 0. .2 n - 1 ] . ' curr ' is current value of n . ; If current number becomes 0 , then all numbers are filled ; Try placing two instances of ' curr ' at all possible locations till solution is found ; Two ' curr ' should be placed at ' curr + 1' distance ; Plave two instances of ' curr ' ; Recur to check if the above placement leads to a solution ; If solution is not possible , then backtrack ; This function prints the result for input number ' n ' using fillUtil ( ) ; Create an array of size 2 n and initialize all elements in it as 0 ; If solution is possible , then print it . ; Driver Code"
C#;"using System ; using System . Collections ; using System . Collections . Generic ; class GFG { class node { public int color = 1 ; public HashSet < int > edges = new HashSet < int > ( ) ; } ; static int canPaint ( List < node > nodes , int n , int m ) { List < int > visited = new List < int > ( ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) { visited . Add ( 0 ) ; } int maxColors = 1 ; for ( int sv = 1 ; sv <= n ; sv ++ ) { if ( visited [ sv ] > 0 ) continue ; visited [ sv ] = 1 ; Queue q = new Queue ( ) ; q . Enqueue ( sv ) ; while ( q . Count != 0 ) { int top = ( int ) q . Peek ( ) ; q . Dequeue ( ) ; foreach ( int it in nodes [ top ] . edges ) { if ( nodes [ top ] . color == nodes [ it ] . color ) nodes [ it ] . color += 1 ; maxColors = Math . Max ( maxColors , Math . Max ( nodes [ top ] . color , nodes [ it ] . color ) ) ; if ( maxColors > m ) return 0 ; if ( visited [ it ] == 0 ) { visited [ it ] = 1 ; q . Enqueue ( it ) ; } } } } return 1 ; } public static void Main ( ) { int n = 4 ; int [ , ] graph = { { 0 , 1 , 1 , 1 } , { 1 , 0 , 1 , 0 } , { 1 , 1 , 0 , 1 } , { 1 , 0 , 1 , 0 } } ; List < node > nodes = new List < node > ( ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) { nodes . Add ( new node ( ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( graph [ i , j ] > 0 ) { nodes [ i ] . edges . Add ( i ) ; nodes [ j ] . edges . Add ( j ) ; } } } Console . WriteLine ( canPaint ( nodes , n , m ) ) ; } }";"m Coloring Problem | Backtracking | C # program for the above approach ; A node class which stores the color and the edges connected to the node ; Create a visited array of n nodes , initialized to zero ; maxColors used till now are 1 as all nodes are painted color 1 ; Do a full BFS traversal from all unvisited starting points ; If the starting point is unvisited , mark it visited and push it in queue ; BFS Travel starts here ; Checking all adjacent nodes to "" top "" edge in our queue ; IMPORTANT : If the color of the adjacent node is same , increase it by 1 ; If number of colors used shoots m , return 0 ; If the adjacent node is not visited , mark it visited and push it in queue ; Driver code ; Create a vector of n + 1 nodes of type "" node "" The zeroth position is just dummy ( 1 to n to be used ) ; Add edges to each node as per given input ; Connect the undirected graph ; Display final answer"
C#;"using System ; class GFG { static void FastDoubling ( int n , int [ ] res ) { int a , b , c , d ; int MOD = 1000000007 ; if ( n == 0 ) { res [ 0 ] = 0 ; res [ 1 ] = 1 ; return ; } FastDoubling ( ( n / 2 ) , res ) ; a = res [ 0 ] ; b = res [ 1 ] ; c = 2 * b - a ; if ( c < 0 ) c += MOD ; c = ( a * c ) % MOD ; d = ( a * a + b * b ) % MOD ; if ( n % 2 == 0 ) { res [ 0 ] = c ; res [ 1 ] = d ; } else { res [ 0 ] = d ; res [ 1 ] = c + d ; } } public static void Main ( ) { int N = 6 ; int [ ] res = new int [ 2 ] ; FastDoubling ( N , res ) ; Console . Write ( res [ 0 ] ) ; } }";"Fast Doubling method to find the Nth Fibonacci number | C # program to find the Nth Fibonacci number using Fast Doubling Method ; Function calculate the N - th fibanacci number using fast doubling method ; Base Condition ; Here a = F ( n ) ; Here b = F ( n + 1 ) ; As F ( 2 n ) = F ( n ) [ 2F ( n + 1 ) F ( n ) ] Here c = F ( 2 n ) ; As F ( 2 n + 1 ) = F ( n ) ^ 2 + F ( n + 1 ) ^ 2 Here d = F ( 2 n + 1 ) ; Check if N is odd or even ; Driver code"
C#;"using System ; class GFG { static int count ( int [ ] arr , int low , int high , int x ) { if ( ( low > high ) || ( low == high && arr [ low ] != x ) ) return 0 ; if ( low == high && arr [ low ] == x ) return 1 ; return count ( arr , low , ( low + high ) / 2 , x ) + count ( arr , 1 + ( low + high ) / 2 , high , x ) ; } public static void Main ( ) { int [ ] arr = { 30 , 1 , 42 , 5 , 56 , 3 , 56 , 9 } ; int n = arr . Length ; int x = 56 ; Console . Write ( count ( arr , 0 , n - 1 , x ) ) ; } }";"Frequency of an integer in the given array using Divide and Conquer | C # implrmrntation of the approach ; Function to return the frequency of x in the subarray arr [ low ... high ] ; If the subarray is invalid or the element is not found ; If there 's only a single element  which is equal to x ; Divide the array into two parts and then find the count of occurrences of x in both the parts ; Driver code"
C#;"using System ; class GFG { static int a , b ; static int [ ] swap ( int [ ] arr , int i , int j ) { int temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } static int Partition ( int [ ] arr , int l , int r ) { int lst = arr [ r ] , i = l , j = l ; while ( j < r ) { if ( arr [ j ] < lst ) { arr = swap ( arr , i , j ) ; i ++ ; } j ++ ; } arr = swap ( arr , i , r ) ; return i ; } static int randomPartition ( int [ ] arr , int l , int r ) { int n = r - l + 1 ; int pivot = ( int ) ( new Random ( ) . Next ( ) % n ) ; arr = swap ( arr , l + pivot , r ) ; return Partition ( arr , l , r ) ; } static int MedianUtil ( int [ ] arr , int l , int r , int k ) { if ( l <= r ) { int partitionIndex = randomPartition ( arr , l , r ) ; if ( partitionIndex == k ) { b = arr [ partitionIndex ] ; if ( a != - 1 ) return int . MinValue ; } else if ( partitionIndex == k - 1 ) { a = arr [ partitionIndex ] ; if ( b != - 1 ) return int . MinValue ; } if ( partitionIndex >= k ) return MedianUtil ( arr , l , partitionIndex - 1 , k ) ; else return MedianUtil ( arr , partitionIndex + 1 , r , k ) ; } return int . MinValue ; } static void findMedian ( int [ ] arr , int n ) { int ans ; a = - 1 ; b = - 1 ; if ( n % 2 == 1 ) { MedianUtil ( arr , 0 , n - 1 , n / 2 ) ; ans = b ; } else { MedianUtil ( arr , 0 , n - 1 , n / 2 ) ; ans = ( a + b ) / 2 ; } Console . Write ( "" Median ▁ = ▁ "" + ans ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 12 , 3 , 5 , 7 , 4 , 19 , 26 } ; int n = arr . Length ; findMedian ( arr , n ) ; } }";"Median of an unsorted array using Quick Select Algorithm | C # program to find median of an array ; Utility function to swapping of element ; Returns the correct position of pivot element ; Picks a random pivot element between l and r and partitions arr [ l . . r ] around the randomly picked element using partition ( ) ; Utility function to find median ; if l < r ; Find the partition index ; If partition index = k , then we found the median of odd number element in [ ] arr ; If index = k - 1 , then we get a & b as middle element of [ ] arr ; If partitionIndex >= k then find the index in first half of the [ ] arr ; If partitionIndex <= k then find the index in second half of the [ ] arr ; Function to find Median ; If n is odd ; If n is even ; Print the Median of [ ] arr ; Driver code"
C#;"using System ; class GFG { static int firstDigit ( int n ) { while ( n >= 10 ) { n /= 10 ; } return n ; } static int getCount ( int n ) { int count = 1 ; while ( n != 0 ) { int leadDigit = firstDigit ( n ) ; n -= leadDigit ; count ++ ; } return count ; } static int getLargestNumber ( int k ) { int left = k ; int right = k * 10 ; int mid = ( left + right ) / 2 ; int len = getCount ( mid ) ; while ( len != k ) { mid = ( left + right ) / 2 ; len = getCount ( mid ) ; if ( len > k ) { right = mid ; } else { left = mid ; } } while ( len == k ) { if ( len != getCount ( mid + 1 ) ) { break ; } mid ++ ; } return ( mid ) ; } public static void Main ( String [ ] args ) { int k = 3 ; Console . WriteLine ( getLargestNumber ( k ) ) ; } }";"Largest number N which can be reduced to 0 in K steps | C # implementation of the approach ; Utility function to return the first digit of a number . ; Remove last digit from number till only one digit is left ; return the first digit ; Utility function that returns the count of numbers written down when starting from n ; Function to find the largest number N which can be reduced to 0 in K steps ; Get the sequence length of the mid point ; Until k sequence length is reached ; Update mid point ; Get count of the new mid point ; Update right to mid ; Update left to mid ; Increment mid point by one while count is equal to k to get the maximum value of mid point ; Driver Code"
C#;"using System ; class GFG { static string checkReachability ( int N , int X , int Y ) { if ( X == 0 && Y == 0 ) { return "" YES "" ; } if ( N % 2 == 0 ) { return "" YES "" ; } else { if ( X % 2 != Y % 2 ) { return "" NO "" ; } else { return "" YES "" ; } } } public static void Main ( string [ ] args ) { int N = 2 ; int X = 5 , Y = 4 ; Console . WriteLine ( checkReachability ( N , X , Y ) ) ; } }";"Check if point ( X , Y ) can be reached from origin ( 0 , 0 ) with jump of 1 and N perpendicularly simultaneously | C # code for the above approach ; Function to check if ( X , Y ) is reachable from ( 0 , 0 ) using the jumps of given type ; Case where source & destination are the same ; Check for even N ( X , Y ) is reachable or not ; If N is odd and parity of X and Y is different return , no valid sequence of jumps exist ; Driver Code"
C#;"using System ; class GFG { static void closestsAngle ( int N , int A ) { double mi = Int32 . MaxValue ; int ans = 0 ; for ( int i = 1 ; i < N - 1 ; i ++ ) { double angle = 180.0 * i / N ; if ( Math . Abs ( angle - A ) < Math . Abs ( mi - A ) ) { mi = angle ; ans = i ; } } Console . Write ( 2 + "" ▁ "" + 1 + "" ▁ "" + ( 2 + ans ) ) ; } public static void Main ( ) { int N = 3 , A = 15 ; closestsAngle ( N , A ) ; } }";"Find three vertices in an N | C # program for the above approach ; Function to find three vertices that subtends an angle closest to A ; Stores the closest angle to A ; Stores the count of edge which subtend an angle of A ; Iterate in the range [ 1 , N - 2 ] ; Stores the angle subtended ; If absolute ( angle - A ) is less than absolute ( mi - A ) ; Update angle to mi , and also update i to ans ; Print the vertices ; Driver Code"
C#;"using System ; class GFG { static double areaOftriangle ( int side ) { double a = Math . Sqrt ( Math . Pow ( side / 2 , 2 ) + Math . Pow ( side / 2 , 2 ) ) ; double b = Math . Sqrt ( Math . Pow ( side , 2 ) + Math . Pow ( side / 2 , 2 ) ) ; double c = Math . Sqrt ( Math . Pow ( side , 2 ) + Math . Pow ( side / 2 , 2 ) ) ; double s = ( a + b + c ) / 2 ; double area = Math . Sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; return area ; } public static void Main ( string [ ] args ) { int N = 10 ; Console . WriteLine ( areaOftriangle ( N ) ) ; } }";"Area of a triangle with two vertices at midpoints of opposite sides of a square and the other vertex lying on vertex of a square | C # program for the above approach ; Function to find the area of the triangle that inscribed in square ; Stores the length of the first side of triangle ; Stores the length of the second side of triangle ; Stores the length of the third side of triangle ; Stores the area of the triangle ; Return the resultant area ; Driver code"
C#;"using System ; class GFG { static void findLine ( int distance , float degree ) { float x = ( float ) ( degree * 3.14159 / 180 ) ; if ( degree > 90 ) { Console . WriteLine ( "" Not ▁ Possible "" ) ; return ; } float result_1 = ( float ) ( Math . Sin ( x ) ) ; float result_2 = ( float ) ( Math . Cos ( x ) ) ; Console . WriteLine ( result_2 . ToString ( ""0.00"" ) + "" x ▁ + "" + result_1 . ToString ( ""0.00"" ) + "" y ▁ = ▁ "" + distance ) ; } static void Main ( ) { int D = 10 ; float A = 30 ; findLine ( D , A ) ; } }";"Equation of a straight line with perpendicular distance D from origin and an angle A between the perpendicular from origin and x | C # program for the approach ; Function to find equation of a line whose distance from origin and angle made by the perpendicular from origin with x - axis is given ; Convert angle from degree to radian ; Handle the special case ; Calculate the sin and cos of angle ; Print the equation of the line ; Driver Code ; Given Input ; Function Call"
C#;"using System ; class GFG { static int centralPoints ( int [ , ] arr , int N ) { int count = 0 ; int c1 , c2 , c3 , c4 ; for ( int i = 0 ; i < N ; i ++ ) { c1 = 0 ; c2 = 0 ; c3 = 0 ; c4 = 0 ; int x = arr [ i , 0 ] ; int y = arr [ i , 1 ] ; for ( int j = 0 ; j < N ; j ++ ) { if ( arr [ j , 0 ] > x && arr [ j , 1 ] == y ) { c1 = 1 ; } if ( arr [ j , 1 ] > y && arr [ j , 0 ] == x ) { c2 = 1 ; } if ( arr [ j , 0 ] < x && arr [ j , 1 ] == y ) { c3 = 1 ; } if ( arr [ j , 1 ] < y && arr [ j , 0 ] == x ) { c4 = 1 ; } } if ( c1 + c2 + c3 + c4 == 4 ) { count ++ ; } } return count ; } public static void Main ( string [ ] args ) { int [ , ] arr = { { 1 , 0 } , { 2 , 0 } , { 1 , 1 } , { 1 , - 1 } } ; int N = arr . GetLength ( 0 ) ; Console . WriteLine ( centralPoints ( arr , N ) ) ; } }";"Count number of coordinates from an array satisfying the given conditions | C # program for the above approach ; Function to count the number of coordinates from a given set that satisfies the given conditions ; Stores the count of central points ; Store the count of each x and y coordinates ; Find all possible pairs ; Initialize variables c1 , c2 , c3 , c4 to define the status of conditions ; Stores value of each point ; Check the conditions for each point by generating all possible pairs ; If arr [ j ] [ 0 ] > x and arr [ j ] [ 1 ] == y ; If arr [ j ] [ 0 ] < x and arr [ j ] [ 1 ] = = y ; If arr [ j ] [ 1 ] > y and arr [ j ] [ 0 ] == x ; If arr [ j ] [ 1 ] < y and arr [ j ] [ 0 ] = = x ; If all conditions satisfy then point is central point ; Increment the count by 1 ; Return the count ; Driver Code"
C#;"using System ; class GFG { static void finalPosition ( char [ ] a , int [ ] b , int M ) { int n = 0 , s = 0 , e = 0 , w = 0 ; char p = ' N ' ; for ( int i = 0 ; i < M ; i ++ ) { if ( p == ' N ' ) { if ( a [ i ] == ' U ' ) { p = ' N ' ; n = n + b [ i ] ; } else if ( a [ i ] == ' D ' ) { p = ' S ' ; s = s + b [ i ] ; } else if ( a [ i ] == ' R ' ) { p = ' E ' ; e = e + b [ i ] ; } else if ( a [ i ] == ' L ' ) { p = ' W ' ; w = w + b [ i ] ; } } else if ( p == ' S ' ) { if ( a [ i ] == ' U ' ) { p = ' S ' ; s = s + b [ i ] ; } else if ( a [ i ] == ' D ' ) { p = ' N ' ; n = n + b [ i ] ; } else if ( a [ i ] == ' R ' ) { p = ' W ' ; w = w + b [ i ] ; } else if ( a [ i ] == ' L ' ) { p = ' E ' ; e = e + b [ i ] ; } } else if ( p == ' E ' ) { if ( a [ i ] == ' U ' ) { p = ' E ' ; e = e + b [ i ] ; } else if ( a [ i ] == ' D ' ) { p = ' W ' ; w = w + b [ i ] ; } else if ( a [ i ] == ' R ' ) { p = ' S ' ; s = s + b [ i ] ; } else if ( a [ i ] == ' L ' ) { p = ' N ' ; n = n + b [ i ] ; } } else if ( p == ' W ' ) { if ( a [ i ] == ' U ' ) { p = ' W ' ; w = w + b [ i ] ; } else if ( a [ i ] == ' D ' ) { p = ' E ' ; e = e + b [ i ] ; } else if ( a [ i ] == ' R ' ) { p = ' N ' ; n = n + b [ i ] ; } else if ( a [ i ] == ' L ' ) { p = ' S ' ; s = s + b [ i ] ; } } } int ver_disp = n - s ; int hor_disp = e - w ; int displacement = ( int ) Math . Ceiling ( Math . Sqrt ( ( ver_disp * ver_disp ) + ( hor_disp * hor_disp ) ) ) ; Console . WriteLine ( displacement + "" ▁ "" + p ) ; } public static void Main ( ) { char [ ] A = { ' U ' , ' R ' , ' R ' , ' R ' , ' R ' } ; int [ ] B = { 1 , 1 , 1 , 1 , 0 } ; int N = 1 ; finalPosition ( A , B , N ) ; } }";"Displacement from origin after N moves of given distances in specified directions | C # program for the above approach ; Function to find the displacement from the origin and direction after performing the given set of moves ; Stores the distances travelled in the directions North , South , East , and West respectively ; Store the initial position of robot ; Traverse the array B [ ] ; If the current direction is North ; If the current direction is South ; If the current direction is East ; If the current direction is West ; Stores the total vertical displacement ; Stores the total horizontal displacement ; Find the displacement ; Print the displacement and direction after N moves ; Driver Code"
C#;"using System ; class GFG { static double lengthOfLatusRectum ( double A , double B ) { double major = 2.0 * A ; double minor = 2.0 * B ; double latus_rectum = ( minor * minor ) / major ; return latus_rectum ; } public static void Main ( ) { double A = 3.0 , B = 2.0 ; Console . WriteLine ( lengthOfLatusRectum ( A , B ) ) ; } }";"Program to find Length of Latus Rectum of an Ellipse | C # program for the above approach ; Function to calculate the length of the latus rectum of an ellipse ; Length of major axis ; Length of minor axis ; Length of the latus rectum ; Driver Code ; Given lengths of semi - major and semi - minor axis ; Function call to calculate length of the latus rectum of a ellipse"
C#;"using System ; public class GFG { static void coneSlantHeight ( double cone_h , double cone_r ) { double slant_height_cone = Math . Sqrt ( Math . Pow ( cone_h , 2 ) + Math . Pow ( cone_r , 2 ) ) ; Console . WriteLine ( "" Slant ▁ height ▁ of ▁ cone ▁ is : ▁ "" + slant_height_cone ) ; } static void pyramidSlantHeight ( double pyramid_h , double pyramid_s ) { double slant_height_pyramid = Math . Sqrt ( Math . Pow ( pyramid_s / 2 , 2 ) + Math . Pow ( pyramid_h , 2 ) ) ; Console . WriteLine ( "" Slant ▁ height ▁ of ▁ pyramid ▁ is : ▁ "" + slant_height_pyramid ) ; } public static void Main ( string [ ] args ) { double H1 = 4.5 , R = 6 ; coneSlantHeight ( H1 , R ) ; double H2 = 4 , S = 4.8 ; pyramidSlantHeight ( H2 , S ) ; } }";"Program to find slant height of cone and pyramid | C # program for the above approach ; Function to calculate slant height of a cone ; Store the slant height of cone ; Print the result ; Function to find the slant height of a pyramid ; Store the slant height of pyramid ; Print the result ; Driver Code ; Dimensions of Cone ; Function Call for slant height of Cone ; Dimensions of Pyramid ; Function to calculate slant height of a pyramid"
C#;"using System ; public class GFG { class pair { public float first ; public float second ; public pair ( float first , float second ) { this . first = first ; this . second = second ; } } static float distance ( float x1 , float y1 , float x2 , float y2 ) { return ( float ) Math . Sqrt ( ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) ) ; } static void lengthOfLatusRectum ( float a , float b , float c ) { pair vertex = new pair ( ( - b / ( 2 * a ) ) , ( ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) ) ; pair focus = new pair ( ( - b / ( 2 * a ) ) , ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) ) ; Console . Write ( 4 * distance ( ( float ) focus . first , ( float ) focus . second , ( float ) vertex . first , ( float ) vertex . second ) ) ; } public static void Main ( String [ ] args ) { float a = 3 , b = 5 , c = 1 ; lengthOfLatusRectum ( a , b , c ) ; } }";"Program to find the length of Latus Rectum of a Parabola | C # program for the above approach ; Function to calculate distance between two points ; Calculating distance ; Function to calculate length of the latus rectum of a parabola ; Stores the co - ordinates of the vertex of the parabola ; Stores the co - ordinates of the focus of parabola ; Print the distance between focus and vertex ; Driver Code ; Given a , b & c ; Function call"
C#;"using System ; class GFG { public class pair { public double first , second ; public pair ( double first , double second ) { this . first = first ; this . second = second ; } } static double distance ( pair p1 , pair p2 ) { double x1 = p1 . first , x2 = p2 . first ; double y1 = p1 . second , y2 = p2 . second ; return Math . Sqrt ( Math . Pow ( x2 - x1 , 2 ) + Math . Pow ( y2 - y1 , 2 ) * 1.0 ) ; } static pair find_orthocenter ( pair A , pair B , pair C ) { double AB = distance ( A , B ) ; double BC = distance ( B , C ) ; double CA = distance ( C , A ) ; if ( AB > BC && AB > CA ) return C ; if ( BC > AB && BC > CA ) return A ; return B ; } static pair find_circumcenter ( pair A , pair B , pair C ) { double AB = distance ( A , B ) ; double BC = distance ( B , C ) ; double CA = distance ( C , A ) ; if ( AB > BC && AB > CA ) return new pair ( ( A . first + B . first ) / 2 , ( A . second + B . second ) / 2 ) ; if ( BC > AB && BC > CA ) return new pair ( ( B . first + C . first ) / 2 , ( B . second + C . second ) / 2 ) ; return new pair ( ( C . first + A . first ) / 2 , ( C . second + A . second ) / 2 ) ; } static void findDistance ( pair A , pair B , pair C ) { pair circumcenter = find_circumcenter ( A , B , C ) ; pair orthocenter = find_orthocenter ( A , B , C ) ; double distance_between = distance ( circumcenter , orthocenter ) ; Console . Write ( distance_between + "" STRNEWLINE "" ) ; } public static void Main ( String [ ] args ) { pair A , B , C ; A = new pair ( 0.0 , 0.0 ) ; B = new pair ( 6.0 , 0.0 ) ; C = new pair ( 0.0 , 8.0 ) ; findDistance ( A , B , C ) ; } }";"Distance between orthocenter and circumcenter of a right | C # program for the above approach ; Function to calculate Euclidean distance between the points p1 and p2 ; Stores x coordinates of both points ; Stores y coordinates of both points ; Return the Euclid distance using distance formula ; Function to find orthocenter of the right angled triangle ; Find the length of the three sides ; Orthocenter will be the vertex opposite to the largest side ; Function to find the circumcenter of right angle triangle ; Circumcenter will be located at center of hypotenuse ; If AB is the hypotenuse ; If BC is the hypotenuse ; If AC is the hypotenuse ; Function to find distance between orthocenter and circumcenter ; Find circumcenter ; Find orthocenter ; Find the distance between the orthocenter and circumcenter ; Print distance between orthocenter and circumcenter ; Driver Code ; Given coordinates A , B , and C ; Function Call"
C#;"using System ; using System . Collections ; using System . Collections . Generic ; class GFG { public class store : IComparer < KeyValuePair < int , int > > { public int Compare ( KeyValuePair < int , int > x , KeyValuePair < int , int > y ) { if ( x . Key != y . Key ) { return x . Key . CompareTo ( y . Key ) ; } else { return x . Value . CompareTo ( y . Value ) ; } } } static void generatePoints ( int L , int W ) { SortedSet < KeyValuePair < int , int > > hash = new SortedSet < KeyValuePair < int , int > > ( new store ( ) ) ; int total = ( L * W ) ; Random rand = new Random ( ) ; while ( ( total -- ) != 0 ) { int X = rand . Next ( ) % L ; int Y = rand . Next ( ) % W ; while ( hash . Contains ( new KeyValuePair < int , int > ( X , Y ) ) ) { X = rand . Next ( ) % L ; Y = rand . Next ( ) % W ; } hash . Add ( new KeyValuePair < int , int > ( X , Y ) ) ; } foreach ( KeyValuePair < int , int > x in hash ) { Console . Write ( "" ( "" + x . Key + "" , ▁ "" + x . Value + "" ) ▁ "" ) ; } } public static void Main ( string [ ] args ) { int L = 3 , W = 2 ; generatePoints ( L , W ) ; } }";"Generate all integral points lying inside a rectangle | C # program to implement the above approach ; Function to generate coordinates lying within the rectangle ; Store all possible coordinates that lie within the rectangle ; Stores the number of possible coordinates that lie within the rectangle ; For random generator ; Generate all possible coordinates ; Generate all possible X - coordinates ; Generate all possible Y - coordinates ; If coordinates ( X , Y ) has not been generated already ; Insert the coordinates ( X , Y ) ; Print the coordinates ; Driver Code ; Rectangle dimensions"
C#;"using System ; class GFG { public static int noOfTriangles ( int n ) { return ( n * ( n + 2 ) * ( 2 * n + 1 ) / 8 ) ; } public static void Main ( String [ ] args ) { int n = 3 ; Console . Write ( noOfTriangles ( n ) ) ; } }";"Count triangles required to form a House of Cards of height N | C # implementation of the above approach ; Function to find number of triangles ; Driver Code ; Function call"
C#;"using System ; class GFG { static int findNumberOfDigits ( int n , int bas ) { int dig = ( ( int ) Math . Floor ( Math . Log ( n ) / Math . Log ( bas ) ) + 1 ) ; return dig ; } static bool isAllKs ( int n , int b , int k ) { int len = findNumberOfDigits ( n , b ) ; int sum = k * ( 1 - ( int ) Math . Pow ( b , len ) ) / ( 1 - b ) ; return sum == n ; } public static void Main ( ) { int N = 13 ; int B = 3 ; int K = 1 ; if ( isAllKs ( N , B , K ) ) Console . Write ( "" Yes "" ) ; else Console . Write ( "" No "" ) ; } }";"Check if N contains all digits as K in base B | C # implementation of above approach ; Function to print the number of digits ; Calculate log using base change property and then take its floor and then add 1 ; Return the output ; Function that returns true if n contains all one 's in base b ; Calculate the sum ; Driver code ; Given number N ; Given base B ; Given digit K ; Function call"
C#;"using System ; class GFG { static void checkRightAngled ( int X1 , int Y1 , int X2 , int Y2 , int X3 , int Y3 ) { int A = ( int ) Math . Pow ( ( X2 - X1 ) , 2 ) + ( int ) Math . Pow ( ( Y2 - Y1 ) , 2 ) ; int B = ( int ) Math . Pow ( ( X3 - X2 ) , 2 ) + ( int ) Math . Pow ( ( Y3 - Y2 ) , 2 ) ; int C = ( int ) Math . Pow ( ( X3 - X1 ) , 2 ) + ( int ) Math . Pow ( ( Y3 - Y1 ) , 2 ) ; if ( ( A > 0 && B > 0 && C > 0 ) && ( A == ( B + C ) || B == ( A + C ) || C == ( A + B ) ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } public static void Main ( String [ ] s ) { int X1 = 0 , Y1 = 2 ; int X2 = 0 , Y2 = 14 ; int X3 = 9 , Y3 = 2 ; checkRightAngled ( X1 , Y1 , X2 , Y2 , X3 , Y3 ) ; } }";"Check if a right | C # program for the above approach ; Function to check if right - angled triangle can be formed by the given coordinates ; Calculate the sides ; Check Pythagoras Formula ; Driver Code"
C#;"using System ; class GFG { static void createPrefixArray ( int n , int [ ] arr , int prefSize , int [ ] pref ) { for ( int i = 0 ; i < prefSize ; i ++ ) { pref [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] + 1000000 ; pref [ x ] ++ ; } for ( int i = 1 ; i < prefSize ; i ++ ) { pref [ i ] += pref [ i - 1 ] ; } } static int pointsOfIntersection ( int m , int [ , ] segments , int size , int [ ] pref ) { int ans = 0 ; for ( int i = 0 ; i < m ; i ++ ) { int x1 = segments [ i , 0 ] ; int x2 = segments [ i , 2 ] ; x1 = x1 + 1000000 ; x2 = x2 + 1000000 ; if ( x1 != x2 ) { if ( x1 > x2 ) { int temp = x1 ; x1 = x2 ; x2 = temp ; } int Occ_Till_Right = pref [ x2 - 1 ] ; int Occ_Till_Left = pref [ x1 ] ; ans = ans + ( Occ_Till_Right - Occ_Till_Left ) ; } } return ans ; } public static void Main ( String [ ] args ) { int N = 4 ; int M = 8 ; int size = 2000000 + 2 ; int [ ] pref = new int [ size ] ; int [ ] lines = { - 5 , - 3 , 2 , 3 } ; int [ , ] segments = { { - 2 , 5 , 5 , - 6 } , { - 5 , - 2 , - 3 , - 5 } , { - 2 , 3 , - 6 , 1 } , { - 1 , - 3 , 4 , 2 } , { 2 , 5 , 2 , 1 } , { 4 , 5 , 4 , - 5 } , { - 2 , - 4 , 5 , 3 } , { 1 , 2 , - 2 , 1 } } ; createPrefixArray ( N , lines , size , pref ) ; Console . Write ( pointsOfIntersection ( M , segments , size , pref ) + "" STRNEWLINE "" ) ; } }";"Count of intersections of M line segments with N vertical lines in XY plane | C # implementation for the above approach . ; Function to create prefix sum array ; Initialize the prefix array to remove garbage values ; Marking the occurences of vertical lines ; x is the value after Index mapping ; Creating the prefix array ; Function returns the count of total intersection ; ans is the number of points of intersection of the line segments with the vertical lines ; Index mapping ; We don 't consider a vertical  line segment because even if  it falls on a verticale line  then it just touches it and  not intersects. ; We have assumed that x1 will be left and x2 right but if not then we just swap them ; Driver code ; N is the number of vertical lines M is the number of line segments ; Format : x1 , y1 , x2 , y1 ; First create the prefix array ; Print the total number of intersections"
C#;"using System ; class GFG { static int count_rectangles ( int N , int M ) { int p_x = ( N * ( N - 1 ) ) / 2 ; int p_y = ( M * ( M - 1 ) ) / 2 ; return p_x * p_y ; } public static void Main ( ) { int N = 3 ; int M = 6 ; Console . Write ( count_rectangles ( N , M ) ) ; } }";"Count of rectangles possible from N and M straight lines parallel to X and Y axis respectively | C # Program to count number of rectangles formed by N lines parallel to X axis M lines parallel to Y axis ; Function to calculate number of rectangles ; Total number of ways to select two lines parallel to X axis ; Total number of ways to select two lines parallel to Y axis ; Total number of rectangles ; Driver Program"
C#;"using System ; class GFG { static void calculateAngle ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 ) { int ABx = x1 - x2 ; int ABy = y1 - y2 ; int ABz = z1 - z2 ; int BCx = x3 - x2 ; int BCy = y3 - y2 ; int BCz = z3 - z2 ; double dotProduct = ABx * BCx + ABy * BCy + ABz * BCz ; double magnitudeAB = ABx * ABx + ABy * ABy + ABz * ABz ; double magnitudeBC = BCx * BCx + BCy * BCy + BCz * BCz ; double angle = dotProduct ; angle /= Math . Sqrt ( magnitudeAB * magnitudeBC ) ; angle = ( angle * 180 ) / 3.14 ; Console . Write ( String . Format ( "" { 0 : F4 } "" , Math . Abs ( angle ) ) ) ; } public static void Main ( ) { int x1 = 1 , y1 = 3 , z1 = 3 ; int x2 = 3 , y2 = 4 , z2 = 5 ; int x3 = 5 , y3 = 6 , z3 = 9 ; calculateAngle ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ; } }";"Angle between a Pair of Lines in 3D | C # program for the above approach ; Function to find the angle between the two lines ; Find direction ratio of line AB ; Find direction ratio of line BC ; Find the dotProduct of lines AB & BC ; Find magnitude of line AB and BC ; Find the cosine of the angle formed by line AB and BC ; Find angle in radian ; Print the angle ; Driver code ; Given coordinates Points A ; Points B ; Points C ; Function Call"
C#;"using System ; class GFG { static int calcAngle ( double h , double m ) { if ( h < 0 m < 0 h > 12 m > 60 ) Console . Write ( "" Wrong ▁ input "" ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) m = 0 ; int hour_angle = ( int ) ( 0.5 * ( h * 60 + m ) ) ; int minute_angle = ( int ) ( 6 * m ) ; int angle = Math . Abs ( hour_angle - minute_angle ) ; angle = Math . Min ( 360 - angle , angle ) ; return angle ; } static float cal_cos ( float n ) { float accuracy = ( float ) 0.0001 , x1 , denominator , cosx , cosval ; n = ( float ) ( n * ( 3.142 / 180.0 ) ) ; x1 = 1 ; cosx = x1 ; cosval = ( float ) Math . Cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= Math . Abs ( cosval - cosx ) ) ; return cosx ; } static float distanceEndpoints ( int a , int b , float c ) { float angle = cal_cos ( c ) ; return ( float ) Math . Sqrt ( ( a * a ) + ( b * b ) - 2 * a * b * angle ) ; } public static void Main ( ) { int hour = 3 ; int min = 30 ; int hourHand = 3 ; int minHand = 4 ; double angle = calcAngle ( hour , min ) ; float distance = distanceEndpoints ( minHand , hourHand , ( long ) angle ) ; Console . Write ( distance ) ; } }";"Distance between end points of Hour and minute hand at given time | C # implementation to find the distance between the end points of the hour and minute hand ; Function to find the angle between Hour hand and minute hand ; Validate the input ; Calculate the angles moved by hour and minute hands with reference to 12 : 00 ; Find the difference between two angles ; Return the smaller angle of two possible angles ; Function to calculate cos value of angle c ; Converting degrees to radian ; Maps the sum along the series ; Holds the actual value of sin ( n ) ; Function to distance between the endpoints of the hour and minute hand ; Driver code ; Time ; Length of hour hand ; Length of minute hand ; Calling Function for finding angle between hour hand and minute hand ; Function for finding distance between end points of minute hand and hour hand"
C#;"using System ; class GFG { static int Pentadecagonal_num ( int n ) { return ( 13 * n * n - 11 * n ) / 2 ; } public static void Main ( string [ ] args ) { int n = 3 ; Console . Write ( Pentadecagonal_num ( n ) + "" STRNEWLINE "" ) ; n = 10 ; Console . Write ( Pentadecagonal_num ( n ) + "" STRNEWLINE "" ) ; } }";"Pentadecagonal Number | C # program to find Nth pentadecagonal number ; Function to find N - th pentadecagonal number ; Formula to calculate nth Pentadecagonal number ; Driver code"
C#;"using System ; class GFG { static int Octadecagonal_num ( int n ) { return ( 16 * n * n - 14 * n ) / 2 ; } public static void Main ( string [ ] args ) { int n = 3 ; Console . Write ( Octadecagonal_num ( n ) + "" STRNEWLINE "" ) ; n = 10 ; Console . Write ( Octadecagonal_num ( n ) + "" STRNEWLINE "" ) ; } }";"Octadecagonal Number | C # program to find Nth octadecagonal number ; Function to find N - th octadecagonal number ; Formula to calculate nth octadecagonal number ; Driver code"
C#;"using System ; class GFG { static int IcositrigonalNum ( int n ) { return ( 21 * n * n - 19 * n ) / 2 ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( IcositrigonalNum ( n ) ) ; n = 10 ; Console . WriteLine ( IcositrigonalNum ( n ) ) ; } }";"Icositrigonal Number | C # program to find nth Icositrigonal number ; Function to find N - th Icositrigonal number ; Formula to calculate nth Icositrigonal number ; Driver code"
C#;"using System ; using System . Collections . Generic ; using System . Linq ; class GFG { static int calculate_change ( int length , int breadth ) { int change = 0 ; change = length + breadth + ( ( length * breadth ) / 100 ) ; return change ; } public static void Main ( String [ ] args ) { int cL = 20 ; int cB = - 10 ; int cA = calculate_change ( cL , cB ) ; Console . Write ( cA ) ; } }";"Find the percentage change in the area of a Rectangle | C # implementation to find the percentage ; Function to calculate percentage change in area of rectangle ; Driver Code"
C#;"using System ; class GFG { static int solve ( int n , int m , int obstacles , double [ ] range ) { double val = Math . Min ( n , m ) ; Array . Sort ( range ) ; int c = 1 ; for ( int i = obstacles - 1 ; i >= 0 ; i -- ) { range [ i ] = 2 * range [ i ] ; val -= range [ i ] ; if ( val <= 0 ) { return c ; } else { c ++ ; } } if ( val > 0 ) { return - 1 ; } return 0 ; } public static void Main ( ) { int n = 4 , m = 5 , obstacles = 3 ; double [ ] range = { 1.0 , 1.25 , 1.15 } ; Console . WriteLine ( solve ( n , m , obstacles , range ) ) ; } }";"Minimum number of Circular obstacles required to obstruct the path in a Grid | C # program to find the minimum number of obstacles required ; Function to find the minimum number of obstacles required ; Find the minimum range required to put obstacles ; Sorting the radius ; If val is less than zero then we have find the number of obstacles required ; Driver code"
C#;"using System ; class GFG { static double area ( double d1 , double a ) { double d2 = Math . Sqrt ( 4 * ( a * a ) - d1 * d1 ) ; double area = 0.5 * d1 * d2 ; return area ; } public static void Main ( String [ ] args ) { double d = 7.07 ; double a = 5 ; Console . WriteLine ( area ( d , a ) ) ; } }";"Program to calculate area of a rhombus whose one side and diagonal are given | C # program to calculate the area of a rhombus whose one side and one diagonal is given ; function to calculate the area of the rhombus ; Second diagonal ; area of rhombus ; return the area ; Driver code"
C#;"using System ; class GFG { static bool pointsAreOnSameSideOfLine ( int a , int b , int c , int x1 , int y1 , int x2 , int y2 ) { fx1 = a * x1 + b * y1 - c ; fx2 = a * x2 + b * y2 - c ; if ( ( fx1 * fx2 ) > 0 ) return true ; return false ; } public static void Main ( ) { int a = 1 , b = 1 , c = 1 ; int x1 = 1 , y1 = 1 ; int x2 = 2 , y2 = 1 ; if ( pointsAreOnSameSideOfLine ( a , b , c , x1 , y1 , x2 , y2 ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Check whether two points ( x1 , y1 ) and ( x2 , y2 ) lie on same side of a given line or not | C # program to check if two points lie on the same side or not ; Function to check if two points lie on the same side or not ; int fx1 ; Variable to store a * x1 + b * y1 - c int fx2 ; Variable to store a * x2 + b * y2 - c ; If fx1 and fx2 have same sign ; Driver code"
C#;"using System ; class GFG { static void newvol ( double x ) { Console . Write ( "" percentage ▁ increase ▁ "" + "" in ▁ the ▁ volume ▁ of ▁ the ▁ cube ▁ is ▁ "" + ( Math . Pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . Pow ( x , 2 ) ) / 100 ) ) ; Console . Write ( "" % "" ) ; } public static void Main ( ) { double x = 10 ; newvol ( x ) ; } }";"Percentage increase in volume of the cube if a side of cube is increased by a given percentage | C # program to find percentage increase in the volume of the cube if a side of cube is increased by a given percentage ; Driver code"
C#;"using System ; class GFG { static void findTriangles ( int n ) { int num = n ; Console . Write ( num + "" ▁ "" ) ; Console . WriteLine ( num * ( num - 4 ) * ( num - 5 ) / 6 ) ; } public static void Main ( ) { int n ; n = 6 ; findTriangles ( n ) ; } }";"Number of triangles formed by joining vertices of n | C # program to implement the above problem ; Function to find the number of triangles ; print the number of triangles having two side common ; print the number of triangles having no side common ; Driver code ; initialize the number of sides of a polygon"
C#;"using System ; class GFG { static void radius ( int n , int d ) { Console . Write ( "" The ▁ radius ▁ of ▁ each ▁ circle ▁ is ▁ "" + d / ( 2 * n - 2 ) ) ; } static public void Main ( ) { int d = 42 , n = 4 ; radius ( n , d ) ; } }";"Find the radii of the circles which are lined in a row , and distance between the centers of first and last circle is given | C # program to find radii of the circles which are lined in a row and distance between the centers of first and last circle is given ; Driver code"
C#;"using System ; class GFG { static void radius ( int n , int d ) { Console . Write ( "" The ▁ side ▁ of ▁ each ▁ square ▁ is ▁ "" + d / ( n - 1 ) ) ; } public static void Main ( ) { int d = 42 , n = 4 ; radius ( n , d ) ; } }";"Find the side of the squares which are lined in a row , and distance between the centers of first and last square is given | C # program to find side of the squares which are lined in a row and distance between the centers of first and last squares is given ; Driver code"
C#;"using System ; class GFG { static void findTriangles ( int n ) { int num ; num = n * ( n - 4 ) ; Console . WriteLine ( num ) ; } public static void Main ( ) { int n ; n = 6 ; findTriangles ( n ) ; } }";"Number of triangles formed by joining vertices of n | C # program to implement the above problem ; Function to find the number of triangles ; print the number of triangles ; Driver code ; initialize the number of sides of a polygon"
C#;"using System ; class GFG { static void diameter ( double r ) { Console . WriteLine ( "" The ▁ length ▁ of ▁ the ▁ longest ▁ chord "" + "" ▁ or ▁ diameter ▁ of ▁ the ▁ circle ▁ is ▁ "" + 2 * r ) ; } public static void Main ( String [ ] args ) { double r = 4 ; diameter ( r ) ; } }";"Find the Diameter or Longest chord of a Circle | C # program to find the longest chord or diameter of the circle whose radius is given ; Function to find the longest chord ; Driver code ; Get the radius ; Find the diameter"
C#;"class GFG { static double getSlope ( double m ) { return m ; } static void Main ( ) { double m = 2 ; System . Console . Write ( getSlope ( m ) ) ; } }";"Slope of the line parallel to the line with the given slope | C # implementation of the approach ; Function to return the slope of the line which is parallel to the line with the given slope ; Driver code"
C#;"using System ; class GFG { public static int totalTriangles ( int h , int v ) { if ( h == 0 && v == 0 ) return 1 ; if ( h == 0 ) return ( ( v + 1 ) * ( v + 2 ) / 2 ) ; if ( v == 0 ) return ( h + 1 ) ; int total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) ; return total ; } public static void Main ( ) { int h = 2 , v = 2 ; Console . Write ( totalTriangles ( h , v ) ) ; } }";"Total number of triangles formed when there are H horizontal and V vertical lines | C # implementation of the approach ; Function to return total triangles ; Only possible triangle is the given triangle ; If only vertical lines are present ; If only horizontal lines are present ; Return total triangles ; Driver code"
C#;"using System ; class gfg { static float sph ( float r , float R , float h ) { if ( r < 0 && R < 0 && h < 0 ) return - 1 ; float x = r ; float V = ( float ) ( 4 * 3.14f * Math . Pow ( r , 3 ) ) / 3 ; return V ; } public static void Main ( ) { float r = 5 , R = 8 , h = 11 ; Console . WriteLine ( sph ( r , R , h ) ) ; } }";"Largest sphere that can be inscribed in a right circular cylinder inscribed in a frustum | C # Program to find the biggest sphere that can be inscribed within a right circular cylinder which in turn is inscribed within a frustum ; Function to find the biggest sphere ; the radii and height cannot be negative ; radius of the sphere ; volume of the sphere ; Driver code"
C#;"using System ; class GFG { static bool checkOrtho ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int m1 , m2 ; if ( x2 - x1 == 0 && x4 - x3 == 0 ) return false ; else if ( x2 - x1 == 0 ) { m2 = ( y4 - y3 ) / ( x4 - x3 ) ; if ( m2 == 0 ) return true ; else return false ; } else if ( x4 - x3 == 0 ) { m1 = ( y2 - y1 ) / ( x2 - x1 ) ; if ( m1 == 0 ) return true ; else return false ; } else { m1 = ( y2 - y1 ) / ( x2 - x1 ) ; m2 = ( y4 - y3 ) / ( x4 - x3 ) ; if ( m1 * m2 == - 1 ) return true ; else return false ; } } public static void Main ( ) { int x1 = 0 , y1 = 4 , x2 = 0 , y2 = - 9 ; int x3 = 2 , y3 = 0 , x4 = - 1 , y4 = 0 ; if ( checkOrtho ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) == true ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Check whether two straight lines are orthogonal or not | C # implementation of above approach ; Function to check if two straight lines are orthogonal or not ; Both lines have infinite slope ; Only line 1 has infinite slope ; Only line 2 has infinite slope ; Find slopes of the lines ; Check if their product is - 1 ; Driver code"
C#;"using System ; public class GFG { static double pentdiagonal ( double a ) { if ( a < 0 ) return - 1 ; double d = 1.22 * a ; return d ; } static public void Main ( ) { double a = 6 ; Console . WriteLine ( pentdiagonal ( a ) ) ; } }";"Diagonal of a Regular Pentagon | C # Program to find the diagonal of a regular pentagon ; Function to find the diagonal of a regular pentagon ; Side cannot be negative ; Length of the diagonal ; Driver code"
C#;"using System ; public class GFG { public static float hexagonArea ( float d ) { return ( float ) ( ( 3 * Math . Sqrt ( 3 ) * d * d ) / 8 ) ; } static public void Main ( ) { float d = 10 ; Console . WriteLine ( "" Area ▁ of ▁ hexagon : ▁ "" + hexagonArea ( d ) ) ; } }";"Area of hexagon with given diagonal length | C # program to find the area of Hexagon with given diagonal ; Function to calculate area ; Formula to find area ; Code driven"
C#;"using System ; class GFG { static int Squares ( int n , int m , int a ) { return ( ( m + a - 1 ) / a ) * ( ( n + a - 1 ) / a ) ; } static void Main ( ) { int n = 6 , m = 6 , a = 4 ; Console . WriteLine ( Squares ( n , m , a ) ) ; } }";"Number of squares of side length required to cover an N * M rectangle | CSHARP program to find number of squares of a * a required to cover n * m rectangle ; function to find a number of squares of a * a required to cover n * m rectangle ; Driver code ; function call"
C#;"using System ; class GFG { static double octadiagonal ( double a ) { if ( a < 0 ) return - 1 ; return a * Math . Sqrt ( 4 + ( 2 * Math . Sqrt ( 2 ) ) ) ; } public static void Main ( ) { double a = 4 ; Console . WriteLine ( octadiagonal ( a ) ) ; } }";"Length of the Diagonal of the Octagon | C # Program to find the diagonal of the octagon ; Function to find the diagonal of the octagon ; side cannot be negative ; diagonal of the octagon ; Driver code"
C#;"using System ; class GFG { static void CalPeri ( ) { int S = 5 , Perimeter ; Perimeter = 10 * S ; Console . WriteLine ( "" The ▁ Perimeter ▁ of ▁ "" + "" Decagon ▁ is ▁ : ▁ "" + Perimeter ) ; } public static void Main ( ) { CalPeri ( ) ; } }";"Program to Calculate the Perimeter of a Decagon | C # program to Calculate the Perimeter of a Decagon ; Function for finding the perimeter ; Driver code"
C#;"using System ; public class GFG { static double findEdges ( double s1 , double s2 , double s3 ) { double a = Math . Sqrt ( s1 * s2 / s3 ) ; double b = Math . Sqrt ( s3 * s1 / s2 ) ; double c = Math . Sqrt ( s3 * s2 / s1 ) ; double sum = a + b + c ; return 4 * sum ; } static public void Main ( ) { double s1 , s2 , s3 ; s1 = 65 ; s2 = 156 ; s3 = 60 ; Console . WriteLine ( findEdges ( s1 , s2 , s3 ) ) ; } }";"Sum of lengths of all 12 edges of any rectangular parallelepiped | C # program to illustrate the above problem ; function to find the sum of all the edges of parallelepiped ; to calculate the length of one edge ; sum of all the edges of one side ; net sum will be equal to the summation of edges of all the sides ; Driver code ; initialize the area of three faces which has a common vertex"
C#;"using System ; class GFG { public static int findMaximumPieces ( int n ) { int x = n / 2 ; return ( ( x + 1 ) * ( n - x + 1 ) ) ; } static public void Main ( ) { int n = 3 ; Console . Write ( "" Max ▁ number ▁ of ▁ pieces ▁ for ▁ n ▁ = ▁ "" + n + "" ▁ is ▁ "" + findMaximumPieces ( 3 ) ) ; } }";"Maximum number of pieces in N cuts | C # program to find maximum no of pieces by given number of cuts ; Function for finding maximum pieces with n cuts . ; to maximize number of pieces x is the horizontal cuts ; Now ( x ) is the horizontal cuts and ( n - x ) is vertical cuts , then maximum number of pieces = ( x + 1 ) * ( n - x + 1 ) ; Driver code ; Taking the maximum number of cuts allowed as 3 ; Finding and printing the max number of pieces"
C#;"using System ; class GFG { static void equation_plane ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 , int x3 , int y3 , int z3 , int x , int y , int z ) { int a1 = x2 - x1 ; int b1 = y2 - y1 ; int c1 = z2 - z1 ; int a2 = x3 - x1 ; int b2 = y3 - y1 ; int c2 = z3 - z1 ; int a = b1 * c2 - b2 * c1 ; int b = a2 * c1 - a1 * c2 ; int c = a1 * b2 - b1 * a2 ; int d = ( - a * x1 - b * y1 - c * z1 ) ; if ( a * x + b * y + c * z + d == 0 ) Console . WriteLine ( "" Coplanar "" ) ; else Console . WriteLine ( "" Not ▁ Coplanar "" ) ; } static public void Main ( ) { int x1 = 3 ; int y1 = 2 ; int z1 = - 5 ; int x2 = - 1 ; int y2 = 4 ; int z2 = - 3 ; int x3 = - 3 ; int y3 = 8 ; int z3 = - 5 ; int x4 = - 3 ; int y4 = 2 ; int z4 = 1 ; equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x4 , y4 , z4 ) ; } }";"Program to check whether 4 points in a 3 | C # program to check if 4 points in a 3 - D plane are Coplanar ; Function to find equation of plane . ; checking if the 4 th point satisfies the above equation ; Driver Code ; function calling"
C#;"using System ; class GFG { static void distance ( float a1 , float b1 , float c1 , float a2 , float b2 , float c2 ) { float d = ( a1 * a2 + b1 * b2 + c1 * c2 ) ; float e1 = ( float ) Math . Sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; float e2 = ( float ) Math . Sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = d / ( e1 * e2 ) ; float pi = ( float ) 3.14159 ; float A = ( 180 / pi ) * ( float ) ( Math . Acos ( d ) ) ; Console . Write ( "" Angle ▁ is ▁ "" + A + "" ▁ degree "" ) ; } public static void Main ( ) { float a1 = 1 ; float b1 = 1 ; float c1 = 2 ; float a2 = 2 ; float b2 = - 1 ; float c2 = 1 ; distance ( a1 , b1 , c1 , a2 , b2 , c2 ) ; } }";"Angle between two Planes in 3D | C # program to find the Angle between two Planes in 3 D . ; Function to find Angle ; Driver code"
C#;"using System ; class GFG { static void mirror_point ( int a , int b , int c , int d , int x1 , int y1 , int z1 ) { float k = ( - a * x1 - b * y1 - c * z1 - d ) / ( float ) ( a * a + b * b + c * c ) ; float x2 = a * k + x1 ; float y2 = b * k + y1 ; float z2 = c * k + z1 ; float x3 = 2 * x2 - x1 ; float y3 = 2 * y2 - y1 ; float z3 = 2 * z2 - z1 ; Console . Write ( "" x3 ▁ = ▁ "" + x3 + "" ▁ "" ) ; Console . Write ( "" y3 ▁ = ▁ "" + y3 + "" ▁ "" ) ; Console . Write ( "" z3 ▁ = ▁ "" + z3 + "" ▁ "" ) ; } static public void Main ( ) { int a = 1 ; int b = - 2 ; int c = 0 ; int d = 0 ; int x1 = - 1 ; int y1 = 3 ; int z1 = 4 ; mirror_point ( a , b , c , d , x1 , y1 , z1 ) ; } }";"Mirror of a point through a 3 D plane | C # program to find Mirror of a point through a 3 D plane ; Function to mirror image ; Driver Code ; function call"
C#;"using System ; class GFG { static int countRectangles ( int radius ) { int rectangles = 0 ; int diameter = 2 * radius ; int diameterSquare = diameter * diameter ; for ( int a = 1 ; a < 2 * radius ; a ++ ) { for ( int b = 1 ; b < 2 * radius ; b ++ ) { int diagonalLengthSquare = ( a * a + b * b ) ; if ( diagonalLengthSquare <= diameterSquare ) { rectangles ++ ; } } } return rectangles ; } public static void Main ( ) { int radius = 2 ; int totalRectangles ; totalRectangles = countRectangles ( radius ) ; Console . WriteLine ( totalRectangles + "" ▁ rectangles ▁ can ▁ be ▁ "" + "" cut ▁ from ▁ a ▁ circle ▁ of "" + "" ▁ Radius ▁ "" + radius ) ; } }";"Number of rectangles in a circle of radius R | C # program to find the number of rectangles that can be cut from a circle of Radius R ; Function to return the total possible rectangles that can be cut from the circle ; Diameter = 2 * Radius ; Square of diameter which is the square of the maximum length diagonal ; generate all combinations of a and b in the range ( 1 , ( 2 * Radius - 1 ) ) ( Both inclusive ) ; Calculate the Diagonal length of this rectangle ; If this rectangle 's  Diagonal Length is  less than the Diameter,  it is a valid rectangle,  thus increment counter ; Driver Code ; Radius of the circle"
C#;"using System ; class GFG1 { static int simi_aaa ( int [ ] a1 , int [ ] a2 ) { Array . Sort ( a1 ) ; Array . Sort ( a2 ) ; if ( a1 [ 0 ] == a2 [ 0 ] && a1 [ 1 ] == a2 [ 1 ] && a1 [ 2 ] == a2 [ 2 ] ) return 1 ; else return 0 ; } static int simi_sas ( int [ ] s1 , int [ ] s2 , int [ ] a1 , int [ ] a2 ) { Array . Sort ( a1 ) ; Array . Sort ( a2 ) ; Array . Sort ( s1 ) ; Array . Sort ( s2 ) ; if ( s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] ) { if ( a1 [ 2 ] == a2 [ 2 ] ) return 1 ; } if ( s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] ) { if ( a1 [ 0 ] == a2 [ 0 ] ) return 1 ; } if ( s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] ) { if ( a1 [ 1 ] == a2 [ 1 ] ) return 1 ; } return 0 ; } static int simi_sss ( int [ ] s1 , int [ ] s2 ) { Array . Sort ( s1 ) ; Array . Sort ( s2 ) ; if ( s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] && s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] && s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] ) return 1 ; return 0 ; } public static void Main ( ) { int [ ] s1 = { 2 , 3 , 3 } ; int [ ] s2 = { 4 , 6 , 6 } ; int [ ] a1 = { 80 , 60 , 40 } ; int [ ] a2 = { 40 , 60 , 80 } ; int aaa = simi_aaa ( a1 , a2 ) ; int sss = simi_sss ( s1 , s2 ) ; int sas = simi_sas ( s1 , s2 , a1 , a2 ) ; if ( aaa == 1 sss == 1 sas == 1 ) { Console . Write ( "" Triangles ▁ are ▁ "" + "" similar ▁ by ▁ "" ) ; if ( aaa == 1 ) Console . Write ( "" AAA ▁ "" ) ; if ( sss == 1 ) Console . Write ( "" SSS ▁ "" ) ; if ( sas == 1 ) Console . Write ( "" SAS . "" ) ; } else Console . WriteLine ( "" Triangles ▁ are ▁ "" + "" not ▁ similar "" ) ; } }";"Program to check similarity of given two triangles | C # program to check similarity between two triangles . ; Function for AAA similarity ; Check for AAA ; Function for SAS similarity ; angle b / w two smallest sides is largest . ; since we take angle b / w the sides . ; Function for SSS similarity ; Check for SSS ; Driver Code ; function call for AAA similarity ; function call for SSS similarity ; function call for SAS similarity ; Check if triangles are similar or not"
C#;"using System ; class GFG { static long center_pentadecagonal_num ( long n ) { return ( 15 * n * n - 15 * n + 2 ) / 2 ; } static public void Main ( ) { long n = 3 ; Console . Write ( n + "" th ▁ number ▁ : ▁ "" ) ; Console . WriteLine ( center_pentadecagonal_num ( n ) ) ; n = 10 ; Console . Write ( n + "" th ▁ number ▁ : ▁ "" ) ; Console . WriteLine ( center_pentadecagonal_num ( n ) ) ; } }";"Centered Pentadecagonal Number | C # Program to find nth centered pentadecagonal number ; centered pentadecagonal function ; Formula to calculate nth centered pentadecagonal number ; Driver Code"
C#;"using System ; class GFG { static int center_nonadecagon_num ( int n ) { return ( 19 * n * n - 19 * n + 2 ) / 2 ; } static public void Main ( ) { int n = 2 ; Console . Write ( n + "" th ▁ centered ▁ "" + "" nonadecagonal ▁ number ▁ : ▁ "" ) ; Console . WriteLine ( center_nonadecagon_num ( n ) ) ; n = 7 ; Console . Write ( n + "" th ▁ centered ▁ "" + "" nonadecagonal ▁ number ▁ : ▁ "" ) ; Console . WriteLine ( center_nonadecagon_num ( n ) ) ; } }";"Centered nonadecagonal number | C # Program to find nth centered nonadecagonal number ; centered nonadecagonal function ; Formula to calculate nth centered nonadecagonal number ; Driver code"
C#;"using System ; class GFG { static int hendecagonal_num ( int n ) { return ( 9 * n * n - 7 * n ) / 2 ; } static public void Main ( ) { int n = 3 ; Console . Write ( n + "" rd ▁ Hendecagonal ▁ number : ▁ "" ) ; Console . WriteLine ( hendecagonal_num ( n ) ) ; n = 10 ; Console . Write ( n + "" th ▁ Hendecagonal ▁ number : ▁ "" ) ; Console . WriteLine ( hendecagonal_num ( n ) ) ; } }";"Hendecagonal number | C # program to find nth Hendecagonal number ; Function to find Hendecagonal number ; Formula to calculate nth Hendecagonal number ; Driver Code"
C#;"using System ; public class GFG { static long cen_octagonalnum ( long n ) { return ( 4 * n * n - 4 * n + 1 ) ; } static public void Main ( ) { long n = 6 ; Console . WriteLine ( n + "" th ▁ centered "" + "" ▁ octagonal ▁ number ▁ : ▁ "" + cen_octagonalnum ( n ) ) ; n = 11 ; Console . WriteLine ( n + "" th ▁ centered "" + "" ▁ octagonal ▁ number ▁ : ▁ "" + cen_octagonalnum ( n ) ) ; } }";"Centered Octagonal Number | Program to find nth centered octagonal number ; Centered octagonal number function ; Formula to calculate nth centered octagonal number & return it into main function . ; Driver code"
C#;"using System ; class GFG { static bool isValid ( int [ ] arr , int i , int j , int m , int c ) { if ( i == j ) return false ; int lhs = arr [ j ] ; int rhs = m * arr [ i ] + c ; return ( lhs == rhs ) ; } static int findOrderedPoints ( int [ ] arr , int n , int m , int c ) { int counter = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int firstIndex = i , secondIndex = j ; if ( isValid ( arr , firstIndex , secondIndex , m , c ) ) counter ++ ; } } return counter ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 2 } ; int n = arr . Length ; int m = 1 , c = 1 ; Console . Write ( findOrderedPoints ( arr , n , m , c ) ) ; } }";"Number of ordered points pair satisfying line equation | C # code to find number of ordered points satisfying line equation ; Checks if ( i , j ) is valid , a point ( i , j ) is valid if point ( arr [ i ] , arr [ j ] ) satisfies the equation y = mx + c And i is not equal to j ; check if i equals to j ; Equation LHS = y , and RHS = mx + c ; Returns the number of ordered pairs ( i , j ) for which point ( arr [ i ] , arr [ j ] ) satisfies the equation of the line y = mx + c ; for every possible ( i , j ) check if ( a [ i ] , a [ j ] ) satisfies the equation y = mx + c ; ( firstIndex , secondIndex ) is same as ( i , j ) ; check if ( firstIndex , secondIndex ) is a valid point ; Driver Code ; equation of line is y = mx + c"
C#;"using System ; class ring { public static bool checkcircle ( int r , int R , int r1 , int x1 , int y1 ) { int dis = ( int ) Math . Sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; } public static void Main ( ) { int r = 8 , R = 4 , r1 = 2 , x1 = 6 , y1 = 0 ; if ( checkcircle ( r , R , r1 , x1 , y1 ) ) Console . WriteLine ( "" yes "" ) ; else Console . WriteLine ( "" no "" ) ; } }";"Check if a given circle lies completely inside the ring formed by two concentric circles | C # code to check if a circle lies in the ring ; Function to check if circle lies in the ring ; distance between center of circle center of concentric circles ( origin ) using Pythagoras theorem ; Condition to check if circle is strictly inside the ring ; Driver Code ; Both circle with radius ' r ' and ' R ' have center ( 0 , 0 )"
C#;"using System ; class GFG { static double surface_area_octahedron ( double side ) { return ( 2 * ( Math . Sqrt ( 3 ) ) * ( side * side ) ) ; } public static void Main ( ) { double side = 7 ; Console . WriteLine ( "" Surface ▁ area ▁ of ▁ octahedron ▁ = "" + surface_area_octahedron ( side ) ) ; } }";"Program for Surface Area of Octahedron | C # program to calculate surface area of Octahedron . ; utility Function ; Driver code"
C#;"using System ; public class GfG { public static int nCk ( int n , int k ) { int [ ] C = new int [ k + 1 ] ; C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . Min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } public static int count_Straightlines ( int n , int m ) { return ( nCk ( n , 2 ) - nCk ( m , 2 ) + 1 ) ; } public static void Main ( String [ ] args ) { int n = 4 , m = 3 ; Console . WriteLine ( count_Straightlines ( n , m ) ) ; } }";"Count of different straight lines with total n points with m collinear | C # program to count number of straight lines with n total points , out of which m are collinear . ; Returns value of binomial coefficient Code taken from https : goo . gl / vhy4jp ; nC0 is 1 ; Compute next row of pascal triangle using the previous row ; Function to calculate number of straight lines can be formed ; Driver Code"
C#;"using System ; public class GFG { static float vol_of_dodecahedron ( int side ) { return ( float ) ( ( ( 15 + ( 7 * ( Math . Sqrt ( 5 ) ) ) ) / 4 ) * ( Math . Pow ( side , 3 ) ) ) ; } static public void Main ( ) { int side = 4 ; Console . WriteLine ( "" Volume ▁ of ▁ dodecahedron ▁ = ▁ "" + vol_of_dodecahedron ( side ) ) ; } }";"Calculate Volume of Dodecahedron | C # program to calculate Volume of dodecahedron ; utility Function ; Driver Function"
C#;"using System ; class GFG { static void overflow ( int H , int r , int h , int N , int R ) { double tank_cap = 3.14 * r * r * H ; double water_vol = 3.14 * r * r * h ; double balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R ; double vol = water_vol + balls_vol ; if ( vol > tank_cap ) { Console . WriteLine ( "" Overflow "" ) ; } else { Console . WriteLine ( "" Not ▁ in ▁ overflow ▁ state "" ) ; } } public static void Main ( ) { int H = 10 , r = 5 , h = 5 , N = 2 , R = 2 ; overflow ( H , r , h , N , R ) ; } }";"Program to check if water tank overflows when n solid balls are dipped in the water tank | C # Code for Program to check if water tank overflows ; function to find if tak will overflow or not ; cylinder capacity ; volume of water in tank ; volume of n balls ; total volume of water and n dipped balls ; condition to check if tank is in overflow state or not ; Driver program to test above function ; giving dimensions ; calling function"
C#;"using System ; class Number { public static float volume ( int radius , int height ) { return ( ( 22 / 7 ) * radius * radius * height ) ; } public static void check_and_print ( double required_time , double given_time ) { if ( required_time < given_time ) Console . WriteLine ( "" Overflow "" ) ; else if ( required_time > given_time ) Console . WriteLine ( "" Underflow "" ) ; else Console . WriteLine ( "" Filled "" ) ; } public static void Main ( ) { int radius = 5 , height = 10 , rate_of_flow = 10 ; double given_time = 70.0 ; double required_time = volume ( radius , height ) / rate_of_flow ; check_and_print ( required_time , given_time ) ; } }";"Program to check if tank will overflow , underflow or filled in given time | C # program to check if Tank will overflow or not in given time ; function to calculate the volume of tank ; function to print overflow / filled / underflow accordingly ; driver code ; radius of the tank ; height of the tank ; rate of flow of water ; time given ; calculate the required time ; printing the result"
C#;"using System ; class GFG { static float cal_cos ( float n ) { float accuracy = 0.0001f , x1 ; float denominator , cosx , cosval ; n = n * ( 3.142f / 180.0f ) ; x1 = 1 ; cosx = x1 ; cosval = ( float ) Math . Cos ( n ) ; int i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= Math . Abs ( cosval - cosx ) ) ; return cosx ; } static float third_side ( int a , int b , float c ) { float angle = cal_cos ( c ) ; return ( float ) Math . Sqrt ( ( a * a ) + ( b * b ) - 2 * a * b * angle ) ; } public static void Main ( ) { float c = 49 ; int a = 5 , b = 8 ; Console . WriteLine ( Math . Round ( third_side ( a , b , c ) * 100000.0 ) / 100000.0 ) ; } }";"Program to find third side of triangle using law of cosines | C # program to find third side of triangle using law of cosines ; Function to calculate cos value of angle c ; Converting degrees to radian ; Maps the sum along the series ; Holds the actual value of sin ( n ) ; Function to find third side ; Driver code ; function call"
C#;"using System ; class GFG { static void fitOrNotFit ( int R , int r , int x , int y , int rad ) { double val = Math . Sqrt ( Math . Pow ( x , 2 ) + Math . Pow ( y , 2 ) ) ; if ( val + rad <= R && val - rad >= R - r ) Console . WriteLine ( "" Fits "" ) ; else Console . WriteLine ( "" Doesn ' t ▁ Fit "" ) ; } public static void Main ( ) { int R = 8 , r = 4 ; int x = 5 , y = 3 , rad = 3 ; fitOrNotFit ( R , r , x , y , rad ) ; } }";"Check whether given circle resides in boundary maintained by two other circles | C # program to check whether circle with given co - ordinates reside within the boundary of outer circle and inner circle ; function to check if given circle fit in boundary or not ; Distance from the center ; Checking the corners of circle ; Driver program ; Radius of outer circle and inner circle respectively ; Co - ordinates and radius of the circle to be checked"
C#;"using System . Collections . Generic ; using System ; class GFG { static double EPSILON = 1.0842e-19 ; static bool compareDoubles ( double A , double B ) { double diff = A - B ; return ( diff < EPSILON ) && ( - diff < EPSILON ) ; } static int numberOfTringles ( int [ ] a , int [ ] b , int [ ] c , int n ) { List < double > slope = new List < double > ( ) ; for ( int i = 0 ; i < n ; i ++ ) slope . Add ( ( double ) ( a [ i ] * 1.0 ) / b [ i ] ) ; slope . Sort ( ) ; int [ ] count = new int [ n ] ; int k = 0 ; int this_count = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( compareDoubles ( ( double ) slope [ i ] , ( double ) slope [ i - 1 ] ) ) this_count ++ ; else { count [ k ++ ] = this_count ; this_count = 1 ; } } count [ k ++ ] = this_count ; int sum1 = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum1 += count [ i ] ; int sum2 = 0 ; int [ ] temp = new int [ n ] ; for ( int i = 0 ; i < k ; i ++ ) { temp [ i ] = count [ i ] * ( sum1 - count [ i ] ) ; sum2 += temp [ i ] ; } sum2 /= 2 ; int sum3 = 0 ; for ( int i = 0 ; i < k ; i ++ ) sum3 += count [ i ] * ( sum2 - temp [ i ] ) ; sum3 /= 3 ; return sum3 ; } public static void Main ( ) { int [ ] a = { 1 , 2 , 3 , 4 } ; int [ ] b = { 2 , 4 , 5 , 5 } ; int [ ] c = { 5 , 7 , 8 , 6 } ; int n = a . Length ; Console . WriteLine ( "" The ▁ number ▁ of ▁ triangles ▁ "" + "" that ▁ can ▁ be ▁ formed ▁ are : ▁ "" + numberOfTringles ( a , b , c , n ) ) ; } }";"Number of Triangles that can be formed given a set of lines in Euclidean Plane | C # program to find the number of triangles that can be formed using a set of lines in Euclidean Plane ; Double variables can ' t ▁ be ▁ checked ▁ precisely ▁ using ▁ ' == ' this function returns true if the double variables are equal ; This function returns the number of triangles for a given set of lines ; Slope array stores the slope of lines ; Slope array is sorted so that all lines with same slope come together ; After sorting slopes , count different slopes . k is index in count [ ] . ; Count of current slope ; Calculating sum1 ( Sum of all slopes ) sum1 = m1 + m2 + ... ; Calculating sum2 . sum2 = m1 * m2 + m2 * m3 + ... ; Needed for sum3 ; Calculating sum3 which gives the final answer m1 * m2 * m3 + m2 * m3 * m4 + ... ; Driver code ; lines are stored as arrays of a , b and c for ' ax + by = c ' ; n is the number of lines"
C#;"using System ; class GFG { public class Pair { public int first , second ; public Pair ( int first , int second ) { this . first = first ; this . second = second ; } } static void lineFromPoints ( Pair P , Pair Q ) { int a = Q . second - P . second ; int b = P . first - Q . first ; int c = a * ( P . first ) + b * ( P . second ) ; if ( b < 0 ) { Console . WriteLine ( "" The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : ▁ "" + a + "" x ▁ - ▁ "" + b + "" y ▁ = ▁ "" + c ) ; } else { Console . WriteLine ( "" The ▁ line ▁ passing ▁ through ▁ points ▁ P ▁ and ▁ Q ▁ is : ▁ "" + a + "" x ▁ + ▁ "" + b + "" y ▁ = ▁ "" + c ) ; } } public static void Main ( String [ ] args ) { Pair P = new Pair ( 3 , 2 ) ; Pair Q = new Pair ( 2 , 6 ) ; lineFromPoints ( P , Q ) ; } }";"Program to find line passing through 2 Points | C # Implementation to find the line passing through two points ; This pair is used to store the X and Y coordinate of a point respectively ; Function to find the line given two points ; Driver code"
C#;"using System ; class GFG { static bool checkPolygonWithMidpoints ( int [ ] arr , int N , int midpoints ) { for ( int j = 0 ; j < midpoints ; j ++ ) { int val = 1 ; for ( int k = j ; k < N ; k += midpoints ) { val &= arr [ k ] ; } if ( val != 0 && N / midpoints > 2 ) { Console . WriteLine ( "" Polygon ▁ possible ▁ with ▁ "" + "" side ▁ length ▁ "" + N / midpoints ) ; return true ; } } return false ; } static void isPolygonPossible ( int [ ] arr , int N ) { int limit = ( int ) Math . Sqrt ( N ) ; for ( int i = 1 ; i <= limit ; i ++ ) { if ( N % i == 0 ) { if ( checkPolygonWithMidpoints ( arr , N , i ) || checkPolygonWithMidpoints ( arr , N , ( N / i ) ) ) return ; } } Console . WriteLine ( "" Not ▁ possible "" ) ; } static public void Main ( ) { int [ ] arr = { 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; isPolygonPossible ( arr , arr . Length ) ; } }";"Regular polygon using only 1 s in a binary numbered circle | C # program to find whether a regular polygon is possible in circle with 1 s as vertices ; method returns true if polygon is possible with ' midpoints ' number of midpoints ; loop for getting first vertex of polygon ; loop over array values at ' midpoints ' distance ; and ( & ) all those values , if even one of them is 0 , val will be 0 ; if val is still 1 and ( N / midpoints ) or ( number of vertices ) are more than two ( for a polygon minimum ) print result and return true ; method prints sides in the polygon or print not possible in case of no possible polygon ; limit for iterating over divisors ; If i divides N then i and ( N / i ) will be divisors ; check polygon for both divisors ; Driver Code"
C#;"using System ; class GFG { static float squareRoot ( float n ) { float x = n ; float y = 1 ; float e = 0.000001f ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; } static int findMaximumHeight ( int N ) { int n = 1 + 8 * N ; int maxH = ( int ) ( - 1 + squareRoot ( n ) ) / 2 ; return maxH ; } public static void Main ( ) { int N = 12 ; Console . Write ( findMaximumHeight ( N ) ) ; } }";"Maximum height when coins are arranged in a triangle | C # program to find maximum height of arranged coin triangle ; Returns the square root of n . Note that the function ; We are using n itself as initial approximation . This can definitely be improved ; e decides the accuracy level ; Method to find maximum height of arrangement of coins ; calculating portion inside the square root ; program to test above function"
C#;"using System ; class GFG { public class Point { public int x , y ; public Point ( int a , int b ) { this . x = a ; this . y = b ; } } ; static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static int getCount ( Point p , Point q ) { if ( p . x == q . x ) return Math . Abs ( p . y - q . y ) - 1 ; if ( p . y == q . y ) return Math . Abs ( p . x - q . x ) - 1 ; return gcd ( Math . Abs ( p . x - q . x ) , Math . Abs ( p . y - q . y ) ) - 1 ; } public static void Main ( String [ ] args ) { Point p = new Point ( 1 , 9 ) ; Point q = new Point ( 8 , 16 ) ; Console . WriteLine ( "" The ▁ number ▁ of ▁ integral ▁ points ▁ between ▁ "" + "" ( "" + p . x + "" , ▁ "" + p . y + "" ) ▁ and ▁ ( "" + q . x + "" , ▁ "" + q . y + "" ) ▁ is ▁ "" + getCount ( p , q ) ) ; } }";"Number of Integral Points between Two Points | C # code to find the number of integral points lying on the line joining the two given points ; Class to represent an Integral point on XY plane . ; Utility function to find GCD of two numbers GCD of a and b ; Finds the no . of Integral points between two given points . ; If line joining p and q is parallel to x axis , then count is difference of y values ; If line joining p and q is parallel to y axis , then count is difference of x values ; Driver code"
C#;"using System ; class GFG { class Point { public int x , y ; public Point ( int x , int y ) { this . x = x ; this . y = y ; } } ; static int distSq ( Point p , Point q ) { return ( p . x - q . x ) * ( p . x - q . x ) + ( p . y - q . y ) * ( p . y - q . y ) ; } static bool isSquare ( Point p1 , Point p2 , Point p3 , Point p4 ) { if ( d2 == 0 d3 == 0 d4 == 0 ) return false ; if ( d2 == d3 && 2 * d2 == d4 && 2 * distSq ( p2 , p4 ) == distSq ( p2 , p3 ) ) { return true ; } if ( d3 == d4 && 2 * d3 == d2 && 2 * distSq ( p3 , p2 ) == distSq ( p3 , p4 ) ) { return true ; } if ( d2 == d4 && 2 * d2 == d3 && 2 * distSq ( p2 , p3 ) == distSq ( p2 , p4 ) ) { return true ; } return false ; } public static void Main ( String [ ] args ) { Point p1 = new Point ( 20 , 10 ) , p2 = new Point ( 10 , 20 ) , p3 = new Point ( 20 , 20 ) , p4 = new Point ( 10 , 10 ) ; Console . WriteLine ( isSquare ( p1 , p2 , p3 , p4 ) == true ? "" Yes "" : "" No "" ) ; } }";"How to check if given four points form a square | A C # program to check if four given points form a square or not . ; Structure of a point in 2D space ; A utility function to find square of distance from point ' p ' to point ' q ' ; This function returns true if ( p1 , p2 , p3 , p4 ) form a square , otherwise false ; int d2 = distSq ( p1 , p2 ) ; from p1 to p2 int d3 = distSq ( p1 , p3 ) ; from p1 to p3 int d4 = distSq ( p1 , p4 ) ; from p1 to p4 ; If lengths if ( p1 , p2 ) and ( p1 , p3 ) are same , then following conditions must met to form a square . 1 ) Square of length of ( p1 , p4 ) is same as twice the square of ( p1 , p2 ) 2 ) Square of length of ( p2 , p3 ) is same as twice the square of ( p2 , p4 ) ; The below two cases are similar to above case ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { static int countDivisors ( int n ) { int divisors = 0 ; int i ; for ( i = 1 ; i * i < n ; i ++ ) { if ( n % i == 0 ) { divisors ++ ; } } if ( i - ( n / i ) == 1 ) { i -- ; } for ( ; i >= 1 ; i -- ) { if ( n % i == 0 ) { divisors ++ ; } } return divisors ; } static int possibleTriplets ( int N ) { int count = 0 ; for ( int i = 1 ; i < N ; i ++ ) { count += countDivisors ( N - i ) ; } return count ; } public static void Main ( ) { int N = 10 ; Console . Write ( possibleTriplets ( N ) ) ; } }";"Count triplets such that product of two numbers added with third number is N | C # program for the above approach ; Function to find the divisors of the number ( N - i ) ; Stores the resultant count of divisors of ( N - i ) ; Iterate over range [ 1 , sqrt ( N ) ] ; Return the total divisors ; Function to find the number of triplets such that A * B - C = N ; Loop to fix the value of C ; Adding the number of divisors in count ; Return count of triplets ; Driver Code"
C#;"using System ; using System . Collections . Generic ; public class GFG { static int maxPlanes ( int [ ] A , int [ ] B ) { HashSet < int > St = new HashSet < int > ( ) ; for ( int i = 0 ; i < A . Length ; i ++ ) { int t = ( A [ i ] % B [ i ] > 0 ) ? 1 : 0 ; t += ( A [ i ] / B [ i ] ) + t ; St . Add ( t ) ; } return St . Count ; } static public void Main ( ) { int [ ] A = { 1 , 3 , 5 , 4 , 8 } ; int [ ] B = { 1 , 2 , 2 , 1 , 2 } ; Console . WriteLine ( maxPlanes ( A , B ) ) ; } }";"Maximize count of planes that can be stopped per second with help of given initial position and speed | C # program for the above approach ; Function to find maximum number of planes that can be stopped from landing ; Stores the times needed for landing for each plane ; Iterate over the arrays ; Stores the time needed for landing of current plane ; Update the value of t ; Append the t in set St ; Return the answer ; Driver code"
C#;"using System ; public class GFG { static void predictTheWinner ( int K , int N ) { if ( N % ( K + 1 ) == 0 ) Console . WriteLine ( "" Bob "" ) ; else Console . WriteLine ( "" Alice "" ) ; } public static void Main ( string [ ] args ) { int K = 7 , N = 50 ; predictTheWinner ( K , N ) ; } }";"Find the player who will win by choosing a number in range [ 1 , K ] with sum total N | C # program for the above approach ; Function to predict the winner ; Driver Code ; Given Input ; Function call"
C#;"using System ; public class GFG { static int maxRightmostElement ( int N , int k , int p , int [ ] arr ) { int ans = arr [ N - 1 ] ; for ( int i = N - 2 ; i >= 0 ; i -- ) { int d = Math . Min ( arr [ i ] / p , k / ( N - 1 - i ) ) ; k -= d * ( N - 1 - i ) ; ans += d * p ; } return ans ; } public static void Main ( string [ ] args ) { int N = 4 , k = 5 , p = 2 ; int [ ] arr = { 3 , 8 , 1 , 4 } ; Console . WriteLine ( maxRightmostElement ( N , k , p , arr ) ) ; } }";"Maximize the rightmost element of an array in k operations in Linear Time | C # program for the above approach ; Function to calculate maximum value of Rightmost element ; Initializing ans to store Maximum valued rightmost element ; Calculating maximum value of Rightmost element ; returning rightmost element ; Driver Code ; Given Input ; Function Call"
C#;"using System ; using System . Collections . Generic ; class GFG { static int smallestMaximum ( int N , int K ) { int sum = ( ( N + K - 1 ) / K ) * K ; if ( sum % N != 0 ) return ( sum / N ) + 1 ; else return sum / N ; } public static void Main ( ) { int N = 4 ; int K = 3 ; Console . Write ( smallestMaximum ( N , K ) ) ; } }";"Minimize the maximum element in constructed Array with sum divisible by K | C # program for the above approach . ; Function to find smallest maximum number in an array whose sum is divisible by K . ; Minimum possible sum possible for an array of size N such that its sum is divisible by K ; If sum is not divisible by N ; If sum is divisible by N ; Driver code ."
C#;"using System ; public class GFG { static void findIfPossible ( int N , int S , int X ) { if ( ( S >= X ) && ( S % 2 == X % 2 ) ) { if ( N >= 3 ) { Console . WriteLine ( "" Yes "" ) ; } if ( N == 1 ) { if ( S == X ) { Console . WriteLine ( "" Yes "" ) ; } else { Console . WriteLine ( "" No "" ) ; } } if ( N == 2 ) { int C = ( S - X ) / 2 ; int A = C ; int B = C ; A = A + X ; if ( ( ( A ^ B ) == X ) ) { Console . WriteLine ( "" Yes "" ) ; } else { Console . WriteLine ( "" No "" ) ; } } } else { Console . WriteLine ( "" No "" ) ; } } public static void Main ( String [ ] args ) { int N = 3 , S = 10 , X = 4 ; findIfPossible ( N , S , X ) ; } }";"Check if it is possible to construct an Array of size N having sum as S and XOR value as X | C # program for the above approach ; Function to find if any sequence is possible or not . ; Since , S is greater than equal to X , and either both are odd or even There always exists a sequence ; Only one case possible is S == X or NOT ; ; Considering the above conditions true , check if XOR of S ^ ( S - X ) is X or not ; Driver code"
C#;"using System ; public class GFG { static String isPossible ( int [ ] arr , int n ) { int mini = int . MaxValue ; for ( int i = 0 ; i < n ; i ++ ) mini = Math . Min ( mini , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == mini ) continue ; int Max = ( arr [ i ] + 1 ) / 2 - 1 ; if ( mini < 0 mini > Max ) return "" No "" ; } return "" Yes "" ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 1 , 3 , 4 } ; int N = arr . Length ; Console . Write ( isPossible ( arr , N ) ) ; } }";"Check whether each Array element can be reduced to minimum element by replacing it with remainder with some X | C # program for the above approach ; Function to check if every integer in the array can be reduced to the minimum array element ; Stores the minimum array element ; Find the minimum element ; Traverse the array [ ] arr ; Stores the maximum value in the range ; Check whether mini lies in the range or not ; Otherwise , return Yes ; Driver code"
C#;"using System ; public class GFG { static int gcdOfTwoNos ( int num1 , int num2 ) { if ( num1 == 0 ) return num2 ; if ( num2 == 0 ) return num1 ; if ( num1 == num2 ) return num1 ; if ( num1 > num2 ) return gcdOfTwoNos ( num1 - num2 , num2 ) ; return gcdOfTwoNos ( num1 , num2 - num1 ) ; } static int Min_sum ( int [ ] arr , int N ) { int min_sum = 1000000 , maxGcd = 1 ; for ( int i = 0 ; i < N ; i ++ ) { int gcd ; if ( i == 0 ) gcd = arr [ 1 ] ; else { gcd = arr [ i - 1 ] ; } for ( int j = 0 ; j < N ; j ++ ) { if ( j != i ) gcd = gcdOfTwoNos ( gcd , arr [ j ] ) ; } if ( gcd > maxGcd ) maxGcd = gcd ; } return maxGcd ; } public static void Main ( string [ ] args ) { int [ ] arr = { 16 , 5 , 10 , 25 } ; int N = arr . Length ; Console . WriteLine ( Min_sum ( arr , N ) ) ; } }";"Maximum number which can divide all array element after one replacement | C # program for the above approach ; Function to return gcd of two numbers ; If one of numbers is 0 then gcd is other number ; If both are equal then that value is gcd ; One is greater ; Function to return minimum sum ; Initialize min_sum with large value ; Initialize variable gcd ; Update maxGcd if gcd is greater than maxGcd ; returning the maximum divisor of all elements ; Driver code"
C#;"using System ; class GFG { static int countOddIntegers ( int [ ] arr , int N ) { int [ ] Fact = new int [ N ] ; Fact [ 0 ] = 1 ; for ( int i = 1 ; i < N ; i ++ ) { Fact [ i ] = i * Fact [ i - 1 ] ; } int [ ] freq = new int [ 10 ] ; for ( int i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; } int ans = 0 ; for ( int i = 1 ; i <= 9 ; i += 2 ) { if ( freq [ i ] == 0 ) continue ; freq [ i ] -- ; for ( int j = 1 ; j <= 9 ; j ++ ) { int cur_ans = 0 ; if ( freq [ j ] == 0 ) { continue ; } freq [ j ] -- ; cur_ans = Fact [ N - 2 ] ; for ( int k = 0 ; k <= 9 ; k ++ ) { cur_ans = cur_ans / Fact [ freq [ k ] ] ; } ans += cur_ans ; freq [ j ] ++ ; } freq [ i ] ++ ; } return ans ; } public static void Main ( String [ ] args ) { int [ ] A = { 2 , 3 , 4 , 1 , 2 , 3 } ; int N = A . Length ; Console . Write ( countOddIntegers ( A , N ) ) ; } }";"Count of distinct N | C # program of the above approach ; Function to find the count of distinct odd integers with N digits using the given digits in the array arr [ ] ; Stores the factorial of a number ; Calculate the factorial of all numbers from 1 to N ; Stores the frequency of each digit ; Stores the final answer ; Loop to iterate over all values of Nth digit i and 1 st digit j ; If digit i does not exist in the given array move to next i ; Fixing i as Nth digit ; Stores the answer of a specific value of i and j ; If digit j does not exist move to the next j ; Fixing j as 1 st digit ; Calculate number of ways to arrange remaining N - 2 digits ; Including j back into the set of digits ; Including i back into the set of the digits ; Return Answer ; Driver Code ; Function Call"
C#;"using System ; using System . Collections . Generic ; class GFG { static int sumOfDigits ( int N ) { int sum = 0 ; while ( N > 0 ) { sum += ( N % 10 ) ; N = N / 10 ; } return sum ; } static int CountPair ( int [ ] arr , int n ) { Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int val = arr [ i ] + sumOfDigits ( arr [ i ] ) ; if ( mp . ContainsKey ( val ) ) mp [ val ] ++ ; else mp . Add ( val , 1 ) ; } int count = 0 ; foreach ( KeyValuePair < int , int > entry in mp ) { int val = entry . Key ; int times = entry . Value ; count += ( ( times * ( times - 1 ) ) / 2 ) ; } return count ; } public static void Main ( ) { int [ ] arr = { 105 , 96 , 20 , 2 , 87 , 96 } ; int N = arr . Length ; Console . Write ( CountPair ( arr , N ) ) ; } }";"Count pairs in an array having sum of elements with their respective sum of digits equal | C # program for the above approach ; Function to find the sum of digits of the number N ; Stores the sum of digits ; If the number N is greater than 0 ; Return the sum ; Function to find the count of pairs such that arr [ i ] + sumOfDigits ( arr [ i ] ) is equal to ( arr [ j ] + sumOfDigits ( arr [ j ] ) ; Stores the frequency of value of arr [ i ] + sumOfDigits ( arr [ i ] ) ; Traverse the given array ; Find the value ; Increment the frequency ; Stores the total count of pairs ; Traverse the map mp ; Update the count of pairs ; Return the total count of pairs ; Driver Code"
C#;"using System ; public class GFG { static void build_tree ( int [ ] b , int [ ] seg_tree , int l , int r , int vertex ) { if ( l == r ) { seg_tree [ vertex ] = b [ l ] ; return ; } int mid = ( l + r ) / 2 ; build_tree ( b , seg_tree , l , mid , 2 * vertex ) ; build_tree ( b , seg_tree , mid + 1 , r , 2 * vertex + 1 ) ; seg_tree [ vertex ] = __gcd ( seg_tree [ 2 * vertex ] , seg_tree [ 2 * vertex + 1 ] ) ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } static int range_gcd ( int [ ] seg_tree , int v , int tl , int tr , int l , int r ) { if ( l > r ) return 0 ; if ( l == tl && r == tr ) return seg_tree [ v ] ; int tm = ( tl + tr ) / 2 ; return __gcd ( range_gcd ( seg_tree , 2 * v , tl , tm , l , Math . Min ( tm , r ) ) , range_gcd ( seg_tree , 2 * v + 1 , tm + 1 , tr , Math . Max ( tm + 1 , l ) , r ) ) ; } static void maxSubarrayLen ( int [ ] arr , int n ) { int [ ] seg_tree = new int [ 4 * ( n ) + 1 ] ; build_tree ( arr , seg_tree , 0 , n - 1 , 1 ) ; int maxLen = 0 ; int l = 0 , r = 0 ; while ( r < n && l < n ) { if ( range_gcd ( seg_tree , 1 , 0 , n - 1 , l , r ) == 1 ) { l ++ ; } maxLen = Math . Max ( maxLen , r - l + 1 ) ; r ++ ; } Console . Write ( maxLen ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 410 , 52 , 51 , 180 , 222 , 33 , 33 } ; int N = arr . Length ; maxSubarrayLen ( arr , N ) ; } }";"Longest subarray with GCD greater than 1 | C # program of the above approach ; Function to build the Segment Tree from the given array to process range queries in log ( N ) time ; Termination Condition ; Find the mid value ; Left and Right Recursive Call ; Update the Segment Tree Node ; Function to return the GCD of the elements of the Array from index l to index r ; Base Case ; Find the middle range ; Find the GCD and return ; Function to print maximum length of the subarray having GCD > one ; Stores the Segment Tree ; Function call to build the Segment tree from array [ ] arr ; Store maximum length of subarray ; Starting and ending pointer of the current window ; Case where the GCD of the current window is 1 ; Update the maximum length ; Print answer ; Driver Code"
C#;"using System ; class GFG { static void findAandB ( int N ) { int K = ( int ) ( Math . Log ( N ) / Math . Log ( 2 ) ) ; int B = ( 1 << K ) ; int A = B ^ N ; Console . Write ( A + "" ▁ "" + B ) ; } public static void Main ( String [ ] args ) { int N = 26 ; findAandB ( N ) ; } }";"Smallest pair of integers with minimum difference whose Bitwise XOR is N | C # program for the above approach ; Function to find the numbers A and B whose Bitwise XOR is N and the difference between them is minimum ; Find the MSB of the N ; Find the value of B ; Find the value of A ; Print the result ; Driver Code"
C#;"using System ; class GFG { static void findValuesOfK ( int g ) { int count = 0 ; for ( int i = 1 ; i * i <= g ; i ++ ) { if ( g % i == 0 ) { if ( i != g / i ) { if ( i % 2 == 1 ) { count ++ ; } if ( ( g / i ) % 2 == 1 ) { count ++ ; } } else if ( i % 2 == 1 ) { count ++ ; } } } Console . WriteLine ( count ) ; } public static void Main ( ) { int G = 125 ; findValuesOfK ( G ) ; } }";"Find all possible values of K such that the sum of first N numbers starting from K is G | C # program for the above approach ; Function to find the count the value of K such that sum of the first N numbers from K is G ; Stores the total count of K ; Iterate till square root of g ; If the number is factor of g ; If the second factor is not equal to first factor ; Check if two factors are odd or not ; If second factor is the same as the first factor then check if the first factor is odd or not ; Print the resultant count ; Driver code"
C#;"using System ; class GFG { static double Avgdifference ( double [ ] arr , int N , int K ) { double sum = 0 ; for ( int i = 0 ; i < K ; i ++ ) sum += arr [ i ] ; double min = sum ; double max = sum ; for ( int i = K ; i <= N - K + 1 ; i ++ ) { sum += arr [ i ] - arr [ i - K ] ; if ( min > sum ) min = sum ; if ( max < sum ) max = sum ; } return ( max - min ) / K ; } public static void Main ( String [ ] args ) { double [ ] arr = { 3 , 8 , 9 , 15 } ; int N = arr . Length ; int K = 2 ; Console . Write ( Avgdifference ( arr , N , K ) ) ; } }";"Difference between maximum and minimum average of all K | C # program for the above approach ; Function to find the difference between the maximum and minimum subarrays of length K ; Stores the sum of subarray over the range [ 0 , K ] ; Iterate over the range [ 0 , K ] ; Store min and max sum ; Iterate over the range [ K , N - K ] ; Increment sum by arr [ i ] - arr [ i - K ] ; Update max and min moving sum ; Return difference between max and min average ; Driver Code ; Given Input ; Function Call"
C#;"using System ; using System . Collections . Generic ; class GFG { static void findSet ( int N , int K ) { List < int > a = new List < int > ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { if ( i != K ) a . Add ( i ) ; } int MaxDistinct = ( N - K ) + ( K / 2 ) ; a . Reverse ( ) ; for ( int i = 0 ; i < MaxDistinct ; i ++ ) Console . Write ( a [ i ] + "" ▁ "" ) ; } public static void Main ( ) { int N = 5 , K = 3 ; findSet ( N , K ) ; } }";"Count of distinct integers in range [ 1 , N ] that do not have any subset sum as K | C # program for the above approach ; Function to find maximum number of distinct integers in [ 1 , N ] having no subset with sum equal to K ; Declare a vector to store the required numbers ; Store all the numbers in [ 1 , N ] except K ; Store the maximum number of distinct numbers ; Reverse the array ; Print the required numbers ; Driver Code ; Given Input ; Function Call"
C#;"using System ; class GFG { public static long [ ] ExtendedEuclidAlgo ( long a , long b ) { if ( a == 0 ) { return new long [ ] { b , 0 , 1 } ; } else { long x1 = 1 , y1 = 1 ; long [ ] gcdy = ExtendedEuclidAlgo ( b % a , a ) ; long gcd = gcdy [ 0 ] ; x1 = gcdy [ 1 ] ; y1 = gcdy [ 2 ] ; long y = x1 ; long x = y1 - ( long ) ( b / a ) * x1 ; return new long [ ] { gcd , x , y } ; } } public static void linearCongruence ( long A , long B , long N ) { A = A % N ; B = B % N ; long u = 0 , v = 0 ; long [ ] person = ExtendedEuclidAlgo ( A , N ) ; long d = person [ 0 ] ; u = person [ 1 ] ; v = person [ 2 ] ; if ( B % d != 0 ) { Console . WriteLine ( - 1 ) ; return ; } long x0 = ( u * ( B / d ) ) % N ; if ( x0 < 0 ) x0 += N ; for ( long i = 0 ; i <= d - 1 ; i ++ ) { long an = ( x0 + i * ( N / d ) ) % N ; Console . Write ( an + "" ▁ "" ) ; } } static public void Main ( ) { long A = 15 ; long B = 9 ; long N = 18 ; linearCongruence ( A , B , N ) ; } }";"Solve Linear Congruences Ax = B ( mod N ) for values of x in range [ 0 , N | C # program for the above approach ; Function to stores the values of x and y and find the value of gcd ( a , b ) ; Base Case ; Store the result of recursive call ; Update x and y using results of recursive call ; Function to give the distinct solutions of ax = b ( mod n ) ; Function Call to find the value of d and u ; No solution exists ; Else , initialize the value of x0 ; Print all the answers ; Driver Code ; Input ; Function Call"
C#;"using System ; using System . Collections . Generic ; class GFG { static int factorialWithoutMul ( int N ) { int ans = N ; for ( int i = N - 1 ; i > 0 ; i -- ) { int sum = 0 ; for ( int j = 0 ; j < i ; j ++ ) sum += ans ; ans = sum ; } return ans ; } public static void Main ( ) { int N = 5 ; Console . Write ( factorialWithoutMul ( N ) ) ; } }";"Factorial of a number without using multiplication | C # program for the above approach ; Function to calculate factorial of the number without using multiplication operator ; Variable to store the final factorial ; Outer loop ; Inner loop ; Driver code ; Input ; Function calling"
C#;"using System ; class GFG { public static void tripletAndSum ( int [ ] arr , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { for ( int k = j + 1 ; k < n ; k ++ ) { ans += arr [ i ] & arr [ j ] & arr [ k ] ; } } } Console . WriteLine ( ans ) ; } static public void Main ( ) { int [ ] arr = { 3 , 5 , 4 , 7 } ; int N = arr . Length ; tripletAndSum ( arr , N ) ; } }";"Sum of Bitwise AND of all unordered triplets of an array | C # program for the above approach ; Function to calculate sum of Bitwise AND of all unordered triplets from a given array such that ( i < j < k ) ; Stores the resultant sum of Bitwise AND of all triplets ; Generate all triplets of ( arr [ i ] , arr [ j ] , arr [ k ] ) ; Add Bitwise AND to ans ; Print the result ; Driver code"
C#;"using System ; class GFG { static int tripletAndSum ( int [ ] arr , int n ) { int ans = 0 ; for ( int bit = 0 ; bit < 32 ; bit ++ ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] & ( 1 << bit ) ) != 0 ) cnt ++ ; } ans += ( 1 << bit ) * cnt * ( cnt - 1 ) * ( cnt - 2 ) / 6 ; } return ans ; } public static void Main ( ) { int [ ] arr = { 3 , 5 , 4 , 7 } ; int N = arr . Length ; Console . Write ( tripletAndSum ( arr , N ) ) ; } }";"Sum of Bitwise AND of all unordered triplets of an array | C # program for the above approach ; Function to calculate sum of Bitwise AND of all unordered triplets from a given array such that ( i < j < k ) ; Stores the resultant sum of Bitwise AND of all triplets ; Traverse over all the bits ; Count number of elements with the current bit set ; There are ( cnt ) C ( 3 ) numbers with the current bit set and each triplet contributes 2 ^ bit to the result ; Return the resultant sum ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { static void smallestPermutation ( int [ ] arr , int N ) { bool [ ] w = new bool [ 2 * N + 1 ] ; for ( int i = 0 ; i < N ; i ++ ) { w [ arr [ i ] ] = true ; } HashSet < int > S = new HashSet < int > ( ) ; for ( int i = 1 ; i <= 2 * N ; i ++ ) { if ( ! w [ i ] ) S . Add ( i ) ; } bool found = true ; List < int > P = new List < int > ( ) ; int [ ] p = { 4 , 5 , 1 , 2 , 3 , 6 } ; for ( int i = 0 ; i < N ; i ++ ) { if ( S . Contains ( arr [ i ] ) ) { found = false ; break ; } P . Add ( arr [ i ] ) ; P . Add ( arr [ i ] ) ; S . Remove ( arr [ i ] ) ; } if ( ! found ) { Console . WriteLine ( "" - 1"" ) ; } else { for ( int i = 0 ; i < 2 * N ; i ++ ) Console . Write ( p [ i ] + "" ▁ "" ) ; } } static void Main ( ) { int [ ] arr = { 4 , 1 , 3 } ; int N = arr . Length ; smallestPermutation ( arr , N ) ; } }";"Lexicographically smallest permutation of length 2 N that can be obtained from an N | C # program for the above approach ; Function to find the lexicographically smallest permutation of length 2 * N satisfying the given conditions ; Stores if i - th element is placed at odd position or not ; Traverse the array ; Mark arr [ i ] true ; Stores all the elements not placed at odd positions ; Iterate in the range [ 1 , 2 * N ] ; If w [ i ] is not marked ; Stores whether it is possible to obtain the required permutation or not ; Stores the permutation ; Traverse the array arr [ ] ; If it is S . end ( ) ; Mark found false ; Push arr [ i ] and * it into the array ; Erase the current element from the Set ; If found is not marked ; Otherwise , ; Print the permutation ; Driver code ; Given Input ; Function call"
C#;"using System . Collections . Generic ; using System ; class GFG { static void maximumSubsequenceSum ( int [ ] A , int N ) { int ans = 0 ; Dictionary < int , int > mp = new Dictionary < int , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( mp . ContainsKey ( A [ i ] - i ) ) mp [ A [ i ] - i ] += A [ i ] ; else mp [ A [ i ] - i ] = A [ i ] ; ans = Math . Max ( ans , mp [ A [ i ] - i ] ) ; } Console . Write ( ans ) ; } public static void Main ( String [ ] args ) { int [ ] A = { 10 , 7 , 1 , 9 , 10 , 1 } ; int N = A . Length ; maximumSubsequenceSum ( A , N ) ; } }";"Maximum sum of a subsequence having difference between their indices equal to the difference between their values | C # program for the above approach ; Function to find the maximum sum of a subsequence having difference between indices equal to difference in their values ; Stores the maximum sum ; Stores the value for each A [ i ] - i ; Traverse the array ; Update the value in map ; Update the answer ; Finally , print the answer ; Driver code ; Given Input ; Function Call"
C#;"using System ; class GFG { static void nearestPerfectSquare ( int [ ] arr , int N ) { for ( int i = 0 ; i < N ; i ++ ) { int sr = ( int ) Math . Sqrt ( arr [ i ] ) ; int a = sr * sr ; int b = ( sr + 1 ) * ( sr + 1 ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) Console . Write ( a + "" ▁ "" ) ; else Console . Write ( b + "" ▁ "" ) ; } } public static void Main ( ) { int [ ] arr = { 5 , 2 , 7 , 13 } ; int N = arr . Length ; nearestPerfectSquare ( arr , N ) ; } }";"Find the nearest perfect square for each element of the array | C # program for the above approach ; Function to find the nearest perfect square for every element in the given array ; Traverse the array ; Calculate square root of current element ; Calculate perfect square ; Find the nearest ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { static bool [ ] prime = new bool [ 100001 ] ; static void SieveOfEratosthenes ( int n ) { for ( int i = 0 ; i < 100001 ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } } static void NumberofSets ( int N ) { SieveOfEratosthenes ( N ) ; if ( N == 2 ) { Console . Write ( 1 ) ; } else if ( N == 3 ) { Console . Write ( 2 ) ; } else { int ans = 1 ; for ( int i = N / 2 + 1 ; i <= N ; i ++ ) { if ( prime [ i ] ) { ans += 1 ; } } Console . Write ( ans ) ; } } public static void Main ( ) { int N = 9 ; NumberofSets ( N ) ; } }";"Count of sets possible using integers from a range [ 2 , N ] using given operations that are in Equivalence Relation | C # program for the above approach ; Sieve of Eratosthenes to find primes less than or equal to N ; Function to find number of Sets ; Handle Base Case ; Set which contains less than or equal to N / 2 ; Number greater than N / 2 and are prime increment it by 1 ; If the number is prime Increment answer by 1 ; Driver Code ; Input ; Function Call"
C#;"using System ; class GFG { static int floorDifference ( int [ ] A , int N , int X ) { int totalSum = 0 ; int perElementSum = 0 ; for ( int i = 0 ; i < N ; i ++ ) { totalSum += A [ i ] ; perElementSum += A [ i ] / X ; } int totalFloorSum = totalSum / X ; return Math . Abs ( totalFloorSum - perElementSum ) ; } static void Main ( ) { int [ ] A = { 1 , 2 , 3 , 4 , 5 , 6 } ; int X = 4 ; int N = A . Length ; Console . Write ( floorDifference ( A , N , X ) ) ; } }";"Absolute difference between floor of Array sum divided by X and floor sum of every Array element when divided by X | C # program for the above approach ; Function to find absolute difference between the two sum values ; Variable to store total sum ; Variable to store sum of A [ i ] / X ; Traverse the array ; Update totalSum ; Update perElementSum ; Floor of total sum divided by X ; Return the absolute difference ; Driver code ; Input ; Size of Array ; Function call to find absolute difference between the two sum values"
C#;"using System ; public class GFG { static int val ( char c ) { if ( c >= '0' && c <= '9' ) return ( int ) c - '0' ; else return ( int ) c - ' A ' + 10 ; } static int toDeci ( string str , int basse ) { int len = str . Length ; int power = 1 ; int num = 0 ; for ( int i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str [ i ] ) >= basse ) { Console . Write ( "" Invalid ▁ Number "" ) ; return - 1 ; } num += val ( str [ i ] ) * power ; power = power * basse ; } return num ; } static char reVal ( int num ) { if ( num >= 0 && num <= 9 ) return ( char ) ( num + '0' ) ; else return ( char ) ( num - 10 + ' A ' ) ; } static string fromDeci ( int basse , int inputNum ) { string res = "" "" ; while ( inputNum > 0 ) { res += reVal ( inputNum % basse ) ; inputNum /= basse ; } res = reverse ( res ) ; return res ; } static void convertbasse ( string s , int a , int b ) { int num = toDeci ( s , a ) ; string ans = fromDeci ( b , num ) ; Console . Write ( ans ) ; } static string reverse ( string input ) { char [ ] a = input . ToCharArray ( ) ; int l , r = a . Length - 1 ; for ( l = 0 ; l < r ; l ++ , r -- ) { char temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return new string ( a ) ; } static public void Main ( ) { string s = ""10B "" ; int a = 16 , b = 10 ; convertbasse ( s , a , b ) ; } }";"Convert a number from base A to base B | C # program for the above approach ; Function to return ASCII value of a character ; Function to convert a number from given basse to decimal number ; Stores the length of the string ; Initialize power of basse ; Initialize result ; Decimal equivalent is str [ len - 1 ] * 1 + str [ len - 2 ] * basse + str [ len - 3 ] * ( basse ^ 2 ) + ... ; A digit in input number must be less than number 's basse ; Update num ; Update power ; Function to return equivalent character of a given value ; Function to convert a given decimal number to a given basse ; Store the result ; Repeatedly divide inputNum by basse and take remainder ; Update res ; Update inputNum ; Reverse the result ; Function to convert a given number from a basse to another basse ; Convert the number from basse A to decimal ; Convert the number from decimal to basse B ; Print the result ; Driver Code ; Given input ; Function Call"
C#;"using System ; class GFG { static int fact ( int N ) { if ( N == 1 N == 0 ) return 1 ; return N * fact ( N - 1 ) ; } static void prefixFactorialArray ( int [ ] arr , int N ) { for ( int i = 1 ; i < N ; i ++ ) { arr [ i ] += arr [ i - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { arr [ i ] = fact ( arr [ i ] ) ; } for ( int i = 0 ; i < N ; i ++ ) { Console . Write ( arr [ i ] + "" ▁ "" ) ; } } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 } ; int N = arr . Length ; prefixFactorialArray ( arr , N ) ; } }";"Prefix Factorials of a Prefix Sum Array | C # program for the above approach ; Function to find the factorial of a number N ; Base Case ; Find the factorial recursively ; Function to find the prefix factorial array ; Find the prefix sum array ; Find the factorials of each array element ; Print the resultant array ; Driver Code"
C#;"using System ; class GFG { static double findAverage ( int N ) { double avg = ( ( 6 * N * N * N * N ) + ( 15 * N * N * N ) + ( 10 * N * N ) - 1 ) / 30.0 ; return avg ; } public static void Main ( ) { int N = 3 ; Console . WriteLine ( findAverage ( N ) ) ; } }";"Mean of fourth powers of first N natural numbers | C # program for the above approach ; Function to find the average of the fourth power of first N natural numbers ; Store the resultant average calculated using formula ; Return the average ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { static List < int > removeEveryKth ( List < int > l , int k ) { for ( int i = 0 ; i < l . Count ; i ++ ) { if ( i % k == 0 ) l [ i ] = 0 ; } List < int > arr = new List < int > ( ) ; arr . Add ( 0 ) ; for ( int i = 1 ; i < l . Count ; i ++ ) { if ( l [ i ] != 0 ) arr . Add ( l [ i ] ) ; } return arr ; } static void printArray ( List < int > l ) { for ( int i = 1 ; i < l . Count ; i ++ ) Console . Write ( l [ i ] + "" ▁ "" ) ; Console . WriteLine ( ) ; } static void printSequence ( int n , int k ) { List < int > l = new List < int > ( ) ; for ( int i = 0 ; i < n + 1 ; i ++ ) l . Add ( i ) ; int x = 1 ; for ( int i = 0 ; i < k ; i ++ ) { int p = l [ x ] + l [ x + 1 ] ; l = removeEveryKth ( l , p ) ; x += 1 ; } printArray ( l ) ; } public static void Main ( ) { int N = 8 ; int K = 2 ; printSequence ( N , K ) ; } }";"Modify array by removing ( arr [ i ] + arr [ i + 1 ] ) th element exactly K times | C # program for the above approach ; Function to modify array by removing every K - th element from the array ; Check if current element is the k - th element ; Stores the elements after removing every kth element ; Append the current element if it is not k - th element ; Return the new array after removing every k - th element ; Function to print the array ; Traverse the array l [ ] ; Function to print the array after performing the given operations exactly k times ; Store first N natural numbers ; Iterate over the range [ 0 , k - 1 ] ; Store sums of the two consecutive terms ; Remove every p - th element from the array ; Increment x by 1 for the next iteration ; Print the resultant array ; Driver Code ; Given arrays ; Function Call"
C#;"using System ; class GFG { static int makeEqual ( int [ ] arr , int n ) { int [ ] fre0 = new int [ 33 ] ; int [ ] fre1 = new int [ 33 ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; for ( int j = 0 ; j < 33 ; j ++ ) { if ( ( x & 1 ) != 0 ) { fre1 [ j ] += 1 ; } else { fre0 [ j ] += 1 ; } x = x >> 1 ; } } int ans = 0 ; for ( int i = 0 ; i < 33 ; i ++ ) { ans += Math . Min ( fre0 [ i ] , fre1 [ i ] ) ; } return ans ; } public static void Main ( ) { int [ ] arr = { 3 , 5 } ; int N = arr . Length ; Console . WriteLine ( makeEqual ( arr , N ) ) ; } }";"Minimum number of bits of array elements required to be flipped to make all array elements equal | C # program for the above approach ; Function to count minimum number of bits required to be flipped to make all array elements equal ; Stores the count of unset bits ; Stores the count of set bits ; Traverse the array ; Traverse the bit of arr [ i ] ; If current bit is set ; Increment fre1 [ j ] ; Otherwise ; Increment fre0 [ j ] ; Right shift x by 1 ; Stores the count of total moves ; Traverse the range [ 0 , 32 ] ; Update the value of ans ; Return the minimum number of flips required ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { static int sum ( int [ ] arr , int N , int K ) { int sum = 0 ; List < int > v = new List < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { v . Add ( arr [ i ] ) ; } for ( int i = 0 ; i < v . Count ; i ++ ) { if ( v [ i ] % K == 0 ) { int x = v [ i ] / K ; for ( int j = 0 ; j < K ; j ++ ) { v . Add ( x ) ; } } else break ; } for ( int i = 0 ; i < v . Count ; i ++ ) sum = sum + v [ i ] ; return sum ; } public static void Main ( string [ ] args ) { int [ ] arr = { 4 , 6 , 8 , 2 } ; int K = 2 ; int N = arr . Length ; Console . WriteLine ( sum ( arr , N , K ) ) ; } }";"Sum of array elements possible by appending arr [ i ] / K to the end of the array K times for array elements divisible by K | C # program for the above approach ; Function to calculate sum of array elements after adding arr [ i ] / K to the end of the array if arr [ i ] is divisible by K ; Stores the sum of the array ; Traverse the array arr [ ] ; Traverse the vector ; If v [ i ] is divisible by K ; Iterate over the range [ 0 , K ] ; Update v ; Otherwise ; Traverse the vector v ; Return the sum of the updated array ; Driver Code"
C#;"using System ; class GFG { static void check ( int [ ] arr , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum == 0 ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } public static void Main ( string [ ] args ) { int [ ] arr = { 1 , - 1 , 3 , - 2 , - 1 } ; int N = arr . Length ; check ( arr , N ) ; } }";"Check if sum of arr [ i ] / j for all possible pairs ( i , j ) in an array is 0 or not | C # program for the above approach ; Function to check if sum of all values of ( arr [ i ] / j ) for all 0 < i <= j < ( N - 1 ) is 0 or not ; Stores the required sum ; Traverse the array ; If the sum is equal to 0 ; Otherwise ; Driver Code"
C#;"using System ; class GFG { static void expectedValue ( int P , int a , int b , int N ) { double expValue = P + ( N * 0.5 * ( a + b ) ) ; Console . Write ( expValue ) ; } static void Main ( ) { int P = 3000 , a = 20 , b = 10 , N = 30 ; expectedValue ( P , a , b , N ) ; } }";"Program to calculate expected increase in price P after N consecutive days | C # program for the above approach ; Function to find the increased value of P after N days ; Expected value of the number P after N days ; Print the expected value ; Driver code"
C#;"using System ; class GFG { static int startingPoint ( int [ ] A , int N ) { int sum = 0 ; int ind = 0 ; int min = Int32 . MaxValue ; for ( int i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; if ( sum < min ) { min = sum ; ind = i + 1 ; } } if ( sum < 0 ) { return - 1 ; } return ind % N ; } public static void Main ( ) { int [ ] arr = { 3 , - 6 , 7 , - 4 , - 4 , 6 , - 1 } ; int N = arr . Length ; Console . Write ( startingPoint ( arr , N ) ) ; } }";"Find the index in a circular array from which prefix sum is always non | C # program for the above approach ; Function to find the starting index of the given circular array s . t . prefix sum array is non negative ; Stores the sum of the array ; Stores the starting index ; Stores the minimum prefix sum of A [ 0. . i ] ; Traverse the array arr [ ] ; Update the value of sum ; If sum is less than min ; Update the min as the value of prefix sum ; Update in ; Otherwise , no such index is possible ; Driver Code"
C#;"using System ; class GFG { static int nearestPow ( int x , int y ) { if ( y == 1 ) return 1 ; int k = ( int ) ( Math . Log ( x , y ) ) ; if ( Math . Abs ( Math . Pow ( y , k ) - x ) < Math . Abs ( Math . Pow ( y , ( k + 1 ) ) - x ) ) return ( int ) ( Math . Pow ( y , k ) ) ; return ( int ) ( Math . Pow ( y , ( k + 1 ) ) ) ; } static void replacebyNearestPower ( int [ ] arr ) { int prev = arr [ arr . Length - 1 ] ; int lastNext = arr [ 0 ] ; int next = 0 ; for ( int i = 0 ; i < arr . Length ; i ++ ) { int temp = arr [ i ] ; if ( i == arr . Length - 1 ) next = lastNext ; else next = arr [ ( i + 1 ) % arr . Length ] ; int prevPow = nearestPow ( arr [ i ] , prev ) ; int nextPow = nearestPow ( arr [ i ] , next ) ; if ( Math . Abs ( arr [ i ] - prevPow ) < Math . Abs ( arr [ i ] - nextPow ) ) arr [ i ] = prevPow ; else arr [ i ] = nextPow ; prev = temp ; } for ( int i = 0 ; i < arr . Length ; i ++ ) Console . Write ( arr [ i ] + "" ▁ "" ) ; } public static void Main ( ) { int [ ] arr = { 2 , 3 , 4 , 1 , 2 } ; replacebyNearestPower ( arr ) ; } }";"Modify array by replacing elements with the nearest power of its previous or next element | C # program for the above approach ; Function to calculate the power of y which is nearest to x ; Base Case ; Stores the logarithmic value of x with base y ; Function to replace each array element by the nearest power of its previous or next element ; Stores the previous and next element ; Traverse the array ; Calculate nearest power for previous and next elements ; Replacing the array values ; Print the updated array ; Driver Code ; Given array"
C#;"using System ; using System . Collections . Generic ; class GFG { static bool makeSumX ( int [ ] arr , int X , int S , int i ) { if ( i == arr . Length ) { return S == X ; } string a = Convert . ToString ( arr [ i ] ) ; int l = Int32 . Parse ( a . Substring ( 0 , a . Length - 1 ) ) ; int r = Int32 . Parse ( a . Substring ( 1 ) ) ; bool x = makeSumX ( arr , X , S + l , i + 1 ) ; bool y = makeSumX ( arr , X , S + r , i + 1 ) ; return ( x y ) ; } static void Check ( int [ ] arr , int X ) { if ( makeSumX ( arr , X , 0 , 0 ) ) { Console . Write ( "" Yes "" ) ; } else { Console . Write ( "" No "" ) ; } } public static void Main ( ) { int [ ] arr = { 545 , 433 , 654 , 23 } ; int X = 134 ; Check ( arr , X ) ; } }";"Check if sum of array can be made equal to X by removing either the first or last digits of every array element | C # program for the above approach ; Utility Function to check if the sum of the array elements can be made equal to X by removing either the first or last digits of every array element ; Base Case ; Convert arr [ i ] to string ; Remove last digit ; Remove first digit ; Recursive function call ; Function to check if sum of given array can be made equal to X or not ; Driver Code ; Function Call"
C#;"using System ; class GFG { static bool isPower ( int m , int y ) { int res1 = ( int ) Math . Log ( y ) / ( int ) Math . Log ( m ) ; double res2 = ( int ) Math . Log ( y ) / ( int ) Math . Log ( m ) ; return ( res1 == res2 ) ; } static int numSub ( int [ ] arr , int n , int m ) { int ans = 0 ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPower ( m , arr [ i ] ) ) { cnt ++ ; ans += ( cnt * ( cnt - 1 ) ) / 2 ; } else { cnt = 0 ; } } return ans ; } public static void Main ( ) { int [ ] arr = { 1 , 1 , 1 , 3 } ; int m = 3 ; int n = arr . Length ; Console . Write ( numSub ( arr , n , m ) ) ; } }";"Count subarrays having product equal to the power of a given Prime Number | C # program for the above approach ; Function to check if y is a power of m or not ; Calculate log y base m and store it in a variable with integer datatype ; Calculate log y base m and store it in a variable with double datatype ; If res1 and res2 are equal , return True . Otherwise , return false ; Function to count the number of subarrays having product of elements equal to a power of m , where m is a prime number ; Stores the count of subarrays required ; Stores current sequence of consecutive array elements which are a multiple of m ; Traverse the array ; If arr [ i ] is a power of M ; Increment cnt ; Update ans ; Update cnt ; Return the count of subarrays ; Driver code ; Input"
C#;"using System ; class GFG { static int cntPairs ( int [ ] arr , int N ) { int res = 0 ; int [ ] bit = new int [ 32 ] ; for ( int i = 0 ; i < N ; i ++ ) { int pos = ( int ) ( Math . Log ( arr [ i ] ) / Math . Log ( 2 ) ) ; bit [ pos ] ++ ; } for ( int i = 0 ; i < 32 ; i ++ ) { res += ( bit [ i ] * ( bit [ i ] - 1 ) ) / 2 ; } return res ; } static public void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 } ; int N = arr . Length ; Console . Write ( cntPairs ( arr , N ) ) ; } }";"Count pairs whose Bitwise AND exceeds Bitwise XOR from a given array | C # program to implement the above approach ; Function to count pairs that satisfy the above condition ; Stores the count of pairs ; Stores the count of array elements having same positions of MSB ; Traverse the array ; Stores the index of MSB of array elements ; Calculate number of pairs ; Driver Code ; Given Input ; Function call to count pairs satisfying the given condition"
C#;"using System ; using System . Collections . Generic ; using System . Linq ; class GFG { static void minimumMEX ( int [ ] arr , int N , int K ) { HashSet < int > s = new HashSet < int > ( ) ; for ( int i = 1 ; i <= N + 1 ; i ++ ) s . Add ( i ) ; for ( int i = 0 ; i < K ; i ++ ) s . Remove ( arr [ i ] ) ; int mex = s . First ( ) ; for ( int i = K ; i < N ; i ++ ) { s . Remove ( arr [ i ] ) ; s . Add ( arr [ i - K ] ) ; int firstElem = s . First ( ) ; mex = Math . Min ( mex , firstElem ) ; } Console . Write ( mex + "" ▁ "" ) ; } static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 } ; int K = 3 ; int N = arr . Length ; minimumMEX ( arr , N , K ) ; } }";"Minimum MEX from all subarrays of length K | C # program for the above approach ; Function to return minimum MEX from all K - length subarrays ; Stores element from [ 1 , N + 1 ] which are not present in subarray ; Store number 1 to N + 1 in set s ; Find the MEX of K - length subarray starting from index 0 ; Find the MEX of all subarrays of length K by erasing arr [ i ] and inserting arr [ i - K ] ; Store first element of set ; Updating the mex ; Print minimum MEX of all K length subarray ; Driver code"
C#;"using System ; class GFG { static void smallerNumbers ( int [ ] arr , int N ) { int [ ] hash = new int [ 100000 ] ; for ( int i = 0 ; i < N ; i ++ ) hash [ arr [ i ] ] ++ ; for ( int i = 1 ; i < 100000 ; i ++ ) { hash [ i ] += hash [ i - 1 ] ; } for ( int i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) { Console . WriteLine ( ""0"" ) ; continue ; } Console . Write ( hash [ arr [ i ] - 1 ] + "" ▁ "" ) ; } } public static void Main ( string [ ] args ) { int [ ] arr = { 3 , 4 , 1 , 1 , 2 } ; int N = arr . Length ; smallerNumbers ( arr , N ) ; } }";"Count smaller elements present in the array for each array element | C # program for the above approach ; Function to count for each array element , the number of elements that are smaller than that element ; Stores the frequencies of array elements ; Traverse the array ; Update frequency of arr [ i ] ; Compute prefix sum of the array hash [ ] ; Traverse the array arr [ ] ; If current element is 0 ; Print the resultant count ; Driver Code"
C#;"using System ; public class GFG { static int truncMod ( int a , int n ) { int q = a / n ; return a - n * q ; } static public void Main ( ) { int a , b ; a = 9 ; b = 4 ; Console . WriteLine ( a + "" ▁ % ▁ "" + b + "" ▁ = ▁ "" + truncMod ( a , b ) ) ; a = - 9 ; b = 4 ; Console . WriteLine ( a + "" ▁ % ▁ "" + b + "" ▁ = ▁ "" + truncMod ( a , b ) ) ; a = 9 ; b = - 4 ; Console . WriteLine ( a + "" ▁ % ▁ "" + b + "" ▁ = ▁ "" + truncMod ( a , b ) ) ; a = - 9 ; b = - 4 ; Console . WriteLine ( a + "" ▁ % ▁ "" + b + "" ▁ = ▁ "" + truncMod ( a , b ) ) ; } }";"Modulo Operations in Programming With Negative Results | C # program for the above approach ; Function to calculate and return the remainder of a % n ; ( a / n ) implicitly gives the truncated result ; Driver Code ; Modulo of two positive numbers ; Modulo of a negative number by a positive number ; Modulo of a positive number by a negative number ; Modulo of two negative numbers"
C#;"using System ; class GFG { static double average ( int [ ] arr , int N ) { int sum = 0 ; for ( int i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; return ( double ) ( sum / N ) ; } static double mean ( int [ ] arr , int N ) { double avg = 0.0 ; for ( int i = 0 ; i < N ; i ++ ) { avg += ( ( double ) ( ( arr [ i ] - avg ) / ( i + 1 ) ) ) ; } return avg ; } static public void Main ( ) { int [ ] arr = { Int32 . MaxValue , 1 , 2 } ; int N = arr . Length ; Console . WriteLine ( "" Average ▁ by ▁ Standard ▁ method : ▁ "" + ( average ( arr , N ) ) . ToString ( "" F10"" ) ) ; Console . WriteLine ( "" Average ▁ by ▁ Efficient ▁ method : ▁ "" + ( mean ( arr , N ) ) . ToString ( "" F10"" ) ) ; } }";"Program for average of an array without running into overflow | C # program for the above approach ; Function to calculate average of an array using standard method ; Stores the sum of array ; Find the sum of the array ; Return the average ; Function to calculate average of an array using efficient method ; Store the average of the array ; Traverse the array arr [ ] ; Update avg ; Return avg ; Driver Code ; Input ; Function call"
C#;"using System ; using System . Collections . Generic ; class GFG { static void countPairs ( int [ ] arr , int N ) { int count = 0 ; Dictionary < double , int > mp = new Dictionary < double , int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { double val = 1.0 * arr [ i ] ; double idx = 1.0 * ( i + 1 ) ; if ( mp . ContainsKey ( val / idx ) ) count += mp [ val / idx ] ; if ( mp . ContainsKey ( val / idx ) ) mp [ val / idx ] ++ ; else mp [ val / idx ] = 1 ; } Console . WriteLine ( count ) ; } public static void Main ( ) { int [ ] arr = { 1 , 3 , 5 , 6 , 5 } ; int N = arr . Length ; countPairs ( arr , N ) ; } }";"Count number of pairs ( i , j ) from an array such that arr [ i ] * j = arr [ j ] * i | C # program for the above approach ; Function to count pairs from an array satisfying given conditions ; Stores the total count of pairs ; Stores count of a [ i ] / i ; Traverse the array ; Updating count ; Update frequency in the Map ; Print count of pairs ; Driver Code ; Given array ; Size of the array ; Function call to count pairs satisfying given conditions"
C#;"using System ; using System . Collections . Generic ; class GFG { static void add_edge ( List < List < int > > adj , int u , int v ) { adj [ u ] . Add ( v ) ; adj [ v ] . Add ( u ) ; } static void dfs ( List < int > parent , List < List < int > > adj , int u , int par = - 1 ) { parent [ u ] = par ; foreach ( int child in adj [ u ] ) { if ( child != par ) dfs ( parent , adj , child , u ) ; } } static void countSmallerAncestors ( List < List < int > > adj , int n ) { List < int > parent = new List < int > ( ) ; for ( int i = 0 ; i < ( int ) ( 1e5 ) ; i ++ ) { parent . Add ( 0 ) ; } dfs ( parent , adj , 1 ) ; for ( int i = 1 ; i <= n ; i ++ ) { int node = i ; int cnt = 0 ; while ( parent [ node ] != - 1 ) { if ( parent [ node ] < i ) cnt += 1 ; node = parent [ node ] ; } Console . Write ( cnt + "" ▁ "" ) ; } } static void Main ( ) { int N = 6 ; List < List < int > > adj = new List < List < int > > ( ) ; for ( int i = 0 ; i < ( int ) ( 1e5 ) ; i ++ ) { adj . Add ( new List < int > ( ) ) ; } add_edge ( adj , 1 , 5 ) ; add_edge ( adj , 1 , 4 ) ; add_edge ( adj , 4 , 6 ) ; add_edge ( adj , 5 , 3 ) ; add_edge ( adj , 5 , 2 ) ; countSmallerAncestors ( adj , N ) ; } }";"Count ancestors with smaller value for each node of a Binary Tree | C # program for the above approach ; Function to add an edge between nodes u and v ; Function to perform the DFS Traversal and store parent of each node ; Store the immediate parent ; Traverse the children of the current node ; Recursively call for function dfs for the child node ; Function to count the number of ancestors with values smaller than that of the current node ; Stores the parent of each node ; Perform the DFS Traversal ; Traverse all the nodes ; Store the number of ancestors smaller than node ; Loop until parent [ node ] != - 1 ; If the condition satisfies , increment cnt by 1 ; Print the required result for the current node ; Driver Code ; Tree Formation"
C#;"using System ; public class GFG { public static void countSubsequences ( int [ ] A ) { int odd = 0 ; int even = 0 ; foreach ( int el in A ) { if ( el % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 ) Console . WriteLine ( 0 ) ; else Console . WriteLine ( 1 << ( A . Length - 1 ) ) ; } public static void Main ( String [ ] args ) { int [ ] A = { 1 , 3 , 4 } ; countSubsequences ( A ) ; } }";"Count subsequences having odd Bitwise XOR values from an array | C # program for above approach ; Function to count the subsequences having odd bitwise XOR value ; Stores count of odd elements ; Stores count of even elements ; Traverse the array A [ ] ; If el is odd ; If count of odd elements is 0 ; Driver code ; Given array A [ ] ; Function call to count subsequences having odd bitwise XOR value"
C#;"using System ; class GFG { static void maxModProdSubarr ( int [ ] arr , int n , int M ) { int ans = 0 ; int length = n ; for ( int i = 0 ; i < n ; i ++ ) { int product = 1 ; for ( int j = i ; j < n ; j ++ ) { product = ( product * arr [ i ] ) % M ; if ( product > ans ) { ans = product ; if ( length > j - i + 1 ) { length = j - i + 1 ; } } } } Console . WriteLine ( "" Maximum ▁ subarray ▁ product ▁ is ▁ "" + ans ) ; Console . WriteLine ( "" Minimum ▁ length ▁ of ▁ the ▁ maximum ▁ "" + "" product ▁ subarray ▁ is ▁ "" + length ) ; } static void Main ( ) { int [ ] arr = { 2 , 3 , 4 , 2 } ; int N = arr . Length ; int M = 5 ; maxModProdSubarr ( arr , N , M ) ; } }";"Maximum subarray product modulo M | C # program for above approach ; Function to find maximum subarray product modulo M and minimum length of the subarray ; Stores maximum subarray product modulo M and minimum length of the subarray ; Stores the minimum length of subarray having maximum product ; Traverse the array ; Stores the product of a subarray ; Calculate Subarray whose start index is i ; Multiply product by arr [ i ] ; If product greater than ans ; Update ans ; Update length ; Print maximum subarray product mod M ; Print minimum length of subarray having maximum product ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { static int GCD ( int a , int b ) { return b == 0 ? a : GCD ( b , a % b ) ; } static bool coprime ( int a , int b ) { if ( GCD ( a , b ) == 1 ) return true ; return false ; } static int numOfPairs ( List < string > arr , int N ) { int count = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( coprime ( Int32 . Parse ( arr [ i ] ) , Int32 . Parse ( arr [ j ] ) ) ) { count = count + 1 ; } } } return count ; } static void noOfCoPrimePairs ( int N , int d1 , int d2 ) { List < string > l = new List < string > ( ) ; l . Add ( d1 . ToString ( ) ) ; l . Add ( d2 . ToString ( ) ) ; l . Sort ( ) ; if ( N < Int32 . Parse ( l [ 1 ] ) ) return ; List < string > total = new List < string > ( l ) ; List < string > temp2 = new List < string > ( l ) ; int flag = 0 ; List < string > temp3 = new List < string > ( ) ; while ( l [ 0 ] . Length < 10 ) { for ( int i = 0 ; i < l . Count ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { if ( Int32 . Parse ( l [ i ] + temp2 [ j ] ) > N ) { flag = 1 ; break ; } total . Add ( l [ i ] + temp2 [ j ] ) ; temp3 . Add ( l [ i ] + temp2 [ j ] ) ; } if ( flag == 1 ) break ; } if ( flag == 1 ) break ; l = temp3 ; temp3 . Clear ( ) ; } int lenOfTotal = total . Count ; int ans = numOfPairs ( total , lenOfTotal ) ; Console . WriteLine ( ans ) ; } public static void Main ( ) { int N = 30 , d1 = 2 , d2 = 3 ; noOfCoPrimePairs ( N , d1 , d2 ) ; } }";"Number of co | C # program for the above approach ; Function to check whether given integers are co - prime or not ; Utility function to count number of co - prime pairs ; Traverse the array ; If co - prime ; Increment count ; Return count ; Function to count number of co - prime pairs ; Stores digits in string form ; Sort the list ; Keep two copies of list l ; Generate 2 digit numbers using d1 and d2 ; If current number does not exceed N ; Stores length of list ; Stores number of co - prime pairs ; Print number of co - prime pairs ; Driver Code ; Given value of N , d1 , d2 ; Function call to count number of co - prime pairs"
C#;"using System ; class GFG { static void tile_placing ( int [ , ] grid , int N ) { int [ ] dp = new int [ N + 5 ] ; for ( int i = 0 ; i < N + 5 ; i ++ ) { dp [ i ] = 0 ; } int orig_cost = 0 ; for ( int i = 0 ; i < 2 ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { orig_cost += grid [ i , j ] ; } } dp [ 0 ] = 0 ; dp [ 1 ] = Math . Abs ( grid [ 0 , 0 ] - grid [ 1 , 0 ] ) ; for ( int i = 2 ; i <= N ; i ++ ) { dp [ i ] = Math . Max ( dp [ i - 1 ] + Math . Abs ( grid [ 0 , i - 1 ] - grid [ 1 , i - 1 ] ) , dp [ i - 2 ] + Math . Abs ( grid [ 0 , i - 2 ] - grid [ 0 , i - 1 ] ) + Math . Abs ( grid [ 1 , i - 2 ] - grid [ 1 , i - 1 ] ) ) ; } Console . Write ( orig_cost - dp [ N ] ) ; } public static void Main ( ) { int [ , ] M = { { 7 , 5 , 1 , 3 } , { 8 , 6 , 0 , 2 } } ; int N = 4 ; tile_placing ( M , N ) ; } }";"Minimize cost of placing tiles of dimensions 2 * 1 over a Matrix | C # program for the above approach ; Function to find the minimum cost in placing N tiles in a grid M [ ] [ ] ; Stores the minimum profit after placing i tiles ; Traverse the grid [ ] [ ] ; Update the orig_cost ; Traverse over the range [ 2 , N ] ; Place tiles horizentally or vertically ; Print the answer ; Driver Code"
C#;"using System ; class GFG { static void findSplit ( int [ ] arr , int N ) { for ( int l = 1 ; l <= N - 4 ; l ++ ) { for ( int r = l + 2 ; r <= N - 2 ; r ++ ) { int lsum = 0 , rsum = 0 , msum = 0 ; for ( int i = 0 ; i <= l - 1 ; i ++ ) { lsum += arr [ i ] ; } for ( int i = l + 1 ; i <= r - 1 ; i ++ ) { msum += arr [ i ] ; } for ( int i = r + 1 ; i < N ; i ++ ) { rsum += arr [ i ] ; } if ( lsum == rsum && rsum == msum ) { Console . WriteLine ( l + "" ▁ "" + r ) ; return ; } } } Console . Write ( - 1 ) ; } public static void Main ( string [ ] args ) { int [ ] arr = { 2 , 5 , 12 , 7 , 19 , 4 , 3 } ; int N = arr . Length ; findSplit ( arr , N ) ; } }";"Print indices of pair of array elements required to be removed to split array into 3 equal sum subarrays | C # program for the above approach ; Function to check if array can be split into three equal sum subarrays by removing two elements ; Stores sum of all three subarrays ; Sum of left subarray ; Sum of middle subarray ; Sum of right subarray ; Check if sum of subarrays are equal ; Print the possible pair ; If no pair exists , print - 1 ; Driver Code ; Given array ; Size of the array"
C#;"using System ; class GFG { static int solve ( int [ ] A , int n , int [ ] Q , int q ) { int one = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( A [ i ] == 1 ) one ++ ; int glows = 0 , count = 0 ; if ( one >= ( int ) Math . Ceiling ( ( double ) n / 2 ) ) glows = 1 ; for ( int i = 0 ; i < q ; i ++ ) { int prev = glows ; if ( A [ Q [ i ] - 1 ] == 1 ) one -- ; if ( A [ Q [ i ] - 1 ] == 0 ) one ++ ; A [ Q [ i ] - 1 ] ^= 1 ; if ( one >= ( int ) Math . Ceiling ( ( double ) n / 2.0 ) ) { glows = 1 ; } else { glows = 0 ; } if ( prev != glows ) count ++ ; } return count ; } static public void Main ( ) { int n = 3 ; int [ ] arr = { 1 , 1 , 0 } ; int q = 3 ; int [ ] Q = { 3 , 2 , 1 } ; Console . WriteLine ( solve ( arr , n , Q , q ) ) ; } }";"Count the number of times a Bulb switches its state | C # program for the above approach ; Function to find the number of times a bulb switches its state ; Count of 1 s ; Traverse the array ; Update count of 1 s ; Update the status of bulb ; Traverse the array Q [ ] ; Stores previous state of the bulb ; Toggle the switch and update count of 1 s ; If the bulb switches state ; Return count ; Driver Code ; Input ; Queries ; Function call to find number of times the bulb toggles"
C#;"using System ; using System . Collections . Generic ; class GFG { static int sumOfDigits ( int N ) { int sum = 0 ; while ( N != 0 ) { sum += N % 10 ; N /= 10 ; } return sum ; } static void elementsHavingDigitSumK ( int [ ] arr , int N , int K ) { int count = 0 ; for ( int i = 0 ; i < N ; ++ i ) { if ( sumOfDigits ( arr [ i ] ) == K ) { count ++ ; } } Console . WriteLine ( count ) ; } static void Main ( ) { int [ ] arr = { 23 , 54 , 87 , 29 , 92 , 62 } ; int K = 11 ; int N = arr . Length ; elementsHavingDigitSumK ( arr , N , K ) ; } }";"Count array elements having sum of digits equal to K | C # program for the above approach ; Function to calculate the sum of digits of the number N ; Stores the sum of digits ; Return the sum ; Function to count array elements ; Store the count of array elements having sum of digits K ; Traverse the array ; If sum of digits is equal to K ; Increment the count ; Print the count ; Driver code ; Given array ; Given value of K ; Size of the array ; Function call to count array elements having sum of digits equal to K"
C#;"using System ; using System . Collections ; class GFG { static Boolean isOperand ( char x ) { return ( x >= ' a ' && x <= ' z ' ) || ( x >= ' A ' && x <= ' Z ' ) ; } static String getInfix ( String exp ) { Stack s = new Stack ( ) ; for ( int i = 0 ; i < exp . Length ; i ++ ) { if ( isOperand ( exp [ i ] ) ) { s . Push ( exp [ i ] + "" "" ) ; } else { String op1 = ( String ) s . Peek ( ) ; s . Pop ( ) ; String op2 = ( String ) s . Peek ( ) ; s . Pop ( ) ; s . Push ( "" ( "" + op2 + exp [ i ] + op1 + "" ) "" ) ; } } return ( String ) s . Peek ( ) ; } public static void Main ( String [ ] args ) { String exp = "" ab * c + "" ; Console . WriteLine ( getInfix ( exp ) ) ; } }";"Postfix to Infix | C # program to find infix for a given postfix . ; Get Infix for a given postfix expression ; Push operands ; We assume that input is a valid postfix and expect an operator . ; There must be a single element in stack now which is the required infix . ; Driver code"
C#;"using System ; class GfG { class node { public int data ; public node left , right ; } static int updatetree ( node root ) { if ( root == null ) return 0 ; if ( root . left == null && root . right == null ) return root . data ; int leftsum = updatetree ( root . left ) ; int rightsum = updatetree ( root . right ) ; root . data += leftsum ; return root . data + rightsum ; } static void inorder ( node node ) { if ( node == null ) return ; inorder ( node . left ) ; Console . Write ( node . data + "" ▁ "" ) ; inorder ( node . right ) ; } static node newNode ( int data ) { node node = new node ( ) ; node . data = data ; node . left = null ; node . right = null ; return ( node ) ; } public static void Main ( ) { node root = newNode ( 1 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 3 ) ; root . left . left = newNode ( 4 ) ; root . left . right = newNode ( 5 ) ; root . right . right = newNode ( 6 ) ; updatetree ( root ) ; Console . WriteLine ( "" Inorder ▁ traversal ▁ of ▁ the ▁ modified ▁ tree ▁ is "" ) ; inorder ( root ) ; } }";"Change a Binary Tree so that every node stores sum of all nodes in left subtree | C # program to store sum of nodes in left subtree in every node ; A tree node ; Function to modify a Binary Tree so that every node stores sum of values in its left child including its own value ; Base cases ; Update left and right subtrees ; Add leftsum to current node ; Return sum of values under root ; Utility function to do inorder traversal ; Utility function to create a new node ; Driver code ; Let us construct below tree 1 / \ 2 3 / \ \ 4 5 6"
C#;"using System ; class GFG { static void calculateSpan ( int [ ] price , int n , int [ ] S ) { S [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { S [ i ] = 1 ; for ( int j = i - 1 ; ( j >= 0 ) && ( price [ i ] >= price [ j ] ) ; j -- ) S [ i ] ++ ; } } static void printArray ( int [ ] arr ) { string result = string . Join ( "" ▁ "" , arr ) ; Console . WriteLine ( result ) ; } public static void Main ( ) { int [ ] price = { 10 , 4 , 5 , 90 , 120 , 80 } ; int n = price . Length ; int [ ] S = new int [ n ] ; calculateSpan ( price , n , S ) ; printArray ( S ) ; } }";"The Stock Span Problem | C # implementation for brute force method to calculate stock span values ; method to calculate stock span values ; Span value of first day is always 1 ; Calculate span value of remaining days by linearly checking previous days ; Initialize span value ; Traverse left while the next element on left is smaller than price [ i ] ; A utility function to print elements of array ; Driver function ; Fill the span values in array S [ ] ; print the calculated span values"
C#;"using System ; using System . Collections ; class GFG { static void calculateSpan ( int [ ] price , int n , int [ ] S ) { Stack st = new Stack ( ) ; st . Push ( 0 ) ; S [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { while ( st . Count > 0 && price [ ( int ) st . Peek ( ) ] <= price [ i ] ) st . Pop ( ) ; S [ i ] = ( st . Count == 0 ) ? ( i + 1 ) : ( i - ( int ) st . Peek ( ) ) ; st . Push ( i ) ; } } static void printArray ( int [ ] arr ) { for ( int i = 0 ; i < arr . Length ; i ++ ) Console . Write ( arr [ i ] + "" ▁ "" ) ; } public static void Main ( String [ ] args ) { int [ ] price = { 10 , 4 , 5 , 90 , 120 , 80 } ; int n = price . Length ; int [ ] S = new int [ n ] ; calculateSpan ( price , n , S ) ; printArray ( S ) ; } }";"The Stock Span Problem | C # linear time solution for stock span problem ; a linear time solution for stock span problem A stack based efficient method to calculate stock span values ; Create a stack and Push index of first element to it ; Span value of first element is always 1 ; Calculate span values for rest of the elements ; Pop elements from stack while stack is not empty and top of stack is smaller than price [ i ] ; If stack becomes empty , then price [ i ] is greater than all elements on left of it , i . e . , price [ 0 ] , price [ 1 ] , . . price [ i - 1 ] . Else price [ i ] is greater than elements after top of stack ; Push this element to stack ; A utility function to print elements of array ; Driver method ; Fill the span values in array S [ ] ; print the calculated span values"
C#;"using System ; public class GFG { static void calculateSpan ( int [ ] A , int n , int [ ] ans ) { ans [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { int counter = 1 ; while ( ( i - counter ) >= 0 && A [ i ] >= A [ i - counter ] ) { counter += ans [ i - counter ] ; } ans [ i ] = counter ; } } static void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + "" ▁ "" ) ; } public static void Main ( String [ ] args ) { int [ ] price = { 10 , 4 , 5 , 90 , 120 , 80 } ; int n = price . Length ; int [ ] S = new int [ n ] ; calculateSpan ( price , n , S ) ; printArray ( S , n ) ; } }";"The Stock Span Problem | C # program for a linear time solution for stock span problem without using stack ; An efficient method to calculate stock span values implementing the same idea without using stack ; Span value of first element is always 1 ; Calculate span values for rest of the elements ; A utility function to print elements of array ; Driver code ; Fill the span values in array S [ ] ; print the calculated span values"
C#;"using System ; class GFG { static void printNGE ( int [ ] arr , int n ) { int next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } Console . WriteLine ( arr [ i ] + "" ▁ - - ▁ "" + next ) ; } } public static void Main ( ) { int [ ] arr = { 11 , 13 , 21 , 3 } ; int n = arr . Length ; printNGE ( arr , n ) ; } }";"Next Greater Element | Simple C # program to print next greater elements in a given array ; prints element and NGE pair for all elements of arr [ ] of size n ; driver code"
C#;"using System ; public class Node { public int data ; public Node left , right ; public Node ( int item ) { data = item ; left = right = null ; } } class GFG { public Node root ; public virtual void mirror ( ) { root = mirror ( root ) ; } public virtual Node mirror ( Node node ) { if ( node == null ) { return node ; } Node left = mirror ( node . left ) ; Node right = mirror ( node . right ) ; node . left = right ; node . right = left ; return node ; } public virtual void inOrder ( ) { inOrder ( root ) ; } public virtual void inOrder ( Node node ) { if ( node == null ) { return ; } inOrder ( node . left ) ; Console . Write ( node . data + "" ▁ "" ) ; inOrder ( node . right ) ; } public static void Main ( string [ ] args ) { GFG tree = new GFG ( ) ; tree . root = new Node ( 1 ) ; tree . root . left = new Node ( 2 ) ; tree . root . right = new Node ( 3 ) ; tree . root . left . left = new Node ( 4 ) ; tree . root . left . right = new Node ( 5 ) ; Console . WriteLine ( "" Inorder ▁ traversal ▁ "" + "" of ▁ input ▁ tree ▁ is ▁ : "" ) ; tree . inOrder ( ) ; Console . WriteLine ( "" "" ) ; tree . mirror ( ) ; Console . WriteLine ( "" Inorder ▁ traversal ▁ "" + "" of ▁ binary ▁ tree ▁ is ▁ : ▁ "" ) ; tree . inOrder ( ) ; } }";"Convert a Binary Tree into its Mirror Tree | C # program to convert binary tree into its mirror ; Class containing left and right child of current node and key value ; Change a tree so that the roles of the left and right pointers are swapped at every node . So the tree ... 4 / \ 2 5 / \ 1 3 is changed to ... 4 / \ 5 2 / \ 3 1 ; do the subtrees ; swap the left and right pointers ; Helper function to test mirror ( ) . Given a binary search tree , print out its data elements in increasing sorted order . ; testing for example nodes ; print inorder traversal of the input tree ; convert tree to its mirror ; print inorder traversal of the minor tree"
C#;"using System ; using System . Collections ; class GFG { static void fillNext ( int [ ] next , int [ ] a , int n ) { Stack s = new Stack ( ) ; s . Push ( 0 ) ; for ( int i = 1 ; i < n ; i ++ ) { while ( s . Count > 0 ) { int cur = ( int ) s . Peek ( ) ; if ( a [ cur ] < a [ i ] ) { next [ cur ] = i ; s . Pop ( ) ; } else break ; } s . Push ( i ) ; } while ( s . Count > 0 ) { int cur = ( int ) s . Peek ( ) ; next [ cur ] = - 1 ; s . Pop ( ) ; } } static void count ( int [ ] a , int [ ] dp , int n ) { int [ ] next = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) next [ i ] = 0 ; fillNext ( next , a , n ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( next [ i ] == - 1 ) dp [ i ] = 0 ; else dp [ i ] = 1 + dp [ next [ i ] ] ; } } static int answerQuery ( int [ ] dp , int index ) { return dp [ index ] ; } public static void Main ( String [ ] args ) { int [ ] a = { 3 , 4 , 2 , 7 , 5 , 8 , 10 , 6 } ; int n = a . Length ; int [ ] dp = new int [ n ] ; count ( a , dp , n ) ; Console . WriteLine ( answerQuery ( dp , 3 ) ) ; Console . WriteLine ( answerQuery ( dp , 6 ) ) ; Console . WriteLine ( answerQuery ( dp , 1 ) ) ; } }";"Number of NGEs to the right | C # program to print number of NGEs to the right ; array to store the next greater element index ; Use stack ; Push the 0 th index to the stack ; traverse in the loop from 1 - nth index ; iterate till loop is empty ; get the topmost index in the stack ; if the current element is greater then the top index - th element , then this will be the next greatest index of the top index - th element ; initialize the cur index position 's  next greatest as index ; Pop the cur index as its greater element has been found ; if not greater then break ; Push the i index so that its next greatest can be found ; iterate for all other index left inside stack ; mark it as - 1 as no element in greater then it in right ; function to count the number of next greater numbers to the right ; initializes the next array as 0 ; calls the function to pre - calculate the next greatest element indexes ; if the i - th element has no next greater element to right ; Count of next greater numbers to right . ; answers all queries in O ( 1 ) ; returns the number of next greater elements to the right . ; Driver code ; calls the function to count the number of greater elements to the right for every element . ; query 1 answered ; query 2 answered ; query 3 answered"
C#;"using System ; using System . Collections . Generic ; public class GFG { static List < int > no_NGN ( int [ ] arr , int n ) { List < int > nxt = new List < int > ( ) ; Stack < int > s = new Stack < int > ( ) ; nxt . Add ( 0 ) ; s . Push ( n - 1 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { while ( s . Count != 0 && arr [ i ] >= arr [ s . Peek ( ) ] ) s . Pop ( ) ; if ( s . Count == 0 ) nxt . Add ( 0 ) ; else nxt . Add ( nxt [ n - s . Peek ( ) - 1 ] + 1 ) ; s . Push ( i ) ; } nxt . Reverse ( ) ; return nxt ; } public static void Main ( String [ ] args ) { int n = 8 ; int [ ] arr = { 3 , 4 , 2 , 7 , 5 , 8 , 10 , 6 } ; List < int > nxt = no_NGN ( arr , n ) ; Console . Write ( nxt [ 3 ] + "" STRNEWLINE "" ) ; Console . Write ( nxt [ 6 ] + "" STRNEWLINE "" ) ; Console . Write ( nxt [ 1 ] + "" STRNEWLINE "" ) ; } }";"Number of NGEs to the right |  ; use of stl stack in Java ; push the ( n - 1 ) th index to the stack ; traverse in reverse order ; if no element is greater than arr [ i ] the number of NGEs to right is 0 ; number of NGEs to right of arr [ i ] is one greater than the number of NGEs to right of higher number to its right ; reverse again because values are in reverse order ; returns the vector of number of next greater elements to the right of each index . ; Driver code ; query 1 answered ; query 2 answered ; query 3 answered"
C#;"using System ; using System . Collections . Generic ; class GFG { static int MAX = 1000 ; static int [ ] nextGreaterInLeft ( int [ ] a , int n ) { int [ ] left_index = new int [ MAX ] ; Stack < int > s = new Stack < int > ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( s . Count != 0 && a [ i ] > a [ s . Peek ( ) - 1 ] ) { int r = s . Peek ( ) ; s . Pop ( ) ; left_index [ r - 1 ] = i + 1 ; } s . Push ( i + 1 ) ; } return left_index ; } static int [ ] nextGreaterInRight ( int [ ] a , int n ) { int [ ] right_index = new int [ MAX ] ; Stack < int > s = new Stack < int > ( ) ; for ( int i = 0 ; i < n ; ++ i ) { while ( s . Count != 0 && a [ i ] > a [ s . Peek ( ) - 1 ] ) { int r = s . Peek ( ) ; s . Pop ( ) ; right_index [ r - 1 ] = i + 1 ; } s . Push ( i + 1 ) ; } return right_index ; } static int LRProduct ( int [ ] arr , int n ) { int [ ] left = nextGreaterInLeft ( arr , n ) ; int [ ] right = nextGreaterInRight ( arr , n ) ; int ans = - 1 ; for ( int i = 1 ; i <= n ; i ++ ) { ans = Math . Max ( ans , left [ i ] * right [ i ] ) ; } return ans ; } static void Main ( ) { int [ ] arr = new int [ ] { 5 , 4 , 3 , 4 , 5 } ; int n = arr . Length ; Console . Write ( LRProduct ( arr , n ) ) ; } }";"Maximum product of indexes of next greater on left and right | C # program to find the max LRproduct [ i ] among all i ; function to find just next greater element in left side ; checking if current element is greater than top ; on index of top store the current element index which is just greater than top element ; else push the current element in stack ; function to find just next greater element in right side ; checking if current element is greater than top ; on index of top store the current element index which is just greater than top element stored index should be start with 1 ; else push the current element in stack ; Function to find maximum LR product ; for each element storing the index of just greater element in left side ; for each element storing the index of just greater element in right side ; finding the max index product ; Drivers code"
C#;"using System ; public class GFG { static readonly int N = 8 ; static int [ , ] MATRIX = { { 0 , 0 , 1 , 0 } , { 0 , 0 , 1 , 0 } , { 0 , 0 , 0 , 0 } , { 0 , 0 , 1 , 0 } } ; static int knows ( int a , int b ) { return MATRIX [ a , b ] ; } static int findCelebrity ( int n ) { int [ ] indegree = new int [ n ] ; int [ ] outdegree = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int x = knows ( i , j ) ; outdegree [ i ] += x ; indegree [ j ] += x ; } } for ( int i = 0 ; i < n ; i ++ ) if ( indegree [ i ] == n - 1 && outdegree [ i ] == 0 ) return i ; return - 1 ; } public static void Main ( String [ ] args ) { int n = 4 ; int id = findCelebrity ( n ) ; if ( id == - 1 ) Console . Write ( "" No ▁ celebrity "" ) ; else Console . Write ( "" Celebrity ▁ ID ▁ "" + id ) ; } }";"The Celebrity Problem | C # program to find celebrity ; Max # of persons in the party ; Person with 2 is celebrity ; Returns - 1 if celebrity is not present . If present , returns id ( value from 0 to n - 1 ) . ; the graph needs not be constructed as the edges can be found by using knows function degree array ; ; query for all edges ; set the degrees ; find a person with indegree n - 1 and out degree 0 ; Driver code"
C#;"using System ; using System . Collections . Generic ; using System . Text ; public class EvaluateString { public static bool hasPrecedence ( char op1 , char op2 ) { if ( op2 == ' ( ' op2 == ' ) ' ) { return false ; } if ( ( op1 == ' * ' op1 == ' / ' ) && ( op2 == ' + ' op2 == ' - ' ) ) { return false ; } else { return true ; } } public static int applyOp ( char op , int b , int a ) { switch ( op ) { case ' + ' : return a + b ; case ' - ' : return a - b ; case ' * ' : return a * b ; case ' / ' : if ( b == 0 ) { throw new System . NotSupportedException ( "" Cannot ▁ divide ▁ by ▁ zero "" ) ; } return a / b ; } return 0 ; } public static int evaluate ( string expression ) { char [ ] tokens = expression . ToCharArray ( ) ; Stack < int > values = new Stack < int > ( ) ; Stack < char > ops = new Stack < char > ( ) ; for ( int i = 0 ; i < tokens . Length ; i ++ ) { if ( tokens [ i ] == ' ▁ ' ) { continue ; } else if ( tokens [ i ] == ' ( ' ) { ops . Push ( tokens [ i ] ) ; } if ( tokens [ i ] >= '0' && tokens [ i ] <= '9' ) { StringBuilder sbuf = new StringBuilder ( ) ; while ( i < tokens . Length && tokens [ i ] >= '0' && tokens [ i ] <= '9' ) { sbuf . Append ( tokens [ i ++ ] ) ; } values . Push ( int . Parse ( sbuf . ToString ( ) ) ) ; i -- ; } else if ( tokens [ i ] == ' ) ' ) { while ( ops . Peek ( ) != ' ( ' ) { values . Push ( applyOp ( ops . Pop ( ) , values . Pop ( ) , values . Pop ( ) ) ) ; } ops . Pop ( ) ; } else if ( tokens [ i ] == ' + ' tokens [ i ] == ' - ' tokens [ i ] == ' * ' tokens [ i ] == ' / ' ) { while ( ops . Count > 0 && hasPrecedence ( tokens [ i ] , ops . Peek ( ) ) ) { values . Push ( applyOp ( ops . Pop ( ) , values . Pop ( ) , values . Pop ( ) ) ) ; } ops . Push ( tokens [ i ] ) ; } } while ( ops . Count > 0 ) { values . Push ( applyOp ( ops . Pop ( ) , values . Pop ( ) , values . Pop ( ) ) ) ; } return values . Pop ( ) ; } public static void Main ( string [ ] args ) { Console . WriteLine ( EvaluateString . evaluate ( ""10 ▁ + ▁ 2 ▁ * ▁ 6"" ) ) ; Console . WriteLine ( EvaluateString . evaluate ( ""100 ▁ * ▁ 2 ▁ + ▁ 12"" ) ) ; Console . WriteLine ( EvaluateString . evaluate ( ""100 ▁ * ▁ ( ▁ 2 ▁ + ▁ 12 ▁ ) "" ) ) ; Console . WriteLine ( EvaluateString . evaluate ( ""100 ▁ * ▁ ( ▁ 2 ▁ + ▁ 12 ▁ ) ▁ / ▁ 14"" ) ) ; } }";"Expression Evaluation | A C # program to evaluate a given expression where tokens are separated by space . ; Returns true if ' op2' has higher or same precedence as ' op1' , otherwise returns false . ; A utility method to apply an operator ' op ' on operands ' a ' and ' b ' . Return the result . ; Function that returns value of expression after evaluation . ; Stack for numbers : ' values ' ; Stack for Operators : ' ops ' ; Current token is a whitespace , skip it ; Current token is an opening brace , push it to ' ops ' ; Current token is a number , push it to stack for numbers ; There may be more than one digits in number ; Right now the i points to the character next to the digit , since the for loop also increases the i , we would skip one token position ; we need to decrease the value of i by 1 to correct the offset . ; Closing brace encountered , solve entire brace ; Current token is an operator . ; While top of ' ops ' has same or greater precedence to current token , which is an operator . Apply operator on top of ' ops ' to top two elements in values stack ; Push current token to ' ops ' . ; Entire expression has been parsed at this point , apply remaining ops to remaining values ; Top of ' values ' contains result , return it ; Driver method to test above methods"
C#;"using System . Collections . Generic ; using System ; class GFG { public class Node { public int data ; public Node left ; public Node right ; } ; static Node newNode ( int data ) { Node node = new Node ( ) ; node . data = data ; node . left = node . right = null ; return ( node ) ; } static void mirror ( Node root ) { if ( root == null ) return ; Queue < Node > q = new Queue < Node > ( ) ; q . Enqueue ( root ) ; while ( q . Count > 0 ) { Node curr = q . Peek ( ) ; q . Dequeue ( ) ; Node temp = curr . left ; curr . left = curr . right ; curr . right = temp ; ; if ( curr . left != null ) q . Enqueue ( curr . left ) ; if ( curr . right != null ) q . Enqueue ( curr . right ) ; } } static void inOrder ( Node node ) { if ( node == null ) return ; inOrder ( node . left ) ; Console . Write ( node . data + "" ▁ "" ) ; inOrder ( node . right ) ; } public static void Main ( String [ ] args ) { Node root = newNode ( 1 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 3 ) ; root . left . left = newNode ( 4 ) ; root . left . right = newNode ( 5 ) ; Console . Write ( "" STRNEWLINE ▁ Inorder ▁ traversal ▁ of ▁ the "" + "" ▁ coned ▁ tree ▁ is ▁ STRNEWLINE "" ) ; inOrder ( root ) ; mirror ( root ) ; Console . Write ( "" STRNEWLINE ▁ Inorder ▁ traversal ▁ of ▁ the ▁ "" + "" mirror ▁ tree ▁ is ▁ STRNEWLINE "" ) ; inOrder ( root ) ; } }";"Convert a Binary Tree into its Mirror Tree | C # Iterative Java program to convert a Binary Tree to its mirror ; A binary tree node has data , pointer to left child and a pointer to right child ; Helper function that allocates a new node with the given data and null left and right pointers . ; Change a tree so that the roles of the left and right pointers are swapped at every node . So the tree ... 4 / \ 2 5 / \ 1 3 is changed to ... 4 / \ 5 2 / \ 3 1 ; Do BFS . While doing BFS , keep swapping left and right children ; pop top node from queue ; swap left child with right child ; push left and right children ; Helper function to print Inorder traversal . ; Driver code ; Print inorder traversal of the input tree ; Convert tree to its mirror ; Print inorder traversal of the mirror tree"
C#;"using System ; class GFG { public class Stack { public int capacity ; public int top ; public int [ ] array ; } Stack createStack ( int capacity ) { Stack stack = new Stack ( ) ; stack . capacity = capacity ; stack . top = - 1 ; stack . array = new int [ capacity ] ; return stack ; } Boolean isFull ( Stack stack ) { return ( stack . top == stack . capacity - 1 ) ; } Boolean isEmpty ( Stack stack ) { return ( stack . top == - 1 ) ; } void push ( Stack stack , int item ) { if ( isFull ( stack ) ) return ; stack . array [ ++ stack . top ] = item ; } int pop ( Stack stack ) { if ( isEmpty ( stack ) ) return int . MinValue ; return stack . array [ stack . top -- ] ; } void moveDisk ( char fromPeg , char toPeg , int disk ) { Console . WriteLine ( "" Move ▁ the ▁ disk ▁ "" + disk + "" ▁ from ▁ "" + fromPeg + "" ▁ to ▁ "" + toPeg ) ; } void moveDisksBetweenTwoPoles ( Stack src , Stack dest , char s , char d ) { int pole1TopDisk = pop ( src ) ; int pole2TopDisk = pop ( dest ) ; if ( pole1TopDisk == int . MinValue ) { push ( src , pole2TopDisk ) ; moveDisk ( d , s , pole2TopDisk ) ; } else if ( pole2TopDisk == int . MinValue ) { push ( dest , pole1TopDisk ) ; moveDisk ( s , d , pole1TopDisk ) ; } else if ( pole1TopDisk > pole2TopDisk ) { push ( src , pole1TopDisk ) ; push ( src , pole2TopDisk ) ; moveDisk ( d , s , pole2TopDisk ) ; } else { push ( dest , pole2TopDisk ) ; push ( dest , pole1TopDisk ) ; moveDisk ( s , d , pole1TopDisk ) ; } } void tohIterative ( int num_of_disks , Stack src , Stack aux , Stack dest ) { int i , total_num_of_moves ; char s = ' S ' , d = ' D ' , a = ' A ' ; if ( num_of_disks % 2 == 0 ) { char temp = d ; d = a ; a = temp ; } total_num_of_moves = ( int ) ( Math . Pow ( 2 , num_of_disks ) - 1 ) ; for ( i = num_of_disks ; i >= 1 ; i -- ) push ( src , i ) ; for ( i = 1 ; i <= total_num_of_moves ; i ++ ) { if ( i % 3 == 1 ) moveDisksBetweenTwoPoles ( src , dest , s , d ) ; else if ( i % 3 == 2 ) moveDisksBetweenTwoPoles ( src , aux , s , a ) ; else if ( i % 3 == 0 ) moveDisksBetweenTwoPoles ( aux , dest , a , d ) ; } } public static void Main ( String [ ] args ) { int num_of_disks = 3 ; GFG ob = new GFG ( ) ; Stack src , dest , aux ; src = ob . createStack ( num_of_disks ) ; dest = ob . createStack ( num_of_disks ) ; aux = ob . createStack ( num_of_disks ) ; ob . tohIterative ( num_of_disks , src , aux , dest ) ; } }";"Iterative Tower of Hanoi | C # program for iterative Tower of Hanoi ; A structure to represent a stack ; function to create a stack of given capacity . ; Stack is full when top is equal to the last index ; Stack is empty when top is equal to - 1 ; Function to add an item to stack . It increases top by 1 ; Function to remove an item from stack . It decreases top by 1 ; Function to show the movement of disks ; Function to implement legal movement between two poles ; When pole 1 is empty ; When pole2 pole is empty ; When top disk of pole1 > top disk of pole2 ; When top disk of pole1 < top disk of pole2 ; Function to implement TOH puzzle ; If number of disks is even , then interchange destination pole and auxiliary pole ; Larger disks will be pushed first ; Driver code ; Input : number of disks ; Create three stacks of size ' num _ of _ disks ' to hold the disks"
C#;"using System ; using System . Collections . Generic ; class GFG { static void deleteMid ( Stack < char > st , int n , int curr = 0 ) { if ( st . Count == 0 curr == n ) return ; char x = st . Peek ( ) ; st . Pop ( ) ; deleteMid ( st , n , curr + 1 ) ; if ( curr != n / 2 ) st . Push ( x ) ; } public static void Main ( ) { Stack < char > st = new Stack < char > ( ) ; st . Push ( '1' ) ; st . Push ( '2' ) ; st . Push ( '3' ) ; st . Push ( '4' ) ; st . Push ( '5' ) ; st . Push ( '6' ) ; st . Push ( '7' ) ; deleteMid ( st , st . Count ) ; while ( st . Count != 0 ) { char p = st . Peek ( ) ; st . Pop ( ) ; Console . Write ( p + "" ▁ "" ) ; } } }";"Delete middle element of a stack | C # code to delete middle of a stack without using additional data structure . ; Deletes middle of stack of size n . Curr is current item number ; If stack is empty or all items are traversed ; Remove current item ; Remove other items ; Put all items back except middle ; Driver Code ; push elements into the stack ; Printing stack after deletion of middle ."
C#;"using System ; using System . Collections . Generic ; class GFG { static Stack < int > sortStack ( Stack < int > input ) { Stack < int > tmpStack = new Stack < int > ( ) ; while ( input . Count != 0 ) { int tmp = input . Peek ( ) ; input . Pop ( ) ; while ( tmpStack . Count != 0 && tmpStack . Peek ( ) < tmp ) { input . Push ( tmpStack . Peek ( ) ) ; tmpStack . Pop ( ) ; } tmpStack . Push ( tmp ) ; } return tmpStack ; } static void sortArrayUsingStacks ( int [ ] arr , int n ) { Stack < int > input = new Stack < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) input . Push ( arr [ i ] ) ; Stack < int > tmpStack = sortStack ( input ) ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = tmpStack . Peek ( ) ; tmpStack . Pop ( ) ; } } static void Main ( ) { int [ ] arr = new int [ ] { 10 , 5 , 15 , 45 } ; int n = arr . Length ; sortArrayUsingStacks ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + "" ▁ "" ) ; } }";"Sorting array using Stacks | C # program to sort an array using stack ; This function return the sorted stack ; pop out the first element ; while temporary stack is not empty and top of stack is smaller than temp ; pop from temporary stack and push it to the input stack ; push temp in tempory of stack ; Push array elements to stack ; Sort the temporary stack ; Put stack elements in arrp [ ] ; Driver Code"
C#;"using System ; using System . Collections . Generic ; public class Node { public int data ; public Node left , right ; public Node ( int data ) { this . data = data ; left = right = null ; } } public class BinaryTree { Node root ; Node head ; void push ( Node node ) { node . right = head ; node . left = null ; if ( head != null ) head . left = node ; head = node ; } void printList ( Node node ) { while ( node != null ) { Console . Write ( node . data + "" ▁ "" ) ; node = node . right ; } } void spiralLevelOrder ( Node root ) { if ( root == null ) return ; LinkedList < Node > q = new LinkedList < Node > ( ) ; q . AddFirst ( root ) ; Stack < Node > stk = new Stack < Node > ( ) ; int level = 0 ; while ( q . Count != 0 ) { int nodeCount = q . Count ; if ( ( level & 1 ) % 2 != 0 ) { while ( nodeCount > 0 ) { Node node = q . First . Value ; q . RemoveFirst ( ) ; stk . Push ( node ) ; if ( node . left != null ) q . AddLast ( node . left ) ; if ( node . right != null ) q . AddLast ( node . right ) ; nodeCount -- ; } } else { while ( nodeCount > 0 ) { Node node = q . Last . Value ; q . RemoveLast ( ) ; stk . Push ( node ) ; if ( node . right != null ) q . AddFirst ( node . right ) ; if ( node . left != null ) q . AddFirst ( node . left ) ; nodeCount -- ; } } level ++ ; } while ( stk . Count != 0 ) { push ( stk . Peek ( ) ) ; stk . Pop ( ) ; } Console . WriteLine ( "" Created ▁ DLL ▁ is ▁ : ▁ "" ) ; printList ( head ) ; } public static void Main ( String [ ] args ) { BinaryTree tree = new BinaryTree ( ) ; tree . root = new Node ( 1 ) ; tree . root . left = new Node ( 2 ) ; tree . root . right = new Node ( 3 ) ; tree . root . left . left = new Node ( 4 ) ; tree . root . left . right = new Node ( 5 ) ; tree . root . right . left = new Node ( 6 ) ; tree . root . right . right = new Node ( 7 ) ; tree . root . left . left . left = new Node ( 8 ) ; tree . root . left . left . right = new Node ( 9 ) ; tree . root . left . right . left = new Node ( 10 ) ; tree . root . left . right . right = new Node ( 11 ) ; tree . root . right . left . right = new Node ( 13 ) ; tree . root . right . right . left = new Node ( 14 ) ; tree . spiralLevelOrder ( tree . root ) ; } }";"Convert a Binary Tree into Doubly Linked List in spiral fashion | C # program to convert Binary Tree into Doubly Linked List where the nodes are represented spirally ; A binary tree node ; Given a reference to a node , inserts the node on the front of the list . ; Make right of given node as head and left as NULL ; change left of head node to given node ; move the head to point to the given node ; Function to prints contents of DLL ; Function to print corner node at each level ; Base Case ; Create an empty deque for doing spiral level order traversal and enqueue root ; create a stack to store Binary Tree nodes to insert into DLL later ; nodeCount indicates number of Nodes at current level . ; Dequeue all Nodes of current level and Enqueue all Nodes of next level odd level ; dequeue node from front & push it to stack ; insert its left and right children in the back of the deque ; even level ; dequeue node from the back & push it to stack ; inserts its right and left children in the front of the deque ; pop all nodes from stack and push them in the beginning of the list ; Driver program to test above functions ; Let us create binary tree as shown in above diagram ; tree . root . right . left . left = new Node ( 12 ) ; ; tree . root . right . right . right = new Node ( 15 ) ;"
C#;"using System ; using System . Collections . Generic ; class GFG { public static void reverseWords ( string str ) { Stack < char > st = new Stack < char > ( ) ; for ( int i = 0 ; i < str . Length ; ++ i ) { if ( str [ i ] != ' ▁ ' ) { st . Push ( str [ i ] ) ; } else { while ( st . Count > 0 ) { Console . Write ( st . Pop ( ) ) ; } Console . Write ( "" ▁ "" ) ; } } while ( st . Count > 0 ) { Console . Write ( st . Pop ( ) ) ; } } public static void Main ( string [ ] args ) { string str = "" Geeks ▁ for ▁ Geeks "" ; reverseWords ( str ) ; } }";"Reverse individual words | C # program to reverse individual words in a given string using STL list ; reverses individual words of a string ; Traverse given string and push all characters to stack until we see a space . ; When we see a space , we print contents of stack . ; Since there may not be space after last word . ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { static int MAXN = 100005 ; public class pair { public int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static void makeNext ( int [ ] arr , int n , int [ ] nextBig ) { Stack < pair > s = new Stack < pair > ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { nextBig [ i ] = i ; while ( s . Count != 0 && s . Peek ( ) . first < arr [ i ] ) s . Pop ( ) ; if ( s . Count != 0 ) nextBig [ i ] = s . Peek ( ) . second ; s . Push ( new pair ( arr [ i ] , i ) ) ; } } static void makePrev ( int [ ] arr , int n , int [ ] prevBig ) { Stack < pair > s = new Stack < pair > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { prevBig [ i ] = - 1 ; while ( s . Count != 0 && s . Peek ( ) . first < arr [ i ] ) s . Pop ( ) ; if ( s . Count != 0 ) prevBig [ i ] = s . Peek ( ) . second ; s . Push ( new pair ( arr [ i ] , i ) ) ; } } static int wrapper ( int [ ] arr , int n ) { int [ ] nextBig = new int [ MAXN ] ; int [ ] prevBig = new int [ MAXN ] ; int [ ] maxi = new int [ MAXN ] ; int ans = 0 ; makePrev ( arr , n , prevBig ) ; makeNext ( arr , n , nextBig ) ; for ( int i = 0 ; i < n ; i ++ ) if ( nextBig [ i ] != i ) maxi [ nextBig [ i ] - i ] = Math . Max ( maxi [ nextBig [ i ] - i ] , i - prevBig [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) ans += maxi [ i ] ; return ans ; } public static void Main ( String [ ] args ) { int [ ] arr = { 1 , 3 , 2 , 4 } ; int n = arr . Length ; Console . WriteLine ( wrapper ( arr , n ) ) ; } }";"Count subarrays where second highest lie before highest | C # program to count number of distinct instance where second highest number lie before highest number in all subarrays . ; Pair class ; Finding the next greater element of the array . ; Finding the previous greater element of the array . ; Wrapper Function ; Finding previous largest element ; Finding next largest element ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { public static int getMaxArea ( int [ ] hist , int n ) { Stack < int > s = new Stack < int > ( ) ; int max_area = 0 ; int tp ; int area_with_top ; int i = 0 ; while ( i < n ) { if ( s . Count == 0 || hist [ s . Peek ( ) ] <= hist [ i ] ) { s . Push ( i ++ ) ; } else { tp = s . Peek ( ) ; s . Pop ( ) ; area_with_top = hist [ tp ] * ( s . Count == 0 ? i : i - s . Peek ( ) - 1 ) ; if ( max_area < area_with_top ) { max_area = area_with_top ; } } } while ( s . Count > 0 ) { tp = s . Peek ( ) ; s . Pop ( ) ; area_with_top = hist [ tp ] * ( s . Count == 0 ? i : i - s . Peek ( ) - 1 ) ; if ( max_area < area_with_top ) { max_area = area_with_top ; } } return max_area ; } public static void Main ( string [ ] args ) { int [ ] hist = new int [ ] { 6 , 2 , 5 , 4 , 5 , 1 , 6 } ; Console . WriteLine ( "" Maximum ▁ area ▁ is ▁ "" + getMaxArea ( hist , hist . Length ) ) ; } }";"Largest Rectangular Area in a Histogram | Set 2 | C # program to find maximum rectangular area in linear time ; The main function to find the maximum rectangular area under given histogram with n bars ; Create an empty stack . The stack holds indexes of hist [ ] array The bars stored in stack are always in increasing order of their heights . ; Initialize max area ; To store top of stack ; To store area with top ; bar as the smallest bar Run through all bars of given histogram ; If this bar is higher than the bar on top stack , push it to stack ; If this bar is lower than top of stack , then calculate area of rectangle with stack top as the smallest ( or minimum height ) bar . ' i ' is ' right ▁ index ' for the top and element before top in stack is ' left ▁ index ' ; store the top index ; pop the top ; Calculate the area with hist [ tp ] stack as smallest bar ; update max area , if needed ; Now pop the remaining bars from stack and calculate area with every popped bar as the smallest bar ; Driver Code"
C#;"using System ; class GFG { static void towerOfHanoi ( int n , char from_rod , char to_rod , char aux_rod ) { if ( n == 1 ) { Console . WriteLine ( "" Move ▁ disk ▁ 1 ▁ from ▁ rod ▁ "" + from_rod + "" ▁ to ▁ rod ▁ "" + to_rod ) ; return ; } towerOfHanoi ( n - 1 , from_rod , aux_rod , to_rod ) ; Console . WriteLine ( "" Move ▁ disk ▁ "" + n + "" ▁ from ▁ rod ▁ "" + from_rod + "" ▁ to ▁ rod ▁ "" + to_rod ) ; towerOfHanoi ( n - 1 , aux_rod , to_rod , from_rod ) ; } public static void Main ( String [ ] args ) { int n = 4 ; towerOfHanoi ( n , ' A ' , ' C ' , ' B ' ) ; } }";"Program for Tower of Hanoi | C # recursive program to solve tower of hanoi puzzle ; Driver method ; Number of disks ; A , B and C are names of rods"
C#;"using System ; class GFG { static int [ ] arr = { 10 , 20 , 30 , 50 , 10 , 70 , 30 } ; static void printMaxOfMin ( int n ) { for ( int k = 1 ; k <= n ; k ++ ) { int maxOfMin = int . MinValue ; for ( int i = 0 ; i <= n - k ; i ++ ) { int min = arr [ i ] ; for ( int j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; } if ( min > maxOfMin ) maxOfMin = min ; } Console . Write ( maxOfMin + "" ▁ "" ) ; } } public static void Main ( ) { printMaxOfMin ( arr . Length ) ; } }";"Find maximum of minimum for every window size in a given array | C # program using Naive approach to find maximum of minimum of all windows of different sizes ; Consider all windows of different sizes starting from size 1 ; Initialize max of min for current window size k ; Traverse through all windows of current size k ; Find minimum of current window ; Update maxOfMin if required ; Print max of min for current window size ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { public static int [ ] arr = new int [ ] { 10 , 20 , 30 , 50 , 10 , 70 , 30 } ; public static void printMaxOfMin ( int n ) { Stack < int > s = new Stack < int > ( ) ; int [ ] left = new int [ n + 1 ] ; int [ ] right = new int [ n + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { left [ i ] = - 1 ; right [ i ] = n ; } for ( int i = 0 ; i < n ; i ++ ) { while ( s . Count > 0 && arr [ s . Peek ( ) ] >= arr [ i ] ) { s . Pop ( ) ; } if ( s . Count > 0 ) { left [ i ] = s . Peek ( ) ; } s . Push ( i ) ; } while ( s . Count > 0 ) { s . Pop ( ) ; } for ( int i = n - 1 ; i >= 0 ; i -- ) { while ( s . Count > 0 && arr [ s . Peek ( ) ] >= arr [ i ] ) { s . Pop ( ) ; } if ( s . Count > 0 ) { right [ i ] = s . Peek ( ) ; } s . Push ( i ) ; } int [ ] ans = new int [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { ans [ i ] = 0 ; } for ( int i = 0 ; i < n ; i ++ ) { int len = right [ i ] - left [ i ] - 1 ; ans [ len ] = Math . Max ( ans [ len ] , arr [ i ] ) ; } for ( int i = n - 1 ; i >= 1 ; i -- ) { ans [ i ] = Math . Max ( ans [ i ] , ans [ i + 1 ] ) ; } for ( int i = 1 ; i <= n ; i ++ ) { Console . Write ( ans [ i ] + "" ▁ "" ) ; } } public static void Main ( string [ ] args ) { printMaxOfMin ( arr . Length ) ; } }";"Find maximum of minimum for every window size in a given array | An efficient C # program to find maximum of all minimums of windows of different size ; Used to find previous and next smaller ; Arrays to store previous and next smaller ; Initialize elements of left [ ] and right [ ] ; Fill elements of left [ ] using logic discussed on www . geeksforgeeks . org / next - greater - element / https : ; Empty the stack as stack is going to be used for right [ ] ; Fill elements of right [ ] using same logic ; Create and initialize answer array ; Fill answer array by comparing minimums of all lengths computed using left [ ] and right [ ] ; length of the interval ; arr [ i ] is a possible answer for this length ' len ' interval , check x if arr [ i ] is more than max for ' len ' ; Some entries in ans [ ] may not be filled yet . Fill them by taking values from right side of ans [ ] ; Print the result ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { public static int findMaxLen ( string str ) { int n = str . Length ; Stack < int > stk = new Stack < int > ( ) ; stk . Push ( - 1 ) ; int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ( ' ) { stk . Push ( i ) ; } else { if ( stk . Count > 0 ) stk . Pop ( ) ; if ( stk . Count > 0 ) { result = Math . Max ( result , i - stk . Peek ( ) ) ; } else { stk . Push ( i ) ; } } } return result ; } public static void Main ( string [ ] args ) { string str = "" ( ( ( ) ( ) "" ; Console . WriteLine ( findMaxLen ( str ) ) ; str = "" ( ) ( ( ) ) ) ) ) "" ; Console . WriteLine ( findMaxLen ( str ) ) ; } }";"Length of the longest valid substring | C # program to find length of the longest valid substring ; method to get length of the longest valid ; Create a stack and push - 1 as initial index to it . ; Initialize result ; Traverse all characters of given string ; If opening bracket , push index of it ; If closing bracket , i . e . , str [ i ] = ' ) ' ; Pop the previous opening bracket 's index ; Check if this length formed with base of current valid substring is more than max so far ; If stack is empty . push current index as base for next valid substring ( if any ) ; Driver Code ; Function call ; Function call"
C#;"using System ; using System . Collections . Generic ; class GFG { static int N = 12 , ans ; static List < List < int > > tree = new List < List < int > > ( ) ; static int dfs ( int [ ] visit , int node ) { int num = 0 , temp = 0 ; visit [ node ] = 1 ; for ( int i = 0 ; i < tree [ node ] . Count ; i ++ ) { if ( visit [ tree [ node ] [ i ] ] == 0 ) { temp = dfs ( visit , tree [ node ] [ i ] ) ; if ( temp % 2 != 0 ) num += temp ; else ans ++ ; } } return num + 1 ; } static int minEdge ( int n ) { int [ ] visit = new int [ n + 2 ] ; ans = 0 ; dfs ( visit , 1 ) ; return ans ; } public static void Main ( String [ ] args ) { int n = 10 ; for ( int i = 0 ; i < n + 2 ; i ++ ) tree . Add ( new List < int > ( ) ) ; tree [ 1 ] . Add ( 3 ) ; tree [ 3 ] . Add ( 1 ) ; tree [ 1 ] . Add ( 6 ) ; tree [ 6 ] . Add ( 1 ) ; tree [ 1 ] . Add ( 2 ) ; tree [ 2 ] . Add ( 1 ) ; tree [ 3 ] . Add ( 4 ) ; tree [ 4 ] . Add ( 3 ) ; tree [ 6 ] . Add ( 8 ) ; tree [ 8 ] . Add ( 6 ) ; tree [ 2 ] . Add ( 7 ) ; tree [ 7 ] . Add ( 2 ) ; tree [ 2 ] . Add ( 5 ) ; tree [ 5 ] . Add ( 2 ) ; tree [ 4 ] . Add ( 9 ) ; tree [ 9 ] . Add ( 4 ) ; tree [ 4 ] . Add ( 10 ) ; tree [ 10 ] . Add ( 4 ) ; Console . WriteLine ( minEdge ( n ) ) ; } }";"Convert a tree to forest of even nodes | C # program to find maximum number to be removed to convert a tree into forest containing trees of even number of nodes ; Return the number of nodes of subtree having node as a root . ; Mark node as visited . ; Traverse the adjacency list to find non - visited node . ; Finding number of nodes of the subtree of a subtree . ; If nodes are even , increment number of edges to removed . Else leave the node as child of subtree . ; Return the maximum number of edge to remove to make forest . ; Driver Code"
C#;"using System ; public class GFG { static int findMaxLen ( String s ) { if ( s . Length <= 1 ) return 0 ; int curMax = 0 ; int [ ] longest = new int [ s . Length ] ; for ( int i = 1 ; i < s . Length ; i ++ ) { if ( s [ i ] == ' ) ' && i - longest [ i - 1 ] - 1 >= 0 && s [ i - longest [ i - 1 ] - 1 ] == ' ( ' ) { longest [ i ] = longest [ i - 1 ] + 2 + ( ( i - longest [ i - 1 ] - 2 >= 0 ) ? longest [ i - longest [ i - 1 ] - 2 ] : 0 ) ; curMax = Math . Max ( longest [ i ] , curMax ) ; } } return curMax ; } public static void Main ( String [ ] args ) { String str = "" ( ( ( ) ( ) "" ; Console . Write ( findMaxLen ( str ) + "" STRNEWLINE "" ) ; str = "" ( ) ( ( ) ) ) ) ) "" ; Console . Write ( findMaxLen ( str ) + "" STRNEWLINE "" ) ; } }";"Length of the longest valid substring | C # program to find length of the longest valid subString ; Initialize curMax to zero ; Iterate over the String starting from second index ; Driver code ; Function call ; Function call"
C#;"using System ; public class GFG { public static int solve ( String s , int n ) { int left = 0 , right = 0 ; int maxlength = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ( ' ) left ++ ; else right ++ ; if ( left == right ) maxlength = Math . Max ( maxlength , 2 * right ) ; else if ( right > left ) left = right = 0 ; } left = right = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' ( ' ) left ++ ; else right ++ ; if ( left == right ) maxlength = Math . Max ( maxlength , 2 * left ) ; else if ( left > right ) left = right = 0 ; } return maxlength ; } public static void Main ( String [ ] args ) { Console . Write ( solve ( "" ( ( ( ) ( ) ( ) ( ) ( ( ( ( ) ) "" , 16 ) ) ; } }";"Length of the longest valid substring | C # program to implement the above approach ; Function to return the length of the longest valid substring ; Variables for left and right counter maxlength to store the maximum length found so far ; Iterating the string from left to right ; If "" ( "" is encountered , then left counter is incremented else right counter is incremented ; Whenever left is equal to right , it signifies that the subsequence is valid and ; Reseting the counters when the subsequence becomes invalid ; Iterating the string from right to left ; If "" ( "" is encountered , then left counter is incremented else right counter is incremented ; Whenever left is equal to right , it signifies that the subsequence is valid and ; Reseting the counters when the subsequence becomes invalid ; Driver code ; Function call"
C#;"using System ; using System . Collections . Generic ; class GFG { static bool checkRedundancy ( String s ) { Stack < char > st = new Stack < char > ( ) ; char [ ] str = s . ToCharArray ( ) ; foreach ( char ch in str ) { if ( ch == ' ) ' ) { char top = st . Peek ( ) ; st . Pop ( ) ; bool flag = true ; while ( top != ' ( ' ) { if ( top == ' + ' top == ' - ' top == ' * ' top == ' / ' ) { flag = false ; } top = st . Peek ( ) ; st . Pop ( ) ; } if ( flag == true ) { return true ; } } else { st . Push ( ch ) ; } } return false ; } static void findRedundant ( String str ) { bool ans = checkRedundancy ( str ) ; if ( ans == true ) { Console . WriteLine ( "" Yes "" ) ; } else { Console . WriteLine ( "" No "" ) ; } } public static void Main ( String [ ] args ) { String str = "" ( ( a + b ) ) "" ; findRedundant ( str ) ; str = "" ( a + ( b ) / c ) "" ; findRedundant ( str ) ; str = "" ( a + b * ( c - d ) ) "" ; findRedundant ( str ) ; } }";"Expression contains redundant bracket or not | C # Program to check whether valid expression is redundant or not ; Function to check redundant brackets in a balanced expression ; create a stack of characters ; Iterate through the given expression ; if current character is close parenthesis ' ) ' ; If immediate pop have open parenthesis ' ( ' duplicate brackets found ; Check for operators in expression ; Fetch top element of stack ; If operators not found ; push open parenthesis ' ( ' , ; operators and operands to stack ; Function to check redundant brackets ; Driver code"
C#;"using System ; using System . Collections . Generic ; public class GFG { static readonly int MAX_CHAR = 26 ; static bool adjSign ( String s , int i ) { if ( i == 0 ) return true ; if ( s [ i - 1 ] == ' - ' ) return false ; return true ; } static void eval ( String s , int [ ] v , bool add ) { Stack < Boolean > stk = new Stack < Boolean > ( ) ; stk . Push ( true ) ; int i = 0 ; while ( i < s . Length ) { if ( s [ i ] == ' + ' s [ i ] == ' - ' ) { i ++ ; continue ; } if ( s [ i ] == ' ( ' ) { if ( adjSign ( s , i ) ) stk . Push ( stk . Peek ( ) ) ; else stk . Push ( ! stk . Peek ( ) ) ; } else if ( s [ i ] == ' ) ' ) stk . Pop ( ) ; else { if ( stk . Peek ( ) ) v [ s [ i ] - ' a ' ] += ( adjSign ( s , i ) ? add ? 1 : - 1 : add ? - 1 : 1 ) ; else v [ s [ i ] - ' a ' ] += ( adjSign ( s , i ) ? add ? - 1 : 1 : add ? 1 : - 1 ) ; } i ++ ; } } static bool areSame ( String expr1 , String expr2 ) { int [ ] v = new int [ MAX_CHAR ] ; eval ( expr1 , v , true ) ; eval ( expr2 , v , false ) ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) if ( v [ i ] != 0 ) return false ; return true ; } public static void Main ( String [ ] args ) { String expr1 = "" - ( a + b + c ) "" , expr2 = "" - a - b - c "" ; if ( areSame ( expr1 , expr2 ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Check if two expressions with brackets are same | C # program to check if two expressions evaluate to same . ; Return local sign of the operand . For example , in the expr a - b - ( c ) , local signs of the operands are + a , - b , + c ; Evaluate expressions into the count vector of the 26 alphabets . If add is true , then add count to the count vector of the alphabets , else remove count from the count vector . ; stack stores the global sign for operands . ; + means true global sign is positive initially ; global sign for the bracket is pushed to the stack ; global sign is popped out which was pushed in for the last bracket ; global sign is positive ( we use different values in two calls of functions so that we finally check if all vector elements are 0. ; global sign is negative here ; Returns true if expr1 and expr2 represent same expressions ; Create a vector for all operands and initialize the vector as 0. ; Put signs of all operands in expr1 ; Subtract signs of operands in expr2 ; If expressions are same , vector must be 0. ; Driver Code"
C#;"using System ; using System . Collections ; public class GFG { static void test ( String expression , int index ) { int i ; if ( expression [ index ] != ' [ ' ) { Console . Write ( expression + "" , ▁ "" + index + "" : ▁ - 1 STRNEWLINE "" ) ; return ; } Stack st = new Stack ( ) ; for ( i = index ; i < expression . Length ; i ++ ) { if ( expression [ i ] == ' [ ' ) { st . Push ( ( int ) expression [ i ] ) ; } else if ( expression [ i ] == ' ] ' ) { st . Pop ( ) ; if ( st . Count == 0 ) { Console . Write ( expression + "" , ▁ "" + index + "" : ▁ "" + i + "" STRNEWLINE "" ) ; return ; } } } Console . Write ( expression + "" , ▁ "" + index + "" : ▁ - 1 STRNEWLINE "" ) ; } public static void Main ( ) { test ( "" [ ABC [ 23 ] ] [89 ] "" , 0 ) ; test ( "" [ ABC [ 23 ] ] [89 ] "" , 4 ) ; test ( "" [ ABC [ 23 ] ] [89 ] "" , 9 ) ; test ( "" [ ABC [ 23 ] ] [89 ] "" , 1 ) ; } }";"Find index of closing bracket for a given opening bracket in an expression | C # program to find index of closing bracket for given opening bracket . ; Function to find index of closing bracket for given opening bracket . ; If index given is invalid and is not an opening bracket . ; Stack to store opening brackets . ; Traverse through string starting from given index . ; If current character is an opening bracket push it in stack . ; If current character is a closing bracket , pop from stack . If stack is empty , then this closing bracket is required bracket . ; If no matching closing bracket is found . ; Driver Code ; should be 8 ; should be 7 ; should be 12 ; No matching bracket"
C#;"using System ; class GfG { class Node { public int data ; public Node left ; public Node right ; } static Node newNode ( int key ) { Node node = new Node ( ) ; node . data = key ; node . left = null ; node . right = null ; return node ; } static void convertTree ( Node root ) { if ( root == null ) return ; convertTree ( root . left ) ; convertTree ( root . right ) ; if ( root . left != null && root . right != null ) root . data = ( root . left . data ) & ( root . right . data ) ; } static void printInorder ( Node root ) { if ( root == null ) return ; printInorder ( root . left ) ; Console . Write ( root . data + "" ▁ "" ) ; printInorder ( root . right ) ; } public static void Main ( ) { Node root = newNode ( 0 ) ; root . left = newNode ( 1 ) ; root . right = newNode ( 0 ) ; root . left . left = newNode ( 0 ) ; root . left . right = newNode ( 1 ) ; root . right . left = newNode ( 1 ) ; root . right . right = newNode ( 1 ) ; Console . Write ( "" Inorder ▁ traversal ▁ before ▁ conversion ▁ "" ) ; printInorder ( root ) ; convertTree ( root ) ; Console . WriteLine ( ) ; Console . Write ( "" Inorder ▁ traversal ▁ after ▁ conversion ▁ "" ) ; printInorder ( root ) ; } }";"Convert a given Binary tree to a tree that holds Logical AND property | C # code to convert a given binary tree to a tree that holds logical AND property . ; Structure of binary tree ; function to create a new node ; Convert the given tree to a tree where each node is logical AND of its children The main idea is to do Postorder traversal ; first recur on left child ; then recur on right child ; first recur on left child ; then print the data of node ; now recur on right child ; Driver code ; Create following Binary Tree 1 / \ 1 0 / \ / \ 0 1 1 1"
C#;"using System ; using System . Collections . Generic ; class GFG { static Boolean findDuplicateparenthesis ( String s ) { Stack < char > Stack = new Stack < char > ( ) ; char [ ] str = s . ToCharArray ( ) ; foreach ( char ch in str ) { if ( ch == ' ) ' ) { char top = Stack . Peek ( ) ; Stack . Pop ( ) ; int elementsInside = 0 ; while ( top != ' ( ' ) { elementsInside ++ ; top = Stack . Peek ( ) ; Stack . Pop ( ) ; } if ( elementsInside < 1 ) { return true ; } } else { Stack . Push ( ch ) ; } } return false ; } public static void Main ( String [ ] args ) { String str = "" ( ( ( a + ( b ) ) + ( c + d ) ) ) "" ; if ( findDuplicateparenthesis ( str ) ) { Console . WriteLine ( "" Duplicate ▁ Found ▁ "" ) ; } else { Console . WriteLine ( "" No ▁ Duplicates ▁ Found ▁ "" ) ; } } }";"Find if an expression has duplicate parenthesis or not | C # program to find duplicate parenthesis in a balanced expression ; Function to find duplicate parenthesis in a balanced expression ; create a stack of characters ; Iterate through the given expression ; if current character is close parenthesis ' ) ' ; pop character from the stack ; stores the number of characters between a closing and opening parenthesis if this count is less than or equal to 1 then the brackets are redundant else not ; push open parenthesis ' ( ' , operators and operands to stack ; No duplicates found ; Driver code ; input balanced expression"
C#;"using System ; using System . Collections . Generic ; public class GFG { public static void nextGreater ( int [ ] arr , int [ ] next , char order ) { Stack < int > stack = new Stack < int > ( ) ; for ( int i = arr . Length - 1 ; i >= 0 ; i -- ) { while ( stack . Count != 0 && ( ( order == ' G ' ) ? arr [ stack . Peek ( ) ] <= arr [ i ] : arr [ stack . Peek ( ) ] >= arr [ i ] ) ) stack . Pop ( ) ; if ( stack . Count != 0 ) next [ i ] = stack . Peek ( ) ; else next [ i ] = - 1 ; stack . Push ( i ) ; } } public static void nextSmallerOfNextGreater ( int [ ] arr ) { int [ ] NG = new int [ arr . Length ] ; int [ ] RS = new int [ arr . Length ] ; nextGreater ( arr , NG , ' G ' ) ; nextGreater ( arr , RS , ' S ' ) ; for ( int i = 0 ; i < arr . Length ; i ++ ) { if ( NG [ i ] != - 1 && RS [ NG [ i ] ] != - 1 ) Console . Write ( arr [ RS [ NG [ i ] ] ] + "" ▁ "" ) ; else Console . Write ( "" - 1 ▁ "" ) ; } } public static void Main ( ) { int [ ] arr = { 5 , 1 , 9 , 2 , 5 , 1 , 7 } ; nextSmallerOfNextGreater ( arr ) ; } }";"Find next Smaller of next Greater in an array | C # Program to find Right smaller element of next greater element ; function find Next greater element ; create empty stack ; Traverse all array elements in reverse order order == ' G ' we compute next greater elements of every element order == ' S ' we compute right smaller element of every element ; Keep removing top element from S while the top element is smaller then or equal to arr [ i ] ( if Key is G ) element is greater then or equal to arr [ i ] ( if order is S ) ; store the next greater element of current element ; If all elements in S were smaller than arr [ i ] ; Push this element ; Function to find Right smaller element of next greater element ; stores indexes of next greater elements ; stores indexes of right smaller elements ; Find next greater element Here G indicate next greater element ; Find right smaller element using same function nextGreater ( ) Here S indicate right smaller elements ; If NG [ i ] = = - 1 then there is no smaller element on right side . We can find Right smaller of next greater by arr [ RS [ NG [ i ] ] ] ; Driver code"
C#;"using System ; public class Node { public char data ; public Node left , right ; public Node ( char item ) { data = item ; left = null ; right = null ; } } public class BinaryTree { public virtual Node convertExpression ( char [ ] expression , int i ) { if ( i >= expression . Length ) { return null ; } Node root = new Node ( expression [ i ] ) ; ++ i ; if ( i < expression . Length && expression [ i ] == ' ? ' ) { root . left = convertExpression ( expression , i + 1 ) ; } else if ( i < expression . Length ) { root . right = convertExpression ( expression , i + 1 ) ; } return root ; } public virtual void printTree ( Node root ) { if ( root == null ) { return ; } Console . Write ( root . data + "" ▁ "" ) ; printTree ( root . left ) ; printTree ( root . right ) ; } public static void Main ( string [ ] args ) { string exp = "" a ? b ? c : d : e "" ; BinaryTree tree = new BinaryTree ( ) ; char [ ] expression = exp . ToCharArray ( ) ; Node root = tree . convertExpression ( expression , 0 ) ; tree . printTree ( root ) ; } }";"Convert Ternary Expression to a Binary Tree | C # program to convert a ternary expreesion to a tree . ; Class to represent Tree node ; Class to convert a ternary expression to a Tree ; Function to convert Ternary Expression to a Binary Tree . It return the root of tree ; Base case ; store current character of expression_string [ ' a ' to ' z ' ] ; Move ahead in str ; if current character of ternary expression is ' ? ' then we add next character as a left child of current node ; else we have to add it as a right child of current node expression . at ( 0 ) == ' : ' ; function print tree ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { static int countNumber ( int n ) { int result = 0 ; Stack < int > s = new Stack < int > ( ) ; for ( int i = 1 ; i <= 9 ; i ++ ) { if ( i <= n ) { s . Push ( i ) ; result ++ ; } while ( s . Count != 0 ) { int tp = s . Peek ( ) ; s . Pop ( ) ; for ( int j = tp % 10 ; j <= 9 ; j ++ ) { int x = tp * 10 + j ; if ( x <= n ) { s . Push ( x ) ; result ++ ; } } } } return result ; } public static void Main ( String [ ] args ) { int n = 15 ; Console . WriteLine ( countNumber ( n ) ) ; } }";"Count natural numbers whose all permutation are greater than that number | C # program to count the number less than N , whose all permutation is greater than or equal to the number . ; Return the count of the number having all permutation greater than or equal to the number . ; Pushing 1 to 9 because all number from 1 to 9 have this property . ; take a number from stack and add a digit smaller than last digit of it . ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { public static int removeConsecutiveSame ( List < string > v ) { int n = v . Count ; for ( int i = 0 ; i < n - 1 ; ) { if ( v [ i ] . Equals ( v [ i + 1 ] ) ) { v . RemoveAt ( i ) ; v . RemoveAt ( i ) ; if ( i > 0 ) { i -- ; } n = n - 2 ; } else { i ++ ; } } return v . Count ; } public static void Main ( string [ ] args ) { List < string > v = new List < string > ( ) ; v . Add ( "" tom "" ) ; v . Add ( "" jerry "" ) ; v . Add ( "" jerry "" ) ; v . Add ( "" tom "" ) ; Console . WriteLine ( removeConsecutiveSame ( v ) ) ; } }";"Delete consecutive same words in a sequence | C # program to remove consecutive same words ; Method to find the size of manipulated sequence ; Start traversing the sequence ; Compare the current string with next one Erase both if equal ; Erase function delete the element and also shifts other element that 's why   i is not updated  ; Update i , as to check from previous element again ; Reduce sequence size ; Increment i , if not equal ; Return modified size ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { public static int removeConsecutiveSame ( List < string > v ) { Stack < string > st = new Stack < string > ( ) ; for ( int i = 0 ; i < v . Count ; i ++ ) { if ( st . Count == 0 ) { st . Push ( v [ i ] ) ; } else { string str = st . Peek ( ) ; if ( str . Equals ( v [ i ] ) ) { st . Pop ( ) ; } else { st . Push ( v [ i ] ) ; } } } return st . Count ; } public static void Main ( string [ ] args ) { List < string > v = new List < string > ( ) ; v . Add ( "" ab "" ) ; v . Add ( "" aa "" ) ; v . Add ( "" aa "" ) ; v . Add ( "" bcd "" ) ; v . Add ( "" ab "" ) ; Console . WriteLine ( removeConsecutiveSame ( v ) ) ; } }";"Delete consecutive same words in a sequence | C # implementation of above method ; Method to find the size of manipulated sequence ; Start traversing the sequence ; Push the current string if the stack is empty ; compare the current string with stack top if equal , pop the top ; Otherwise push the current string ; Return stack size ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { public static string decode ( string str ) { Stack < int > integerstack = new Stack < int > ( ) ; Stack < char > stringstack = new Stack < char > ( ) ; string temp = "" "" , result = "" "" ; for ( int i = 0 ; i < str . Length ; i ++ ) { int count = 0 ; if ( char . IsDigit ( str [ i ] ) ) { while ( char . IsDigit ( str [ i ] ) ) { count = count * 10 + str [ i ] - '0' ; i ++ ; } i -- ; integerstack . Push ( count ) ; } else if ( str [ i ] == ' ] ' ) { temp = "" "" ; count = 0 ; if ( integerstack . Count > 0 ) { count = integerstack . Peek ( ) ; integerstack . Pop ( ) ; } while ( stringstack . Count > 0 && stringstack . Peek ( ) != ' [ ' ) { temp = stringstack . Peek ( ) + temp ; stringstack . Pop ( ) ; } if ( stringstack . Count > 0 && stringstack . Peek ( ) == ' [ ' ) { stringstack . Pop ( ) ; } for ( int j = 0 ; j < count ; j ++ ) { result = result + temp ; } for ( int j = 0 ; j < result . Length ; j ++ ) { stringstack . Push ( result [ j ] ) ; } result = "" "" ; } else if ( str [ i ] == ' [ ' ) { if ( char . IsDigit ( str [ i - 1 ] ) ) { stringstack . Push ( str [ i ] ) ; } else { stringstack . Push ( str [ i ] ) ; integerstack . Push ( 1 ) ; } } else { stringstack . Push ( str [ i ] ) ; } } while ( stringstack . Count > 0 ) { result = stringstack . Peek ( ) + result ; stringstack . Pop ( ) ; } return result ; } public static void Main ( string [ ] args ) { string str = ""3 [ b2 [ ca ] ] "" ; Console . WriteLine ( decode ( str ) ) ; } }";"Decode a string recursively encoded as count followed by substring | C # program to decode a string recursively encoded as count followed substring ; Returns decoded string for ' str ' ; Traversing the string ; If number , convert it into number and push it into integerstack . ; If closing bracket ' ] ' , pop elemment until ' [ ' opening bracket is not found in the character stack . ; Repeating the popped string ' temo ' count number of times . ; Push it in the character stack . ; If ' [ ' opening bracket , push it into character stack . ; Pop all the elmenet , make a string and return . ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GfG { public class Node { public int data ; public Node left , right ; } static Node newNode ( int data ) { Node node = new Node ( ) ; node . data = data ; node . left = null ; node . right = null ; return node ; } static void printAncestors ( Node root , int key ) { if ( root == null ) return ; Stack < Node > st = new Stack < Node > ( ) ; while ( 1 == 1 ) { while ( root != null && root . data != key ) { st . Push ( root ) ; root = root . left ; } if ( root != null && root . data == key ) break ; if ( st . Peek ( ) . right == null ) { root = st . Peek ( ) ; st . Pop ( ) ; while ( st . Count != 0 && st . Peek ( ) . right == root ) { root = st . Peek ( ) ; st . Pop ( ) ; } } root = st . Count == 0 ? null : st . Peek ( ) . right ; } while ( st . Count != 0 ) { Console . Write ( st . Peek ( ) . data + "" ▁ "" ) ; st . Pop ( ) ; } } public static void Main ( String [ ] args ) { Node root = newNode ( 1 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 7 ) ; root . left . left = newNode ( 3 ) ; root . left . right = newNode ( 5 ) ; root . right . left = newNode ( 8 ) ; root . right . right = newNode ( 9 ) ; root . left . left . left = newNode ( 4 ) ; root . left . right . right = newNode ( 6 ) ; root . right . right . left = newNode ( 10 ) ; int key = 6 ; printAncestors ( root , key ) ; } }";"Iterative method to find ancestors of a given binary tree | C # program to print all ancestors of a given key ; Structure for a tree node ; A utility function to create a new tree node ; Iterative Function to print all ancestors of a given key ; Create a stack to hold ancestors ; Traverse the complete tree in postorder way till we find the key ; Traverse the left side . While traversing , push the nodes into the stack so that their right subtrees can be traversed later ; push current node ; move to next node ; If the node whose ancestors are to be printed is found , then break the while loop . ; Check if right sub - tree exists for the node at top If not then pop that node because we don 't   need this node any more.  ; If the popped node is right child of top , then remove the top as well . Left child of the top must have processed before . ; if stack is not empty then simply set the root as right child of top and start traversing right sub - tree . ; If stack is not empty , print contents of stack Here assumption is that the key is there in tree ; Driver code ; Let us construct a binary tree"
C#;"using System ; using System . Collections . Generic ; class GfG { public class StackWithMax { static Stack < int > mainStack = new Stack < int > ( ) ; static Stack < int > trackStack = new Stack < int > ( ) ; public void push ( int x ) { mainStack . Push ( x ) ; if ( mainStack . Count == 1 ) { trackStack . Push ( x ) ; return ; } if ( x > trackStack . Peek ( ) ) trackStack . Push ( x ) ; else trackStack . Push ( trackStack . Peek ( ) ) ; } public int getMax ( ) { return trackStack . Peek ( ) ; } public void pop ( ) { mainStack . Pop ( ) ; trackStack . Pop ( ) ; } } ; public static void Main ( ) { StackWithMax s = new StackWithMax ( ) ; s . push ( 20 ) ; Console . WriteLine ( s . getMax ( ) ) ; s . push ( 10 ) ; Console . WriteLine ( s . getMax ( ) ) ; s . push ( 50 ) ; Console . WriteLine ( s . getMax ( ) ) ; } }";"Tracking current Maximum Element in a Stack | C # program to keep track of maximum element in a stack ; main stack ; tack to keep track of max element ; If current element is greater than the top element of track stack , push the current element to track stack otherwise push the element at top of track stack again into it . ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { public static Stack < int > st = new Stack < int > ( ) ; public static void push_digits ( int number ) { while ( number != 0 ) { st . Push ( number % 10 ) ; number = number / 10 ; } } public static int reverse_number ( int number ) { push_digits ( number ) ; int reverse = 0 ; int i = 1 ; while ( st . Count > 0 ) { reverse = reverse + ( st . Peek ( ) * i ) ; st . Pop ( ) ; i = i * 10 ; } return reverse ; } public static void Main ( string [ ] args ) { int number = 39997 ; Console . WriteLine ( reverse_number ( number ) ) ; } }";"Reverse a number using stack | C # program to reverse the number using a stack ; Stack to maintain order of digits ; Function to push digits into stack ; Function to reverse the number ; Function call to push number 's   digits to stack  ; Popping the digits and forming the reversed number ; Return the reversed number formed ; Driver Code ; Function call to reverse number"
C#;"using System ; using System . Collections . Generic ; public class FlipTree { public class Node { public int data ; public Node left , right ; public Node ( int data ) { this . data = data ; } } ; public static Node flipBinaryTree ( Node root ) { if ( root == null ) return root ; if ( root . left == null && root . right == null ) return root ; Node flippedRoot = flipBinaryTree ( root . left ) ; root . left . left = root . right ; root . left . right = root ; root . left = root . right = null ; return flippedRoot ; } public static void printLevelOrder ( Node root ) { if ( root == null ) return ; Queue < Node > q = new Queue < Node > ( ) ; q . Enqueue ( root ) ; while ( true ) { int nodeCount = q . Count ; if ( nodeCount == 0 ) break ; while ( nodeCount > 0 ) { Node node = q . Dequeue ( ) ; Console . Write ( node . data + "" ▁ "" ) ; if ( node . left != null ) q . Enqueue ( node . left ) ; if ( node . right != null ) q . Enqueue ( node . right ) ; nodeCount -- ; } Console . WriteLine ( ) ; } } public static void Main ( String [ ] args ) { Node root = new Node ( 1 ) ; root . left = new Node ( 2 ) ; root . right = new Node ( 1 ) ; root . right . left = new Node ( 4 ) ; root . right . right = new Node ( 5 ) ; Console . WriteLine ( "" Level ▁ order ▁ traversal ▁ of ▁ given ▁ tree "" ) ; printLevelOrder ( root ) ; root = flipBinaryTree ( root ) ; Console . WriteLine ( "" Level ▁ order ▁ traversal ▁ of ▁ flipped ▁ tree "" ) ; printLevelOrder ( root ) ; } }";"Flip Binary Tree | C # program to flip a binary tree ; A binary tree node structure ; method to flip the binary tree ; recursively call the same method ; rearranging main root Node after returning from recursive call ; Iterative method to do level order traversal line by line ; Base Case ; Create an empty queue for level order traversal ; Enqueue Root and initialize height ; nodeCount ( queue size ) indicates number of nodes at current lelvel . ; Dequeue all nodes of current level and Enqueue all nodes of next level ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GfG { static String simplify ( String str ) { int len = str . Length ; char [ ] res = new char [ len ] ; int index = 0 , i = 0 ; Stack < int > s = new Stack < int > ( ) ; s . Push ( 0 ) ; while ( i < len ) { if ( str [ i ] == ' + ' ) { if ( s . Peek ( ) == 1 ) res [ index ++ ] = ' - ' ; if ( s . Peek ( ) == 0 ) res [ index ++ ] = ' + ' ; } else if ( str [ i ] == ' - ' ) { if ( s . Peek ( ) == 1 ) res [ index ++ ] = ' + ' ; else if ( s . Peek ( ) == 0 ) res [ index ++ ] = ' - ' ; } else if ( str [ i ] == ' ( ' && i > 0 ) { if ( str [ i - 1 ] == ' - ' ) { int x = ( s . Peek ( ) == 1 ) ? 0 : 1 ; s . Push ( x ) ; } else if ( str [ i - 1 ] == ' + ' ) s . Push ( s . Peek ( ) ) ; } else if ( str [ i ] == ' ) ' ) s . Pop ( ) ; else res [ index ++ ] = str [ i ] ; i ++ ; } return new String ( res ) ; } public static void Main ( String [ ] args ) { String s1 = "" a - ( b + c ) "" ; String s2 = "" a - ( b - c - ( d + e ) ) - f "" ; Console . WriteLine ( simplify ( s1 ) ) ; Console . WriteLine ( simplify ( s2 ) ) ; } }";"Remove brackets from an algebraic string containing + and | C # program to simplify algebraic string ; Function to simplify the string ; resultant string of max length equal to length of input string ; create empty stack ; If top is 1 , flip the operator ; If top is 0 , append the same operator ; x is opposite to the top of stack ; push value equal to top of the stack ; If closing parentheses pop the stack once ; copy the character to the result ; Driver code"
C#;"using System ; class GFG { static int BOUND = 4 ; static int top = - 1 ; static int length = 0 ; static int [ ] create_new ( int [ ] a ) { int [ ] new_a = new int [ length + BOUND ] ; for ( int i = 0 ; i < length ; i ++ ) new_a [ i ] = a [ i ] ; length += BOUND ; return new_a ; } static int [ ] push ( int [ ] a , int element ) { if ( top == length - 1 ) a = create_new ( a ) ; a [ ++ top ] = element ; return a ; } static void pop ( int [ ] a ) { top -- ; } static void display ( int [ ] a ) { if ( top == - 1 ) Console . WriteLine ( "" Stack ▁ is ▁ Empty "" ) ; else { Console . Write ( "" Stack : ▁ "" ) ; for ( int i = 0 ; i <= top ; i ++ ) Console . Write ( a [ i ] + "" ▁ "" ) ; Console . WriteLine ( ) ; } } public static void Main ( String [ ] args ) { int [ ] a = create_new ( new int [ length + BOUND ] ) ; a = push ( a , 1 ) ; a = push ( a , 2 ) ; a = push ( a , 3 ) ; a = push ( a , 4 ) ; display ( a ) ; a = push ( a , 5 ) ; a = push ( a , 6 ) ; display ( a ) ; a = push ( a , 7 ) ; a = push ( a , 8 ) ; display ( a ) ; a = push ( a , 9 ) ; display ( a ) ; } }";"Growable array based stack | C # Program to implement growable array based stack using tight strategy ; constant amount at which stack is increased ; top of the stack ; length of stack ; function to create new stack ; allocate memory for new stack ; copying the content of old stack ; re - sizing the length ; function to push new element ; if stack is full , create new one ; insert element at top of the stack ; function to pop an element ; function to display ; if top is - 1 , that means stack is empty ; Driver Code ; creating initial stack ; pushing element to top of stack ; pushing more element when stack is full ; pushing more element so that stack can grow"
C#;"using System ; using System . Collections . Generic ; class GFG { static void constructBlanceArray ( int [ ] BOP , int [ ] BCP , String str , int n ) { Stack < int > stk = new Stack < int > ( ) ; ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ( ' ) stk . Push ( i ) ; else { if ( stk . Count != 0 ) { BCP [ i ] = 1 ; BOP [ stk . Peek ( ) ] = 1 ; stk . Pop ( ) ; } else BCP [ i ] = 0 ; } } for ( int i = 1 ; i < n ; i ++ ) { BCP [ i ] += BCP [ i - 1 ] ; BOP [ i ] += BOP [ i - 1 ] ; } } static int query ( int [ ] BOP , int [ ] BCP , int s , int e ) { if ( BOP [ s - 1 ] == BOP [ s ] ) { return ( BCP [ e ] - BOP [ s ] ) * 2 ; } else { return ( BCP [ e ] - BOP [ s ] + 1 ) * 2 ; } } public static void Main ( String [ ] args ) { String str = "" ( ) ) ( ( ) ) ( ( ) ) ( "" ; int n = str . Length ; int [ ] BCP = new int [ n + 1 ] ; int [ ] BOP = new int [ n + 1 ] ; constructBlanceArray ( BOP , BCP , str , n ) ; int startIndex = 5 , endIndex = 11 ; Console . Write ( "" Maximum ▁ Length ▁ Correct ▁ "" + "" Bracket ▁ Subsequence ▁ between ▁ "" + startIndex + "" ▁ and ▁ "" + endIndex + "" ▁ = ▁ "" + query ( BOP , BCP , startIndex , endIndex ) + "" STRNEWLINE "" ) ; startIndex = 4 ; endIndex = 5 ; Console . Write ( "" Maximum ▁ Length ▁ Correct ▁ "" + "" Bracket ▁ Subsequence ▁ between ▁ "" + startIndex + "" ▁ and ▁ "" + endIndex + "" ▁ = ▁ "" + query ( BOP , BCP , startIndex , endIndex ) + "" STRNEWLINE "" ) ; startIndex = 1 ; endIndex = 5 ; Console . Write ( "" Maximum ▁ Length ▁ Correct ▁ "" + "" Bracket ▁ Subsequence ▁ between ▁ "" + startIndex + "" ▁ and ▁ "" + endIndex + "" ▁ = ▁ "" + query ( BOP , BCP , startIndex , endIndex ) + "" STRNEWLINE "" ) ; } }";"Range Queries for Longest Correct Bracket Subsequence Set | 2 | C # code to answer the query in constant time ; Function for precomputation ; Create a stack and push - 1 as initial index to it . ; Traverse all characters of given String ; If opening bracket , push index of it ; If closing bracket , i . e . , str [ i ] = ' ) ' ; If closing bracket , i . e . , str [ i ] = ' ) ' && stack is not empty then mark both "" open ▁ & ▁ close "" bracket indexs as 1 . Pop the previous opening bracket 's index ; If stack is empty . ; Function return output of each query in O ( 1 ) ; Driver code"
C#;"using System ; public class HeapSort { void heapify ( int [ ] arr , int n , int i ) { int largest = i ; int l = 2 * i + 1 ; int r = 2 * i + 2 ; if ( l < n && arr [ l ] > arr [ largest ] ) largest = l ; if ( r < n && arr [ r ] > arr [ largest ] ) largest = r ; if ( largest != i ) { int swap = arr [ i ] ; arr [ i ] = arr [ largest ] ; arr [ largest ] = swap ; heapify ( arr , n , largest ) ; } } public void sort ( int [ ] arr ) { int n = arr . Length ; for ( int i = n / 2 - 1 ; i >= 0 ; i -- ) heapify ( arr , n , i ) ; for ( int i = n - 1 ; i > 0 ; i -- ) { int temp = arr [ 0 ] ; arr [ 0 ] = arr [ i ] ; arr [ i ] = temp ; heapify ( arr , i , 0 ) ; } } static void printArray ( int [ ] arr ) { int n = arr . Length ; for ( int i = 0 ; i < n ; ++ i ) Console . Write ( arr [ i ] + "" ▁ "" ) ; Console . Read ( ) ; } public static void Main ( ) { int [ ] arr = { 12 , 11 , 13 , 5 , 6 , 7 } ; int n = arr . Length ; HeapSort ob = new HeapSort ( ) ; ob . sort ( arr ) ; Console . WriteLine ( "" Sorted ▁ array ▁ is "" ) ; printArray ( arr ) ; } }";"HeapSort | C # program for implementation of Heap Sort ; To heapify a subtree rooted with node i which is an index in arr [ ] . n is size of heap ; Initialize largest as root ; left = 2 * i + 1 ; right = 2 * i + 2 ; If left child is larger than root ; If right child is larger than largest so far ; If largest is not root ; Recursively heapify the affected sub - tree ; The main function to sort an array of given size ; Build heap ( rearrange array ) ; One by one extract an element from heap ; Move current root to end ; call max heapify on the reduced heap ; A utility function to print array of size n ; Driver code"
C#;"using System ; class HeapSort { static void buildMaxHeap ( int [ ] arr , int n ) { for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > arr [ ( i - 1 ) / 2 ] ) { int j = i ; while ( arr [ j ] > arr [ ( j - 1 ) / 2 ] ) { swap ( arr , j , ( j - 1 ) / 2 ) ; j = ( j - 1 ) / 2 ; } } } } static void heapSort ( int [ ] arr , int n ) { buildMaxHeap ( arr , n ) ; for ( int i = n - 1 ; i > 0 ; i -- ) { swap ( arr , 0 , i ) ; int j = 0 , index ; do { index = ( 2 * j + 1 ) ; if ( index < ( i - 1 ) && arr [ index ] < arr [ index + 1 ] ) index ++ ; if ( index < i && arr [ j ] < arr [ index ] ) swap ( arr , j , index ) ; j = index ; } while ( index < i ) ; } } public static void swap ( int [ ] a , int i , int j ) { int temp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = temp ; } static void printArray ( int [ ] arr ) { int n = arr . Length ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( arr [ i ] + "" ▁ "" ) ; Console . WriteLine ( ) ; } public static void Main ( String [ ] args ) { int [ ] arr = { 10 , 20 , 15 , 17 , 9 , 21 } ; int n = arr . Length ; Console . Write ( "" Given ▁ array : ▁ "" ) ; printArray ( arr ) ; heapSort ( arr , n ) ; Console . Write ( "" Sorted ▁ array : ▁ "" ) ; printArray ( arr ) ; } }";"Iterative HeapSort | C # implementation of Iterative Heap Sort ; function build Max Heap where value of each child is always smaller than value of their parent ; if child is bigger than parent ; swap child and parent until parent is smaller ; swap value of first indexed with last indexed ; maintaining heap property after each swapping ; if left child is smaller than right child point index variable to right child ; if parent is smaller than child then swapping parent with child having higher value ; A utility function to print array of size n ; Driver Code"
C#;"using System ; using System . Collections . Generic ; class GFG { public class Node { public int data ; public Node left , right ; } public static Node newNode ( int data ) { Node temp = new Node ( ) ; temp . data = data ; temp . left = temp . right = null ; return temp ; } public static Node flipBinaryTree ( Node root ) { Node curr = root ; Node next = null ; Node temp = null ; Node prev = null ; while ( curr != null ) { next = curr . left ; curr . left = temp ; temp = curr . right ; curr . right = prev ; prev = curr ; curr = next ; } return prev ; } public static void printLevelOrder ( Node root ) { if ( root == null ) { return ; } LinkedList < Node > q = new LinkedList < Node > ( ) ; q . AddLast ( root ) ; while ( true ) { int nodeCount = q . Count ; if ( nodeCount == 0 ) { break ; } while ( nodeCount > 0 ) { Node node = q . First . Value ; Console . Write ( node . data + "" ▁ "" ) ; q . RemoveFirst ( ) ; if ( node . left != null ) { q . AddLast ( node . left ) ; } if ( node . right != null ) { q . AddLast ( node . right ) ; } nodeCount -- ; } Console . WriteLine ( ) ; } } public static void Main ( string [ ] args ) { Node root = newNode ( 1 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 3 ) ; root . right . left = newNode ( 4 ) ; root . right . right = newNode ( 5 ) ; Console . Write ( "" Level ▁ order ▁ traversal ▁ "" + "" of ▁ given ▁ tree STRNEWLINE "" ) ; printLevelOrder ( root ) ; root = flipBinaryTree ( root ) ; Console . Write ( "" STRNEWLINE Level ▁ order ▁ traversal ▁ "" + "" of ▁ the ▁ flipped ▁ tree STRNEWLINE "" ) ; printLevelOrder ( root ) ; } }";"Flip Binary Tree | C # program to flip a binary tree ; A binary tree node ; Utility function to create a new Binary Tree Node ; method to flip the binary tree ; Initialization of pointers ; Iterate through all left nodes ; Swapping nodes now , need temp to keep the previous right child Making prev ' s ▁ right ▁ ▁ as ▁ curr ' s left child ; Storing curr 's right child ; Making prev as curr 's  right child ; Iterative method to do level order traversal line by line ; Base Case ; Create an empty queue for level order traversal ; Enqueue Root and initialize height ; nodeCount ( queue size ) indicates number of nodes at current lelvel . ; Dequeue all nodes of current level and Enqueue all nodes of next level ; Driver code"
C#;"using System ; public class Node { public int data ; public Node left , right ; public Node ( int item ) { data = item ; left = right = null ; } } public class BinaryTree { Node root ; bool IsFoldable ( Node node ) { if ( node == null ) return true ; return IsFoldableUtil ( node . left , node . right ) ; } bool IsFoldableUtil ( Node n1 , Node n2 ) { if ( n1 == null && n2 == null ) return true ; if ( n1 == null n2 == null ) return false ; return IsFoldableUtil ( n1 . left , n2 . right ) && IsFoldableUtil ( n1 . right , n2 . left ) ; } public static void Main ( String [ ] args ) { BinaryTree tree = new BinaryTree ( ) ; tree . root = new Node ( 1 ) ; tree . root . left = new Node ( 2 ) ; tree . root . right = new Node ( 3 ) ; tree . root . right . left = new Node ( 4 ) ; tree . root . left . right = new Node ( 5 ) ; if ( tree . IsFoldable ( tree . root ) ) Console . WriteLine ( "" tree ▁ is ▁ foldable "" ) ; else Console . WriteLine ( "" Tree ▁ is ▁ not ▁ foldable "" ) ; } }";"Foldable Binary Trees | C # program to check foldable binary tree ; A binary tree node has data , pointer to left child and a pointer to right child ; Returns true if the given tree can be folded ; A utility function that checks if trees with roots as n1 and n2 are mirror of each other ; If both left and right subtrees are NULL , then return true ; If one of the trees is NULL and other is not , then return false ; Otherwise check if left and right subtrees are mirrors of their counterparts ; Driver code ; The constructed binary tree is 1 / \ 2 3 \ / 4 5"
C#;"using System ; public class Node { public int data ; public Node left , right ; public Node ( int d ) { data = d ; left = right = null ; } } class GFG { public Node root ; public virtual int isSumProperty ( Node node ) { int left_data = 0 , right_data = 0 ; if ( node == null || ( node . left == null && node . right == null ) ) { return 1 ; } else { if ( node . left != null ) { left_data = node . left . data ; } if ( node . right != null ) { right_data = node . right . data ; } if ( ( node . data == left_data + right_data ) && ( isSumProperty ( node . left ) != 0 ) && isSumProperty ( node . right ) != 0 ) { return 1 ; } else { return 0 ; } } } public static void Main ( string [ ] args ) { GFG tree = new GFG ( ) ; tree . root = new Node ( 10 ) ; tree . root . left = new Node ( 8 ) ; tree . root . right = new Node ( 2 ) ; tree . root . left . left = new Node ( 3 ) ; tree . root . left . right = new Node ( 5 ) ; tree . root . right . right = new Node ( 2 ) ; if ( tree . isSumProperty ( tree . root ) != 0 ) { Console . WriteLine ( "" The ▁ given ▁ tree ▁ satisfies "" + "" ▁ children ▁ sum ▁ property "" ) ; } else { Console . WriteLine ( "" The ▁ given ▁ tree ▁ does ▁ not "" + "" ▁ satisfy ▁ children ▁ sum ▁ property "" ) ; } } }";"Check for Children Sum Property in a Binary Tree | C # program to check children sum property ; A binary tree node has data , pointer to left child and a pointer to right child ; returns 1 if children sum property holds for the given node and both of its children ; left_data is left child data and right_data is for right child data ; If node is NULL or it 's a leaf   node then return true  ; If left child is not present then 0 is used as data of left child ; If right child is not present then 0 is used as data of right child ; if the node and both of its children satisfy the property return 1 else 0 ; Driver Code"
C#;"using System ; class GFG { static bool isHeap ( int [ ] arr , int i , int n ) { if ( i >= ( n - 2 ) / 2 ) { return true ; } if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && isHeap ( arr , 2 * i + 1 , n ) && isHeap ( arr , 2 * i + 2 , n ) ) { return true ; } return false ; } public static void Main ( String [ ] args ) { int [ ] arr = { 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 } ; int n = arr . Length - 1 ; if ( isHeap ( arr , 0 , n ) ) { Console . Write ( "" Yes "" ) ; } else { Console . Write ( "" No "" ) ; } } }";"How to check if a given array represents a Binary Heap ? | C # program to check whether a given array represents a max - heap or not ; Returns true if arr [ i . . n - 1 ] represents a max - heap ; If a leaf node ; If an internal node and is greater than its children , and same is recursively true for the children ; Driver Code"
C#;"using System ; class GFG { static bool isHeap ( int [ ] arr , int n ) { for ( int i = 0 ; i <= ( n - 2 ) / 2 ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) { return false ; } if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) { return false ; } } return true ; } public static void Main ( ) { int [ ] arr = { 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 } ; int n = arr . Length ; if ( isHeap ( arr , n ) ) { Console . Write ( "" Yes "" ) ; } else { Console . Write ( "" No "" ) ; } } }";"How to check if a given array represents a Binary Heap ? | C # program to check whether a given array represents a max - heap or not ; Returns true if arr [ i . . n - 1 ] represents a max - heap ; Start from root and go till the last internal node ; If left child is greater , return false ; If right child is greater , return false ; Driver Code"
C#;"using System ; class MinHeap { int [ ] harr ; int heap_size ; int capacity ; public MinHeap ( int [ ] a , int size ) { heap_size = size ; capacity = size ; harr = a ; int i = ( heap_size - 1 ) / 2 ; while ( i >= 0 ) { MinHeapify ( i ) ; i -- ; } } void MinHeapify ( int i ) { int l = left ( i ) ; int r = right ( i ) ; int smallest = i ; if ( l < heap_size && harr [ l ] < harr [ i ] ) smallest = l ; if ( r < heap_size && harr [ r ] < harr [ smallest ] ) smallest = r ; if ( smallest != i ) { swap ( i , smallest ) ; MinHeapify ( smallest ) ; } } int parent ( int i ) { return ( i - 1 ) / 2 ; } int left ( int i ) { return ( 2 * i + 1 ) ; } int right ( int i ) { return ( 2 * i + 2 ) ; } int extractMin ( ) { if ( heap_size <= 0 ) return int . MaxValue ; if ( heap_size == 1 ) { heap_size -- ; return harr [ 0 ] ; } int root = harr [ 0 ] ; harr [ 0 ] = harr [ heap_size - 1 ] ; heap_size -- ; MinHeapify ( 0 ) ; return root ; } void insertKey ( int k ) { if ( heap_size == capacity ) { Console . WriteLine ( "" Overflow : ▁ Could ▁ not ▁ insertKey "" ) ; return ; } heap_size ++ ; int i = heap_size - 1 ; harr [ i ] = k ; while ( i != 0 && harr [ parent ( i ) ] > harr [ i ] ) { swap ( i , parent ( i ) ) ; i = parent ( i ) ; } } Boolean isSizeOne ( ) { return ( heap_size == 1 ) ; } void swap ( int x , int y ) { int temp = harr [ x ] ; harr [ x ] = harr [ y ] ; harr [ y ] = temp ; } static int minCost ( int [ ] len , int n ) { int cost = 0 ; MinHeap minHeap = new MinHeap ( len , n ) ; while ( ! minHeap . isSizeOne ( ) ) { int min = minHeap . extractMin ( ) ; int sec_min = minHeap . extractMin ( ) ; cost += ( min + sec_min ) ; minHeap . insertKey ( min + sec_min ) ; } return cost ; } public static void Main ( String [ ] args ) { int [ ] len = { 4 , 3 , 2 , 6 } ; int size = len . Length ; Console . WriteLine ( "" Total ▁ cost ▁ for ▁ connecting ▁ ropes ▁ is ▁ "" + minCost ( len , size ) ) ; } } ;";"Connect n ropes with minimum cost | C # program to connect n ropes with minimum cost ; A class for Min Heap ; Array of elements in heap ; Current number of elements in min heap ; maximum possible size of min heap ; Constructor : Builds a heap from a given array a [ ] of given size ; A recursive method to heapify a subtree with the root at given index This method assumes that the subtrees are already heapified ; to get index of left child of node at index i ; to get index of right child of node at index i ; Method to remove minimum element ( or root ) from min heap ; Store the minimum value , and remove it from heap ; Inserts a new key ' k ' ; First insert the new key at the end ; Fix the min heap property if it is violated ; A utility function to check if size of heap is 1 or not ; A utility function to swap two elements ; The main function that returns the minimum cost to connect n ropes of lengths stored in len [ 0. . n - 1 ] ; Initialize result ; Create a min heap of capacity equal to n and put all ropes in it ; Iterate while size of heap doesn 't become 1 ; Extract two minimum length ropes from min heap ; Update total cost ; Insert a new rope in min heap with length equal to sum of two extracted minimum lengths ; Finally return total minimum cost for connecting all ropes ; Driver code"
C#;"using System ; using System . Collections . Generic ; public class ConnectRopes { static int minCost ( int [ ] arr , int n ) { List < int > pq = new List < int > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { pq . Add ( arr [ i ] ) ; } int res = 0 ; while ( pq . Count > 1 ) { pq . Sort ( ) ; int first = pq [ 0 ] ; int second = pq [ 1 ] ; pq . RemoveRange ( 0 , 2 ) ; res += first + second ; pq . Add ( first + second ) ; } return res ; } public static void Main ( String [ ] args ) { int [ ] len = { 4 , 3 , 2 , 6 } ; int size = len . Length ; Console . WriteLine ( "" Total ▁ cost ▁ for ▁ connecting "" + "" ▁ ropes ▁ is ▁ "" + minCost ( len , size ) ) ; } }";"Connect n ropes with minimum cost | C # program to connect n ropes with minimum cost ; Create a priority queue ; Initialize result ; While size of priority queue is more than 1 ; Extract shortest two ropes from pq ; Connect the ropes : update result and insert the new rope to pq ; Driver program to test above function"
C#;"using System ; public class GFG { public static void mergeKArrays ( int [ , ] arr , int a , int [ ] output ) { int c = 0 ; for ( int i = 0 ; i < a ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) output [ c ++ ] = arr [ i , j ] ; } Array . Sort ( output ) ; } public static void printArray ( int [ ] arr , int size ) { for ( int i = 0 ; i < size ; i ++ ) Console . Write ( arr [ i ] + "" ▁ "" ) ; } public static void Main ( String [ ] args ) { int [ , ] arr = { { 2 , 6 , 12 , 34 } , { 1 , 9 , 20 , 1000 } , { 23 , 34 , 90 , 2000 } } ; int k = 4 ; int n = 3 ; int [ ] output = new int [ n * k ] ; mergeKArrays ( arr , n , output ) ; Console . WriteLine ( "" Merged ▁ array ▁ is ▁ "" ) ; printArray ( output , n * k ) ; } }";"Merge k sorted arrays | Set 1 | C # program to merge k sorted arrays of size n each . ; This function takes an array of arrays as an argument and All arrays are assumed to be sorted . It merges them together and prints the readonly sorted output . ; traverse the matrix ; sort the array ; A utility function to print array elements ; Driver program to test above functions"
C#;"using System ; using System . Collections . Generic ; class GFG { static void generate_derangement ( int N ) { int [ ] S = new int [ N + 1 ] ; List < int > PQ = new List < int > ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { S [ i ] = i ; PQ . Add ( S [ i ] ) ; } int [ ] D = new int [ N + 1 ] ; PQ . Sort ( ) ; for ( int i = 1 ; i <= N ; i ++ ) { PQ . Sort ( ) ; int d = PQ [ 0 ] ; PQ . RemoveAt ( 0 ) ; if ( d != S [ i ] i == N ) { D [ i ] = d ; } else { PQ . Sort ( ) ; D [ i ] = PQ [ 0 ] ; PQ . RemoveAt ( 0 ) ; PQ . Add ( d ) ; } } if ( D [ N ] == S [ N ] ) { int t = D [ N - 1 ] ; D [ N - 1 ] = D [ N ] ; D [ N ] = t ; } for ( int i = 1 ; i <= N ; i ++ ) Console . Write ( D [ i ] + "" ▁ "" ) ; Console . Write ( "" STRNEWLINE "" ) ; } public static void Main ( String [ ] args ) { generate_derangement ( 10 ) ; } }";"Smallest Derangement of Sequence | C # program to generate smallest derangement using priority queue . ; Generate Sequence and insert into a priority queue . ; Generate Least Derangement ; Print Derangement ; Driver code"
C#;"using System ; class GFG { static void generate_derangement ( int N ) { int [ ] S = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) S [ i ] = i ; int [ ] D = new int [ N + 1 ] ; for ( int i = 1 ; i <= N ; i += 2 ) { if ( i == N ) { D [ N ] = S [ N - 1 ] ; D [ N - 1 ] = S [ N ] ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } } for ( int i = 1 ; i <= N ; i ++ ) Console . Write ( D [ i ] + "" ▁ "" ) ; Console . WriteLine ( ) ; } public static void Main ( ) { generate_derangement ( 10 ) ; } }";"Smallest Derangement of Sequence | Efficient C # program to find smallest derangement . ; Generate Sequence S ; Generate Derangement ; Only if i is odd Swap S [ N - 1 ] and S [ N ] ; Print Derangement ; Driver Program"
C#;"using System ; using System . Collections . Generic ; class GFG { static void printLargest ( int [ ] seq , int N ) { int [ ] res = new int [ N ] ; List < int > pq = new List < int > ( ) ; for ( int i = 0 ; i < N ; i ++ ) pq . Add ( seq [ i ] ) ; for ( int i = 0 ; i < N ; i ++ ) { pq . Sort ( ) ; pq . Reverse ( ) ; int d = pq [ 0 ] ; pq . RemoveAt ( 0 ) ; if ( d != seq [ i ] i == N - 1 ) { res [ i ] = d ; } else { res [ i ] = pq [ 0 ] ; pq . RemoveAt ( 0 ) ; pq . Add ( d ) ; } } if ( res [ N - 1 ] == seq [ N - 1 ] ) { res [ N - 1 ] = res [ N - 2 ] ; res [ N - 2 ] = seq [ N - 1 ] ; } Console . WriteLine ( "" Largest ▁ Derangement "" ) ; for ( int i = 0 ; i < N ; i ++ ) Console . Write ( res [ i ] + "" ▁ "" ) ; } static void Main ( ) { int [ ] seq = { 92 , 3 , 52 , 13 , 2 , 31 , 1 } ; int n = seq . Length ; printLargest ( seq , n ) ; } }";"Largest Derangement of a Sequence | C # program to find the largest derangement ; Stores result ; Insert all elements into a priority queue ; Fill Up res [ ] from left to right ; New Element poped equals the element in original sequence . Get the next largest element ; If given sequence is in descending order then we need to swap last two elements again ; Driver code"
C#;"using System ; class GFG { static int Profit ( int costPrice , int sellingPrice ) { int profit = ( sellingPrice - costPrice ) ; return profit ; } static int Loss ( int costPrice , int sellingPrice ) { int Loss = ( costPrice - sellingPrice ) ; return Loss ; } public static void Main ( ) { int costPrice = 1500 , sellingPrice = 2000 ; if ( sellingPrice == costPrice ) Console . Write ( "" No ▁ profit ▁ nor ▁ Loss "" ) ; else if ( sellingPrice > costPrice ) Console . Write ( Profit ( costPrice , sellingPrice ) + "" ▁ Profit ▁ "" ) ; else Console . Write ( Loss ( costPrice , sellingPrice ) + "" ▁ Loss ▁ "" ) ; } }";"Program to calculate Profit Or Loss | C # code to demonstrate Profit and Loss ; Function to calculate Profit ; Function to calculate Loss ; Driver Code"
C#;"using System ; class GFG { static int nextPerfectSquare ( int N ) { int nextN = ( int ) Math . Floor ( Math . Sqrt ( N ) ) + 1 ; return nextN * nextN ; } public static void Main ( ) { int n = 35 ; Console . WriteLine ( nextPerfectSquare ( n ) ) ; } }";"Find the Next perfect square greater than a given number | C # implementation of above approach ; Function to find the next perfect square ; Driver Code"
C#;"using System ; class GFG { static void printSubstrings ( int n ) { int s = ( int ) Math . Log10 ( n ) ; int d = ( int ) ( Math . Pow ( 10 , s ) + 0.5 ) ; int k = d ; while ( n > 0 ) { while ( d > 0 ) { Console . WriteLine ( n / d ) ; d = d / 10 ; } n = n % k ; k = k / 10 ; d = k ; } } public static void Main ( ) { int n = 123 ; printSubstrings ( n ) ; } }";"Print all substring of a number without any conversion | C # implementation of above approach ; Function to print the substrings of a number ; Calculate the total number of digits ; 0.5 has been added because of it will return double value like 99.556 ; Print all the numbers from starting position ; Update the no . ; Update the no . of digits ; Driver code"
C#;"using System ; class GFG { static long MOD = ( long ) ( 1e9 + 7 ) ; static long powerLL ( long x , long n ) { long result = 1 ; while ( n > 0 ) { if ( n % 2 == 1 ) { result = result * x % MOD ; } n = n / 2 ; x = x * x % MOD ; } return result ; } static long powerStrings ( String sa , String sb ) { long a = 0 , b = 0 ; for ( int i = 0 ; i < sa . Length ; i ++ ) { a = ( a * 10 + ( sa [ i ] - '0' ) ) % MOD ; } for ( int i = 0 ; i < sb . Length ; i ++ ) { b = ( b * 10 + ( sb [ i ] - '0' ) ) % ( MOD - 1 ) ; } return powerLL ( a , b ) ; } public static void Main ( String [ ] args ) { String sa = ""2"" , sb = ""3"" ; Console . WriteLine ( powerStrings ( sa , sb ) ) ; } }";"Modulo power for large numbers represented as strings | C # program to find ( a ^ b ) % MOD where a and b may be very large and represented as strings . ; Returns modulo exponentiation for two numbers represented as long long int . It is used by powerStrings ( ) . Its complexity is log ( n ) ; Returns modulo exponentiation for two numbers represented as strings . It is used by powerStrings ( ) ; We convert strings to number ; calculating a % MOD ; calculating b % ( MOD - 1 ) ; Now a and b are long long int . We calculate a ^ b using modulo exponentiation ; Driver code ; As numbers are very large that is it may contains upto 10 ^ 6 digits . So , we use string ."
C#;"using System ; class GFG { static bool isPowerOfTwo ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ; } static int previousPowerOfTwo ( int n ) { while ( ( n & n - 1 ) > 1 ) { n = n & n - 1 ; } return n ; } static bool checkSum ( int n ) { if ( n == 0 n == 1 ) { Console . WriteLine ( "" No "" ) ; return false ; } else if ( isPowerOfTwo ( n ) ) { Console . WriteLine ( n / 2 + "" ▁ "" + n / 2 ) ; return true ; } else { int x = previousPowerOfTwo ( n ) ; int y = n - x ; if ( isPowerOfTwo ( y ) ) { Console . WriteLine ( x + "" ▁ "" + y ) ; return true ; } else { return false ; } } } public static void Main ( ) { int n1 = 20 ; if ( checkSum ( n1 ) == false ) Console . WriteLine ( "" No "" ) ; Console . WriteLine ( ) ; int n2 = 11 ; if ( checkSum ( n2 ) == false ) Console . WriteLine ( "" No "" ) ; } }";"Check if a number can be expressed as 2 ^ x + 2 ^ y | C # code to check if a number can be expressed as 2 ^ x + 2 ^ y ; Utility function to check if a number is power of 2 or not ; Utility function to determine the value of previous power of 2 ; function to check if n can be expressed as 2 ^ x + 2 ^ y or not ; if value of n is 0 or 1 it can not be expressed as 2 ^ x + 2 ^ y ; if a number is power of it can be expressed as 2 ^ x + 2 ^ y ; if the remainder after subtracting previous power of 2 is also a power of 2 then it can be expressed as 2 ^ x + 2 ^ y ; driver code"
C#;"using System ; class GFG { static int complement ( int num ) { int len = 0 , temp , comp ; temp = num ; while ( true ) { len ++ ; num = num / 10 ; if ( Math . Abs ( num ) == 0 ) break ; } num = temp ; comp = ( int ) Math . Pow ( 10 , len ) - num ; return comp ; } public static void Main ( ) { Console . WriteLine ( complement ( 25 ) ) ; Console . WriteLine ( complement ( 456 ) ) ; } }";"10 's Complement of a decimal number | C # program to find 10 's complement ; Function to find 10 's complement ; Calculating total digits in num ; restore num ; calculate 10 's complement ; Driver code"
C#;"using System ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 && b == 0 ) return 0 ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } public static void Main ( ) { int a = 98 , b = 56 ; Console . WriteLine ( "" GCD ▁ of ▁ "" + a + "" ▁ and ▁ "" + b + "" ▁ is ▁ "" + gcd ( a , b ) ) ; } }";"Program to find HCF ( Highest Common Factor ) of 2 Numbers | C # program to find GCD of two numbers ; Recursive function to return gcd of a and b ; Everything divides 0 ; base case ; a is greater ; Driver method"
C#;"using System ; public class GFG { static int countOddSum ( int [ ] a , int n ) { int c_odd = 0 , result = 0 ; bool odd = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) { odd = ! odd ; } if ( odd ) { c_odd ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { result += c_odd ; if ( a [ i ] % 2 == 1 ) { c_odd = ( n - i - c_odd ) ; } } return result ; } public static void Main ( String [ ] args ) { int [ ] ar = { 5 , 4 , 4 , 5 , 1 , 3 } ; int n = ar . Length ; Console . Write ( "" The ▁ Number ▁ of ▁ Subarrays ▁ "" + "" with ▁ odd ▁ sum ▁ is ▁ "" + countOddSum ( ar , n ) ) ; } }";"Number of sub arrays with odd sum | C # program to find number of subarrays with odd sum ; Function to find number of subarrays with odd sum ; ' odd ' stores number of odd numbers upto ith index ' c _ odd ' stores number of odd sum subarrays starting at ith index ' Result ' stores the number of odd sum subarrays ; First find number of odd sum subarrays starting at 0 th index ; Find number of odd sum subarrays starting at ith index add to result ; Driver code"
C#;"using System ; public class GFG { static void findNthRoot ( double x , int n ) { double low , high ; if ( x >= 0 && x <= 1 ) { low = x ; high = 1 ; } else { low = 1 ; high = x ; } double epsilon = 0.00000001 ; double guess = ( low + high ) / 2 ; while ( Math . Abs ( ( Math . Pow ( guess , n ) ) - x ) >= epsilon ) { if ( Math . Pow ( guess , n ) > x ) { high = guess ; } else { low = guess ; } guess = ( low + high ) / 2 ; } Console . WriteLine ( guess ) ; } static public void Main ( ) { double x = 5 ; int n = 2 ; findNthRoot ( x , n ) ; } }";"Calculating n | C # Program to find n - th real root of x ; Initialize boundary values ; used for taking approximations of the answer ; Do binary search ; Driver code"
C#;"using System ; public class GFG { static long calculateSum ( int n ) { long sum = 0 ; for ( int row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; } static public void Main ( ) { int n = 10 ; Console . WriteLine ( "" Sum ▁ of ▁ all ▁ elements : "" + calculateSum ( n ) ) ; } }";"Sum of all elements up to Nth row in a Pascal triangle | C # program to find sum of all elements upto nth row in Pascal triangle . ; Function to find sum of all elements upto nth row . ; Initialize sum with 0 ; Loop to calculate power of 2 upto n and add them ; Driver Code"
C#;"using System ; public class GFG { static int findAllSequence ( int N ) { if ( N % 2 == 0 ) { return ( int ) ( Math . Pow ( 2 , N / 2 + 1 ) + Math . Pow ( 2 , N / 2 ) - 2 ) ; } else { return ( int ) ( Math . Pow ( 2 , ( N + 1 ) / 2 ) + Math . Pow ( 2 , ( N + 1 ) / 2 ) - 2 ) ; } } public static void Main ( ) { int N = 2 ; Console . WriteLine ( findAllSequence ( N ) ) ; } }";"Number of sequences which has HEAD at alternate positions to the right of the first HEAD | C # program to find number of sequences ; function to calculate total sequences possible ; Value of N is even ; Value of N is odd ; Driver code"
C#;"using System ; class GFG { static int N = 1000000 ; static long [ ] phi = new long [ N + 5 ] ; static void computeTotient ( ) { for ( int i = 1 ; i <= N ; i ++ ) phi [ i ] = i ; for ( int p = 2 ; p <= N ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( int i = 2 * p ; i <= N ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } } static long power ( long x , long y , long p ) { while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static long calculate ( long x , long k , long mod ) { long [ ] arr = new long [ N ] ; long count = 0 ; while ( mod > 1 ) { arr [ ( int ) count ++ ] = mod ; mod = phi [ ( int ) mod ] ; } long result = 1 ; long loop = count + 1 ; arr [ ( int ) count ] = 1 ; for ( int i = ( int ) Math . Min ( k , loop ) - 1 ; i >= 0 ; i -- ) result = power ( x , result , arr [ i ] ) ; return result ; } static public void Main ( ) { computeTotient ( ) ; long x = 3 , k = 2 , m = 3 ; Console . WriteLine ( calculate ( x , k , m ) ) ; } }";"Compute power of power k times % m | C # program for computing x ^ x ^ x ^ x . . % m ; Create an array to store phi or totient values ; Function to calculate Euler Totient values ; indicates not evaluated yet and initializes for product formula . ; Compute other Phi values ; If phi [ p ] is not computed already , then number p is prime ; Phi of a prime number p is always equal to p - 1. ; Update phi values of all multiples of p ; Add contribution of p to its multiple i by multiplying with ( 1 - 1 / p ) ; Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; x = x % p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 ; y = y / 2 ; Function to calculate ( x ^ x ^ x ^ x ... k times ) % m ; to store different mod values ; run loop in reverse to calculate result ; Driver Code ; compute euler totient function values ; Calling function to compute answer"
C#;"using System ; class GFG { static int countOnes ( int n ) { int count = 1 ; int rem = 1 ; while ( rem != 0 ) { rem = ( rem * 10 + 1 ) % n ; count ++ ; } return count ; } static public void Main ( ) { int n = 13 ; Console . WriteLine ( countOnes ( n ) ) ; } }";"Number of ones in the smallest repunit | C # program to print the number of 1 s in smallest repunit multiple of the number . ; Function to find number of 1 s in smallest repunit multiple of the number ; to store number of 1 s in smallest repunit multiple of the number . ; initialize rem with 1 ; run loop until rem becomes zero ; rem * 10 + 1 here represents the repunit modulo n ; when remainder becomes 0 return count ; Driver Code ; Calling function"
C#;"using System ; class GFG { static int largestNum ( int a , int b ) { return a * ( ( a / b ) > 0 ? 1 : 0 ) + b * ( ( b / a ) > 0 ? 1 : 0 ) ; } public static void Main ( String [ ] args ) { int a = 22 , b = 1231 ; Console . Write ( largestNum ( a , b ) ) ; } }";"Largest of two distinct numbers without using any conditional statements or operators | C # program for above implementation ; Function to find the largest number ; Driver code"
C#;"using System ; class GFG { static int gcd ( int a , int b ) { int c = a % b ; while ( c != 0 ) { a = b ; b = c ; c = a % b ; } return b ; } static int numberOfmeet ( int a , int b ) { int ans ; if ( a > b ) ans = a - b ; else ans = b - a ; if ( a < 0 ) a = a * ( - 1 ) ; if ( b < 0 ) b = b * ( - 1 ) ; return ans / gcd ( a , b ) ; } static public void Main ( ) { int a = 1 , b = - 1 ; Console . WriteLine ( numberOfmeet ( a , b ) ) ; } }";"Number of Distinct Meeting Points on a Circular Road | C # Program to find number of distinct point of meet on a circular road ; Returns the GCD of two number . ; Returns the number of distinct meeting points . ; Find the relative speed . ; convert the negative value to positive . ; Driver Code"
C#;"using System ; using System . Collections . Generic ; public class GFG { static int MAX = 1005 ; static void SieveOfEratosthenes ( List < int > primes ) { bool [ ] prime = new bool [ MAX ] ; for ( int i = 0 ; i < prime . Length ; i ++ ) { prime [ i ] = true ; } for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i < MAX ; i += p ) { prime [ i ] = false ; } } } for ( int p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) { primes . Add ( p ) ; } } } static int minimumSquareFreeDivisors ( int N ) { List < int > primes = new List < int > ( ) ; SieveOfEratosthenes ( primes ) ; int max_count = 0 ; for ( int i = 0 ; i < primes . Count && primes [ i ] * primes [ i ] <= N ; i ++ ) { if ( N % primes [ i ] == 0 ) { int tmp = 0 ; while ( N % primes [ i ] == 0 ) { tmp ++ ; N /= primes [ i ] ; } max_count = Math . Max ( max_count , tmp ) ; } } if ( max_count == 0 ) { max_count = 1 ; } return max_count ; } public static void Main ( ) { int N = 24 ; Console . WriteLine ( "" Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is ▁ "" + minimumSquareFreeDivisors ( N ) ) ; N = 6 ; Console . WriteLine ( "" Minimum ▁ Number ▁ of ▁ Square ▁ Free ▁ Divisors ▁ is ▁ "" + minimumSquareFreeDivisors ( N ) ) ; } }";"Minimum number of Square Free Divisors | C # Program to find the minimum number of square free divisors ; Initializing MAX with SQRT ( 10 ^ 6 ) ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Print all prime numbers ; This function returns the minimum number of Square Free divisors ; Precomputing Prime Factors ; holds max of max power of all prime factors ; holds the max power of current prime factor ; If number itself is prime , it will be included as answer and thus minimum required answer is 1 ; Driver Code to test above functions"
C#;"using System ; using System . Linq ; public class GFG { static int findMaxGCD ( int [ ] arr , int n , int k ) { int high = arr . Max ( ) ; int [ ] divisors = new int [ high + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j <= Math . Sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % j == 0 ) { divisors [ j ] ++ ; if ( j != arr [ i ] / j ) divisors [ arr [ i ] / j ] ++ ; } } } for ( int i = high ; i >= 1 ; i -- ) if ( divisors [ i ] >= k ) return i ; return 0 ; } static public void Main ( ) { int [ ] arr = { 1 , 2 , 4 , 8 , 8 , 12 } ; int k = 3 ; int n = arr . Length ; Console . WriteLine ( findMaxGCD ( arr , n , k ) ) ; } }";"Subsequence of size k with maximum possible GCD | C # program to find subsequence of size k with maximum possible GCD ; function to find GCD of sub sequence of size k with max GCD in the array ; Computing highest element ; Array to store the count of divisors i . e . Potential GCDs ; Iterating over every element ; Calculating all the divisors ; Divisor found ; Incrementing count for divisor ; Element / divisor is also a divisor Checking if both divisors are not same ; Checking the highest potential GCD ; If this divisor can divide at least k numbers , it is a GCD of at least one sub sequence of size k ; Driver code ; Array in which sub sequence with size k with max GCD is to be found"
C#;"using System ; class GFG { static double determinantOfMatrix ( double [ , ] mat ) { double ans ; ans = mat [ 0 , 0 ] * ( mat [ 1 , 1 ] * mat [ 2 , 2 ] - mat [ 2 , 1 ] * mat [ 1 , 2 ] ) - mat [ 0 , 1 ] * ( mat [ 1 , 0 ] * mat [ 2 , 2 ] - mat [ 1 , 2 ] * mat [ 2 , 0 ] ) + mat [ 0 , 2 ] * ( mat [ 1 , 0 ] * mat [ 2 , 1 ] - mat [ 1 , 1 ] * mat [ 2 , 0 ] ) ; return ans ; } static void findSolution ( double [ , ] coeff ) { double [ , ] d = { { coeff [ 0 , 0 ] , coeff [ 0 , 1 ] , coeff [ 0 , 2 ] } , { coeff [ 1 , 0 ] , coeff [ 1 , 1 ] , coeff [ 1 , 2 ] } , { coeff [ 2 , 0 ] , coeff [ 2 , 1 ] , coeff [ 2 , 2 ] } , } ; double [ , ] d1 = { { coeff [ 0 , 3 ] , coeff [ 0 , 1 ] , coeff [ 0 , 2 ] } , { coeff [ 1 , 3 ] , coeff [ 1 , 1 ] , coeff [ 1 , 2 ] } , { coeff [ 2 , 3 ] , coeff [ 2 , 1 ] , coeff [ 2 , 2 ] } , } ; double [ , ] d2 = { { coeff [ 0 , 0 ] , coeff [ 0 , 3 ] , coeff [ 0 , 2 ] } , { coeff [ 1 , 0 ] , coeff [ 1 , 3 ] , coeff [ 1 , 2 ] } , { coeff [ 2 , 0 ] , coeff [ 2 , 3 ] , coeff [ 2 , 2 ] } , } ; double [ , ] d3 = { { coeff [ 0 , 0 ] , coeff [ 0 , 1 ] , coeff [ 0 , 3 ] } , { coeff [ 1 , 0 ] , coeff [ 1 , 1 ] , coeff [ 1 , 3 ] } , { coeff [ 2 , 0 ] , coeff [ 2 , 1 ] , coeff [ 2 , 3 ] } , } ; double D = determinantOfMatrix ( d ) ; double D1 = determinantOfMatrix ( d1 ) ; double D2 = determinantOfMatrix ( d2 ) ; double D3 = determinantOfMatrix ( d3 ) ; Console . Write ( "" D ▁ is ▁ : ▁ { 0 : F6 } ▁ STRNEWLINE "" , D ) ; Console . Write ( "" D1 ▁ is ▁ : ▁ { 0 : F6 } ▁ STRNEWLINE "" , D1 ) ; Console . Write ( "" D2 ▁ is ▁ : ▁ { 0 : F6 } ▁ STRNEWLINE "" , D2 ) ; Console . Write ( "" D3 ▁ is ▁ : ▁ { 0 : F6 } ▁ STRNEWLINE "" , D3 ) ; if ( D != 0 ) { double x = D1 / D ; double y = D2 / D ; Console . Write ( "" Value ▁ of ▁ x ▁ is ▁ : ▁ { 0 : F6 } STRNEWLINE "" , x ) ; Console . Write ( "" Value ▁ of ▁ y ▁ is ▁ : ▁ { 0 : F6 } STRNEWLINE "" , y ) ; Console . Write ( "" Value ▁ of ▁ z ▁ is ▁ : ▁ { 0 : F6 } STRNEWLINE "" , z ) ; } else { if ( D1 == 0 && D2 == 0 && D3 == 0 ) Console . Write ( "" Infinite ▁ solutions STRNEWLINE "" ) ; else if ( D1 != 0 D2 != 0 D3 != 0 ) Console . Write ( "" No ▁ solutions STRNEWLINE "" ) ; } } public static void Main ( ) { double [ , ] coeff = { { 2 , - 1 , 3 , 9 } , { 1 , 1 , 1 , 6 } , { 1 , - 1 , 1 , 2 } } ; findSolution ( coeff ) ; } }";"System of Linear Equations in three variables using Cramer 's Rule | C # program to calculate solutions of linear equations using cramer 's rule ; This functions finds the determinant of Matrix ; This function finds the solution of system of linear equations using cramer 's rule ; Matrix d using coeff as given in cramer 's rule ; Matrix d1 using coeff as given in cramer 's rule ; Matrix d2 using coeff as given in cramer 's rule ; Matrix d3 using coeff as given in cramer 's rule ; Calculating Determinant of Matrices d , d1 , d2 , d3 ; Case 1 ; Coeff have a unique solution . Apply Cramer 's Rule ; double z = D3 / D ; calculating z using cramer 's rule ; Case 2 ; Driver Code ; storing coefficients of linear equations in coeff matrix"
C#;"using System ; class GFG { static void printGreater ( int x , int y ) { double X = y * Math . Log ( x ) ; double Y = x * Math . Log ( y ) ; if ( Math . Abs ( X - Y ) < 1e-9 ) { Console . WriteLine ( "" Equal "" ) ; } else if ( X > Y ) { Console . WriteLine ( x + "" ^ "" + y ) ; } else { Console . WriteLine ( y + "" ^ "" + x ) ; } } public static void Main ( ) { int x = 5 , y = 8 ; printGreater ( x , y ) ; } }";"Find larger of x ^ y and y ^ x | C # program to print greater of x ^ y and y ^ x ; Driver Code"
C#;"using System ; class Series { static int sumOfSeries ( int n ) { return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( sumOfSeries ( n ) ) ; } }";"n | C # program to find the n - th term in series ; Function to find nth term ; Driver Code"
C#;"using System ; public class GFG { static double mulmod ( long a , long b , long mod ) { a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res + a ) % mod ; a = ( a * 2 ) % mod ; b /= 2 ; } return res % mod ; } static long findProduct ( long N ) { long product = 1 , fact = 1 ; long MOD = ( long ) ( 1e9 + 7 ) ; for ( int i = 1 ; i <= N ; i ++ ) { fact = ( long ) mulmod ( fact , i , MOD ) ; product = ( long ) mulmod ( product , fact , MOD ) ; if ( product == 0 ) return 0 ; } return product ; } static public void Main ( ) { long N = 3 ; Console . WriteLine ( findProduct ( N ) ) ; N = 5 ; Console . WriteLine ( findProduct ( N ) ) ; } }";"Product of first N factorials | C # Program to find the product of first N factorials ; To compute ( a * b ) % MOD ; long res = 0 ; Initialize result ; If b is odd , add ' a ' to result ; Multiply ' a ' with 2 ; Divide b by 2 ; Return result ; This function computes factorials and product by using above function i . e . modular multiplication ; Initialize product and fact with 1 ; ith factorial ; product of first i factorials ; If at any iteration , product becomes divisible by MOD , simply return 0 ; ; Driver Code to Test above functions"
C#;"using System ; class GFG { static int divSum ( int n ) { int sum = 1 ; for ( int i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) sum = sum + i + n / i ; return sum ; } static bool areEquivalent ( int num1 , int num2 ) { return divSum ( num1 ) == divSum ( num2 ) ; } static public void Main ( ) { int num1 = 559 ; int num2 = 703 ; if ( areEquivalent ( num1 , num2 ) ) Console . WriteLine ( "" Equivalent "" ) ; else Console . WriteLine ( "" Not ▁ Equivalent "" ) ; } }";"Check if sum of divisors of two numbers are same | C # program to find if two numbers are equivalent or not ; Function to calculate sum of all proper divisors num -- > given natural number ; To store sum of divisors ; Find all divisors and add them ; Function to check if both numbers are equivalent or not ; Driver code"
C#;"using System ; class GFG { static int dodecahedral_num ( int n ) { return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) / 2 ; } public static void Main ( ) { int n = 5 ; Console . Write ( n + "" the ▁ Dodecahedral "" + "" ▁ number : "" ) ; Console . WriteLine ( dodecahedral_num ( n ) ) ; } }";"Dodecahedral number | C # program to find nth dodecahedral number ; Function to find dodecahedral number ; Formula to calculate nth dodecahedral number and return it into main function . ; Driver Code ; print result"
C#;"using System ; class GFG { static int bit ( int x ) { int ans = 0 ; while ( x > 0 ) { x /= 2 ; ans ++ ; } return ans ; } static bool check ( int d , int x ) { if ( bit ( x / d ) <= bit ( d ) ) return true ; return false ; } static int bs ( int n ) { int l = 1 , r = ( int ) Math . Sqrt ( n ) ; while ( l < r ) { int m = ( l + r ) / 2 ; if ( check ( m , n ) ) r = m ; else l = m + 1 ; } if ( ! check ( l , n ) ) return l + 1 ; else return l ; } static int countDivisor ( int n ) { return n - bs ( n ) + 1 ; } static public void Main ( ) { int n = 5 ; Console . WriteLine ( countDivisor ( n ) ) ; } }";"Count of divisors having more set bits than quotient on dividing N | C # Program to find number of Divisors which on integer division produce quotient having less set bit than divisor ; Return the count of set bit . ; check if q and d have same number of set bit . ; Binary Search to find the point at which number of set in q is less than or equal to d . ; while left index is less than right index ; finding the middle . ; check if q and d have same number of set it or not . ; Driver Code"
C#;"using System ; class GFG { static void swap ( ref int a , ref int b ) { int t = a ; a = b ; b = t ; } static bool everMeet ( int x1 , int x2 , int v1 , int v2 ) { if ( x1 < x2 && v1 <= v2 ) return false ; if ( x1 > x2 && v1 >= v2 ) return false ; if ( x1 < x2 ) { swap ( ref x1 , ref x2 ) ; swap ( ref v1 , ref v2 ) ; } while ( x1 >= x2 ) { if ( x1 == x2 ) return true ; x1 = x1 + v1 ; x2 = x2 + v2 ; } return false ; } static void Main ( ) { int x1 = 5 , v1 = 8 , x2 = 4 , v2 = 7 ; if ( everMeet ( x1 , x2 , v1 , v2 ) ) Console . Write ( "" Yes "" ) ; else Console . Write ( "" No "" ) ; } }";"Check if two people starting from different points ever meet | C # program to find if two people starting from different positions ever meet or not . ; If speed of a person at a position before other person is smaller , then return false . ; Making sure that x1 is greater ; Until one person crosses other ; first person taking one jump in each iteration ; second person taking one jump in each iteration ; Driver code"
C#;"using System ; class GFG { static String check ( int k , int d0 , int d1 ) { int s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ; int a = ( k - 3 ) % 4 ; int x = 0 ; switch ( a ) { case 0 : x = 0 ; break ; case 1 : x = ( 2 * ( d0 + d1 ) ) % 10 ; break ; case 2 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ; break ; case 3 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ; break ; } int sum = d0 + d1 + ( ( ( k - 3 ) / 4 ) * s + x ) ; if ( sum % 3 == 0 ) return "" YES "" ; return "" NO "" ; } static public void Main ( ) { int k , d0 , d1 ; k = 13 ; d0 = 8 ; d1 = 1 ; Console . WriteLine ( check ( k , d0 , d1 ) ) ; k = 5 ; d0 = 3 ; d1 = 4 ; Console . WriteLine ( check ( k , d0 , d1 ) ) ; } }";"Divisibility by 3 where each digit is the sum of all prefix digits modulo 10 | C # code to check divisibility by 3 ; Function to check the divisibility ; Cycle ; no of residual terms ; sum of residual terms ; if no of residue term = 0 ; if no of residue term = 1 ; if no of residue term = 2 ; if no of residue term = 3 ; sum of all digits ; divisibility check ; Driver Code"
C#;"using System ; class GFG { static void Main ( ) { int a = 4 ; int b = 3 , val = 0 ; if ( ( a % b ) != 0 ) val = ( a / b ) + ( a % b ) ; else val = ( a / b ) ; Console . WriteLine ( "" The ▁ ceiling ▁ "" + "" value ▁ of ▁ 4/3 ▁ is ▁ "" + val ) ; a = 6 ; b = 3 ; if ( ( a % b ) != 0 ) val = ( a / b ) + ( a % b ) ; else val = ( a / b ) ; Console . WriteLine ( "" The ▁ ceiling ▁ "" + "" value ▁ of ▁ 6/3 ▁ is ▁ "" + val ) ; } }";"Find ceil of a / b without using ceil ( ) function | C # program to find ceil ( a / b ) without using ceil ( ) function ; Driver Code ; taking input 1 ; example of perfect division taking input 2"
C#;"using System ; class GFG { static void printCollatz ( int n ) { while ( n != 1 ) { Console . Write ( n + "" ▁ "" ) ; if ( ( n & 1 ) == 1 ) n = 3 * n + 1 ; else n = n / 2 ; } Console . Write ( n ) ; } static void Main ( ) { printCollatz ( 6 ) ; } }";"Program to print Collatz Sequence | C # program to print Collatz sequence ; We simply follow steps while we do not reach 1 ; If n is odd ; If even ; Print 1 at the end ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { static void block ( long x ) { List < int > v = new List < int > ( ) ; Console . Write ( "" Blocks ▁ for ▁ "" + x + "" ▁ : ▁ "" ) ; while ( x > 0 ) { v . Add ( ( int ) x % 2 ) ; x = x / 2 ; } for ( int i = 0 ; i < v . Count ; i ++ ) { if ( v [ i ] == 1 ) { Console . Write ( i ) ; if ( i != v . Count - 1 ) Console . Write ( "" , ▁ "" ) ; } } Console . WriteLine ( ) ; } public static void Main ( ) { block ( 71307 ) ; block ( 1213 ) ; block ( 29 ) ; block ( 100 ) ; } }";"Powers of 2 to required sum | C # program to find the blocks for given number . ; Convert decimal number to its binary equivalent ; Displaying the output when the bit is '1' in binary equivalent of number . ; Driver Code here"
C#;"using System ; class GFG { static void findNumberOfDigits ( long n , int b ) { int dig = ( int ) ( Math . Floor ( Math . Log ( n ) / Math . Log ( b ) ) + 1 ) ; Console . Write ( "" The ▁ Number ▁ of ▁ digits "" + "" ▁ of ▁ Number ▁ "" + n + "" ▁ in ▁ base ▁ "" + b + "" ▁ is ▁ "" + dig ) ; } public static void Main ( ) { long n = 1446 ; int b = 7 ; findNumberOfDigits ( n , b ) ; } }";"Given a number N in decimal base , find number of its digits in any base ( base b ) | C # program to Find Number of digits in base b . ; function to print number of digits ; Calculating log using base changing property and then taking it floor and then adding 1. ; printing output ; Driver method ; taking inputs ; calling the method"
C#;"using System ; class GFG { static bool isValidNesbitt ( double a , double b , double c ) { double A = a / ( b + c ) ; double B = b / ( a + c ) ; double C = c / ( a + b ) ; double inequality = A + B + C ; return ( inequality >= 1.5 ) ; } static public void Main ( ) { double a = 1.0 , b = 2.0 , c = 3.0 ; if ( isValidNesbitt ( a , b , c ) == true ) { Console . Write ( "" Nesbitt ' s ▁ inequality "" + "" ▁ satisfied ▁ "" ) ; Console . WriteLine ( "" for ▁ real ▁ numbers ▁ "" + a + "" , ▁ "" + b + "" , ▁ "" + c ) ; } else Console . WriteLine ( "" Nesbitts ▁ inequality "" + "" ▁ not ▁ satisfied "" ) ; } }";"Nesbitt 's Inequality | C # code to verify Nesbitt 's Inequality ; 3 parts of the inequality sum ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { static List < int > primes ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) prime [ i ] = true ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( prime [ i ] == true ) { for ( int j = i * 2 ; j <= n ; j += i ) prime [ j ] = false ; } } List < int > arr = new List < int > ( ) ; for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] ) arr . Add ( i ) ; } return arr ; } static List < int > signature ( int n ) { List < int > r = primes ( n ) ; var factor = new Dictionary < int , int > ( ) ; List < int > sort_exp = new List < int > ( ) ; int k , t = n ; for ( int i = 0 ; i < r . Count ; i ++ ) { if ( n % r [ i ] == 0 ) { k = 0 ; while ( n % r [ i ] == 0 ) { n = n / r [ i ] ; k ++ ; } factor . Add ( r [ i ] , k ) ; sort_exp . Add ( k ) ; } } sort_exp . Sort ( ) ; Console . Write ( "" ▁ The ▁ Ordered ▁ Prime ▁ Signature ▁ of ▁ "" + t + "" ▁ is ▁ : ▁ STRNEWLINE { ▁ "" ) ; for ( int i = 0 ; i < sort_exp . Count ; i ++ ) { if ( i != sort_exp . Count - 1 ) Console . Write ( sort_exp [ i ] + "" , ▁ "" ) ; else Console . Write ( sort_exp [ i ] + "" ▁ } STRNEWLINE "" ) ; } return sort_exp ; } static void divisors ( int n ) { int f = 1 , l ; List < int > div = signature ( n ) ; l = div . Count ; for ( int i = 0 ; i < l ; i ++ ) { div [ i ] += 1 ; f *= div [ i ] ; } Console . Write ( "" The ▁ total ▁ number ▁ of ▁ divisors ▁ of ▁ "" + n + "" ▁ is ▁ "" + f + "" STRNEWLINE "" ) ; } static void Main ( ) { int n = 13 ; divisors ( n ) ; } }";"Ordered Prime Signature | C # to find total number of divisors of a number , using ordered prime signature ; Finding primes upto entered number ; Finding primes by Sieve of Eratosthenes method ; If prime [ i ] is not changed , then it is prime ; Update all multiples of p ; Forming array of the prime numbers found ; Finding ordered prime signature of the number ; Map to store prime factors and the related exponents ; Declaring an iterator for map ; Finding prime factorization of the number ; Storing the prime factor and its exponent in map ; Storing the exponent in a List ; Sorting the stored exponents ; Printing the prime signature ; Finding total number of divisors of the number ; Adding one to each element present ; in ordered prime signature ; Multiplying the elements ; Driver Code"
C#;"using System ; class GFG { public static void printCubeFree ( int n ) { bool [ ] cubFree = new bool [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) cubFree [ i ] = true ; for ( int i = 2 ; i * i * i <= n ; i ++ ) { if ( cubFree [ i ] ) { for ( int multiple = 1 ; i * i * i * multiple <= n ; multiple ++ ) { cubFree [ i * i * i * multiple ] = false ; } } } for ( int i = 2 ; i <= n ; i ++ ) { if ( cubFree [ i ] == true ) Console . Write ( i + "" ▁ "" ) ; } } public static void Main ( ) { printCubeFree ( 20 ) ; } }";"Cube Free Numbers smaller than n | Efficient C # Program to print all cube free numbers smaller than or equal to n . ; Initialize all numbers as not cube free ; Traverse through all possible cube roots ; If i itself is cube free ; Mark all multiples of i as not cube free ; Print all cube free numbers ; Driver Code"
C#;"using System ; class GFG { static void heapify ( int [ ] arr , int n , int i ) { int smallest = i ; int l = 2 * i + 1 ; int r = 2 * i + 2 ; if ( l < n && arr [ l ] < arr [ smallest ] ) smallest = l ; if ( r < n && arr [ r ] < arr [ smallest ] ) smallest = r ; if ( smallest != i ) { int temp = arr [ i ] ; arr [ i ] = arr [ smallest ] ; arr [ smallest ] = temp ; heapify ( arr , n , smallest ) ; } } static void heapSort ( int [ ] arr , int n ) { for ( int i = n / 2 - 1 ; i >= 0 ; i -- ) heapify ( arr , n , i ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { int temp = arr [ 0 ] ; arr [ 0 ] = arr [ i ] ; arr [ i ] = temp ; heapify ( arr , i , 0 ) ; } } static void printArray ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; ++ i ) Console . Write ( arr [ i ] + "" ▁ "" ) ; Console . WriteLine ( ) ; } public static void Main ( ) { int [ ] arr = { 4 , 6 , 3 , 2 , 9 } ; int n = arr . Length ; heapSort ( arr , n ) ; Console . WriteLine ( "" Sorted ▁ array ▁ is ▁ "" ) ; printArray ( arr , n ) ; } }";"Heap Sort for decreasing order using min heap | C # program for implementation of Heap Sort ; To heapify a subtree rooted with node i which is an index in arr [ ] , n is size of heap ; Initialize smalles as root ; left = 2 * i + 1 ; right = 2 * i + 2 ; If left child is smaller than root ; If right child is smaller than smallest so far ; If smallest is not root ; Recursively heapify the affected sub - tree ; main function to do heap sort ; Build heap ( rearrange array ) ; One by one extract an element from heap ; Move current root to end ; call max heapify on the reduced heap ; A utility function to print array of size n ; Driver program"
C#;"using System ; class GFG { static int isTriangular ( int num ) { if ( num < 0 ) return 0 ; int c = ( - 2 * num ) ; int b = 1 , a = 1 ; int d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return - 1 ; double root1 = ( - b + Math . Sqrt ( d ) ) / ( 2 * a ) ; double root2 = ( - b - Math . Sqrt ( d ) ) / ( 2 * a ) ; if ( ( int ) ( root1 ) > 0 && ( int ) ( Math . Floor ( root1 ) ) == ( int ) ( root1 ) ) return ( int ) ( root1 ) ; if ( ( int ) ( root2 ) > 0 && ( int ) ( Math . Floor ( root2 ) ) == ( int ) ( root2 ) ) return ( int ) ( root2 ) ; return - 1 ; } static int isPerfectSquare ( double x ) { double sr = Math . Sqrt ( x ) ; if ( ( sr - Math . Floor ( sr ) ) == 0 ) return ( int ) ( Math . Floor ( sr ) ) ; else return - 1 ; } static int findS ( int s ) { int sr = isPerfectSquare ( s ) ; if ( sr == - 1 ) return - 1 ; return isTriangular ( sr ) ; } public static void Main ( ) { int s = 9 ; int n = findS ( s ) ; if ( n == - 1 ) Console . Write ( "" - 1"" ) ; else Console . Write ( n ) ; } }";"Squared triangular number ( Sum of cubes ) | C # program to check if a given number is sum of cubes of natural numbers . ; Returns root of n ( n + 1 ) / 2 = num if num is triangular ( or integerroot exists ) . Else returns - 1. ; Considering the equation n * ( n + 1 ) / 2 = num . The equation is : a ( n ^ 2 ) + bn + c = 0 ""; ; Find roots of equation ; checking if root1 is natural ; checking if root2 is natural ; Returns square root of x if it is perfect square . Else returns - 1. ; Find floating point value of square root of x . ; If square root is an integer ; Function to find if the given number is sum of the cubes of first n natural numbers ; Driver code"
C#;"using System ; class GFG { static int trickyCase ( string s , int index ) { int index1 = - 1 ; for ( int i = index - 1 ; i >= 0 ; i -- ) { int digit = s [ i ] - '0' ; if ( digit != 8 ) { index1 = i ; break ; } } if ( index1 == - 1 ) return 2 * ( int ) Math . Pow ( 10 , s . Length ) ; int num = 0 ; for ( int i = 0 ; i < index1 ; i ++ ) num = num * 10 + ( s [ i ] - '0' ) ; if ( s [ index1 ] % 2 == 0 ) num = num * 10 + ( s [ index1 ] - '0' + 2 ) ; else num = num * 10 + ( s [ index1 ] - '0' + 1 ) ; for ( int i = index1 + 1 ; i < s . Length ; i ++ ) num = num * 10 ; return num ; } static int smallestNumber ( int n ) { int num = 0 ; string s = "" "" ; int duplicate = n ; while ( n > 0 ) { s = ( char ) ( n % 10 + 48 ) + s ; n /= 10 ; } int index = - 1 ; for ( int i = 0 ; i < s . Length ; i ++ ) { int digit = s [ i ] - '0' ; int val = digit & 1 ; if ( val == 1 ) { index = i ; break ; } } if ( index == - 1 ) return duplicate ; if ( s [ index ] == '9' ) { num = trickyCase ( s , index ) ; return num ; } for ( int i = 0 ; i < index ; i ++ ) num = num * 10 + ( s [ i ] - '0' ) ; num = num * 10 + ( s [ index ] - '0' + 1 ) ; for ( int i = index + 1 ; i < s . Length ; i ++ ) num = num * 10 ; return num ; } public static void Main ( ) { int N = 2397 ; Console . Write ( smallestNumber ( N ) ) ; } } ? >";"Smallest even digits number not less than N | C # program to print the smallest integer not less than N with all even digits ; function to return the answer when the first odd digit is 9 ; traverse towwars the left to find the non - 8 digit ; index digit ; if digit is not 8 , then break ; if on the left side of the '9' , no 8 is found then we return by adding a 2 and 0 's ; till non - 8 digit add all numbers ; if non - 8 is even or odd than add the next even . ; add 0 to right of 9 ; function to return the smallest number with all digits even ; convert the number to string to perform operations ; find out the first odd number ; if no odd numbers are there , than n is the answer ; if the odd number is 9 , than tricky case handles it ; add all digits till first odd ; increase the odd digit by 1 ; add 0 to the right of the odd number ; Driver Code"
C#;"using System ; class GFG { public static int findNth ( int n ) { int count = 0 ; for ( int curr = 19 ; ; curr += 9 ) { int sum = 0 ; for ( int x = curr ; x > 0 ; x = x / 10 ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } } static public void Main ( ) { Console . WriteLine ( findNth ( 5 ) ) ; } }";"n | C # program to find n - th number with sum of digits as 10. ; Find sum of digits in current no . ; If sum is 10 , we increment count ; If count becomes n , we return current number . ; Driver Code"
C#;"class GFG { static int findSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) for ( int j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; } public static void Main ( ) { int n = 5 ; System . Console . WriteLine ( findSum ( n ) ) ; } }";"Sum of pairwise products | Simple C # program to find sum of given series . ; Driver code"
C#;"using System ; class GFG { static int findSum ( int n ) { int multiTerms = n * ( n + 1 ) / 2 ; int sum = multiTerms ; for ( int i = 2 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sum = sum + multiTerms * i ; } return sum ; } public static void Main ( ) { int n = 5 ; Console . WriteLine ( findSum ( n ) ) ; } }";"Sum of pairwise products | C # program to find sum of given series . ; Sum of multiples of 1 is 1 * ( 1 + 2 + . . ) ; Adding sum of multiples of numbers other than 1 , starting from 2. ; Subtract previous number from current multiple . ; For example , for 2 , we get sum as ( 2 + 3 + 4 + ... . ) * 2 ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { public class pair { public int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static bool isPrime ( int n ) { if ( n < 2 ) return false ; for ( int i = 2 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } static void lemoine ( int n ) { Dictionary < int , pair > pr = new Dictionary < int , pair > ( ) ; int i = 0 ; for ( int q = 1 ; q <= n / 2 ; q ++ ) { int p = n - 2 * q ; if ( isPrime ( p ) && isPrime ( q ) ) pr . Add ( i , new pair ( p , q ) ) ; i ++ ; } foreach ( KeyValuePair < int , pair > it in pr ) Console . Write ( n + "" ▁ = ▁ "" + it . Value . first + "" ▁ + ▁ ( 2 ▁ * ▁ "" + it . Value . second + "" ) STRNEWLINE "" ) ; } public static void Main ( String [ ] args ) { int n = 39 ; Console . Write ( n + "" ▁ can ▁ be ▁ expressed ▁ as ▁ "" + "" STRNEWLINE "" ) ; lemoine ( n ) ; } }";"Lemoine 's Conjecture | C # code to verify Lemoine 's Conjecture for any odd number >= 7 ; Function to check if a number is prime or not ; Representing n as p + ( 2 * q ) to satisfy lemoine 's conjecture ; Declaring a map to hold pairs ( p , q ) ; Declaring an iterator for map Dictionary < int , int > :: iterator it ; it = pr . begin ( ) ; ; Finding various values of p for each q to satisfy n = p + ( 2 * q ) ; After finding a pair that satisfies the equation , check if both p and q are prime or not ; If both p and q are prime , store them in the map ; Displaying all pairs ( p , q ) that satisfy lemoine ' s ▁ conjecture ▁ for ▁ the ▁ number ▁ ' n ' ; Driver code ; Function calling"
C#;"using System ; class GFG { static int totalSumDivisibleByNum ( int digit , int number ) { int firstnum = ( int ) Math . Pow ( 10 , digit - 1 ) ; int lastnum = ( int ) Math . Pow ( 10 , digit ) ; firstnum = ( firstnum - firstnum % number ) + number ; lastnum = ( lastnum - lastnum % number ) ; int count = ( ( lastnum - firstnum ) / number + 1 ) ; return ( ( lastnum + firstnum ) * count ) / 2 ; } public static void Main ( ) { int n = 3 , number = 7 ; Console . WriteLine ( totalSumDivisibleByNum ( n , number ) ) ; } }";"Sum of n digit numbers divisible by a given number | Efficient Java program to find the sum divisible numbers . ; find the Sum of having n digit and divisible by the number ; compute the first and last term ; first number which is divisible by given number ; last number which is divisible by given number ; total divisible number ; return the total sum ; Driver code"
C#;"using System ; class GFG { public static int Nth_of_AP ( int a , int d , int N ) { return ( a + ( N - 1 ) * d ) ; } public static void Main ( ) { int a = 2 ; int d = 1 ; int N = 5 ; Console . WriteLine ( "" The ▁ "" + N + "" th ▁ term ▁ of ▁ the ▁ series ▁ is ▁ : ▁ "" + Nth_of_AP ( a , d , N ) ) ; } }";"Program for N | C # program to find nth term of Arithmetic progression ; using formula to find the Nth term t ( n ) = a ( 1 ) + ( n - 1 ) * d ; Driver code ; starting number ; Common difference ; N th term to be find ; Display the output"
C#;"using System ; class GFG { static bool checkFibinnary ( int n ) { int prev_last = 0 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 && prev_last != 0 ) return false ; prev_last = n & 1 ; n >>= 1 ; } return true ; } public static void Main ( ) { int n = 10 ; if ( checkFibinnary ( n ) == true ) Console . WriteLine ( "" YES "" ) ; else Console . WriteLine ( "" NO "" ) ; } }";"Fibbinary Numbers ( No consecutive 1 s in binary ) | C # program to check if a number is fibinnary number or not ; function to check if binary representation of an integer has consecutive 1 s ; stores the previous last bit initially as 0 ; if current last bit and previous last bit is 1 ; stores the last bit ; right shift the number ; Driver code to check above function"
C#;"using System ; class GFG { static int sumOfSeries ( int n ) { return ( int ) ( 0.6172 * ( Math . Pow ( 10 , n ) - 1 ) - 0.55 * n ) ; } public static void Main ( ) { int n = 2 ; Console . Write ( sumOfSeries ( n ) ) ; } }";"Sum of the series 5 + 55 + 555 + . . up to n terms | C # program for sum of the series 5 + 55 + 555. . ... n ; Function which return the the sum of series ; Driver code"
C#;"using System ; class GFG { static int Nonagonal ( int n ) { return n * ( 7 * n - 5 ) / 2 ; } public static void Main ( ) { int n = 10 ; Console . Write ( Nonagonal ( n ) ) ; } }";"Nonagonal number | C # Program to find nth nonagonal number . ; Function to find nth nonagonal number . ; Formula to find nth nonagonal number . ; Driver function ."
C#;"using System ; using System . Text ; class GFG { static bool divisibleBy20 ( String num ) { int lastTwoDigits = Int32 . Parse ( num . Substring ( 2 ) ) ; return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ) ; } static public void Main ( ) { String num = ""63284689320"" ; if ( divisibleBy20 ( num ) == true ) Console . Write ( "" Yes "" ) ; else Console . Write ( "" No "" ) ; } }";"Check if a large number is divisible by 20 | C # program to check if a large ' n ' number is divisible by 20. ; Get number with last two digits ; Check if the number formed by last two digits is divisible by 5 and 4. ; Driver Code"
C#;"using System ; class GFG { static bool isDvisibleBy12 ( string num ) { if ( num . Length >= 3 ) { int d1 = ( int ) num [ num . Length - 1 ] ; if ( d1 % 2 != 0 ) return false ; int d2 = ( int ) num [ num . Length - 2 ] ; int sum = 0 ; for ( int i = 0 ; i < num . Length ; i ++ ) sum += num [ i ] ; return ( sum % 3 == 0 && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { int number = int . Parse ( num ) ; return ( number % 12 == 0 ) ; } } public static void Main ( ) { String num = ""12244824607284961224"" ; if ( isDvisibleBy12 ( num ) ) Console . Write ( "" Yes "" ) ; else Console . Write ( "" No "" ) ; } }";"Divisibility by 12 for a large number | C # Program to check if number is divisible by 12 ; if number greater then 3 ; find last digit ; no is odd ; find second last digit ; find sum of all digits ; if number is less then or equal to 100 ; Driver function"
C#;"using System ; class GfG { static bool check ( int n ) { int d = ( int ) Math . Sqrt ( n ) ; if ( d * d == n ) return true ; return false ; } static int largestNonPerfectSquareNumber ( int [ ] a , int n ) { int maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! check ( a [ i ] ) ) maxi = Math . Max ( a [ i ] , maxi ) ; } return maxi ; } public static void Main ( ) { int [ ] a = { 16 , 20 , 25 , 2 , 3 , 10 } ; int n = a . Length ; Console . WriteLine ( largestNonPerfectSquareNumber ( a , n ) ) ; } }";"Largest number that is not a perfect square | C # program to find the largest non perfect square number among n numbers ; takes the sqrt of the number ; checks if it is a perfect square number ; function to find the largest non perfect square number ; stores the maximum of all non perfect square numbers ; traverse for all elements in the array ; store the maximum if not a perfect square ; driver code to check the above functions ; function call"
C#;"using System ; class GFG { static void printAP ( int a , int d , int n ) { int curr_term ; curr_term = a ; for ( int i = 1 ; i <= n ; i ++ ) { Console . Write ( curr_term + "" ▁ "" ) ; curr_term += d ; } } public static void Main ( ) { int a = 2 ; int d = 1 ; int n = 5 ; printAP ( a , d , n ) ; } }";"Program to print Arithmetic Progression series | C # Program to print an arithmetic progression series ; Printing AP by simply adding d to previous term . ; Driver code ; starting number ; Common difference ; N th term to be find"
C#;"using System ; class GFG { static void printNonSquare ( int n ) { int curr_count = 2 , num = 2 , count = 0 ; while ( count < n ) { for ( int i = 0 ; i < curr_count && count < n ; i ++ ) { Console . Write ( num + "" ▁ "" ) ; count ++ ; num ++ ; } num ++ ; curr_count += 2 ; } } static public void Main ( ) { int n = 10 ; printNonSquare ( n ) ; } }";"Program to print non square numbers | C # program to print first n non - square numbers . ; Print curr_count numbers . curr_count is current gap between two square numbers . ; skip a square number . ; Count of next non - square numbers is next even number . ; Driver code"
C#;"using System ; public class GfG { public static int countZeroso ( int [ ] a , int n ) { int count2 = 0 , count5 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { while ( a [ i ] % 2 == 0 ) { a [ i ] = a [ i ] / 2 ; count2 ++ ; } while ( a [ i ] % 5 == 0 ) { a [ i ] = a [ i ] / 5 ; count5 ++ ; } } return ( count2 < count5 ) ? count2 : count5 ; } public static void Main ( ) { int [ ] a = new int [ ] { 10 , 100 , 20 , 30 , 50 , 91 , 12 , 80 } ; int n = 8 ; Console . WriteLine ( countZeroso ( a , n ) ) ; } }";"Count number of trailing zeros in product of array | C # program for count total zero in product of array ; Returns count of zeros in product of array ; count number of 2 s in each element ; count number of 5 s in each element ; return the minimum ; Driver function"
C#;"using System ; class GFG { static int squareSum ( int n ) { return 2 * n * ( n + 1 ) * ( 2 * n + 1 ) / 3 ; } public static void Main ( ) { Console . Write ( squareSum ( 8 ) ) ; } }";"Sum of square of first n even numbers | Efficient C # method to find sum of square of first n even numbers . ; driver code"
C#;"using System ; class GFG { static long [ ] pwr ; static bool isMunchhausen ( int n ) { long sum = 0 ; int temp = n ; while ( temp > 0 ) { int index = temp % 10 ; sum = sum + pwr [ index ] ; temp /= 10 ; } return ( sum == n ) ; } static void printMunchhausenNumbers ( int n ) { pwr = new long [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) pwr [ i ] = ( long ) Math . Pow ( ( float ) i , ( float ) i ) ; for ( int i = 1 ; i <= n ; i ++ ) if ( isMunchhausen ( i ) == true ) Console . WriteLine ( i ) ; } public static void Main ( ) { int n = 10000 ; printMunchhausenNumbers ( n ) ; } }";"MÃ ¼ nchhausen Number | C # code for Munchhausen Number ; pwr [ i ] is going to store i raised to power i . ; Function to check out whether the number is Munchhausen Number or not ; Precompute i raised to power i for every i ; The input here is fixed i . e . it will check up to n ; check the integer for Munchhausen Number , if yes then print out the number ; Driver Code"
C#;"using System ; public class GfG { public static int kthdigit ( int a , int b , int k ) { int p = ( int ) Math . Pow ( a , b ) ; int count = 0 ; while ( p > 0 && count < k ) { int rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; } public static void Main ( ) { int a = 5 , b = 2 ; int k = 1 ; Console . WriteLine ( kthdigit ( a , b , k ) ) ; } }";"K | C # program for finding k - th digit in a ^ b ; To compute k - th digit in a ^ b ; Computing a ^ b ; Getting last digit ; Increasing count by 1 ; If current number is required digit ; Remove last digit ; Driver Code"
C#;"using System ; class GFG { static long digSum ( long n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; } static long PowDigSum ( long n , long x ) { long sum = digSum ( n ) ; long rem = x % 6 ; if ( ( sum == 3 sum == 6 ) && x > 1 ) return 9 ; else if ( x == 1 ) return sum ; else if ( x == 0 ) return 1 ; else if ( rem == 0 ) return digSum ( ( long ) Math . Pow ( sum , 6 ) ) ; else return digSum ( ( long ) Math . Pow ( sum , rem ) ) ; } public static void Main ( ) { int n = 33333 ; int x = 332654 ; Console . WriteLine ( PowDigSum ( n , x ) ) ; } }";"Recursive sum of digit in n ^ x , where n and x are very large | C # Code for Sum of digit of n ^ x where n and x are very large ; Function to get sum of digits of a number ; Function to return sum ; Find sum of digits in n ; Find remainder of exponent ; Driver Code"
C#;"using System ; class Area { public static int maxArea ( int [ ] A , int len ) { int l = 0 ; int r = len - 1 ; int area = 0 ; while ( l < r ) { area = Math . Max ( area , Math . Min ( A [ l ] , A [ r ] ) * ( r - l ) ) ; if ( A [ l ] < A [ r ] ) l += 1 ; else r -= 1 ; } return area ; } public static void Main ( ) { int [ ] a = { 1 , 5 , 4 , 3 } ; int [ ] b = { 3 , 1 , 2 , 4 , 5 } ; int len1 = 4 ; Console . WriteLine ( maxArea ( a , len1 ) ) ; int len2 = 5 ; Console . WriteLine ( maxArea ( b , len2 ) ) ; } }";"Container with Most Water | C # code for Max Water Container ; Calculating the max area ; Driver code"
C#;"using System ; class GFG { static int mobius ( int n ) { int p = 0 ; if ( n % 2 == 0 ) { n = n / 2 ; p ++ ; if ( n % 2 == 0 ) return 0 ; } for ( int i = 3 ; i <= Math . Sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = n / i ; p ++ ; if ( n % i == 0 ) return 0 ; } } return ( p % 2 == 0 ) ? - 1 : 1 ; } public static void Main ( ) { int N = 17 ; Console . WriteLine ( "" Mobius ▁ Functions "" + "" ▁ M ( N ) ▁ at ▁ N ▁ = ▁ "" + N + "" ▁ is : ▁ "" + mobius ( N ) ) ; Console . WriteLine ( "" Mobius ▁ Functions "" + "" M ( N ) ▁ at ▁ N ▁ = ▁ "" + 25 + "" ▁ is : ▁ "" + mobius ( 25 ) ) ; Console . WriteLine ( "" Mobius ▁ Functions "" + "" M ( N ) ▁ at ▁ N ▁ = ▁ "" + 6 + "" ▁ is : ▁ "" + mobius ( 6 ) ) ; } }";"Program for Mobius Function | C # program to print all prime factors ; Returns value of mobius ( ) ; Handling 2 separately ; If 2 ^ 2 also divides N ; Check for all other prime factors ; If i divides n ; If i ^ 2 also divides N ; Driver Code"
C#;"using System ; class GFG { static int factorial ( int start , int end ) { int res = 1 ; for ( int i = start ; i <= end ; i ++ ) res *= i ; return res ; } static int sumofsquare ( int n ) { return factorial ( n + 1 , 2 * n ) / factorial ( 1 , n ) ; } public static void Main ( ) { int n = 4 ; Console . WriteLine ( sumofsquare ( n ) ) ; } }";"Sum of squares of binomial coefficients | C # Program to find the sum of square of binomial coefficient . ; function to return product of number from start to end . ; Return the sum of square of binomial coefficient ; Driven Program"
C#;"using System ; class GFG { static double PHI = 1.6180339 ; static int [ ] f = { 0 , 1 , 1 , 2 , 3 , 5 } ; static int fib ( int n ) { if ( n < 6 ) return f [ n ] ; int t = 5 ; int fn = 5 ; while ( t < n ) { fn = ( int ) Math . Round ( fn * PHI ) ; t ++ ; } return fn ; } public static void Main ( ) { int n = 9 ; Console . WriteLine ( n + "" th ▁ Fibonacci "" + "" ▁ Number ▁ = ▁ "" + fib ( n ) ) ; } }";"Find nth Fibonacci number using Golden ratio | C # program to find n - th Fibonacci number ; Approximate value of golden ratio ; Fibonacci numbers upto n = 5 ; Function to find nth Fibonacci number ; Fibonacci numbers for n < 6 ; Else start counting from 5 th term ; Driver code"
C#;"using System ; class GFG { static float func ( float x , float y ) { return ( x + y + x * y ) ; } static void euler ( float x0 , float y , float h , float x ) { while ( x0 < x ) { y = y + h * func ( x0 , y ) ; x0 = x0 + h ; } Console . WriteLine ( "" Approximate ▁ solution ▁ at ▁ x ▁ = ▁ "" + x + "" ▁ is ▁ "" + y ) ; } public static void Main ( ) { float x0 = 0 ; float y0 = 1 ; float h = 0.025f ; float x = 0.1f ; euler ( x0 , y0 , h , x ) ; } }";"Euler Method for solving differential equation | C # program to find approximation of an ordinary differential equation using euler method ; Consider a differential equation dy / dx = ( x + y + xy ) ; Function for Euler formula ; Iterating till the point at which we need approximation ; Printing approximation ; Driver program ; Initial Values ; Value of x at which we need approximation"
C#;"using System ; class GfG { static void solution ( int a , int b , int n ) { for ( int i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { Console . Write ( "" x ▁ = ▁ "" + i + "" , ▁ y ▁ = ▁ "" + ( n - ( i * a ) ) / b ) ; return ; } } Console . Write ( "" No ▁ solution "" ) ; } public static void Main ( ) { int a = 2 , b = 3 , n = 7 ; solution ( a , b , n ) ; } }";"Find x and y satisfying ax + by = n | C # program to find solution of ax + by = n ; function to find the solution ; traverse for all possible values ; check if it is satisfying the equation ; Driver code"
C#;"using System ; class GFG { static int binomialCoeffSum ( int n ) { return ( 1 << n ) ; } static public void Main ( ) { int n = 4 ; Console . WriteLine ( binomialCoeffSum ( n ) ) ; } }";"Sum of Binomial coefficients | C # Program to find sum of Binomial Coefficient . ; Returns value of Binomial Coefficient Sum which is 2 raised to power n . ; Driver program to test above function"
C#;"using System ; class Eulerian { public static void precisionCompute ( int x , int y , int n ) { if ( y == 0 ) { Console . WriteLine ( "" Infinite "" ) ; return ; } if ( x == 0 ) { Console . WriteLine ( ""0"" ) ; return ; } if ( n <= 0 ) { Console . WriteLine ( x / y ) ; return ; } if ( ( ( x > 0 ) && ( y < 0 ) ) || ( ( x < 0 ) && ( y > 0 ) ) ) { Console . WriteLine ( "" - "" ) ; x = x > 0 ? x : - x ; y = y > 0 ? y : - y ; } int d = x / y ; for ( int i = 0 ; i <= n ; i ++ ) { Console . Write ( d ) ; x = x - ( y * d ) ; if ( x == 0 ) break ; x = x * 10 ; d = x / y ; if ( i == 0 ) Console . Write ( "" . "" ) ; } } public static void Main ( ) { int x = 22 , y = 7 , n = 15 ; precisionCompute ( x , y , n ) ; } }";"Program to compute division upto n decimal places | C # program to compute division upto n decimal places . ; Base cases ; Since n <= 0 , don 't compute after  the decimal ; Handling negative numbers ; Integral division ; Now one by print digits after dot using school division method . ; Driver code"
C#;"using System ; class GFG { static void quadrant ( int x , int y ) { if ( x > 0 && y > 0 ) Console . WriteLine ( "" lies ▁ in ▁ First ▁ quadrant "" ) ; else if ( x < 0 && y > 0 ) Console . WriteLine ( "" lies ▁ in ▁ Second ▁ quadrant "" ) ; else if ( x < 0 && y < 0 ) Console . WriteLine ( "" lies ▁ in ▁ Third ▁ quadrant "" ) ; else if ( x > 0 && y < 0 ) Console . WriteLine ( "" lies ▁ in ▁ Fourth ▁ quadrant "" ) ; else if ( x == 0 && y > 0 ) Console . WriteLine ( "" lies ▁ at ▁ positive ▁ y ▁ axis "" ) ; else if ( x == 0 && y < 0 ) Console . WriteLine ( "" lies ▁ at ▁ negative ▁ y ▁ axis "" ) ; else if ( y == 0 && x < 0 ) Console . WriteLine ( "" lies ▁ at ▁ negative ▁ x ▁ axis "" ) ; else if ( y == 0 && x > 0 ) Console . WriteLine ( "" lies ▁ at ▁ positive ▁ x ▁ axis "" ) ; else Console . WriteLine ( "" lies ▁ at ▁ origin "" ) ; } public static void Main ( ) { int x = 1 , y = 1 ; quadrant ( x , y ) ; } }";"Program to determine the quadrant of the cartesian plane | C # program to check quadrant ; Function to check quadrant ; Driver Code ; Function Calling"
C#;"using System ; class Prime { public static bool checkDigits ( int n ) { while ( n > 0 ) { int dig = n % 10 ; if ( dig != 2 && dig != 3 && dig != 5 && dig != 7 ) return false ; n /= 10 ; } return true ; } public static bool prime ( int n ) { if ( n == 1 ) return false ; for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } public static bool isFullPrime ( int n ) { return ( checkDigits ( n ) && prime ( n ) ) ; } public static void Main ( ) { int n = 53 ; if ( isFullPrime ( n ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Check if a number is Full Prime | C # program for checking of full prime ; function to check digits ; check all digits are prime or not ; check if digits are prime or not ; To check if n is prime or not ; check for all factors ; To check if n is Full Prime ; The order is important here for efficiency ; Driver code"
C#;"using System ; class GFG { static string getResult ( string st ) { int sum = 0 ; int length = st . Length ; for ( int i = 0 ; i < length ; i ++ ) { sum = sum + ( int ) Math . Pow ( st [ i ] - '0' , length ) ; } int number = int . Parse ( st ) ; if ( number == sum ) return "" yes "" ; else return "" no "" ; } public static void Main ( string [ ] args ) { string st = ""153"" ; Console . Write ( getResult ( st ) ) ; } }";"Narcissistic number | C # program for checking of Narcissistic number ; Traversing through the string ; Since ascii value of numbers starts from 48 so we subtract it from sum ; Converting string to integer ; Comparing number and sum ; Driver Code"
C#;"using System ; class GFG { static int MAX = 500 ; static int nthSHN ( int n , int [ ] dp ) { if ( n == 1 n == 2 ) return dp [ n ] = 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; return dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n ; } public static void Main ( ) { int n = 6 ; int [ ] dp = new int [ MAX ] ; for ( int i = 0 ; i < dp . Length ; i ++ ) dp [ i ] = - 1 ; Console . Write ( nthSHN ( n , dp ) ) ; } }";"SchrÃ ¶ derâ €“ Hipparchus number | A memoization based optimized C # program to find n - th Schroder - Hipparchus number ; Driver code"
C#;"using System ; public class GfG { static int evenSum ( int n ) { int curr = 2 , sum = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; } public static void Main ( ) { int n = 20 ; Console . WriteLine ( "" Sum ▁ of ▁ first ▁ "" + n + "" ▁ Even ▁ numbers ▁ is : ▁ "" + evenSum ( n ) ) ; } }";"Sum of first n even numbers | C # implementation to find sum of first n even numbers ; function to find sum of first n even numbers ; sum of first n even numbers ; next even number ; required sum ; driver function"
C#;"using System ; public class GfG { static int evenSum ( int n ) { return ( n * ( n + 1 ) ) ; } public static void Main ( ) { int n = 20 ; Console . WriteLine ( "" Sum ▁ of ▁ first ▁ "" + n + "" ▁ Even ▁ numbers ▁ is : ▁ "" + evenSum ( n ) ) ; } }";"Sum of first n even numbers | C # implementation to find sum of first n even numbers ' ; function to find sum of first n even numbers ; required sum ; driver function"
C#;"using System ; class GFG { static double kmphTOmph ( double kmph ) { return 0.6214 * kmph ; } static double mphTOkmph ( double mph ) { return mph * 1.60934 ; } public static void Main ( ) { double kmph = 150 ; double mph = 100 ; Console . WriteLine ( "" speed ▁ in ▁ miles / hr ▁ is ▁ "" + kmphTOmph ( kmph ) ) ; Console . WriteLine ( "" speed ▁ in ▁ km / hr ▁ is ▁ "" + mphTOkmph ( mph ) ) ; } }";"Program to Convert Km / hr to miles / hr and vice versa | C # program for the conversion kmph to mph and vice versa ; Function to convert kmph to mph ; Function to convert mph to kmph ; Driver code to check the above function"
C#;"using System ; using System . Collections . Generic ; class GFG { static long subsequences ( int [ ] a , int n , int r ) { Dictionary < int , int > left = new Dictionary < int , int > ( ) , right = new Dictionary < int , int > ( ) ; long ans = - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( right . ContainsKey ( a [ i ] ) ) right [ a [ i ] ] = right [ a [ i ] ] + 1 ; else right . Add ( a [ i ] , 1 ) ; for ( int i = 0 ; i < n ; i ++ ) { long c1 = 0 , c2 = 0 ; if ( a [ i ] % r == 0 ) if ( left . ContainsKey ( a [ i ] / r ) ) c1 = right [ a [ i ] / r ] ; else c1 = 0 ; if ( right . ContainsKey ( a [ i ] ) ) right [ a [ i ] ] = right [ a [ i ] ] ; else right . Add ( a [ i ] , - 1 ) ; if ( right . ContainsKey ( a [ i ] * r ) ) c2 = right [ a [ i ] * r ] ; else c2 = 0 ; ans += ( c1 * c2 ) ; if ( left . ContainsKey ( a [ i ] ) ) left [ a [ i ] ] = 0 ; else left . Add ( a [ i ] , 1 ) ; } return ans - 1 ; } public static void Main ( String [ ] args ) { int [ ] a = { 1 , 2 , 6 , 2 , 3 , 6 , 9 , 18 , 3 , 9 } ; int n = a . Length ; int r = 3 ; Console . WriteLine ( subsequences ( a , n , r ) ) ; } }";"Number of GP ( Geometric Progression ) subsequences of size 3 | C # program to count GP subsequences of size 3. ; Returns count of G . P . subsequences with length 3 and common ratio r ; Hashing to maintain left and right array elements to the main count ; Stores the answer ; Traverse through the elements ; Keep the count in the hash ; Traverse through all elements and find out the number of elements as k1 * k2 ; Keep the count of left and right elements left is a [ i ] / r and right a [ i ] * r ; If the current element is divisible by k , count elements in left hash . ; Decrease the count in right hash ; Number of right elements ; Calculate the answer ; left count of a [ i ] ; Returns answer ; Driver Code"
C#;"using System ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int findNumber ( int [ ] arr , int n ) { int ans = arr [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) ans = gcd ( ans , arr [ i ] ) ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] == ans ) return ans ; return - 1 ; } public static void Main ( ) { int [ ] arr = { 2 , 2 , 4 } ; int n = arr . Length ; Console . WriteLine ( findNumber ( arr , n ) ) ; } }";"Find element in array that divides all array elements | C # program to find such number in the array that all array elements are divisible by it ; Returns GCD of two numbers ; Function to return the desired number if exists ; Find GCD of array ; Check if GCD is present in array ; Driver Code"
C#;"using System ; using System . Collections ; class GFG { static ArrayList primes = new ArrayList ( ) ; static void SieveofEratosthenes ( int n ) { bool [ ] visited = new bool [ n * n + 2 ] ; for ( int i = 2 ; i <= n + 1 ; i ++ ) if ( ! visited [ i ] ) { for ( int j = i * i ; j <= n + 1 ; j += i ) visited [ j ] = true ; primes . Add ( i ) ; } } static bool specialPrimeNumbers ( int n , int k ) { SieveofEratosthenes ( n ) ; int count = 0 ; for ( int i = 0 ; i < primes . Count ; i ++ ) { for ( int j = 0 ; j < i - 1 ; j ++ ) { if ( ( int ) primes [ j ] + ( int ) primes [ j + 1 ] + 1 == ( int ) primes [ i ] ) { count ++ ; break ; } } if ( count == k ) return true ; } return false ; } public static void Main ( ) { int n = 27 , k = 2 ; if ( specialPrimeNumbers ( n , k ) ) Console . WriteLine ( "" YES "" ) ; else Console . WriteLine ( "" NO "" ) ; } }";"Special prime numbers | C # program to check whether there exist at least k or not in range [ 2. . n ] ; Generating all the prime numbers from 2 to n . ; If a prime number is Special prime number , then we increments the value of k . ; If at least k Special prime numbers are present , then we return 1. else we return 0 from outside of the outer loop . ; Driver function"
C#;"using System ; public class GFG { static void factorize ( long n ) { int count = 0 ; while ( ! ( n % 2 > 0 ) ) { n >>= 1 ; count ++ ; } if ( count > 0 ) Console . WriteLine ( ""2"" + "" ▁ "" + count ) ; for ( long i = 3 ; i <= ( long ) Math . Sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n = n / i ; } if ( count > 0 ) Console . WriteLine ( i + "" ▁ "" + count ) ; } if ( n > 2 ) Console . WriteLine ( n + "" ▁ "" + ""1"" ) ; } static public void Main ( ) { long n = 1000000000000000000 ; factorize ( n ) ; } }";"Prime factors of a big number | C # program to print prime factors and their powers . ; function to calculate all the prime factors and count of every prime factor ; count the number of times 2 divides ; equivalent to n = n / 2 ; ; if 2 divides it ; check for all the possible numbers that can divide it ; if n at the end is a prime number . ; Driver Code"
C#;"using System ; class GFG { static int __gcd ( int a , int b ) { if ( a == 0 ) return b ; return __gcd ( b % a , a ) ; } static int minimumMoves ( int [ ] A , int N ) { int one = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] == 1 ) one ++ ; if ( one != 0 ) return N - one ; int minimum = int . MaxValue ; for ( int i = 0 ; i < N ; i ++ ) { int g = A [ i ] ; for ( int j = i + 1 ; j < N ; j ++ ) { g = __gcd ( A [ j ] , g ) ; if ( g == 1 ) { minimum = Math . Min ( minimum , j - i ) ; break ; } } } if ( minimum == int . MaxValue ) return - 1 ; else return N + minimum - 1 ; } public static void Main ( ) { int [ ] A = { 2 , 4 , 3 , 9 } ; int N = A . Length ; Console . WriteLine ( minimumMoves ( A , N ) ) ; } }";"Minimum gcd operations to make all array elements one | C # program to find minimum GCD operations to make all array elements one . ; __gcd function ; Function to count number of moves . ; Counting Number of ones . ; If there is a one ; Find smallest subarray with GCD equals to one . ; to calculate GCD ; Not Possible ; Final answer ; Driver code"
C#;"using System ; public class GfG { public static void series ( int n , int d ) { if ( d == 0 ) { for ( int i = 0 ; i < n ; i ++ ) Console . Write ( ""0"" ) ; Console . WriteLine ( ) ; return ; } if ( n % 2 == 0 ) { for ( int i = 1 ; i <= n ; i ++ ) { Console . Write ( Math . Pow ( - 1 , i ) * d + "" ▁ "" ) ; } Console . WriteLine ( ) ; } else { float m = n ; float r = ( m / ( m - 1 ) ) ; float g = ( float ) ( d * ( float ) ( Math . Sqrt ( r ) ) ) ; Console . Write ( ""0 ▁ "" ) ; for ( int i = 1 ; i < n ; i ++ ) { Console . Write ( Math . Pow ( - 1 , i ) * g + "" ▁ "" ) ; } Console . WriteLine ( ) ; } } public static void Main ( ) { int n = 3 , d = 3 ; series ( n , d ) ; } }";"Given N and Standard Deviation , find N elements | C # program to find n elements ; function to print series of n elements ; if S . D . is 0 then print all elements as 0. ; print n 0 's ; if S . D . is even ; print - SD , + SD , - SD , + SD ; if odd ; convert n to a float integer ; print one element to be 0 ; print ( n - 1 ) elements as xi derived from the formula ; driver function"
C#;"using System ; class GFG { static int countDigitOne ( int n ) { int countr = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { string str = i . ToString ( ) ; countr += str . Split ( ""1"" ) . Length - 1 ; } return countr ; } public static void Main ( ) { int n = 13 ; Console . WriteLine ( countDigitOne ( n ) ) ; n = 131 ; Console . WriteLine ( countDigitOne ( n ) ) ; n = 159 ; Console . WriteLine ( countDigitOne ( n ) ) ; } }";"Total no of 1 's in numbers | C # code to count the frequency of 1 in numbers less than or equal to the given number . ; Driver Code"
C#;"using System ; class GFG { static long N = 1000000007L ; static long exponentiation ( long bas , long exp ) { long t = 1L ; while ( exp > 0 ) { if ( exp % 2 != 0 ) t = ( t * bas ) % N ; bas = ( bas * bas ) % N ; exp /= 2 ; } return t % N ; } public static void Main ( ) { long bas = 5 ; long exp = 100000 ; long modulo = exponentiation ( bas , exp ) ; Console . WriteLine ( modulo ) ; } }";"Exponential Squaring ( Fast Modulo Multiplication ) | C # program to compute exponential value using ( 2 ^ k ) - ary method . ; prime modulo value ; for cases where exponent is not an even value ; Driver Code"
C#;"using System ; public class GFG { static int factorial ( int x ) { if ( x <= 1 ) return 1 ; int res = 2 ; for ( int i = 3 ; i <= x ; i ++ ) res = res * i ; return res ; } static int gcdOfFactorial ( int m , int n ) { int min = m < n ? m : n ; return factorial ( min ) ; } public static void Main ( ) { int m = 5 , n = 9 ; Console . WriteLine ( gcdOfFactorial ( m , n ) ) ; } }";"GCD of factorials of two numbers | C # program to find GCD of factorial of two numbers . ; Driver program to test above functions"
C#;"using System ; class GFG { static int recDigSum ( int n ) { if ( n == 0 ) return 0 ; else { if ( n % 9 == 0 ) return 9 ; else return n % 9 ; } } static void check ( int n ) { n = recDigSum ( n ) ; if ( n == 2 n == 3 n == 5 n == 7 ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } public static void Main ( ) { int n = 5602 ; check ( n ) ; } }";"Recursive sum of digits of a number is prime or not | C # code to check if recursive sum of digits is prime or not . ; Function for recursive digit sum ; function to check if prime or not the single digit ; calls function which returns sum till single digit ; checking prime ; Driver code"
C#;"using System ; class GFG { static int findNumber ( int n ) { int x = ( int ) Math . Floor ( ( - 1 + Math . Sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ; int Base = ( x * ( x + 1 ) ) / 2 + 1 ; return n - Base + 1 ; } public static void Main ( ) { int n = 55 ; Console . WriteLine ( findNumber ( n ) ) ; } }";"Find n | C # program to find the value at n - th place in the given sequence ; Definition of findNumber function ; Finding x from equation n = x ( x + 1 ) / 2 + 1 ; Base of current block ; Value of n - th element ; Driver code"
C#;"using System ; public class GFG { static int weightedMean ( int n ) { return ( 2 * n + 1 ) / 3 ; } static public void Main ( ) { int n = 10 ; Console . WriteLine ( weightedMean ( n ) ) ; } }";"Program for weighted mean of natural numbers . | Program to find weighted mean of first n natural numbers using formula . ; Returns weighted mean assuming for numbers { 1 , 2 , . . n } and weights { 1 , 2 , . . n } ; Driver program to test the function ."
C#;"using System ; class GFG { static void calculate ( int [ ] a , int [ ] b , int n , int m ) { int mul = 1 ; for ( int i = 0 ; i < m ; i ++ ) if ( b [ i ] != 0 ) mul = mul * b [ i ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = ( int ) Math . Floor ( ( double ) ( a [ i ] / mul ) ) ; Console . Write ( x + "" ▁ "" ) ; } } public static void Main ( ) { int [ ] a = { 5 , 100 , 8 } ; int [ ] b = { 2 , 3 } ; int n = a . Length ; int m = b . Length ; calculate ( a , b , n , m ) ; } }";"Divide every element of one array by other array elements | C # program to find quotient of array elements ; Function to calculate the quotient of every element of the array ; Calculate the product of all elements ; To calculate the quotient of every array element ; Driver code"
C#;"using System ; using System . Collections . Generic ; class GFG { class pair { public int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int findPowerOfP ( int n , int p ) { int count = 0 ; int r = p ; while ( r <= n ) { count += ( n / r ) ; r = r * p ; } return count ; } static List < pair > primeFactorsofK ( int k ) { List < pair > ans = new List < pair > ( ) ; for ( int i = 2 ; k != 1 ; i ++ ) { if ( k % i == 0 ) { int count = 0 ; while ( k % i == 0 ) { k = k / i ; count ++ ; } ans . Add ( new pair ( i , count ) ) ; } } return ans ; } static int largestPowerOfK ( int n , int k ) { List < pair > vec = new List < pair > ( ) ; vec = primeFactorsofK ( k ) ; int ans = int . MaxValue ; for ( int i = 0 ; i < vec . Count ; i ++ ) ans = Math . Min ( ans , findPowerOfP ( n , vec [ i ] . first ) / vec [ i ] . second ) ; return ans ; } public static void Main ( String [ ] args ) { Console . Write ( largestPowerOfK ( 7 , 2 ) + "" STRNEWLINE "" ) ; Console . Write ( largestPowerOfK ( 10 , 9 ) + "" STRNEWLINE "" ) ; } }";"Largest power of k in n ! ( factorial ) where k may not be prime | C # program to find the largest power of k that divides n ! ; To find the power of a prime p in factorial N ; calculating Math . Floor ( n / r ) and adding to the count ; increasing the power of p from 1 to 2 to 3 and so on ; returns all the prime factors of k ; vector to store all the prime factors along with their number of occurrence in factorization of k ; Returns largest power of k that divides n ! ; calculating minimum power of all the prime factors of k ; Driver code"
C#;"using System ; class GFG { static void print ( int n ) { Console . WriteLine ( n + n / 2 ) ; for ( int i = 2 ; i <= n ; i += 2 ) Console . Write ( i + "" ▁ "" ) ; for ( int i = 1 ; i <= n ; i += 2 ) Console . Write ( i + "" ▁ "" ) ; for ( int i = 2 ; i <= n ; i += 2 ) Console . Write ( i + "" ▁ "" ) ; } public static void Main ( ) { int n = 3 ; print ( n ) ; } }";"Minimum number of bombs | C # program to find number of bombings required to kill all aliens . ; function to print where to shoot ; no . of bombs required ; bomb all the even positions ; bomb all the odd positions ; bomb all the even positions again ; Driver code"
C#;"class GFG { static int lcm_fun ( int a , int b ) { if ( b == 0 ) return a ; return lcm_fun ( b , a % b ) ; } static int digitLCM ( int n ) { int lcm = 1 ; while ( n > 0 ) { lcm = ( n % 10 * lcm ) / lcm_fun ( n % 10 , lcm ) ; if ( lcm == 0 ) return 0 ; n = n / 10 ; } return lcm ; } public static void Main ( ) { int n = 397 ; System . Console . WriteLine ( digitLCM ( n ) ) ; } }";"LCM of digits of a given number | C # program to find LCM of digits of a number ; define lcm function ; If at any point LCM become 0. return it ; Driver Code"
C#;"using System ; class GFG { static double e = 2.71828 ; static int roundNo ( float num ) { return ( int ) ( num < 0 ? num - 0.5 : num + 0.5 ) ; } static void printBestCandidate ( int [ ] candidate , int n ) { int sample_size = roundNo ( ( float ) ( n / e ) ) ; Console . WriteLine ( "" STRNEWLINE STRNEWLINE Sample ▁ size ▁ is ▁ "" + sample_size ) ; int best = 0 ; for ( int i = 1 ; i < sample_size ; i ++ ) if ( candidate [ i ] > candidate [ best ] ) best = i ; for ( int i = sample_size ; i < n ; i ++ ) if ( candidate [ i ] >= candidate [ best ] ) { best = i ; break ; } if ( best >= sample_size ) Console . WriteLine ( "" found is "" ( best + 1 ) + "" ▁ with ▁ talent ▁ "" + candidate [ best ] ) ; else Console . Write ( "" Couldn ' t ▁ find ▁ a ▁ best ▁ candidate STRNEWLINE "" ) ; } public static void Main ( String [ ] args ) { int n = 8 ; int [ ] candidate = new int [ n ] ; Random rand = new Random ( ) ; for ( int i = 0 ; i < n ; i ++ ) candidate [ i ] = 1 + rand . Next ( 1 , 8 ) ; Console . Write ( "" Candidate ▁ : ▁ "" ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( i + 1 + "" ▁ "" ) ; Console . WriteLine ( ) ; Console . Write ( "" Talents ▁ : ▁ "" ) ; for ( int i = 0 ; i < n ; i ++ ) Console . Write ( candidate [ i ] + "" ▁ "" ) ; printBestCandidate ( candidate , n ) ; } }";"Secretary Problem ( A Optimal Stopping Problem ) | C # Program to test 1 / e law for Secretary Problem ; To find closest integer of num . ; Finds best candidate using n / e rule . candidate [ ] represents talents of n candidates . ; Calculating sample size for benchmarking . ; Finding best candidate in sample size ; Finding the first best candidate that is better than benchmark set . ; Driver Code ; n = 8 candidates and candidate array contains talents of n candidate where the largest number means highest talented candidate . ; generating random numbers between 1 to 8 for talent of candidate"
C#;"using System ; class GFG { static double u_cal ( double u , int n ) { double temp = u ; for ( int i = 1 ; i < n ; i ++ ) temp = temp * ( u + i ) ; return temp ; } static int fact ( int n ) { int f = 1 ; for ( int i = 2 ; i <= n ; i ++ ) f *= i ; return f ; } static void Main ( ) { int n = 5 ; double [ ] x = { 1891 , 1901 , 1911 , 1921 , 1931 } ; double [ , ] y = new double [ n , n ] ; y [ 0 , 0 ] = 46 ; y [ 1 , 0 ] = 66 ; y [ 2 , 0 ] = 81 ; y [ 3 , 0 ] = 93 ; y [ 4 , 0 ] = 101 ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = n - 1 ; j >= i ; j -- ) y [ j , i ] = y [ j , i - 1 ] - y [ j - 1 , i - 1 ] ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= i ; j ++ ) Console . Write ( y [ i , j ] + "" TABSYMBOL "" ) ; Console . WriteLine ( "" "" ) ; ; } double value = 1925 ; double sum = y [ n - 1 , 0 ] ; double u = ( value - x [ n - 1 ] ) / ( x [ 1 ] - x [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { sum = sum + ( u_cal ( u , i ) * y [ n - 1 , i ] ) / fact ( i ) ; } Console . WriteLine ( "" STRNEWLINE ▁ Value ▁ at ▁ "" + value + "" ▁ is ▁ "" + Math . Round ( sum , 4 ) ) ; } }";"Newton Forward And Backward Interpolation | C # Program to interpolate using newton backward interpolation ; Calculation of u mentioned in formula ; Calculating factorial of given n ; Driver code ; number of values given ; y [ ] [ ] is used for difference table and y [ ] [ 0 ] used for input ; Calculating the backward difference table ; Displaying the backward difference table ; Value to interpolate at ; Initializing u and sum"
C#;"using System ; class GFG { static int sumDigitSquare ( int n ) { int sq = 0 ; while ( n != 0 ) { int digit = n % 10 ; sq += digit * digit ; n = n / 10 ; } return sq ; } static bool isHappy ( int n ) { while ( true ) { if ( n == 1 ) return true ; n = sumDigitSquare ( n ) ; if ( n == 4 ) return false ; } } static public void Main ( ) { int n = 23 ; if ( isHappy ( n ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Happy Numbers | A space optimized C # program to check if a number is happy number ; Returns sum of squares of digits of a number n . For example for n = 12 it returns 1 + 4 = 5 ; Returns true if n is Happy number else returns false . ; Keep replacing n with sum of squares of digits until we either reach 1 or we end up in a cycle ; Number is Happy if we reach 1 ; Replace n with sum of squares of digits ; Number is not Happy if we reach 4 ; Driver code"
C#;"using System ; class GFG { static long findSumSubsets ( int n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( findSumSubsets ( n ) ) ; } }";"Sum of all subsets of a set formed by first n natural numbers | C # program to find sum of all subsets of a set . ; sum of subsets is ( n * ( n + 1 ) / 2 ) * pow ( 2 , n - 1 ) ; Driver code"
C#;"using System ; class GFG { static int findMin ( int [ ] a , int n ) { double sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += Math . Log ( a [ i ] ) ; int x = ( int ) Math . Exp ( sum / n ) ; return x + 1 ; } public static void Main ( ) { int [ ] a = { 3 , 2 , 1 , 4 } ; int n = a . Length ; Console . WriteLine ( findMin ( a , n ) ) ; } }";"Minimum element whose n | C # Code to find Minimum element whose n - th power is greater than product of an array of size n ; function to find the minimum element ; loop to traverse and store the sum of log ; computes sum ; calculates the elements according to formula . ; returns the minimal element ; Driver program to test above function ; initialised array ; computes the size of array ; prints out the minimal element"
C#;"using System ; class GFG { static int countdigits ( int N ) { int count = 0 ; while ( N > 0 ) { count ++ ; N = N / 10 ; } return count ; } static void cyclic ( int N ) { int num = N ; int n = countdigits ( N ) ; while ( true ) { Console . WriteLine ( num ) ; int rem = num % 10 ; int dev = num / 10 ; num = ( int ) ( ( Math . Pow ( 10 , n - 1 ) ) * rem + dev ) ; if ( num == N ) break ; } } public static void Main ( ) { int N = 5674 ; cyclic ( N ) ; } }";"Generate all cyclic permutations of a number | C # Program to generate all cyclic permutations of number ; Function to count the total number of digits in a number . ; Function to generate all cyclic permutations of a number ; Following three lines generates a circular permutation of a number . ; If all the permutations are checked and we obtain original number exit from loop . ; Driver Program"
C#;"using System ; class GFG { static bool isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static bool checkCircular ( int N ) { int count = 0 , temp = N ; while ( temp > 0 ) { count ++ ; temp /= 10 ; } int num = N ; while ( isPrime ( num ) ) { int rem = num % 10 ; int div = num / 10 ; num = ( int ) ( ( Math . Pow ( 10 , count - 1 ) ) * rem ) + div ; if ( num == N ) return true ; } return false ; } public static void Main ( ) { int N = 1193 ; if ( checkCircular ( N ) ) Console . Write ( "" Yes "" ) ; else Console . Write ( "" No "" ) ; } }";"Check whether a number is circular prime or not | C # Program to check if a number is circular prime or not . ; Function to check if a number is prime or not . ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function to check if the number is circular prime or not . ; Count digits . ; Following three lines generate the next circular permutation of a number . We move last digit to first position . ; If all the permutations are checked and we obtain original number exit from loop . ; Driver code"
C#;"using System ; class GFG { static bool sackRace ( int p1 , int s1 , int p2 , int s2 ) { return ( ( s1 > s2 && ( p2 - p1 ) % ( s1 - s2 ) == 0 ) || ( s2 > s1 && ( p1 - p2 ) % ( s2 - s1 ) == 0 ) ) ; } public static void Main ( ) { int p1 = 4 , s1 = 4 , p2 = 8 , s2 = 2 ; if ( sackRace ( p1 , s1 , p2 , s2 ) ) Console . WriteLine ( "" Yes "" ) ; else Console . WriteLine ( "" No "" ) ; } }";"Find if two people ever meet after same number of jumps | C # program to find any one of them can overtake the other ; function to find if any one of them can overtake the other ; Since starting points are always different , they will meet if following conditions are met . ( 1 ) Speeds are not same ( 2 ) Difference between speeds divide the total distance between initial points . ; Driver code"
C#;"using System ; class GFG { public static void solve ( int n ) { double a = n / 2 ; if ( n % 2 != 0 ) { Console . WriteLine ( ( Math . Ceiling ( a ) - 1 ) + "" ▁ "" + ( Math . Floor ( a ) + 1 ) ) ; } else { if ( ( int ) ( a ) % 2 == 0 ) { Console . WriteLine ( ( Math . Ceiling ( a ) - 1 ) + "" ▁ "" + ( Math . Floor ( a ) + 1 ) ) ; } else { Console . WriteLine ( ( Math . Ceiling ( a ) - 2 ) + "" ▁ "" + ( Math . Floor ( a ) + 2 ) ) ; } } } public static void Main ( ) { int n = 34 ; solve ( n ) ; } }";"Largest proper fraction with sum of numerator and denominator equal to a given number | C # program to find the largest fraction a / b such that a + b is equal to given number and a < b . ; Calculate N / 2 ; ; Check if N is odd or even ; If N is odd answer will be ceil ( n / 2 ) - 1 and floor ( n / 2 ) + 1 ; If N is even check if N / 2 i . e a is even or odd ; If N / 2 is even apply the previous formula ; If N / 2 is odd answer will be ceil ( N / 2 ) - 2 and floor ( N / 2 ) + 2 ; Driver code"
C#;"using System ; class GFG { public static void Main ( ) { float P = 1 , R = 1 , T = 1 ; float SI = ( P * T * R ) / 100 ; Console . Write ( "" Simple ▁ interest ▁ = ▁ "" + SI ) ; } }";"Program to find simple interest | A Simple C # program to compute simple interest for given principal amount , time and rate of interest . ; Driver Code ; We can change values here for different inputs ; Calculate simple interest"
C#;"using System ; class GFG { static int countDigits ( int a , int b ) { int count = 0 ; int p = Math . Abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = p / 10 ; } return count ; } public static void Main ( ) { int a = 33 ; int b = - 24 ; Console . WriteLine ( "" Number ▁ of ▁ digits ▁ = ▁ "" + countDigits ( a , b ) ) ; } }";"Number of digits in the product of two numbers | C # implementation to count number of digits in the product of two numbers ; function to count number of digits in the product of two numbers ; absolute value of the product of two numbers ; if product is 0 ; count number of digits in the product ' p ' ; required count of digits ; Driver program to test above"
C#;"using System ; public class GFG { static void multiple ( int a , int b , int x ) { if ( b < 0 ) { if ( a == 1 && x == 1 ) Console . WriteLine ( ""1"" ) ; else Console . WriteLine ( ""0"" ) ; } int mul = ( int ) Math . Pow ( a , b ) ; int ans = mul / x ; int ans1 = x * ans ; int ans2 = x * ( ans + 1 ) ; Console . WriteLine ( ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ) ; } static public void Main ( ) { int a = 349 , b = 1 , x = 4 ; multiple ( a , b , x ) ; } }";"Find multiple of x closest to or a ^ b ( a raised to power b ) | C # Program to find closest multiple of x to a ^ b ; function to find closest multiple of x to a ^ b ; calculate a ^ b / x ; Answer is either ( ans * x ) or ( ans + 1 ) * x ; Printing nearest answer ; Driver Program"
C#;"using System ; public class main { static int maxSum ( int n ) { if ( n == 1 ) return 1 ; else return ( n * ( n - 1 ) / 2 ) - 1 + n / 2 ; } public static void Main ( ) { int n = 3 ; Console . WriteLine ( maxSum ( n ) ) ; } }";"Maximum sum of difference of adjacent elements | C # program to find maximum sum of adjacent elements of permutation of n ; To find max sum of permutation ; Base case ; Otherwise max sum will be ( n * ( n - 1 ) / 2 ) - 1 + n / 2 ; Driver program to test maxSum ( )"
C#;"using System ; public class GFG { static int compute_average ( int a , int b ) { return ( a + b ) / 2 ; } static public void Main ( ) { int a = int . MaxValue ; int b = int . MaxValue ; Console . WriteLine ( "" Actual ▁ average ▁ : ▁ "" + int . MaxValue ) ; Console . WriteLine ( "" Computed ▁ average ▁ : ▁ "" + compute_average ( a , b ) ) ; } }";"Compute average of two numbers without overflow | C # code to compute average of two numbers ; Function to compute average of two numbers ; Driver code ; Assigning maximum integer value ; Average of two equal numbers is the same number ; Function to get the average of 2 numbers"
C#;"using System ; class GFG { static int minNum ( int [ ] arr , int n ) { bool odd = false ; for ( int i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd = ! odd ; if ( odd ) return 1 ; return 2 ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 } ; int n = arr . Length ; Console . Write ( minNum ( arr , n ) ) ; } }";"Add minimum number to an array so that the sum becomes even | C # program to add minimum number so that the sum of array becomes even ; Function to find out minimum number ; Count odd number of terms in array ; Driver Code"
C#;"using System ; class GFG { static bool checkJumbled ( int num ) { if ( num / 10 == 0 ) return true ; while ( num != 0 ) { if ( num / 10 == 0 ) return true ; int digit1 = num % 10 ; int digit2 = ( num / 10 ) % 10 ; if ( Math . Abs ( digit2 - digit1 ) > 1 ) return false ; num = num / 10 ; } return true ; } public static void Main ( ) { int num = - 1234 ; if ( checkJumbled ( num ) ) Console . WriteLine ( "" True ▁ "" ) ; else Console . WriteLine ( "" False ▁ "" ) ; num = - 1247 ; if ( checkJumbled ( num ) ) Console . WriteLine ( "" True "" ) ; else Console . WriteLine ( "" False "" ) ; } }";"Check if a number is jumbled or not | C # code to check if a number is jumbled or not ; Function to check if a number is jumbled or not ; Single digit number ; Checking every digit through a loop ; All digits were checked ; Digit at index i ; Digit at index i - 1 ; If difference is greater than 1 ; Number checked ; Driver code ; - 1234 to be checked ; 287 to be checked"
C#;"using System ; public class GFG { static int msbPos ( int n ) { int pos = 0 ; while ( n != 0 ) { pos ++ ; n = n >> 1 ; } return pos ; } static int josephify ( int n ) { int position = msbPos ( n ) ; int j = 1 << ( position - 1 ) ; n = n ^ j ; n = n << 1 ; n = n | 1 ; return n ; } public static void Main ( ) { int n = 41 ; Console . WriteLine ( josephify ( n ) ) ; } }";"Josephus Problem Using Bit Magic | C # program for Josephus Problem ; Method to find the position of the Most Significant Bit ; keeps shifting bits to the right until we are left with 0 ; method to return at which place Josephus should sit to avoid being killed ; Getting the position of the Most Significant Bit ( MSB ) . The leftmost '1' . If the number is '41' then its binary is '101001' . So msbPos ( 41 ) = 6 ; ' j ' stores the number with which to XOR the number ' n ' . Since we need '100000' We will do 1 << 6 - 1 to get '100000' ; Toggling the Most Significant Bit . Changing the leftmost '1' to '0' . 101001 ^ 100000 = 001001 ( 9 ) ; Left - shifting once to add an extra '0' to the right end of the binary number 001001 = 010010 ( 18 ) ; Toggling the '0' at the end to '1' which is essentially the same as putting the MSB at the rightmost place . 010010 | 1 = 010011 ( 19 ) ; Driver code"
C#;"using System ; public class CountXor { static int countXorPair ( int [ ] arr , int n ) { int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) count ++ ; } return count ; } public static void Main ( ) { int [ ] arr = { 1 , 2 , 3 } ; Console . WriteLine ( countXorPair ( arr , arr . Length ) ) ; } }";"Count pairs with Odd XOR | C # program to count pairs in array whose XOR is odd ; A function will return number of pair whose XOR is odd ; To store count of XOR pair ; If XOR is odd increase count ; Return count ; Driver program to test countXorPair ( )"
C#;"using System ; class GFG { static int powmod ( int x , int y , int p ) { while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } static int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) ( Math . Sqrt ( m ) + 1 ) ; int [ ] value = new int [ m ] ; for ( int i = n ; i >= 1 ; -- i ) value [ powmod ( a , i * n , m ) ] = i ; for ( int j = 0 ; j < n ; ++ j ) { int cur = ( powmod ( a , j , m ) * b ) % m ; if ( value [ cur ] > 0 ) { int ans = value [ cur ] * n - j ; if ( ans < m ) return ans ; } } return - 1 ; } static void Main ( ) { int a = 2 , b = 3 , m = 5 ; Console . WriteLine ( discreteLogarithm ( a , b , m ) ) ; a = 3 ; b = 7 ; m = 11 ; Console . WriteLine ( discreteLogarithm ( a , b , m ) ) ; } }";"Discrete logarithm ( Find an integer k such that a ^ k is congruent modulo b ) | C # program to calculate discrete logarithm ; Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; x = x % p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 ; y = y / 2 ; Function to calculate k for given a , b , m ; Store all values of a ^ ( n * i ) of LHS ; Calculate ( a ^ j ) * b and check for collision ; If collision occurs i . e . , LHS = RHS ; Check whether ans lies below m or not ; Driver code"
C#;"using System ; class GFG { static int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) ( Math . Sqrt ( m ) + 1 ) ; int an = 1 ; for ( int i = 0 ; i < n ; ++ i ) an = ( an * a ) % m ; int [ ] value = new int [ m ] ; for ( int i = 1 , cur = an ; i <= n ; ++ i ) { if ( value [ cur ] == 0 ) value [ cur ] = i ; cur = ( cur * an ) % m ; } for ( int i = 0 , cur = b ; i <= n ; ++ i ) { if ( value [ cur ] > 0 ) { int ans = value [ cur ] * n - i ; if ( ans < m ) return ans ; } cur = ( cur * a ) % m ; } return - 1 ; } static void Main ( ) { int a = 2 , b = 3 , m = 5 ; Console . WriteLine ( discreteLogarithm ( a , b , m ) ) ; a = 3 ; b = 7 ; m = 11 ; Console . WriteLine ( discreteLogarithm ( a , b , m ) ) ; } }";"Discrete logarithm ( Find an integer k such that a ^ k is congruent modulo b ) | C # program to calculate discrete logarithm ; Calculate a ^ n ; Store all values of a ^ ( n * i ) of LHS ; Calculate ( a ^ j ) * b and check for collision ; Driver code"
C#;"using System ; class GFG { static string nthprimedigitsnumber ( int number ) { int rem ; string num = "" "" ; while ( number > 0 ) { rem = number % 4 ; switch ( rem ) { case 1 : num += '2' ; break ; case 2 : num += '3' ; break ; case 3 : num += '5' ; break ; case 0 : num += '7' ; break ; } if ( number % 4 == 0 ) number -- ; number = number / 4 ; } char [ ] st = num . ToCharArray ( ) ; Array . Reverse ( st ) ; return new string ( st ) ; } static void Main ( ) { int number = 21 ; Console . WriteLine ( nthprimedigitsnumber ( 10 ) ) ; Console . WriteLine ( nthprimedigitsnumber ( number ) ) ; } }";"Finding n | C # program to find n - th number with prime digits 2 , 3 and 7 ; remainder for check element position ; if number is 1 st position in tree ; if number is 2 nd position in tree ; if number is 3 rd position in tree ; if number is 4 th position in tree ; Driver code"
C#;"using System ; class Test { static int countPairs ( int N ) { int count = 0 ; for ( int i = 1 ; i <= Math . Pow ( N , ( 1.0 / 3.0 ) ) ; i ++ ) { int cb = i * i * i ; int diff = N - cb ; int cbrtDiff = ( int ) Math . Pow ( diff , ( 1.0 / 3.0 ) ) ; if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) count ++ ; } return count ; } public static void Main ( ) { for ( int i = 1 ; i <= 10 ; i ++ ) Console . Write ( "" For ▁ n ▁ = ▁ "" + i + "" , ▁ "" + + countPairs ( i ) + "" ▁ pair ▁ exists "" + "" STRNEWLINE "" ) ; } }";"Count pairs ( a , b ) whose sum of cubes is N ( a ^ 3 + b ^ 3 = N ) | C # program to count pairs whose sum cubes is N ; method to count the pairs satisfying a ^ 3 + b ^ 3 = N ; Check for each number 1 to cbrt ( N ) ; Store cube of a number ; Subtract the cube from given N ; Check if the difference is also a perfect cube ; If yes , then increment count ; Return count ; Driver method ; Loop to Count no . of pairs satisfying a ^ 3 + b ^ 3 = i for N = 1 to 10"
C#;"using System ; using System . Collections ; using System . Collections . Generic ; class Test { static Dictionary < long , int > primeFactors ( long num ) { Dictionary < long , int > ans = new Dictionary < long , int > ( ) ; for ( long i = 2 ; i * i <= num ; i ++ ) { while ( num % i == 0 ) { num /= i ; if ( ! ans . ContainsKey ( i ) ) { ans [ i ] = 0 ; } ans [ i ] ++ ; } } if ( num > 1 ) { if ( ! ans . ContainsKey ( num ) ) { ans [ num ] = 0 ; } ans [ num ] ++ ; } return ans ; } static long legendre ( long factor , long num ) { long count = 0 , fac2 = factor ; while ( num >= factor ) { count += num / factor ; factor *= fac2 ; } return count ; } static bool possible ( Dictionary < long , int > factors , long num ) { foreach ( int itr in factors . Keys ) { if ( legendre ( itr , num ) < factors [ itr ] ) return false ; } return true ; } static long search ( long start , long end , Dictionary < long , int > factors ) { long mid = ( start + end ) / 2 ; if ( ! possible ( factors , mid ) ) return search ( mid + 1 , end , factors ) ; if ( start == mid ) return mid ; return search ( start , mid , factors ) ; } static long findFact ( long num ) { Dictionary < long , int > factors = primeFactors ( num ) ; return search ( 1 , num , factors ) ; } public static void Main ( ) { Console . WriteLine ( findFact ( 6 ) ) ; Console . WriteLine ( findFact ( 997587429953L ) ) ; } }";"Smallest number S such that N is a factor of S factorial or S ! | C # Program to find factorial that N belongs to ; Calculate prime factors for a given number ; Container for prime factors ; Iterate from 2 to i ^ 2 finding all factors ; If we still have a remainder it is also a prime factor ; Calculate occurrence of an element in factorial of a number ; Iterate through prime factors ; Check if factorial contains less occurrences of prime factor ; Method to binary search 1 to N ; Prime factors are not in the factorial Increase the lowerbound ; We have reached smallest occurrence ; Smaller factorial satisfying requirements may exist , decrease upperbound ; Calculate prime factors and search ; Driver method"
C#;"using System ; using System . Collections ; class Test { static void printEqualModNumbers ( int [ ] arr , int n ) { Array . Sort ( arr ) ; int d = arr [ n - 1 ] - arr [ 0 ] ; if ( d == 0 ) { Console . write ( "" Infinite ▁ solution "" ) ; return ; } ArrayList v = new ArrayList ( ) ; for ( int i = 1 ; i * i <= d ; i ++ ) { if ( d % i == 0 ) { v . Add ( i ) ; if ( i != d / i ) v . Add ( d / i ) ; } } for ( int i = 0 ; i < v . Count ; i ++ ) { int temp = arr [ 0 ] % ( int ) v [ i ] ; int j ; for ( j = 1 ; j < n ; j ++ ) if ( arr [ j ] % ( int ) v [ i ] != temp ) break ; if ( j == n ) Console . Write ( v [ i ] + "" ▁ "" ) ; } } public static void Main ( ) { int [ ] arr = { 38 , 6 , 34 } ; printEqualModNumbers ( arr , arr . Length ) ; } }";"Finding ' k ' such that its modulus with each array element is same | C # implementation of finding all k such that arr [ i ] % k is same for each i ; Prints all k such that arr [ i ] % k is same for all i ; sort the numbers ; max difference will be the difference between first and last element of sorted array ; Case when all the array elements are same ; Find all divisors of d and store in a vector v [ ] ; check for each v [ i ] if its modulus with each array element is same or not ; checking for each array element if its modulus with k is equal to k or not ; if check is true print v [ i ] ; Driver method"
C#;"using System ; public class GFG { static int FirstDigit ( int [ ] arr , int n ) { double S = 0 ; for ( int i = 0 ; i < n ; i ++ ) S = S + Math . Log10 ( arr [ i ] * 1.0 ) ; double fract_S = S - Math . Floor ( S ) ; int ans = ( int ) Math . Pow ( 10 , fract_S ) ; return ans ; } public static void Main ( ) { int [ ] arr = { 5 , 8 , 3 , 7 } ; int n = arr . Length ; Console . WriteLine ( FirstDigit ( arr , n ) ) ; } }";"First digit in product of an array of numbers | C # implementation of finding first digit of product of n numbers ; returns the first digit of product of elements of arr [ ] ; stores the logarithm of product of elements of arr [ ] ; fractional ( s ) = s - floor ( s ) ; ans = 10 ^ fract_s ; Driver method"
C#;"using System ; class GFG { static int countDigit ( int n ) { int temp = n , count = 0 ; while ( temp != 0 ) { int d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) count ++ ; } return count ; } public static void Main ( ) { int n = 1012 ; Console . Write ( countDigit ( n ) ) ; } }";"Find count of digits in a number that divide the number | C # program to count number of digits that divides the number . ; Return the number of digits that divides the number . ; Fetching each digit of the number ; Checking if digit is greater than 0 and can divides n . ; Driver method"
C#;"using System ; class GFG { static int makeOdd ( int n ) { if ( n % 2 != 0 ) return 1 ; int ans = 1 ; while ( n % 2 == 0 ) { n /= 2 ; ans *= 2 ; } return ans ; } public static void Main ( ) { int n = 36 ; int res = makeOdd ( n ) ; Console . Write ( res ) ; } }";"Minimum positive integer to divide a number such that the result is an odd | C # program to make a number odd ; Function to find the value ; Return 1 if already odd ; Check how many times it is divided by 2 ; Driver code"
C#;"using System ; class Solution { static int closestMultiple ( int n , int x ) { if ( x > n ) return x ; n = n + x / 2 ; n = n - ( n % x ) ; return n ; } public static void Main ( ) { int n = 56287 , x = 27 ; Console . WriteLine ( closestMultiple ( n , x ) ) ; } }";"Multiple of x closest to n | C # program to calculate smallest multiple of x closest to a given number ; Function to calculate the smallest multiple ; Driver program"
C#;"using System ; class GFG { static void printCubes ( int a , int b ) { int acrt = ( int ) Math . Pow ( a , ( double ) 1 / 3 ) ; int bcrt = ( int ) Math . Pow ( b , ( double ) 1 / 3 ) ; for ( int i = acrt ; i <= bcrt ; i ++ ) if ( i * i * i >= a && i * i * i <= b ) Console . Write ( i * i * i + "" ▁ "" ) ; } static public void Main ( ) { int a = 24 ; int b = 576 ; Console . WriteLine ( "" Perfect ▁ cubes ▁ "" + "" in ▁ given ▁ range : "" ) ; printCubes ( a , b ) ; } }";"Perfect cubes in a range | C # progroam for Efficient method to print cubes between a and b ; An efficient solution to print perfect cubes between a and b ; Find cube root of both a and b ; Print cubes between acrt and bcrt ; Driver Code"
C#;"using System ; class GFG { static int number0f2s ( int n ) { int count = 0 ; while ( n > 0 ) { if ( n % 10 == 2 ) count ++ ; n = n / 10 ; } return count ; } static int numberOf2sinRange ( int n ) { int count = 0 ; for ( int i = 2 ; i <= n ; i ++ ) count += number0f2s ( i ) ; return count ; } public static void Main ( ) { Console . Write ( numberOf2sinRange ( 22 ) ) ; Console . WriteLine ( ) ; Console . Write ( numberOf2sinRange ( 100 ) ) ; } }";"Number of occurrences of 2 as a digit in numbers from 0 to n | C # program to count 2 s from 0 to n ; Counts the number of '2' digits in a single number ; Counts the number of '2' digits between 0 and n ; Initialize result ; Count 2 's in every number  from 2 to n ; Driver code"
C#;"using System ; class GFG { static int minToggle ( int [ ] arr , int n ) { int [ ] zero = new int [ n + 1 ] ; zero [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; ++ i ) { if ( arr [ i - 1 ] == 0 ) zero [ i ] = zero [ i - 1 ] + 1 ; else zero [ i ] = zero [ i - 1 ] ; } int ans = n ; for ( int i = 1 ; i <= n ; ++ i ) ans = Math . Min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) ; return ans ; } public static void Main ( ) { int [ ] arr = { 1 , 0 , 1 , 1 , 0 } ; int n = arr . Length ; Console . WriteLine ( minToggle ( arr , n ) ) ; } }";"Minimum toggles to partition a binary array so that it has first 0 s then 1 s | C # program to find minimum toggle required ; Function to calculate minimum toggling required by using Dynamic programming ; Fill entries in zero [ ] such that zero [ i ] stores count of zeroes to the left of i ( exl ; If zero found update zero [ ] array ; Finding the minimum toggle required from every index ( 0 to n - 1 ) ; Driver Program"
C#;"using System ; class GFG { static bool check ( String str ) { int n = str . Length ; if ( ( str [ n - 1 ] - '0' ) % 2 != 0 ) return false ; int digitSum = 0 ; for ( int i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - '0' ) ; return ( digitSum % 3 == 0 ) ; } public static void Main ( ) { String str = ""1332"" ; if ( check ( str ) ) Console . Write ( "" Yes "" ) ; else Console . Write ( "" No "" ) ; } }";"Check if a large number is divisible by 6 or not | C # program to find if a number is divisible by 6 or not ; Function to find that number divisible by 6 or not ; Return false if number is not divisible by 2. ; Compute sum of digits ; Check if sum of digits is divisible by 3 ; main function"
C#;"using System ; class Solution { static int res = 0 ; static int checkRecursive ( int num , int x , int k , int n ) { if ( x == 0 ) res ++ ; int r = ( int ) Math . Floor ( Math . Pow ( num , 1.0 / n ) ) ; for ( int i = k + 1 ; i <= r ; i ++ ) { int a = x - ( int ) Math . Pow ( i , n ) ; if ( a >= 0 ) checkRecursive ( num , x - ( int ) Math . Pow ( i , n ) , i , n ) ; } return res ; } static int check ( int x , int n ) { return checkRecursive ( x , x , 0 , n ) ; } public static void Main ( ) { Console . WriteLine ( check ( 10 , 2 ) ) ; } }";"Find ways an Integer can be expressed as sum of n | C # program to find number of ways to express a number as sum of n - th powers of numbers . ; Wrapper over checkRecursive ( ) ; Driver code"
C#;"using System ; class GFG { static int reverseNum ( int n ) { int rem , rev = 0 ; while ( n > 0 ) { rem = n % 10 ; rev = rev * 10 + rem ; n /= 10 ; } return rev ; } static bool isPalindrom ( int num ) { return num == reverseNum ( num ) ; } static int nthPalindrome ( int n , int k ) { int num = ( int ) Math . Pow ( 10 , k - 1 ) ; while ( true ) { if ( isPalindrom ( num ) ) -- n ; if ( n == 0 ) break ; ++ num ; } return num ; } public static void Main ( ) { int n = 6 , k = 5 ; Console . WriteLine ( n + "" th ▁ palindrome ▁ of ▁ "" + k + "" ▁ digit ▁ = ▁ "" + nthPalindrome ( n , k ) ) ; n = 10 ; k = 6 ; Console . WriteLine ( n + "" th ▁ palindrome ▁ of ▁ "" + k + "" ▁ digit ▁ = ▁ "" + nthPalindrome ( n , k ) ) ; } }";"N 'th palindrome of K digits | A naive approach of C # program of finding nth palindrome of k digit ; Utility function to reverse the number n ; Boolean Function to check for palindromic number ; Function for finding nth palindrome of k digits ; Get the smallest k digit number ; check the number is palindrom or not ; if n 'th palindrome found break the loop ; Increment number for checking next palindrome ; Driver code"
C#;"using System ; class GFG { static void nthPalindrome ( int n , int k ) { int temp = ( k & 1 ) != 0 ? ( k / 2 ) : ( k / 2 - 1 ) ; int palindrome = ( int ) Math . Pow ( 10 , temp ) ; palindrome += n - 1 ; Console . Write ( palindrome ) ; if ( ( k & 1 ) > 0 ) palindrome /= 10 ; while ( palindrome > 0 ) { Console . Write ( palindrome % 10 ) ; palindrome /= 10 ; } Console . WriteLine ( "" "" ) ; } static public void Main ( ) { int n = 6 , k = 5 ; Console . Write ( n + "" th ▁ palindrome ▁ of ▁ "" + k + "" ▁ digit ▁ = ▁ "" ) ; nthPalindrome ( n , k ) ; n = 10 ; k = 6 ; Console . Write ( n + "" th ▁ palindrome ▁ of ▁ "" + k + "" ▁ digit ▁ = ▁ "" ) ; nthPalindrome ( n , k ) ; } }";"N 'th palindrome of K digits | C # program of finding nth palindrome of k digit ; Determine the first half digits ; Print the first half digits of palindrome ; If k is odd , truncate the last digit ; print the last half digits of palindrome ; Driver code"
C#;"using System ; public class GFG { static int findMax ( int n , int [ ] a , int [ ] b , int [ ] k , int m ) { int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { int lowerbound = a [ i ] ; int upperbound = b [ i ] ; for ( int j = lowerbound ; j <= upperbound ; j ++ ) arr [ j ] += k [ i ] ; } int res = Int32 . MinValue ; for ( int i = 0 ; i < n ; i ++ ) res = Math . Max ( res , arr [ i ] ) ; return res ; } static public void Main ( ) { int n = 5 ; int [ ] a = { 0 , 1 , 2 } ; int [ ] b = { 1 , 4 , 3 } ; int [ ] k = { 100 , 100 , 100 } ; int m = a . Length ; Console . WriteLine ( "" Maximum ▁ value ▁ after ▁ ' m ' ▁ "" + "" operations ▁ is ▁ "" + findMax ( n , a , b , k , m ) ) ; } }";"Maximum value in an array after m range increment operations | C # implementation of simple approach to find maximum value after m range increments . ; Function to find the maximum element after m operations ; Start performing m operations ; Store lower and upper index i . e . range ; Add ' k [ i ] ' value at this operation to whole range ; Find maximum value after all operations and return ; Driver Code ; Number of values ; Value of k to be added at each operation"
C#;"using System ; class GFG { static int MAX = 100001 ; static long [ ] phi = new long [ MAX ] ; static long [ ] result = new long [ MAX ] ; static void computeTotient ( ) { phi [ 1 ] = 1 ; for ( int i = 2 ; i < MAX ; i ++ ) { if ( phi [ i ] == 0 ) { phi [ i ] = i - 1 ; for ( int j = ( i << 1 ) ; j < MAX ; j += i ) { if ( phi [ j ] == 0 ) phi [ j ] = j ; phi [ j ] = ( phi [ j ] / i ) * ( i - 1 ) ; } } } } static void sumOfGcdPairs ( ) { computeTotient ( ) ; for ( int i = 1 ; i < MAX ; ++ i ) { for ( int j = 2 ; i * j < MAX ; ++ j ) result [ i * j ] += i * phi [ j ] ; } for ( int i = 2 ; i < MAX ; i ++ ) result [ i ] += result [ i - 1 ] ; } public static void Main ( ) { sumOfGcdPairs ( ) ; int N = 4 ; Console . WriteLine ( "" Summation ▁ of ▁ "" + N + "" ▁ = ▁ "" + result [ N ] ) ; N = 12 ; Console . WriteLine ( "" Summation ▁ of ▁ "" + N + "" ▁ = ▁ "" + result [ N ] ) ; N = 5000 ; Console . Write ( "" Summation ▁ of ▁ "" + N + "" ▁ = ▁ "" + + result [ N ] ) ; } }";"Summation of GCD of all the pairs up to N | C # approach of finding sum of GCD of all pairs . ; phi [ i ] stores euler totient function for i result [ j ] stores result for value j ; Precomputation of phi [ ] numbers . Refer below link for details : https : goo . gl / LUqdtY ; Refer https : goo . gl / LUqdtY ; Precomputes result for all numbers till MAX ; Precompute all phi value ; Iterate throght all the divisors of i . ; Add summation of previous calculated sum ; Driver code ; Function to calculate sum of all the GCD pairs"
C#;"using System ; using System . Collections ; class GFG { static final int N = 3 ; static ArrayList solve ( int [ ] v ) { ArrayList res = new ArrayList ( ) ; int all3 = v [ 0 ] + v [ 1 ] + v [ 2 ] ; res . Add ( all3 - v [ 1 ] * 2 ) ; res . Add ( all3 - v [ 2 ] * 2 ) ; res . Add ( all3 - v [ 0 ] * 2 ) ; return res ; } static void findVertex ( int [ ] xmid , int [ ] ymid ) { ArrayList V1 = solve ( xmid ) ; ArrayList V2 = solve ( ymid ) ; for ( int i = 0 ; i < 3 ; i ++ ) { Console . WriteLine ( V1 [ i ] + "" ▁ "" + V2 [ i ] ) ; } } public static void Main ( ) { int [ ] xmid = { 5 , 4 , 5 } ; int [ ] ymid = { 3 , 4 , 5 } ; findVertex ( xmid , ymid ) ; } }";"Find coordinates of the triangle given midpoint of each side | C # program to find coordinate of the triangle given midpoint of each side ; Return after solving the equations and finding the vertices coordinate . ; Finding sum of all three coordinate . ; Solving the equation . ; Finds vertices of a triangles from given middle vertices . ; Find X coordinates of vertices . ; Find Y coordinates of vertices . ; Output the solution . ; Driver code"
C#;"using System ; using System . Collections ; class GFG { static int nthElement ( int a , int b , int n ) { ArrayList seq = new ArrayList ( ) ; for ( int i = 1 ; i <= n ; i ++ ) seq . Add ( a * i ) ; seq . Sort ( ) ; for ( int i = 1 , k = n ; i <= n && k > 0 ; i ++ ) { if ( ! seq . Contains ( b * i ) ) { seq . Add ( b * i ) ; seq . Sort ( ) ; k -- ; } } return ( int ) seq [ n - 1 ] ; } static void Main ( ) { int a = 3 , b = 5 , n = 5 ; Console . WriteLine ( nthElement ( a , b , n ) ) ; } }";"N | C # program to find n - th number in the sorted list of multiples of two numbers . ; Return the n - th number in the sorted list of multiples of two numbers . ; Generating first n multiple of a . ; Sorting the sequence . ; Generating and storing first n multiple of b and storing if not present in the sequence . ; If not present in the sequence ; Storing in the sequence . ; Driver Code"
C#;"using System ; class GFG { static int gcd ( int a , int b ) { return b > 0 ? gcd ( b , a % b ) : a ; } static int countGCD ( int L , int R , int g ) { L = ( L + g - 1 ) / g ; R = R / g ; int ans = 0 ; for ( int i = L ; i <= R ; i ++ ) for ( int j = L ; j <= R ; j ++ ) if ( gcd ( i , j ) == 1 ) ans ++ ; return ans ; } public static void Main ( ) { int L = 1 , R = 11 , g = 5 ; Console . WriteLine ( countGCD ( L , R , g ) ) ; } }";"Count pairs of natural numbers with GCD equal to given number | C # program to count pair in range of natural number having GCD equal to given number . ; Return the GCD of two numbers . ; Return the count of pairs having GCD equal to g . ; Setting the value of L , R . ; For each possible pair check if GCD is 1. ; Driver code"
C#;"using System ; class GFG { static int [ ] dig = { 1 , 1 , 2 , 6 , 4 , 2 , 2 , 4 , 2 , 8 } ; static int lastNon0Digit ( int n ) { if ( n < 10 ) return dig [ n ] ; if ( ( ( n / 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( n / 5 ) * dig [ n % 10 ] ) % 10 ; } public static void Main ( ) { int n = 14 ; Console . Write ( lastNon0Digit ( n ) ) ; } }";"Last non | C # program to find last non - zero digit in n ! ; Initialize values of last non - zero digit of numbers from 0 to 9 ; Check whether tens ( or second last ) digit is odd or even If n = 375 , So n / 10 = 37 and ( n / 10 ) % 10 = 7 Applying formula for even and odd cases . ; Driver code"
C#;"using System ; class GFG { static int gcd ( int a , int b ) { if ( ( a % b ) == 0 ) return b ; return gcd ( b , a % b ) ; } static int firstFactorialDivisibleNumber ( int x ) { int new_x = x ; for ( i = 1 ; i < x ; i ++ ) { new_x /= gcd ( i , new_x ) ; if ( new_x == 1 ) break ; } return i ; } public static void Main ( ) { int x = 16 ; Console . Write ( firstFactorialDivisibleNumber ( x ) ) ; } }";"Find the first natural number whose factorial is divisible by x | Efficient C # program to find first natural number whose factorial divides x . ; GCD function to compute the greatest divisor among a and b ; Returns first number whose factorial divides x . ; int i = 1 ; Result ; Remove common factors ; We found first i . ; Driver code"
C#;"using System ; class GFG { static void sieve ( bool [ ] prime , int n ) { for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = true ; } } static int maxDigitInPrimes ( int L , int R ) { bool [ ] prime = new bool [ R + 1 ] ; for ( int i = 0 ; i < R + 1 ; i ++ ) prime [ i ] = false ; sieve ( prime , R ) ; int [ ] freq = new int [ 10 ] ; for ( int i = L ; i <= R ; i ++ ) { if ( ! prime [ i ] ) { while ( p > 0 ) { freq [ p % 10 ] ++ ; p /= 10 ; } } } int max = freq [ 0 ] , ans = 0 ; for ( int j = 1 ; j < 10 ; j ++ ) { if ( max <= freq [ j ] ) { max = freq [ j ] ; ans = j ; } } return ( max != 0 ) ? ans : - 1 ; } public static void Main ( ) { int L = 1 , R = 20 ; Console . Write ( maxDigitInPrimes ( L , R ) ) ; } }";"Find the highest occurring digit in prime numbers in a range | C # program to find the highest occurring digit in prime numbers in a range L to R . ; Sieve of Eratosthenes ; Returns maximum occurring digits in primes from l to r . ; Finding the prime number up to R . ; Initialise frequency of all digit to 0. ; For all number between L to R , check if prime or not . If prime , incrementing the frequency of digits present in the prime number . ; int p = i ; If i is prime ; Finding digit with highest frequency . ; Driver code"
C#;"using System ; class GFG { static bool [ ] arr = new bool [ 1001 ] ; static void simpleSieve ( ) { for ( int i = 0 ; i < 1001 ; i ++ ) arr [ i ] = true ; for ( int p = 2 ; p * p < 1001 ; p ++ ) { if ( arr [ p ] ) { for ( int i = p * 2 ; i < 1001 ; i = i + p ) arr [ i ] = false ; } } } static int find_sphene ( int N ) { int [ ] arr1 = new int [ 8 ] ; int count = 0 ; int j = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( N % i == 0 && count < 8 ) { count ++ ; arr1 [ j ++ ] = i ; } } if ( count == 8 && ( arr [ arr1 [ 1 ] ] && arr [ arr1 [ 2 ] ] && arr [ arr1 [ 3 ] ] ) ) return 1 ; return 0 ; } public static void Main ( String [ ] args ) { int n = 60 ; simpleSieve ( ) ; int ans = find_sphene ( n ) ; if ( ans == 1 ) Console . Write ( "" Yes "" ) ; else Console . Write ( "" NO "" ) ; } }";"Sphenic Number | C # program to check whether a number is a Sphenic number or not ; Create a global array of size 10001 ; ; This functions finds all primes smaller than ' limit ' . Using simple sieve of eratosthenes . ; Initialize all entries of it as true . A value in mark [ p ] will finally be false if ' p ' is Not a prime , else true . ; One by one traverse all numbers so that their multiples can be marked as composite . ; If p is not changed , then it is a prime ; Update all multiples of p ; To store the 8 divisors ; To count the number of divisor ; Finally check if there re 8 divisor and all the numbers are distinct prime no return 1 else return 0 ) ; ; Driver code"
C#;"using System ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } static int commDiv ( int a , int b ) { int n = gcd ( a , b ) ; int result = 0 ; for ( int i = 1 ; i <= Math . Sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) result += 1 ; else result += 2 ; } } return result ; } public static void Main ( String [ ] args ) { int a = 12 , b = 24 ; Console . Write ( commDiv ( a , b ) ) ; } }";"Common Divisors of Two Numbers | C # implementation of program ; method to calculate gcd of two numbers ; method to calculate all common divisors of two given numbers a , b -- > input integer numbers ; find gcd of a , b ; Count divisors of n . ; if ' i ' is factor of n ; check if divisors are equal ; Driver method"
C#;"using System ; class GFG { static long spellsCount ( String num ) { int n = num . Length ; long result = 1 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; while ( i < n - 1 && num [ i + 1 ] == num [ i ] ) { count ++ ; i ++ ; } result = result * ( long ) Math . Pow ( 2 , count - 1 ) ; } return result ; } public static void Main ( ) { String num = ""11112"" ; Console . Write ( spellsCount ( num ) ) ; } }";"Count ways to spell a number with repeated digits | C # program to count number of ways we can spell a number ; Function to calculate all possible spells of a number with repeated digits num -- > string which is favourite number ; final count of total possible spells ; iterate through complete number ; count contiguous frequency of particular digit num [ i ] ; Compute 2 ^ ( count - 1 ) and multiply with result ; Driver code"
C#;"using System ; class GFG { static int numSquareSum ( int n ) { int squareSum = 0 ; while ( n != 0 ) { squareSum += ( n % 10 ) * ( n % 10 ) ; n /= 10 ; } return squareSum ; } static bool isHappynumber ( int n ) { int slow , fast ; slow = fast = n ; do { slow = numSquareSum ( slow ) ; fast = numSquareSum ( numSquareSum ( fast ) ) ; } while ( slow != fast ) ; return ( slow == 1 ) ; } public static void Main ( ) { int n = 13 ; if ( isHappynumber ( n ) ) Console . WriteLine ( n + "" ▁ is ▁ a ▁ Happy ▁ number "" ) ; else Console . WriteLine ( n + "" ▁ is ▁ not ▁ a ▁ Happy ▁ number "" ) ; } }";"Happy Number | C # program to check a number is a Happy number or not ; Utility method to return sum of square of digit of n ; method return true if n is Happy number ; initialize slow and fast by n ; move slow number by one iteration ; move fast number by two iteration ; if both number meet at 1 , then return true ; Driver code"
C#;"using System ; using System . Collections ; class GFG { static ArrayList allPrimes = new ArrayList ( ) ; static void sieve ( int n ) { bool [ ] prime = new bool [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( int p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) allPrimes . Add ( p ) ; } static int factorialDivisors ( int n ) { int result = 1 ; for ( int i = 0 ; i < allPrimes . Count ; i ++ ) { int p = ( int ) allPrimes [ i ] ; int exp = 0 ; while ( p <= n ) { exp = exp + ( n / p ) ; p = p * ( int ) allPrimes [ i ] ; } result = result * ( exp + 1 ) ; } return result ; } public static void Main ( ) { Console . WriteLine ( factorialDivisors ( 6 ) ) ; } }";"Count Divisors of Factorial | C # program to find count of divisors in n ! ; allPrimes [ ] stores all prime numbers less than or equal to n . ; Fills above vector allPrimes [ ] for a given n ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is not a prime , else true . ; Loop to update prime [ ] ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Store primes in the vector allPrimes ; Function to find all result of factorial number ; Initialize result ; find exponents of all primes which divides n and less than n ; Current divisor ; Find the highest power ( stored in exp ) ' ▁ ▁ of ▁ allPrimes [ i ] ▁ that ▁ divides ▁ n ▁ using ▁ ▁ Legendre ' s formula . ; Multiply exponents of all primes less than n ; return total divisors ; Driver code"
C#;"using System ; class GFG { static int nonFibonacci ( int n ) { int prevPrev = 1 , prev = 2 , curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; curr = prevPrev + prev ; n = n - ( curr - prev - 1 ) ; } n = n + ( curr - prev - 1 ) ; return prev + n ; } public static void Main ( ) { Console . WriteLine ( nonFibonacci ( 5 ) ) ; } }";"Non Fibonacci Numbers | C # program to find n 'th Fibonacci number ; Returns n 'th Non-  Fibonacci number ; curr is to keep track of current fibonacci number , prev is previous , prevPrev is previous of previous . ; While count of non - fibonacci numbers doesn 't become  negative or zero ; Simple Fibonacci number logic ; ( curr - prev - 1 ) is count of non - Fibonacci numbers between curr and prev . ; n might be negative now . Make sure it becomes positive by removing last added gap . ; Now add the positive n to previous Fibonacci number to find the n 'th non-fibonacci. ; Driver Code"
C#;"using System ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; int k ; for ( k = 0 ; ( ( a b ) & 1 ) == 0 ; ++ k ) { a >>= 1 ; b >>= 1 ; } while ( ( a & 1 ) == 0 ) a >>= 1 ; do { while ( ( b & 1 ) == 0 ) b >>= 1 ; if ( a > b ) { int temp = a ; a = b ; b = temp ; } b = ( b - a ) ; } while ( b != 0 ) ; return a << k ; } public static void Main ( ) { int a = 34 , b = 17 ; Console . Write ( "" Gcd ▁ of ▁ given ▁ "" + "" numbers ▁ is ▁ "" + gcd ( a , b ) ) ; } }";"Stein 's Algorithm for finding GCD | Iterative C # program to implement Stein 's Algorithm ; Function to implement Stein 's  Algorithm ; GCD ( 0 , b ) == b ; GCD ( a , 0 ) == a , GCD ( 0 , 0 ) == 0 ; Finding K , where K is the greatest power of 2 that divides both a and b ; Dividing a by 2 until a becomes odd ; From here on , ' a ' is always odd ; If b is even , remove all factor of 2 in b ; Now a and b are both odd . Swap if necessary so a <= b , then set b = b - a ( which is even ) . ; restore common factors of 2 ; Driver code"
C#;"using System ; class GFG { static void findNDigitNumsUtil ( int n , char [ ] ou , int index , int evenSum , int oddSum ) { if ( index > n ) return ; if ( index == n ) { if ( Math . Abs ( evenSum - oddSum ) == 1 ) { ou [ index ] = ' \0' ; Console . Write ( ou ) ; Console . Write ( "" ▁ "" ) ; } return ; } if ( index % 2 != 0 ) { for ( int i = 0 ; i <= 9 ; i ++ ) { ou [ index ] = ( char ) ( i + '0' ) ; findNDigitNumsUtil ( n , ou , index + 1 , evenSum , oddSum + i ) ; } } { for ( int i = 0 ; i <= 9 ; i ++ ) { ou [ index ] = ( char ) ( i + '0' ) ; findNDigitNumsUtil ( n , ou , index + 1 , evenSum + i , oddSum ) ; } } } static void findNDigitNums ( int n ) { char [ ] ou = new char [ n + 1 ] ; int index = 0 ; int evenSum = 0 , oddSum = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) { ou [ index ] = ( char ) ( i + '0' ) ; findNDigitNumsUtil ( n , ou , index + 1 , evenSum + i , oddSum ) ; } } public static void Main ( ) { int n = 3 ; findNDigitNums ( n ) ; } }";"Print all n | C # program to print all n - digit numbers with absolute difference between sum of even and odd digits is 1 ; n -- > value of input out -- > output array index -- > index of next digit to be filled in output array evenSum , oddSum -- > sum of even and odd digits so far ; Base case ; If number becomes n - digit ; if absolute difference between sum of even and odd digits is 1 , print the number ; If current index is odd , then add it to odd sum and recurse ; else else add to even sum and recurse ; This is mainly a wrapper over findNDigitNumsUtil . It explicitly handles leading digit and calls findNDigitNumsUtil ( ) for remaining indexes ; output array to store n - digit numbers ; Initialize number index considered so far ; Initialize even and odd sums ; Explicitly handle first digit and call recursive function findNDigitNumsUtil for remaining indexes . Note that the first digit is considered to be present in even position ; Driver program"
C#;"using System ; class GFG { static string [ ] one = { "" "" , "" one ▁ "" , "" two ▁ "" , "" three ▁ "" , "" four ▁ "" , "" five ▁ "" , "" six ▁ "" , "" seven ▁ "" , "" eight ▁ "" , "" nine ▁ "" , "" ten ▁ "" , "" eleven ▁ "" , "" twelve ▁ "" , "" thirteen ▁ "" , "" fourteen ▁ "" , "" fifteen ▁ "" , "" sixteen ▁ "" , "" seventeen ▁ "" , "" eighteen ▁ "" , "" nineteen ▁ "" } ; static string [ ] ten = { "" "" , "" "" , "" twenty ▁ "" , "" thirty ▁ "" , "" forty ▁ "" , "" fifty ▁ "" , "" sixty ▁ "" , "" seventy ▁ "" , "" eighty ▁ "" , "" ninety ▁ "" } ; static string numToWords ( int n , string s ) { string str = "" "" ; if ( n > 19 ) { str += ten [ n / 10 ] + one [ n % 10 ] ; } else { str += one [ n ] ; } if ( n != 0 ) { str += s ; } return str ; } static string convertToWords ( long n ) { string out1 = "" "" ; out1 += numToWords ( ( int ) ( n / 10000000 ) , "" crore ▁ "" ) ; out1 += numToWords ( ( int ) ( ( n / 100000 ) % 100 ) , "" lakh ▁ "" ) ; out1 += numToWords ( ( int ) ( ( n / 1000 ) % 100 ) , "" thousand ▁ "" ) ; out1 += numToWords ( ( int ) ( ( n / 100 ) % 10 ) , "" hundred ▁ "" ) ; if ( n > 100 && n % 100 > 0 ) { out1 += "" and ▁ "" ; } out1 += numToWords ( ( int ) ( n % 100 ) , "" "" ) ; return out1 ; } static void Main ( ) { long n = 438237764 ; Console . WriteLine ( convertToWords ( n ) ) ; } }";"Program to convert a given number to words | Set 2 | C # program to print a given number in words . The program handles till 9 digits numbers and can be easily extended to 20 digit number ; strings at index 0 is not used , it is to make array indexing simple ; strings at index 0 and 1 are not used , they is to make array indexing simple ; n is 1 - or 2 - digit number ; if n is more than 19 , divide it ; if n is non - zero ; Function to print a given number in words ; stores word representation of given number n ; handles digits at ten millions and hundred millions places ( if any ) ; handles digits at hundred thousands and one millions places ( if any ) ; handles digits at thousands and tens thousands places ( if any ) ; handles digit at hundreds places ( if any ) ; handles digits at ones and tens places ( if any ) ; Driver code ; long handles upto 9 digit no change to unsigned long long int to handle more digit number ; convert given number in words"
C#;"using System ; public class GFG { public static long countEvenSum ( int [ ] a , int n ) { long res = 0 ; int s = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] % 2 == 1 ) { s = n - i - 1 - s ; } else { s = s + 1 ; } res = res + s ; } return res ; } static public void Main ( ) { int [ ] arr = { 1 , 2 , 2 , 3 , 4 , 1 } ; int n = arr . Length ; Console . WriteLine ( "" The ▁ Number ▁ of ▁ Subarrays "" + "" ▁ with ▁ even ▁ sum ▁ is ▁ "" + countEvenSum ( arr , n ) ) ; } }";"Find number of subarrays with even sum | C # program to count number of sub - arrays with even sum using an efficient algorithm Time Complexity - O ( N ) Space Complexity - O ( 1 ) ; result may be large enough not to fit in int ; ; to keep track of subarrays with even sum starting from index i ; if a [ i ] is odd then all subarrays starting from index i + 1 which was odd becomeseven when a [ i ] gets added to it . ; if a [ i ] is even then all subarrays starting from index i + 1 which was even remainseven and one extra a [ i ] even subarray gets added to it . ; Driver Code"
C#;"using System ; class GFG { static int gcd ( int a , int b ) { return ( a % b == 0 ) ? Math . Abs ( b ) : gcd ( b , a % b ) ; } static bool isPossible ( int a , int b , int c ) { return ( c % gcd ( a , b ) == 0 ) ; } public static void Main ( ) { int a = 3 , b = 6 , c = 9 ; if ( isPossible ( a , b , c ) ) Console . WriteLine ( "" Possible "" ) ; else Console . WriteLine ( "" Not ▁ Possible "" ) ; a = 3 ; b = 6 ; c = 8 ; if ( isPossible ( a , b , c ) ) Console . WriteLine ( "" Possible "" ) ; else Console . WriteLine ( "" Not ▁ Possible "" ) ; a = 2 ; b = 5 ; c = 1 ; if ( isPossible ( a , b , c ) ) Console . WriteLine ( "" Possible "" ) ; else Console . WriteLine ( "" Not ▁ Possible "" ) ; } }";"Linear Diophantine Equations | C # program to check for solutions of diophantine equations ; Utility function to find the GCD of two numbers ; This function checks if integral solutions are possible ; Driver Code ; First example ; Second example ; Third example"
C#;"using System ; public class GFG { static void farey ( int n ) { double x1 = 0 , y1 = 1 , x2 = 1 , y2 = n ; Console . Write ( "" { 0 : F0 } / { 1 : F0 } ▁ { 2 : F0 } / { 3 : F0 } "" , x1 , y1 , x2 , y2 ) ; while ( y != 1.0 ) { x = Math . Floor ( ( y1 + n ) / y2 ) * x2 - x1 ; y = Math . Floor ( ( y1 + n ) / y2 ) * y2 - y1 ; Console . Write ( "" ▁ { 0 : F0 } / { 1 : F0 } "" , x , y ) ; x1 = x2 ; x2 = x ; y1 = y2 ; y2 = y ; } } public static void Main ( String [ ] args ) { int n = 7 ; Console . Write ( "" Farey ▁ Sequence ▁ of ▁ order ▁ "" + n + "" ▁ is STRNEWLINE "" ) ; farey ( n ) ; } }";"Farey Sequence | Efficient C # program to print Farey Sequence of order n ; Optimized function to print Farey sequence of order n ; We know first two terms are 0 / 1 and 1 / n ; double x , y = 0 ; For next terms to be evaluated ; Using recurrence relation to find the next term ; Print next term ; Update x1 , y1 , x2 and y2 for next iteration ; Driver program"
C#;"using System ; class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return ( gcd ( b , a % b ) ) ; } static void findSmallest ( int a , int b ) { int lcm = ( a * b ) / gcd ( a , b ) ; Console . Write ( "" x ▁ = ▁ "" + lcm / a + "" y = "" } public static void Main ( ) { int a = 25 , b = 35 ; findSmallest ( a , b ) ; } }";"Find smallest values of x and y such that ax | C # program to find the smallest values of x and y that satisfy "" ax ▁ - ▁ by ▁ = ▁ 0"" ; To find GCD using Eculcid 's algorithm ; Prints smallest values of x and y that satisfy "" ax ▁ - ▁ by ▁ = ▁ 0"" ; Find LCM ; Driver code"
C#;"using System ; class GFG { public int power ( int x , int y , int p ) { while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } public int modInverse ( int a , int p ) { return power ( a , p - 2 , p ) ; } public int modFact ( int n , int p ) { if ( p <= n ) return 0 ; int res = ( p - 1 ) ; for ( int i = n + 1 ; i < p ; i ++ ) res = ( res * modInverse ( i , p ) ) % p ; return res ; } public static void Main ( ) { GFG g = new GFG ( ) ; int n = 25 , p = 29 ; Console . WriteLine ( g . modFact ( n , p ) ) ; } }";"Compute n ! under modulo p | C # program to comput n ! % p using Wilson 's Theorem ; Utility function to do modular exponentiation . It returns ( x ^ y ) % p ; int res = 1 ; Initialize result x = x % p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 ; y = y / 2 ; Function to find modular inverse of a under modulo p using Fermat 's method. Assumption: p is prime ; Returns n ! % p using Wilson 's Theorem ; n ! % p is 0 if n >= p ; Initialize result as ( p - 1 ) ! which is - 1 or ( p - 1 ) ; Multiply modulo inverse of all numbers from ( n + 1 ) to p ; Driver method"
C#;"using System ; class GFG { static int countWays ( int n ) { for ( int i = 1 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) for ( int k = j ; k < n ; k ++ ) for ( int l = k ; l < n ; l ++ ) if ( i + j + k + l == n ) counter ++ ; return counter ; } static public void Main ( ) { int n = 8 ; Console . WriteLine ( countWays ( n ) ) ; } }";"Count number of ways to divide a number in 4 parts | A Simple C # program to count number of ways to represent a number n as sum of four . ; Returns count of ways ; Generate all possible quadruplet and increment counter when sum of a quadruplet is equal to n ; Driver Code"
C#;"using System ; class GFG { static int pairAndSum ( int [ ] arr , int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] & arr [ j ] ; return ans ; } public static void Main ( ) { int [ ] arr = { 5 , 10 , 15 } ; int n = arr . Length ; Console . Write ( pairAndSum ( arr , n ) ) ; } }";"Sum of Bitwise And of all pairs in a given array | A Simple C # program to compute sum of bitwise AND of all pairs ; Returns value of "" arr [ 0 ] ▁ & ▁ arr [ 1 ] ▁ + ▁ ▁ arr [ 0 ] ▁ & ▁ arr [ 2 ] ▁ + ▁ . . . ▁ arr [ i ] ▁ & ▁ arr [ j ] ▁ + ▁ ▁ . . . . . ▁ arr [ n - 2 ] ▁ & ▁ arr [ n - 1 ] "" ; Consider all pairs ( arr [ i ] , arr [ j ) such that i < j ; Driver program to test above function"
C#;"using System ; class GFG { static int pairAndSum ( int [ ] arr , int n ) { for ( int i = 0 ; i < 32 ; i ++ ) { int k = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) k ++ ; } ans += ( 1 << i ) * ( k * ( k - 1 ) / 2 ) ; } return ans ; } public static void Main ( ) { int [ ] arr = new int [ ] { 5 , 10 , 15 } ; int n = arr . Length ; Console . Write ( pairAndSum ( arr , n ) ) ; } }";"Sum of Bitwise And of all pairs in a given array | An efficient C # program to compute sum of bitwise AND of all pairs ; Returns value of "" arr [ 0 ] ▁ & ▁ arr [ 1 ] ▁ + ▁ ▁ arr [ 0 ] ▁ & ▁ arr [ 2 ] ▁ + ▁ . . . ▁ arr [ i ] ▁ & ▁ arr [ j ] ▁ + ▁ ▁ . . . . . ▁ arr [ n - 2 ] ▁ & ▁ arr [ n - 1 ] "" ; Traverse over all bits ; Count number of elements with i 'th bit set Initialize the count ; There are k set bits , means k ( k - 1 ) / 2 pairs . Every pair adds 2 ^ i to the answer . Therefore , we add ""2 ^ i ▁ * ▁ ▁ [ k * ( k - 1 ) / 2 ] "" to the answer . ; Driver program to test above function"
C#;"using System ; namespace prime { public class GFG { public static bool isprime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } public static void Main ( ) { if ( isprime ( 11 ) ) Console . WriteLine ( "" true "" ) ; else Console . WriteLine ( "" false "" ) ; if ( isprime ( 15 ) ) Console . WriteLine ( "" true "" ) ; else Console . WriteLine ( "" false "" ) ; } } }";"Primality Test | Set 1 ( Introduction and School Method ) | A optimized school method based C # program to check if a number is prime ; Corner cases ; Check from 2 to n - 1 ; Driver program"
Javascript;"function maxPresum ( a , b ) { let X = Math . max ( a [ 0 ] , 0 ) ; for ( let i = 1 ; i < a . length ; i ++ ) { a [ i ] += a [ i - 1 ] ; X = Math . max ( X , a [ i ] ) ; } let Y = Math . max ( b [ 0 ] , 0 ) ; for ( let i = 1 ; i < b . length ; i ++ ) { b [ i ] += b [ i - 1 ] ; Y = Math . max ( Y , b [ i ] ) ; } return X + Y ; } let A = [ 2 , - 1 , 4 , - 5 ] ; let B = [ 4 , - 3 , 12 , 4 , - 3 ] ; document . write ( maxPresum ( A , B ) ) ;";"Maximum Prefix Sum possible by merging two given arrays | Javascript Program to implement the above approach ; Stores the maximum prefix sum of the array A [ ] ; Traverse the array A [ ] ; Stores the maximum prefix sum of the array B [ ] ; Traverse the array B [ ] ; Driver code"
Javascript;"function sumOfTwoCubes ( n ) { var lo = 1 , hi = ( n ) ; while ( lo <= hi ) { var curr = ( lo * lo * lo + hi * hi * hi ) ; if ( curr == n ) return true ; if ( curr < n ) lo ++ ; else hi -- ; } return false ; } var N = 28 ; if ( sumOfTwoCubes ( N ) ) { document . write ( "" "" ) ; } else { document . write ( "" "" ) ; }";"Check if a number can be represented as sum of two positive perfect cubes | Function to check if N can be represented as sum of two perfect cubes or not ; if it is same return true ; ; if the curr smaller than n increment the lo ; if the curr is greater than curr decrement the hi ; Driver Code ; Function call to check if N can be represented as sum of two perfect cubes or not"
Javascript;"var sieve = Array ( 1000000 ) ; function sieveOfPrimes ( ) { sieve = Array ( 1000000 ) . fill ( 1 ) ; var N = 1000000 ; for ( var i = 2 ; i * i <= N ; i ++ ) { if ( sieve [ i ] == 0 ) continue ; for ( var j = i * i ; j <= N ; j += i ) sieve [ j ] = 0 ; } } function getArray ( arr , N ) { var A = Array ( N ) . fill ( 0 ) ; var v = [ ] ; sieveOfPrimes ( ) ; for ( var i = 2 ; i <= 1e5 ; i ++ ) if ( sieve [ i ] ) v . push ( i ) ; var j = 0 ; for ( var i = 0 ; i < N ; i ++ ) { var ind = arr [ i ] ; if ( A [ i ] != 0 ) continue ; else if ( A [ ind ] != 0 ) A [ i ] = A [ ind ] ; else { var prime = v [ j ++ ] ; A [ i ] = prime ; A [ ind ] = A [ i ] ; } } for ( var i = 0 ; i < N ; i ++ ) { document . write ( A [ i ] + "" "" ) ; } } var arr = [ 4 , 1 , 2 , 3 , 4 ] ; var N = arr . length ; getArray ( arr , N ) ;";"Generate an N | JavaScript program for the above approach ; Function to generate all prime numbers upto 10 ^ 6 ; Initialize sieve [ ] as 1 ; Iterate over the range [ 2 , N ] ; If current element is non - prime ; Make all multiples of i as 0 ; Function to construct an array A [ ] satisfying the given conditions ; Stores the resultant array ; Stores all prime numbers ; Sieve of Erastosthenes ; Append the integer i if it is a prime ; Indicates current position in list of prime numbers ; Traverse the array arr [ ] ; If already filled with another prime number ; If A [ i ] is not filled but A [ ind ] is filled ; Store A [ i ] = A [ ind ] ; If none of them were filled ; To make sure A [ i ] does not affect other values , store next prime number ; Print the resultant array ; Driver Code ; Function Call"
Javascript;"function findNthNumber ( N ) { let result = 0 ; let p = 1 ; while ( N > 0 ) { result += ( p * ( N % 9 ) ) ; N = parseInt ( N / 9 , 10 ) ; p = p * 10 ; } return result ; } let N = 9 ; document . write ( findNthNumber ( N ) ) ;";"Nth natural number after removing all numbers consisting of the digit 9 | Function to find Nth number in base 9 ; Stores the Nth number ; Iterate while N is greater than 0 ; Update result ; Divide N by 9 ; Multiply p by 10 ; Return result ; Driver code"
Javascript;"function check ( A , B ) { if ( A == B ) { return 1 ; } let dig1 = Math . floor ( Math . log10 ( A ) + 1 ) ; let dig2 = Math . floor ( Math . log10 ( B ) + 1 ) ; if ( dig1 != dig2 ) { return 0 ; } let temp = A ; while ( true ) { let power = Math . pow ( 10 , dig1 - 1 ) ; let firstdigit = parseInt ( A / power , 10 ) ; A = A - firstdigit * power ; A = A * 10 + firstdigit ; if ( A == B ) { return 1 ; } if ( A == temp ) { return 0 ; } } } let A = 967 , B = 679 ; if ( check ( A , B ) == 1 ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check if an integer is rotation of another given integer | Function to check if the integer A is a rotation of the integer B ; Stores the count of digits in A ; Stores the count of digits in B ; If dig1 not equal to dig2 ; Stores position of first digit ; Stores the first digit ; Rotate the digits of the integer ; If A is equal to B ; If A is equal to the initial value of integer A ; Driver Code"
Javascript;"function sameProductQuadruples ( nums , N ) { var umap = new Array ( 10000 ) . fill ( 0 ) ; var res = 0 ; for ( var i = 0 ; i < N ; ++ i ) { for ( var j = i + 1 ; j < N ; ++ j ) { var prod = nums [ i ] * nums [ j ] ; res += 8 * umap [ prod ] ; ++ umap [ prod ] ; } } document . write ( res ) ; } var arr = [ 2 , 3 , 4 , 6 ] ; var N = arr . length ; sameProductQuadruples ( arr , N ) ;";"Count of quadruples with product of a pair equal to the product of the remaining pair | Function to count the number of unique quadruples from an array that satisfies the given condition ; Hashmap to store the product of pairs ; Store the count of required quadruples ; Traverse the array arr [ ] and generate all possible pairs ; Store their product ; Pair ( a , b ) can be used to generate 8 unique permutations with another pair ( c , d ) ; Increment um [ prod ] by 1 ; Print the result ; Driver Code"
Javascript;"var MOD = 1000000007 ; function power ( x , y , p = MOD ) { var res = 1 ; x = x % p ; while ( y > 0 ) { if ( y & 1 ) res = ( res * 1 * x ) % p ; y = y >> 1 ; x = ( x * 1 * x ) % p ; } return res ; } function totalWays ( N , M ) { var X = parseInt ( N / 2 ) ; var S = ( X * 1 * ( X + 1 ) ) % MOD ; document . write ( power ( S , M , MOD ) << "" "" ) ; } var N = 5 , M = 2 ; totalWays ( N , M ) ;";"Count ways to place M objects in distinct partitions of N boxes | Javascript implementation of the above Approach ; Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; Initialize Result ; Update x if x >= MOD to avoid multiplication overflow ; If y is odd , multiply x with result ; y = y / 2 ; Change x to x ^ 2 ; Utility function to find the Total Number of Ways ; Number of Even Indexed Boxes ; Number of partitions of Even Indexed Boxes ; Number of ways to distribute objects ; N = number of boxes M = number of distinct objects ; Function call to get Total Number of Ways"
Javascript;"function isCycleExists ( arr , N ) { for ( let i = 1 ; i < N ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) { document . write ( "" "" ) ; return ; } } document . write ( "" "" ) ; } let arr = [ 1 , 3 , 2 , 4 , 5 ] ; let N = arr . length ; isCycleExists ( arr , N ) ;";"Check if a graph constructed from an array based on given conditions consists of a cycle or not | Function to check if the graph constructed from given array contains a cycle or not ; Traverse the array ; If arr [ i ] is less than arr [ i - 1 ] and arr [ i ] ; Given array ; Size of the array"
Javascript;"function getMax ( arr , N , K ) { for ( i = 1 ; i < N ; i ++ ) { var cur_val = arr [ i ] ; while ( K >= i ) { if ( cur_val > 0 ) { arr [ 0 ] = arr [ 0 ] + 1 ; cur_val = cur_val - 1 ; K = K - i ; } else break ; } } document . write ( arr [ 0 ] ) ; } var arr = [ 1 , 0 , 3 , 2 ] ; var N = arr . length ; var K = 5 ; getMax ( arr , N , K ) ;";"Maximize first array element by performing given operations at most K times | Function to maximize the first array element ; Traverse the array ; Initialize cur_val to a [ i ] ; If all operations are not over yet ; If current value is greater than zero ; Incrementing first element of array by 1 ; Decrementing current value of array by 1 ; Decrementing number of operations by i ; If current value is zero , then break ; Print first array element ; Given array ; Size of the array ; Given K ; Prints the maximum possible value of the first array element"
Javascript;"function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function DistinctValues ( arr , N ) { var max_value = Number . MIN_VALUE ; for ( i = 0 ; i < N ; ++ i ) { max_value = Math . max ( max_value , arr [ i ] ) ; } var GCDArr = arr [ 0 ] ; for ( i = 1 ; i < N ; ++ i ) { GCDArr = gcd ( GCDArr , arr [ i ] ) ; } var answer = ( max_value / GCDArr ) + 1 ; return answer ; } var arr = [ 4 , 12 , 16 , 24 ] ; var N = arr . length ; document . write ( DistinctValues ( arr , N ) ) ;";"Count Non | Function to find the gcd of the two numbers ; Function to find distinct elements in the array by repeatidely inserting the absolute difference of all possible pairs ; Stores largest element of the array ; Traverse the array , arr ; Update max_value ; Stores GCD of array ; Traverse the array , arr ; Update GCDArr ; Stores distinct elements in the array by repeatidely inserting absolute difference of all possible pairs ; Given array arr"
Javascript;"function minSwaps ( b ) { var n = b . length ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( ( b [ 0 ] [ 0 ] ^ b [ 0 ] [ j ] ^ b [ i ] [ 0 ] ^ b [ i ] [ j ] ) == 1 ) { return - 1 ; } } } var rowSum = 0 ; var colSum = 0 ; var rowSwap = 0 ; var colSwap = 0 ; for ( i = 0 ; i < n ; i ++ ) { rowSum += b [ i ] [ 0 ] ; colSum += b [ 0 ] [ i ] ; var cond1 = 0 ; var cond2 = 0 ; if ( b [ i ] [ 0 ] == i % 2 ) cond1 = 1 ; if ( b [ 0 ] [ i ] == i % 2 ) cond2 = 1 ; rowSwap += cond1 ; colSwap += cond2 ; } if ( rowSum != n / 2 && rowSum != ( n + 1 ) / 2 ) return - 1 ; if ( colSum != n / 2 && colSum != ( n + 1 ) / 2 ) return - 1 ; if ( n % 2 == 1 ) { if ( ( colSwap % 2 ) == 1 ) colSwap = n - colSwap ; if ( ( rowSwap % 2 ) == 1 ) rowSwap = n - rowSwap ; } else { colSwap = Math . min ( colSwap , n - colSwap ) ; rowSwap = Math . min ( rowSwap , n - rowSwap ) ; } return ( rowSwap + colSwap ) / 2 ; } var M = [ [ 0 , 1 , 1 , 0 ] , [ 0 , 1 , 1 , 0 ] , [ 1 , 0 , 0 , 1 ] , [ 1 , 0 , 0 , 1 ] ] ; var ans = minSwaps ( M ) ; document . write ( ans ) ;";"Minimum row or column swaps required to make every pair of adjacent cell of a Binary Matrix distinct | Function to return number of moves to convert matrix into chessboard ; Size of the matrix ; Traverse the matrix ; Initialize rowSum to count 1 s in row ; Initialize colSum to count 1 s in column ; To store no . of rows to be corrected ; To store no . of columns to be corrected ; Traverse in the range [ 0 , N - 1 ] ; Check if rows is either N / 2 or ( N + 1 ) / 2 and return - 1 ; Check if rows is either N / 2 or ( N + 1 ) / 2 and return - 1 ; Check if N is odd ; Check if column required to be corrected is odd and then assign N - colSwap to colSwap ; Check if rows required to be corrected is odd and then assign N - rowSwap to rowSwap ; Take min of colSwap and N - colSwap ; Take min of rowSwap and N - rowSwap ; Finally return answer ; Given matrix ; Function Call ; Prvar answer"
Javascript;"function count_setbit ( N ) { let result = 0 ; for ( let i = 0 ; i < 32 ; i ++ ) { if ( ( ( 1 << i ) & N ) > 0 ) { result ++ ; } } document . write ( result ) ; } let N = 43 ; count_setbit ( N ) ;";"Minimum number of coins having value equal to powers of 2 required to obtain N | Function to count of set bit in N ; Stores count of set bit in N ; Iterate over the range [ 0 , 31 ] ; If current bit is set ; Update result ; Driver Code"
Javascript;"let mod = 1000000007 ; function ValOfTheExpression ( n ) { let factorial = new Array ( n + 1 ) ; factorial [ 0 ] = factorial [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { factorial [ i ] = ( ( factorial [ i - 1 ] % mod ) * ( i % mod ) ) % mod ; } let dp = new Array ( n + 1 ) ; dp [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { dp [ i ] = ( ( dp [ i - 1 ] % mod ) * ( factorial [ i ] % mod ) ) % mod ; } return dp [ n ] ; } let n = 4 ; document . write ( ValOfTheExpression ( n ) ) ;";"Evaluate the expression ( N1 * ( N | Javascript program to implement the above approach ; Function to find the value of the expression ( N ^ 1 * ( N 1 ) ^ 2 * ... * 1 ^ N ) % ( 109 + 7 ) . ; factorial [ i ] : Stores factorial of i ; Base Case for factorial ; Precompute the factorial ; dp [ N ] : Stores the value of the expression ( N ^ 1 * ( N 1 ) ^ 2 * ... * 1 ^ N ) % ( 109 + 7 ) . ; Update dp [ i ] ; Return the answer . ; Driver code ; Function call"
Javascript;"function minChocolates ( A , N ) { let B = new Array ( N ) . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { B [ i ] = 1 ; } for ( let i = 1 ; i < N ; i ++ ) { if ( A [ i ] > A [ i - 1 ] ) B [ i ] = B [ i - 1 ] + 1 ; else B [ i ] = 1 ; } for ( let i = N - 2 ; i >= 0 ; i -- ) { if ( A [ i ] > A [ i + 1 ] ) B [ i ] = Math . max ( B [ i + 1 ] + 1 , B [ i ] ) ; else B [ i ] = Math . max ( B [ i ] , 1 ) ; } let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { sum += B [ i ] ; } document . write ( sum + "" "" ) ; } let A = [ 23 , 14 , 15 , 14 , 56 , 29 , 14 ] ; let N = A . length ; minChocolates ( A , N ) ;";"Chocolate Distribution Problem | Set 2 | FUnction to prlet minimum number of candies required ; Distribute 1 chocolate to each ; Traverse from left to right ; Traverse from right to left ; Initialize sum ; Find total sum ; Return sum ; Given array ; Size of the given array"
Javascript;"function constructArrayWithGivenLCM ( N ) { let newArr = new Array ( N ) ; newArr . fill ( 0 ) ; let j = 0 ; for ( let i = 1 ; i * i <= N ; i ++ ) { if ( N % i == 0 ) { newArr [ j ] = i ; j ++ ; if ( parseInt ( N / i , 10 ) != i ) { newArr [ j ] = parseInt ( N / i , 10 ) ; j ++ ; } } } newArr . sort ( function ( a , b ) { return a - b } ) ; for ( let i = j ; i < N ; i ++ ) { document . write ( newArr [ i ] + "" "" ) ; } } let N = 12 ; constructArrayWithGivenLCM ( N ) ;";"Construct longest possible sequence of unique elements with given LCM | Function to construct an array of unique elements whose LCM is N ; Stores array elements whose LCM is N ; Iterate over the range [ 1 , sqrt ( N ) ] ; If N is divisible by i ; Insert i into newArr [ ] ; If N is not perfect square ; Sort the array newArr [ ] ; Print array elements ; Given N ; Function Call"
Javascript;"function getPower ( p ) { var res = 1 ; while ( p -- ) { res *= 5 ; } return res ; } function countNumbersUtil ( N ) { var count = 0 ; var digits = [ ] ; while ( N ) { digits . push ( N % 10 ) ; N = parseInt ( N / 10 ) ; } digits . reverse ( ) ; var D = digits . length ; for ( var i = 1 ; i <= D ; i ++ ) { var res = getPower ( i ) ; if ( i == D ) { for ( var p = 1 ; p <= D ; p ++ ) { var x = digits [ p - 1 ] ; var tmp = 0 ; if ( p % 2 == 0 ) { tmp = ( 5 - parseInt ( x / ( 2 + 1 ) ) ) * getPower ( D - p ) ; } else { tmp = ( 5 - parseInt ( ( x + 1 ) / 2 ) ) * getPower ( D - p ) ; } res -= tmp ; if ( p % 2 != x % 2 ) { break ; } } } count += res ; } return count ; } function countNumbers ( L , R ) { document . write ( ( countNumbersUtil ( R ) - countNumbersUtil ( L - 1 ) ) + "" "" ) ; } var L = 128 , R = 162 ; countNumbers ( L , R ) ;";"Count numbers from given range having odd digits at odd places and even digits at even places | Function to calculate 5 ^ p ; Stores the result ; Multiply 5 p times ; Return the result ; Function to count all numbers upto N having odd digits at odd places and even digits at even places ; Stores the count ; Stores the digits of N ; Insert the digits of N ; Reverse the vector to arrange the digits from first to last ; Stores count of digits of n ; Stores the count of numbers with i digits ; If the last digit is reached , subtract numbers eceeding range ; Iterate over all the places ; Stores the digit in the pth place ; Stores the count of numbers having a digit greater than x in the p - th position ; Calculate the count of numbers exceeding the range if p is even ; Calculate the count of numbers exceeding the range if p is odd ; Subtract the count of numbers exceeding the range from total count ; If the parity of p and the parity of x are not same ; Add count of numbers having i digits and satisfies the given conditions ; Return the total count of numbers till n ; Function to calculate the count of numbers from given range having odd digits places and even digits at even places ; Count of numbers in range [ L , R ] = Count of numbers till R - ; Count of numbers till ( L - 1 ) ; Driver Code"
Javascript;"function alternatingSumOfFirst_N ( N ) { var alternateSum = 0 ; for ( i = 1 ; i <= N ; i ++ ) { if ( i % 2 == 0 ) { alternateSum += - i ; } else { alternateSum += i ; } } return alternateSum ; } var N = 6 ; document . write ( alternatingSumOfFirst_N ( N ) ) ;";"Sum of first N natural numbers with alternate signs | Function to find the sum of first N natural numbers with alternate signs ; Stores sum of alternate sign of first N natural numbers ; If is an even number ; Update alternateSum ; If i is an odd number ; Update alternateSum ; Driver Code"
Javascript;"function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function findSum ( N ) { var sum = 0 ; for ( var i = 1 ; i < N ; i ++ ) { if ( gcd ( i , N ) == 1 ) { sum += i ; } } return sum ; } var N = 5 ; document . write ( findSum ( N ) ) ;";"Sum of all numbers up to N that are co | Function to return gcd of a and b ; Base Case ; Recursive GCD ; Function to calculate the sum of all numbers till N that are coprime with N ; Stores the resultant sum ; Iterate over [ 1 , N ] ; If gcd is 1 ; Update sum ; Return the final sum ; Given N ; Function Call"
Javascript;"function solve ( arr , n ) { var mp = new Map ( ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( mp . has ( arr [ i ] ) ) mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) else mp . set ( arr [ i ] , 1 ) ; } var cnt = 0 ; mp . forEach ( ( value , key ) => { cnt += ( ( value ) * ( value - 1 ) / 2 ) ; } ) ; var ans = Array ( n ) ; for ( var i = 0 ; i < n ; i ++ ) { ans [ i ] = cnt - ( mp . get ( arr [ i ] ) - 1 ) ; } for ( var i = 0 ; i < n ; i ++ ) { document . write ( ans [ i ] + "" "" ) ; } } var arr = [ 1 , 1 , 2 , 1 , 2 ] ; var N = arr . length ; solve ( arr , N ) ;";"Count all distinct pairs of repeating elements from the array for every array element | Function to print the required count of pairs excluding the current element ; Store the frequency ; Find all the count ; Delete the contribution of each element for equal pairs ; Print the answer ; Given array arr [ ] ; Function Call"
Javascript;"function modexp ( x , n , m ) { if ( n == 0 ) { return 1 ; } else if ( n % 2 == 0 ) { return modexp ( ( x * x ) % m , parseInt ( n / 2 , 10 ) , m ) ; } else { return ( x * modexp ( ( x * x ) % m , parseInt ( ( n - 1 ) / 2 , 10 ) , m ) % m ) ; } } function modInverse ( x , m ) { return modexp ( x , m - 2 , m ) ; } function countNumbers ( N ) { let m = 1000000007 ; let factorial = new Array ( 100001 ) ; factorial [ 0 ] = 1 ; for ( let i = 1 ; i < 100001 ; i ++ ) { factorial [ i ] = ( factorial [ i - 1 ] * i ) % m ; } let count = new Array ( 10 ) ; for ( let i = 0 ; i < 10 ; i ++ ) { count [ i ] = 0 ; } let length = N . length ; for ( let i = 0 ; i < length ; i ++ ) count [ N [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ++ ; let result = factorial [ length ] ; for ( let i = 0 ; i < 10 ; i ++ ) { result = 0 * ( result * modInverse ( factorial [ count [ i ] ] , m ) ) % m + 12 ; } document . write ( result ) ; } let N = "" "" ; countNumbers ( N ) ;";"Count of distinct numbers formed by shuffling the digits of a large number N | Recursive function to return the value of ( x ^ n ) % m ; Base Case ; If N is even ; Else N is odd ; Function to find modular inverse of a number x under modulo m ; Using Fermat 's little theorem ; Function to count of numbers formed by shuffling the digits of a large number N ; Modulo value ; Array to store the factorials upto the maximum value of N ; Store factorial of i at index i ; To store count of occurrence of a digit ; Increment the count of digit occured ; Assign the factorial of length of input ; Multiplying result with the modulo multiplicative inverse of factorial of count of i ; Print the result ; Given number as string ; Function call"
Javascript;"var spf = Array ( 10001 ) ; function spf_array ( spf ) { spf [ 1 ] = 1 ; for ( var i = 2 ; i < 1000 ; i ++ ) spf [ i ] = i ; for ( var i = 4 ; i < 1000 ; i += 2 ) spf [ i ] = 2 ; for ( var i = 3 ; i * i < 1000 ; i ++ ) { if ( spf [ i ] == i ) { for ( var j = i * i ; j < 1000 ; j += i ) if ( spf [ j ] == j ) spf [ j ] = i ; } } } function frequent_prime ( arr , N , K ) { spf_array ( spf ) ; var Hmap = new Map ( ) ; var result = [ ] ; var i = 0 ; var c = 0 ; for ( i = 0 ; i < N ; i ++ ) { var x = arr [ i ] ; while ( x != 1 ) { if ( Hmap . has ( spf [ x ] ) ) Hmap . set ( spf [ x ] , Hmap . get ( spf [ x ] ) + 1 ) else Hmap . set ( spf [ x ] , 1 ) ; x = parseInt ( x / spf [ x ] ) ; } } Hmap . delete ( 1 ) ; Hmap . forEach ( ( value , key ) => { var primeNum = key ; var frequency = value ; if ( frequency % K == 0 ) { result . push ( primeNum ) ; } } ) ; if ( result . length > 0 ) { result . forEach ( it => { document . write ( it + "" "" ) ; } ) ; } else { document . write ( "" "" ) ; } } var arr = [ 1 , 4 , 6 ] ; var K = 1 ; var N = arr . length ; frequent_prime ( arr , N , K ) ;";"Find prime factors of Array elements whose sum of exponents is divisible by K | To store the smallest prime factor till 10 ^ 5 ; Function to compute smallest prime factor array ; Initialize the spf array first element ; Marking smallest prime factor for every number to be itself ; Separately marking smallest prime factor for every even number as 2 ; Checking if i is prime ; Marking SPF for all numbers divisible by i ; Marking spf [ j ] if it is not previously marked ; Function that finds minimum operation ; Create a spf [ ] array ; Map created to store the unique prime numbers ; To store the result ; To store minimum operations ; To store every unique prime number ; Erase 1 as a key because it is not a prime number ; First Prime Number ; Frequency is divisible by K then insert primeNum in the result [ ] ; Print the elements if it exists ; Given array arr [ ] ; Given K ; Function Call"
Javascript;"function Kmultiples ( n , k ) { var a = n ; for ( i = 1 ; i <= k ; i ++ ) { document . write ( n + "" "" + i + "" "" + a + "" "" ) ; var j = 0 ; while ( n >= ( 1 << j ) ) { a += n & ( 1 << j ) ; j ++ ; } } } var N = 16 , K = 7 ; Kmultiples ( N , K ) ;";"Generate first K multiples of N using Bitwise operators | Function to prvar the first K multiples of N ; Prvar the value of N * i ; Iterate each bit of N and add Math . pow ( 2 , pos ) , where pos is the index of each set bit ; Check if current bit at pos j is fixed or not ; For next set bit ; Driver Code"
Javascript;"function calculateB ( x , y ) { let n = x . length ; let sx = x . reduce ( ( a , b ) => a + b , 0 ) ; let sy = y . reduce ( ( a , b ) => a + b , 0 ) let sxsy = 0 ; let sx2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sxsy += x [ i ] * y [ i ] ; sx2 += x [ i ] * x [ i ] ; } let b = ( n * sxsy - sx * sy ) / ( n * sx2 - sx * sx ) ; return b ; } function leastRegLine ( X , Y ) { let b = calculateB ( X , Y ) ; let n = X . length ; let meanX = X . reduce ( ( a , b ) => a + b , 0 ) / n ; let meanY = Y . reduce ( ( a , b ) => a + b , 0 ) / n ; let a = meanY - b * meanX ; document . write ( "" "" ) ; document . write ( "" "" ) ; document . write ( a . toFixed ( 3 ) ) ; document . write ( "" "" ) ; document . write ( b . toFixed ( 3 ) ) ; document . write ( "" "" ) ; } let X = [ 95 , 85 , 80 , 70 , 60 ] ; let Y = [ 90 , 80 , 70 , 65 , 60 ] ; leastRegLine ( X , Y ) ;";"Least Square Regression Line | Function to calculate b ; sum of array x ; sum of array y ; for sum of product of x and y ; sum of square of x ; Function to find the least regression line ; Finding b ; calculating a ; Printing regression line ; statistical data"
Javascript;"function countRepeatingDigits ( N ) { var res = 0 ; var cnt = Array ( 10 ) . fill ( 0 ) ; while ( N > 0 ) { var rem = N % 10 ; cnt [ rem ] ++ ; N = N / 10 ; } for ( var i = 0 ; i < 10 ; i ++ ) { if ( cnt [ i ] > 1 ) { res ++ ; } } return res ; } var N = 12 ; document . write ( countRepeatingDigits ( N ) ) ;";"Count of repeating digits in a given Number | Function that returns the count of repeating digits of the given number ; Initialize a variable to store count of Repeating digits ; Initialize cnt array to store digit count ; Iterate through the digits of N ; Retrieve the last digit of N ; Increase the count of digit ; Remove the last digit of N ; Iterate through the cnt array ; If frequency of digit is greater than 1 ; Increment the count of Repeating digits ; Return count of repeating digit ; Given array arr [ ] ; Function Call"
Javascript;"function findTemperature ( x , y , s ) { let Day1 , Day2 ; let diff = ( x - y ) * 6 ; Day2 = ( diff + s ) / 2 ; Day1 = s - Day2 ; document . write ( "" "" + Day1 + "" "" ) ; document . write ( "" "" + Day2 + "" "" ) ; } let x = 5 , y = 10 , s = 40 ; findTemperature ( x , y , s ) ;";"Find temperature of missing days using given sum and average | Function for finding the temperature ; Store Day1 - Day2 in diff ; Remaining from s will be Day1 ; Print Day1 and Day2 ; Driver Code ; Functions"
Javascript;"function freqCount ( str , k ) { var count = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] == k ) count ++ ; } return count ; } function findAandB ( n , k ) { var flag = 0 ; for ( var i = 1 ; i < n ; i ++ ) { if ( freqCount ( i . toString ( ) , String . fromCharCode ( k + 48 ) ) == 0 && freqCount ( ( n - i ) . toString ( ) , String . fromCharCode ( k + 48 ) ) == 0 ) { document . write ( "" "" + i + "" "" + ( n - i ) + "" "" ) ; flag = 1 ; break ; } } if ( flag == 0 ) cout + - 1 ; } var N = 100 ; var K = 0 ; findAandB ( N , K ) ;";"Find two numbers whose sum is N and does not contain any digit as K | Javascript program for the above approach ; Function to find two numbers whose sum is N and do not contain any digit as k ; Check every number i and ( n - i ) ; Check if i and n - i doesn 't  contain k in them print i and n-i ; Check if flag is 0 then print - 1 ; Given N and K ; Function call"
Javascript;"function calculate ( P , Q ) { let mod = 998244353 , expo ; expo = mod - 2 ; p = 748683265 ; while ( expo != 0 ) { if ( ( expo & 1 ) == 1 ) { P = ( P * Q ) % mod ; } Q = ( Q * Q ) % mod ; expo >>= 1 ; } return p ; } let p = 1 , q = 4 ; document . write ( calculate ( p , q ) ) ;";"Find the value of P and modular inverse of Q modulo 998244353 | Function to find the value of P * Q ^ - 1 mod 998244353 ; Loop to find the value until the expo is not zero ; Multiply p with q if expo is odd ; Reduce the value of expo by 2 ; Driver code ; Function call"
Javascript;"function maxLCMWithGivenSum ( X ) { let A , B ; if ( X & 1 ) { A = X / 2 ; B = X / 2 + 1 ; } else { if ( ( X / 2 ) % 2 == 0 ) { A = X / 2 - 1 ; B = X / 2 + 1 ; } else { A = X / 2 - 2 ; B = X / 2 + 2 ; } } document . write ( A + "" "" + B + "" "" ) ; } let X = 30 ; maxLCMWithGivenSum ( X ) ;";"Find two numbers with given sum and maximum possible LCM | Function that print two numbers with the sum X and maximum possible LCM ; variables to store the result ; If X is odd ; If X is even ; If floor ( X / 2 ) is even ; If floor ( X / 2 ) is odd ; Print the result ; Given Number ; Function call"
Javascript;"function MaxSubarrayLength ( arr , n , k ) { let left = - 1 ; let right = 0 ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] % k ) != 0 ) { if ( left == - 1 ) { left = i ; } right = i ; } sum += arr [ i ] ; } if ( ( sum % k ) != 0 ) { return n ; } else if ( left == - 1 ) { return - 1 ; } else { let prefix_length = left + 1 ; let suffix_length = n - right ; return n - Math . min ( prefix_length , suffix_length ) ; } } let arr = [ 6 , 3 , 12 , 15 ] ; let n = arr . length ; let K = 3 ; document . write ( MaxSubarrayLength ( arr , n , K ) ) ;";"Length of longest subarray whose sum is not divisible by integer K | Function to find the longest subarray with sum is not divisible by k ; left is the index of the leftmost element that is not divisible by k ; right is the index of the rightmost element that is not divisible by k ; sum of the array ; Find the element that is not multiple of k ; left = - 1 means we are finding the leftmost element that is not divisible by k ; Updating the rightmost element ; Update the sum of the array up to the index i ; Check if the sum of the array is not divisible by k , then return the size of array ; All elements of array are divisible by k , then no such subarray possible so return - 1 ; Length of prefix elements that can be removed ; Length of suffix elements that can be removed ; Return the length of subarray after removing the elements which have lesser number of elements ; Driver Code"
Javascript;"function solve ( X , Y ) { if ( X > Y ) { let temp = X ; X = Y ; Y = temp ; } if ( X == Y ) document . write ( 0 ) ; else if ( Y % X == 0 ) document . write ( 1 ) ; else document . write ( 2 ) ; } let X = 8 , Y = 13 ; solve ( X , Y ) ;";"Minimum steps to convert X to Y by repeated division and multiplication | Javascript implementation to find minimum steps to convert X to Y by repeated division and multiplication ; Check if X is greater than Y then swap the elements ; Check if X equals Y ; Driver code"
Javascript;"function countQuadraples ( N ) { var cnt = 0 ; var m = new Map ( ) ; for ( var a = 1 ; a <= N ; a ++ ) { for ( var b = 1 ; b <= N ; b ++ ) { var x = a * a + b * b ; if ( m . has ( x ) ) m . set ( x , m . get ( x ) + 1 ) else m . set ( x , 1 ) } } for ( var c = 1 ; c <= N ; c ++ ) { for ( var d = 1 ; d <= N ; d ++ ) { var x = c * c + d * d ; if ( m . has ( x ) ) cnt += m . get ( x ) ; } } return cnt ; } var N = 2 ; document . write ( countQuadraples ( N ) )";"Count quadruplets ( A , B , C , D ) till N such that sum of square of A and B is equal to that of C and D | Function to count the quadruples ; Counter variable ; Map to store the sum of pair ( a ^ 2 + b ^ 2 ) ; Iterate till N ; Calculate a ^ 2 + b ^ 2 ; Increment the value in map ; Check if this sum was also in a ^ 2 + b ^ 2 ; Return the count ; Given N ; Function Call"
Javascript;"function count_pairs ( a , b , N ) { let i , j ; let count = 0 ; for ( i = 0 ; i < ( N - 1 ) ; i ++ ) { for ( j = ( i + 1 ) ; j < N ; j ++ ) { if ( ( a [ i ] + a [ j ] ) > ( b [ i ] + b [ j ] ) ) { count ++ ; } } } return count ; } let N = 5 ; let a = [ 1 , 2 , 3 , 4 , 5 ] ; let b = [ 2 , 5 , 6 , 1 , 9 ] ; document . write ( count_pairs ( a , b , N ) ) ;";"Count of distinct index pair ( i , j ) such that element sum of First Array is greater | function to find the number of pairs satisfying the given cond . ; Variables used for traversal ; count variable to store the count of possible pairs ; Nested loop to find out the possible pairs ; Check if the given condition is satisfied or not . If yes then increment the count . ; Return the count value ; Size of the arrays ; Initialise the arrays ; Function call that returns the count of possible pairs"
Javascript;"function numberOfPairs ( a , b , n ) { let c = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { c [ i ] = a [ i ] - b [ i ] ; } c . sort ( function ( a , b ) { return a - b } ) ; let answer = 0 ; for ( let i = 1 ; i < n ; i ++ ) { if ( c [ i ] <= 0 ) continue ; let pos = - 1 ; for ( let j = 0 ; j < n ; j ++ ) { if ( c [ i ] + c [ j ] > 0 ) { pos = j ; break ; } } answer += ( i - pos ) ; } return answer ; } let n = 5 ; let a = [ 1 , 2 , 3 , 4 , 5 ] ; let b = [ 2 , 5 , 6 , 1 , 9 ] ; document . write ( numberOfPairs ( a , b , n ) ) ;";"Count of distinct index pair ( i , j ) such that element sum of First Array is greater | Function to find the number of pairs . ; Array c [ ] where c [ i ] = a [ i ] - b [ i ] ; Sort the array c ; Initialise answer as 0 ; Iterate from index 0 to n - 1 ; If c [ i ] <= 0 then in the sorted array c [ i ] + c [ pos ] can never greater than 0 where pos < i ; Which is equivalent to c [ j ] >= - c [ i ] + 1 ; Add ( i - pos ) to answer ; Return the answer ; Number of elements in a and b ; Array a ; Array b"
Javascript;"function print_h_index ( arr , N ) { var ms = [ ] ; for ( var i = 0 ; i < N ; i ++ ) { ms . push ( arr [ i ] ) ; ms . sort ( ( a , b ) => a - b ) if ( ms [ 0 ] < ms . length ) { ms . shift ( ) ; } document . write ( ms . length + "" "" ) ; } } var arr = [ 9 , 10 , 7 , 5 , 0 , 10 , 2 , 0 ] ; var N = arr . length ; print_h_index ( arr , N ) ;";"Find K for every Array element such that at least K prefixes are â ‰¥ K | Function to find the K - value for every index in the array ; Multiset to store the array in the form of red - black tree ; Iterating over the array ; Inserting the current value in the multiset ; Condition to check if the smallest value in the set is less than it 's size ; Erase the smallest value ; h - index value will be the size of the multiset ; array ; Size of the array ; function call"
Javascript;"function prefixProduct ( a , n ) { for ( let i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i ] * a [ i - 1 ] ; } for ( let j = 0 ; j < n ; j ++ ) { document . write ( a [ j ] + "" "" ) ; } return 0 ; } let arr = [ 2 , 4 , 6 , 5 , 10 ] ; let N = arr . length ; prefixProduct ( arr , N ) ;";"Prefix Product Array | Function to generate prefix product array ; Update the array with the product of prefixes ; Print the array ; Driver Code"
Javascript;"function countWays ( N ) { if ( N < 4 ) return 0 ; let ans = ( ( N - 1 ) * ( N - 2 ) ) / 2 ; let s = 0 ; for ( let i = 2 ; i <= N - 3 ; i ++ ) { for ( let j = 1 ; j < i ; j ++ ) { if ( N == 2 * i + j ) s ++ ; } } if ( N % 3 == 0 ) s = 3 * s + 1 ; else s = 3 * s ; return ans - s ; } let N = 10 ; document . write ( countWays ( N ) ) ;";"Count of ways to distribute N items among 3 people with one person receiving maximum | Function to find the number of ways to distribute N items among 3 people ; No distribution possible ; Total number of ways to distribute N items among 3 people ; Store the number of distributions which are not possible ; Count possibilities of two persons receiving the maximum ; If N is divisible by 3 ; Return the final count of ways to distribute ; Driver Code"
Javascript;"function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } function isMagnanimous ( N ) { let s = N . toString ( ) ; let l = s . length ; if ( l < 2 ) return false ; for ( let i = 0 ; i < l - 1 ; i ++ ) { let left = s . substring ( 0 , i + 1 ) ; let right = s . substring ( i + 1 ) ; let x = parseInt ( left ) ; let y = parseInt ( right ) ; if ( ! isPrime ( x + y ) ) return false ; } return true ; } let N = 12 ; if ( isMagnanimous ( N ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Magnanimous Numbers | Function to check if n is prime ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function to check if the number is Magnanimous or not ; Converting the number to string ; Finding length of string ; Number should not be of single digit ; Loop to find all left and right part of the string ; Driver code"
Javascript;"const limit = 10000000 ; let position = Array ( limit + 1 ) . fill ( 0 ) ; function sieve ( ) { position [ 0 ] = - 1 ; position [ 1 ] = - 1 ; let pos = 0 ; for ( let i = 2 ; i <= limit ; i ++ ) { if ( position [ i ] == 0 ) { position [ i ] = ++ pos ; for ( let j = i * 2 ; j <= limit ; j += i ) position [ j ] = - 1 ; } } } function getSum ( n ) { let sum = 0 ; while ( n != 0 ) { sum = sum + n % 10 ; n = parseInt ( n / 10 ) ; } return sum ; } function isHonakerPrime ( n ) { let pos = position [ n ] ; if ( pos == - 1 ) return false ; return getSum ( n ) == getSum ( pos ) ; } sieve ( ) ; let N = 121 ; if ( isHonakerPrime ( N ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Honaker Prime Number | Javascript program for above approach ; Function to precompute the position of every prime number using Sieve ; 0 and 1 are not prime numbers ; Variable to store the position ; Incrementing the position for every prime number ; Function to get sum of digits ; Function to check whether the given number is Honaker Prime number or not ; Precompute the prime numbers till 10 ^ 6 ; Given Number ; Function Call"
Javascript;"let N = 4 , M = 5 ; function isPrime ( n ) { if ( n <= 1 ) return false ; for ( let i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) if ( n % i == 0 ) return false ; return true ; } function takeSum ( a ) { let s = 0 ; for ( let i = 0 ; i < N ; i ++ ) for ( let j = 0 ; j < M ; j ++ ) s += a [ i ] [ j ] ; return s ; } let a = [ [ 1 , 2 , 3 , 4 , 2 ] , [ 0 , 1 , 2 , 3 , 34 ] , [ 0 , 34 , 21 , 12 , 12 ] , [ 1 , 2 , 3 , 6 , 6 ] ] ; let sum = takeSum ( a ) ; if ( isPrime ( sum ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check if Matrix sum is prime or not | Javascript implementation to check if the sum of matrix is prime or not ; Function to check whether a number is prime or not ; Corner case ; Check from 2 to n - 1 ; Function for to find the sum of the given matrix ; Driver Code"
Javascript;"function sumOfSumSeries ( N ) { let sum = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { sum = sum + ( i * ( i + 1 ) ) / 2 ; } return sum ; } let N = 5 ; document . write ( sumOfSumSeries ( N ) ) ;";"Sum of sum | Function to find the sum ; Calculate sum - series for every natural number and add them ; Driver code"
Javascript;"function sumOfSumSeries ( n ) { return ( n * ( n + 1 ) * ( n + 2 ) ) / 6 ; } let N = 5 ; document . write ( sumOfSumSeries ( N ) ) ;";"Sum of sum | Function to find the sum ; Driver code"
Javascript;"function isContaindigit ( n ) { while ( n > 0 ) { if ( ! ( n % 10 == 0 n % 10 == 1 n % 10 == 8 ) ) return false ; n = parseInt ( n / 10 , 10 ) ; } return true ; } function ispalindrome ( n ) { let temp = n . toString ( ) ; let l = temp . length ; for ( let i = 0 ; i < parseInt ( l / 2 , 10 ) ; i ++ ) { if ( temp [ i ] != temp [ l - i - 1 ] ) return false ; } return true ; } function isTetradic ( n ) { if ( ispalindrome ( n ) && isContaindigit ( n ) ) return true ; return false ; } function printTetradicPrimesLessThanN ( n ) { let prime = new Array ( n + 1 ) ; prime . fill ( true ) ; let p = 2 ; while ( p * p <= n ) { if ( prime [ p ] ) { for ( let i = p * 2 ; i < n + 1 ; i += p ) prime [ i ] = false ; } p += 1 ; } for ( p = 2 ; p < n + 1 ; p ++ ) { if ( prime [ p ] && isTetradic ( p ) ) document . write ( p + "" "" ) ; } } let n = 1000 ; printTetradicPrimesLessThanN ( n ) ;";"Tetradic Primes | Function to check if the number N having all digits lies in the set ( 0 , 1 , 8 ) ; Function to check if the number N is palindrome ; Function to check if a number N is Tetradic ; Function to generate all primes and checking whether number is Tetradic or not ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Print all Tetradic prime numbers ; Checking whether the given number is prime Tetradic or not ; Driver code"
Javascript;"function concat ( a , b ) { var s1 = a . toString ( ) ; var s2 = b . toString ( ) ; var s = s1 + s2 ; var c = s ; return c ; } function isAstonishing ( n ) { for ( var i = 1 ; i < n ; i ++ ) { var sum = 0 ; for ( var j = i ; j < n ; j ++ ) { sum += j ; if ( sum == n ) { var concatenation = concat ( i , j ) ; if ( concatenation == n ) { return true ; } } } } return false ; } var n = 429 ; if ( isAstonishing ( n ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Astonishing Numbers | Function to concatenate two integers into one ; Convert both the integers to string ; Concatenate both strings ; Convert the concatenated string to integer ; return the formed integer ; Function to check if N is a Astonishing number ; Loop to find sum of all integers from i till the sum becomes >= n ; variable to store sum of all integers from i to j and check if sum and concatenation equals n or not ; finding concatenation of i and j ; condition for Astonishing number ; Given Number ; Function Call"
Javascript;"function checkSame ( n , b ) { var m = { } ; while ( n != 0 ) { var r = n % b ; n = n / b ; if ( r in m ) m [ r ] += 1 else m [ r ] = 1 } var last = - 1 ; for ( var i in m ) { if ( last != - 1 && m [ i ] != last ) { return false ; } else { last = m [ i ] ; } } return true ; } var n = 9 ; var base = 2 ; if ( checkSame ( n , base ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Digitally balanced numbers | Function to check if the digits in the number is the same number of digits ; Loop to iterate over the digits of the number N ; Loop to iterate over the map ; Driver Code ; function to check"
Javascript;"function seriesSum ( n ) { let sum = 0 ; let currProd = 1 ; let currSum = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { currProd *= i ; currSum += i ; sum += currProd - currSum ; } return sum ; } let N = 5 ; document . write ( seriesSum ( N ) + "" "" ) ;";"Sum of series formed by difference between product and sum of N natural numbers | Function to calculate the sum upto Nth term ; Stores the sum of the series ; Stores the product of natural numbers upto the current term ; Stores the sum of natural numbers upto the upto current term ; Generate the remaining terms and calculate sum ; Update the sum ; Return the sum ; Driver code"
Javascript;"function count ( a , n ) { let countElements = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let flag = true ; for ( let j = 0 ; j < n ; j ++ ) { if ( i == j ) continue ; if ( a [ i ] % a [ j ] == 0 ) { flag = false ; break ; } } if ( flag == true ) ++ countElements ; } return countElements ; } let arr = [ 86 , 45 , 18 , 4 , 8 , 28 , 19 , 33 , 2 ] ; let n = arr . length ; document . write ( count ( arr , n ) ) ;";"Count of elements not divisible by any other elements of Array | Function to count the number of elements of array which are not divisible by any other element in the array arr [ ] ; Iterate over the array ; Check if the element is itself or not ; Check for divisibility ; Return the final result ; Given array ; Function Call"
Javascript;"function smallestNumber ( N ) { return N * Math . ceil ( Math . pow ( 10 , ( N - 1 ) ) / N ) ; } let N = 2 ; document . write ( smallestNumber ( N ) ) ;";"Smallest N digit number divisible by N | Function to find the smallest N - digit number divisible by N ; Return the smallest N - digit number calculated using above formula ; Given N ; Function Call"
Javascript;"function CountPairs ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] % 2 == 0 arr [ j ] % 2 == 0 ) count ++ ; } } return count ; } let arr = [ 8 , 2 , 3 , 1 , 4 , 2 ] ; let n = arr . length ; document . write ( CountPairs ( arr , n ) ) ;";"Count pairs in an array containing at least one even value | Function to count the pairs in the array such as there is at least one even element in each pair ; Generate all possible pairs and increment then count if the condition is satisfied ; Driver code ; Function call"
Javascript;"function CountPairs ( arr , n ) { let even = 0 , odd = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } return ( even * ( even - 1 ) ) / 2 + ( even * odd ) ; } let arr = [ 8 , 2 , 3 , 1 , 4 , 2 ] ; let n = arr . length ; document . write ( CountPairs ( arr , n ) ) ;";"Count pairs in an array containing at least one even value | Function to count the pairs in the array such as there is at least one even element in each pair ; Store count of even and odd elements ; Check element is even or odd ; Driver Code"
Javascript;"function isComposite ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return false ; if ( n % 2 == 0 n % 3 == 0 ) return true ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return true ; return false ; } function isGiugaNum ( n ) { if ( ! ( isComposite ( n ) ) ) return false ; let N = n ; while ( n % 2 == 0 ) { if ( ( N / 2 - 1 ) % 2 != 0 ) return false ; n = n / 2 ; } for ( let i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { if ( ( N / i - 1 ) % i != 0 ) return false ; n = n / i ; } } if ( n > 2 ) if ( ( N / n - 1 ) % n != 0 ) return false ; return true ; } let n = 30 ; if ( isGiugaNum ( n ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Giuga Numbers | Function to check if n is a composite number ; Corner cases ; This is checked to skip middle 5 numbers ; Function to check if N is a Giuga Number ; N should be composite to be a Giuga Number ; Print the number of 2 s that divide n ; N must be odd at this point . So we can skip one element ; While i divides n , print i and divide n ; This condition is to handle the case when n is a prime number > 2 ; Given Number N ; Function Call"
Javascript;"function isDroll ( n ) { if ( n == 1 ) return false ; let sum_even = 0 ; let sum_odd = 0 ; while ( n % 2 == 0 ) { sum_even += 2 ; n = n / 2 ; } for ( let i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { sum_odd += i ; n = n / i ; } } if ( n > 2 ) sum_odd += n ; return sum_even == sum_odd ; } let n = 72 ; if ( isDroll ( n ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Droll Numbers | Function to check droll numbers ; To store sum of even prime factors ; To store sum of odd prime factors ; Add the number of 2 s that divide n in sum_even ; N must be odd at this polet . So we can skip one element ( Note i = i + 2 ) ; While i divides n , prlet i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; Condition to check droll number ; Given Number N ; Function Call"
Javascript;"function gcd ( a , b ) { if ( b == 0 ) return a ; return ( gcd ( b , a % b ) ) ; } function CountPairs ( n ) { let cnt = 0 ; for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { let div1 = i ; let div2 = Math . floor ( n / i ) ; let sum = div1 + div2 ; if ( gcd ( sum , n ) == 1 ) cnt += 1 ; } } return cnt ; } let n = 24 ; document . write ( CountPairs ( n ) + "" "" ) ;";"Count all pairs of divisors of a number N whose sum is coprime with N | Function to calculate GCD ; Function to count all valid pairs ; Initialize count ; Check if sum of pair and n are coprime ; Return the result ; Driver code"
Javascript;"function isPossible ( A , B ) { return ( A - B > 1 ) ; } let A = 10 , B = 4 ; if ( isPossible ( A , B ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check if A can be converted to B by reducing with a Prime number | Function to find if it is possible to make A equal to B ; Driver Code ; Function Call"
Javascript;"let sub = new Array ( 100005 ) ; sub . fill ( 0 ) ; function minDivisorDifference ( n ) { let num1 = 0 ; let num2 = 0 ; for ( let i = parseInt ( Math . sqrt ( n ) , 10 ) ; i <= n ; i ++ ) { if ( n % i == 0 ) { num1 = i ; num2 = parseInt ( n / i , 10 ) ; break ; } } return Math . abs ( num1 - num2 ) ; } function dfs ( g , u , par ) { sub [ u ] = minDivisorDifference ( u ) ; let mx = 0 ; for ( let c = 0 ; c < g [ u ] . length ; c ++ ) { if ( g [ u ] != par ) { let ans = dfs ( g , g [ u ] , u ) ; mx = Math . max ( mx , ans ) ; } } sub [ u ] += mx ; return sub [ u ] ; } let g = new Array ( 100005 ) ; for ( let i = 0 ; i < g . length ; i ++ ) g [ i ] = [ ] ; let edges = 6 ; g [ 18 ] . push ( 7 ) ; g [ 7 ] . push ( 18 ) ; g [ 18 ] . push ( 15 ) ; g [ 15 ] . push ( 18 ) ; g [ 15 ] . push ( 2 ) ; g [ 2 ] . push ( 15 ) ; g [ 7 ] . push ( 4 ) ; g [ 4 ] . push ( 7 ) ; g [ 7 ] . push ( 12 ) ; g [ 12 ] . push ( 7 ) ; g [ 12 ] . push ( 9 ) ; g [ 9 ] . push ( 12 ) ; let root = 18 ; document . write ( dfs ( g , root , - 1 ) ) ;";"Maximize sum of minimum difference of divisors of nodes in N | Array to store the result at each node ; Function to get minimum difference between the divisors of a number ; Iterate from square root of N to N ; return absolute difference ; DFS function to calculate the maximum sum ; Store the min difference ; Add the maximum of all children to sub [ u ] ; Return maximum sum of node ' u ' to its parent ; Driver code"
Javascript;"function isCenteredcube ( N ) { let i = 1 ; while ( true ) { let ith_term = ( 2 * i + 1 ) * ( i * i + i + 1 ) ; if ( ith_term == N ) { return true ; } if ( ith_term > N ) { return false ; } i ++ ; } } let N = 9 ; if ( isCenteredcube ( N ) ) { document . write ( "" "" ) ; } else { document . write ( "" "" ) ; }";"Program to check if N is a Centered Cubic Number | Function to check if the number N is a centered cubic number ; Iterating from 1 ; Infinite loop ; Finding ith_term ; Checking if the number N is a Centered cube number ; If ith_term > N then N is not a Centered cube number ; Incrementing i ; Driver code ; Function call"
Javascript;"function productOfGP ( a , r , n ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) { product = product * a ; a = a * r ; } return product ; } let a = 1 , r = 2 ; let N = 4 ; document . write ( productOfGP ( a , r , N ) ) ;";"Product of N terms of a given Geometric series | Function to calculate product of geometric series ; Initialise final product with 1 ; Multiply product with each term stored in a ; Return the final product ; Given first term and common ratio ; Number of terms ; Function Call"
Javascript;"function gcd ( a , b ) { if ( b == 0 ) { return a ; } return gcd ( b , a % b ) ; } function findlcm ( arr , n ) { var ans = arr [ 0 ] ; for ( var i = 1 ; i < n ; i ++ ) { ans = ( ( ( arr [ i ] * ans ) ) / ( gcd ( arr [ i ] , ans ) ) ) ; } return ans ; } function addReduce ( n , num , den ) { var final_numerator = 0 ; var final_denominator = findlcm ( den , n ) ; for ( var i = 0 ; i < n ; i ++ ) { final_numerator = final_numerator + ( num [ i ] ) * parseInt ( final_denominator / den [ i ] ) ; } var GCD = gcd ( final_numerator , final_denominator ) ; final_numerator = parseInt ( final_numerator / GCD ) ; final_denominator = parseInt ( final_denominator / GCD ) ; document . write ( final_numerator + "" "" + final_denominator + "" "" ) ; } var N = 3 ; var arr1 = [ 1 , 2 , 5 ] ; var arr2 = [ 2 , 1 , 6 ] ; addReduce ( N , arr1 , arr2 ) ;";"Sum of given N fractions in reduced form | Function to find GCD of a & b using Euclid Lemma ; Base Case ; Function to find the LCM of all elements in arr [ ] ; Initialize result ; Iterate arr [ ] to find LCM ; Return the final LCM ; Function to find the sum of N fraction in reduced form ; To store the sum of all final numerators ; Find the LCM of all denominator ; Find the sum of all N numerators & denominators ; Add each fraction one by one ; Find GCD of final numerator and denominator ; Convert into reduced form by dividing from GCD ; Print the final fraction ; Given N ; Given Numerator ; Given Denominator ; Function Call"
Javascript;"function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } function minLCM ( arr , n ) { let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { let g = gcd ( arr [ i ] , arr [ j ] ) ; let lcm = arr [ i ] / g * arr [ j ] ; ans = Math . min ( ans , lcm ) ; } } return ans ; } let arr = [ 2 , 4 , 3 , 6 , 5 ] ; let n = arr . length ; document . write ( minLCM ( arr , n ) ) ;";"Minimum LCM of all pairs in a given array | function to compute GCD of two numbers ; function that return minimum possible lcm from any pair ; fix the ith element and iterate over all the array to find minimum LCM ; Driver code"
Javascript;"function solve ( n ) { let upper_limit = Math . ceil ( Math . pow ( n , 1.0 / 4 ) ) ; for ( let x = 0 ; x <= upper_limit ; x ++ ) { for ( let y = 0 ; y <= upper_limit ; y ++ ) { let num1 = x * x * x * x ; let num2 = y * y * y * y ; if ( num1 - num2 == n ) { document . write ( "" "" + x + "" "" + y ) ; return ; } } } document . write ( - 1 ) ; } let n = 15 ; solve ( n ) ;";"Find two numbers whose difference of fourth power is equal to N | Function which find required x & y ; Upper limit of x & y , if such x & y exists ; num1 stores x ^ 4 ; num2 stores y ^ 4 ; If condition is satisfied the print and return ; If no such pair exists ; Driver code"
Javascript;"function divisorsSame ( n ) { let even_div = 0 , odd_div = 0 ; for ( let i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( Math . floor ( n / i ) == i ) { if ( i % 2 == 0 ) { even_div ++ ; } else { odd_div ++ ; } } else { if ( i % 2 == 0 ) { even_div ++ ; } else { odd_div ++ ; } if ( Math . floor ( n / i ) % 2 == 0 ) { even_div ++ ; } else { odd_div ++ ; } } } } return ( even_div == odd_div ) ; } let N = 6 ; if ( divisorsSame ( N ) ) { document . write ( "" "" ) ; } else { document . write ( "" "" ) ; }";"Check if count of even divisors of N is equal to count of odd divisors | Function to check if count of even and odd divisors are equal ; To store the count of even factors and odd factors ; Loop till [ 1 , sqrt ( N ) ] ; If divisors are equal add only one ; Check for even divisor ; Odd divisor ; Check for both divisor i . e . , i and N / i ; Check if i is odd or even ; Check if N / i is odd or even ; Return true if count of even_div and odd_div are equals ; Given Number ; Function Call"
Javascript;"function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } function isBalancedPrime ( n ) { if ( ! isPrime ( n ) n == 2 ) return false ; let previous_prime = n - 1 ; let next_prime = n + 1 ; while ( ! isPrime ( next_prime ) ) next_prime ++ ; while ( ! isPrime ( previous_prime ) ) previous_prime -- ; let mean = ( previous_prime + next_prime ) / 2 ; if ( n == mean ) return true ; else return false ; } let n = 53 ; if ( isBalancedPrime ( n ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check if N is a Balanced Prime number or not | Utility function to check if a number is prime or not ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function that returns true if n is a Balanced prime ; If n is not a prime number or n is the first prime then return false ; Initialize previous_prime to n - 1 and next_prime to n + 1 ; Find next prime number ; Find previous prime number ; Arithmetic mean ; If n is a weak prime ; Driver code"
Javascript;"let N = 100001 ; let adj = new Array ( N ) ; let a = new Array ( N ) ; let ans = new Array ( N ) ; function hasOddNumberOfDivisors ( n ) { if ( Math . sqrt ( n ) == parseInt ( Math . sqrt ( n ) , 10 ) ) return true ; return false ; } function dfs ( node , parent ) { let count = 0 ; for ( let i = 0 ; i < adj [ node ] . length ; i ++ ) { if ( adj [ node ] [ i ] != parent ) { count += dfs ( adj [ node ] [ i ] , node ) ; } } if ( hasOddNumberOfDivisors ( a [ node ] ) ) ++ count ; ans [ node ] = count ; return count ; } let n = 5 ; let q = [ 4 , 1 , 5 , 3 ] ; for ( let i = 0 ; i < adj . length ; i ++ ) adj [ i ] = [ ] ; adj [ 1 ] . push ( 2 ) ; adj [ 2 ] . push ( 1 ) ; adj [ 2 ] . push ( 3 ) ; adj [ 3 ] . push ( 2 ) ; adj [ 3 ] . push ( 4 ) ; adj [ 4 ] . push ( 3 ) ; adj [ 1 ] . push ( 5 ) ; adj [ 5 ] . push ( 1 ) ; a [ 1 ] = 4 ; a [ 2 ] = 9 ; a [ 3 ] = 14 ; a [ 4 ] = 100 ; a [ 5 ] = 5 ; dfs ( 1 , - 1 ) ; for ( let i = 0 ; i < q . length ; i ++ ) { document . write ( ans [ q [ i ] ] + "" "" ) ; }";"Count of nodes having odd divisors in the given subtree for Q queries | Javascript implementation to count the number of nodes having odd number of divisors for each query ; Adjacency list for tree . ; Array for values and answer at ith node . ; Function to check whether N has odd divisors or not ; DFS function to pre - compute the answers ; Initialize the count ; Repeat for every child ; Increase the count if current node has odd number of divisors ; Driver Code ; Adjacency List ; Function call"
Javascript;"function lowerBound ( array , length , value ) { var low = 0 ; var high = length ; while ( low < high ) { var mid = parseInt ( ( low + high ) / 2 ) ; if ( value <= array [ mid ] ) { high = mid ; } else { low = mid + 1 ; } } return low ; } function costCalculation ( current , arr , n , pref , a , r , minimum ) { var index = lowerBound ( arr , arr . length , current ) ; var left = index * current - pref [ index ] ; var right = pref [ n ] - pref [ index ] - ( n - index ) * current ; var res = Math . min ( left , right ) ; left -= res ; right -= res ; var total = res * minimum ; total += left * a ; total += right * r ; return total ; } function solve ( arr , n , a , r , m ) { arr . sort ( ) ; var minimum = Math . min ( a + r , m ) ; var pref = Array ( n + 1 ) . fill ( 0 ) ; for ( i = 0 ; i < n ; i ++ ) pref [ i + 1 ] = pref [ i ] + arr [ i ] ; var ans = 10000 ; for ( i = 0 ; i < n ; i ++ ) ans = Math . min ( ans , costCalculation ( arr [ i ] , arr , n , pref , a , r , minimum ) ) ; ans = Math . min ( ans , costCalculation ( pref [ n ] / n , arr , n , pref , a , r , minimum ) ) ; ans = Math . min ( ans , costCalculation ( pref [ n ] / n + 1 , arr , n , pref , a , r , minimum ) ) ; document . write ( ans ) ; } var arr = [ 5 , 5 , 3 , 6 , 5 ] ; var A = 1 , R = 2 , M = 4 ; var size = arr . length ; solve ( arr , size , A , R , M ) ;";"Minimum Cost to make all array elements equal using given operations | javascript implementation to find the minimum cost to make all array elements equal ; Checks if the value is less than middle element of the array ; Function that returns the cost of making all elements equal to current element ; Compute the lower bound of current element ; Calculate the requirement of add operation ; Calculate the requirement of subtract operation ; Compute minimum of left and right ; Computing the total cost of add and subtract operations ; Function that prints minimum cost of making all elements equal ; Sort the given array ; Calculate minimum from a + r and m ; Compute prefix sum and store in pref array ; Find the minimum cost from the given elements ; Finding the minimum cost from the other cases where minimum cost can occur ; Printing the minimum cost of making all elements equal ; Driver Code ; Function Call"
Javascript;"function countBinaries ( N ) { let ctr = 1 ; let ans = 0 ; while ( N > 0 ) { if ( N % 10 == 1 ) { ans += Math . pow ( 2 , ctr - 1 ) ; } else if ( N % 10 > 1 ) { ans = Math . pow ( 2 , ctr ) - 1 ; } ctr ++ ; N /= 10 ; } return ans ; } let N = 20 ; document . write ( countBinaries ( N ) ) ;";"Count of integers up to N which represent a Binary number | Function to return the count ; If the current last digit is 1 ; Add 2 ^ ( ctr - 1 ) possible integers to the answer ; If the current digit exceeds 1 ; Set answer as 2 ^ ctr - 1 as all possible binary integers with ctr number of digits can be obtained ; Driver Code"
Javascript;"function countBinaries ( N ) { let powersOfTwo = [ ] ; powersOfTwo . push ( 1 ) ; for ( let i = 1 ; i < 11 ; i ++ ) { powersOfTwo . push ( powersOfTwo [ i - 1 ] * 2 ) ; } let ctr = 1 ; let ans = 0 ; while ( N > 0 ) { if ( N % 10 == 1 ) { ans += powersOfTwo [ ctr - 1 ] ; } else if ( N % 10 > 1 ) { ans = powersOfTwo [ ctr ] - 1 ; } ctr ++ ; N /= 10 ; } return ans ; } let N = 20 ; document . write ( countBinaries ( N ) ) ;";"Count of integers up to N which represent a Binary number | Function to return the count ; PreCompute and store the powers of 2 ; If the current last digit is 1 ; Add 2 ^ ( ctr - 1 ) possible integers to the answer ; If the current digit exceeds 1 ; Set answer as 2 ^ ctr - 1 as all possible binary integers with ctr number of digits can be obtained ; Driver Code"
Javascript;"function Centered_Hexadecagonal_num ( n ) { return ( 8 * n * n - 8 * n + 1 ) ; } function sum_Centered_Hexadecagonal_num ( n ) { let summ = 0 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Hexadecagonal_num ( i ) ; } return summ ; } let n = 5 ; document . write ( sum_Centered_Hexadecagonal_num ( n ) ) ;";"Find the sum of the first Nth Centered Hexadecagonal Number | Centered_Hexadecagonal number function ; Formula to calculate nth Centered_Hexadecagonal number & return it into main function . ; Function to find the sum of the first N centered hexadecagonal number ; Variable to store the sum ; Loop to iterate through the first N numbers ; Finding the sum ; Driver Code ; Display first Nth Centered_Hexadecagonal number"
Javascript;"function center_heptagonal_num ( n ) { return ( 7 * n * n - 7 * n + 2 ) / 2 ; } function sum_center_heptagonal_num ( n ) { let summ = 0 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { summ += center_heptagonal_num ( i ) ; } return summ ; } let n = 5 ; document . write ( sum_center_heptagonal_num ( n ) ) ;";"Find the sum of the first N Centered heptagonal number | Function to find the N - th centered heptagonal number ; Formula to calculate nth centered heptagonal number ; Function to find the sum of the first N centered heptagonal numbers ; Variable to store the sum ; Iterating through the range 1 to N ; Driver Code"
Javascript;"function Centered_Dodecagonal_num ( n ) { return 6 * n * ( n - 1 ) + 1 ; } function sum_Centered_Dodecagonal_num ( n ) { let summ = 0 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Dodecagonal_num ( i ) ; } return summ ; } let n = 5 ; document . write ( sum_Centered_Dodecagonal_num ( n ) ) ;";"Find the sum of the first N Centered Dodecagonal Number | Function to find the N - th Centered Dodecagonal number ; Formula to calculate nth Centered_Dodecagonal number ; Function to find the sum of the first N Centered_Dodecagonal number ; Variable to store the sum ; Iterating from 1 to N ; Finding the sum ; Driver code"
Javascript;"function center_Octagonal_num ( n ) { return ( 4 * n * n - 4 * n + 1 ) ; } function sum_center_Octagonal_num ( n ) { let summ = 0 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { summ += center_Octagonal_num ( i ) ; } return summ ; } let n = 5 ; document . write ( sum_center_Octagonal_num ( n ) ) ;";"Find the sum of the first N Centered Octagonal Number | Function to find the N - th centered octagonal number ; Formula to calculate nth centered octagonal number ; Function to find the sum of the first N centered octagonal numbers ; Variable to store the sum ; Iterating through the range 1 to N ; Driver code"
Javascript;"function Centered_decagonal_num ( n ) { return ( 5 * n * n - 5 * n + 1 ) ; } function sum_Centered_decagonal_num ( n ) { let summ = 0 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_decagonal_num ( i ) ; } return summ ; } let n = 5 ; document . write ( sum_Centered_decagonal_num ( n ) ) ;";"Find the sum of the first N Centered Decagonal Numbers | Function to find the N - th centred decagonal number ; Formula to calculate nth centered_decagonal number & return it into main function . ; Function to find the sum of the first N centered decagonal numbers ; Variable to store the sum ; Iterating through the range ; Driver code ; Display first Nth centered_decagonal number"
Javascript;"function center_octadecagon_num ( n ) { return ( 9 * n * n - 9 * n + 1 ) ; } function sum_center_octadecagon_num ( n ) { let summ = 0 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { summ += center_octadecagon_num ( i ) ; } return summ ; } let n = 3 ; document . write ( sum_center_octadecagon_num ( n ) ) ;";"Find the sum of the first N Centered Octadecagonal Numbers | Function to find the N - th centered octadecagonal number ; Formula to calculate nth centered octadecagonal number ; Function to find the sum of the first N centered octadecagonal numbers ; Variable to store the sum ; Iterating through the range 1 to N ; Driver Code"
Javascript;"function Centered_Pentadecagonal_num ( n ) { return ( 15 * n * n - 15 * n + 2 ) / 2 ; } function sum_Centered_Pentadecagonal_num ( n ) { let summ = 0 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Pentadecagonal_num ( i ) ; } return summ ; } let n = 5 ; document . write ( sum_Centered_Pentadecagonal_num ( n ) ) ;";"Find the sum of the first Nth Centered Pentadecagonal Number | Function to find the centered pentadecagonal number ; Formula to calculate N - th centered pentadecagonal number ; Function to find the sum of the first N centered pentadecagonal numbers ; Variable to store the sum ; Driver Code"
Javascript;"function isoctagonal ( N ) { var n = ( 2 + Math . sqrt ( 12 * N + 4 ) ) / 6 ; return ( n - parseInt ( n ) == 0 ) ; } var N = 8 ; if ( isoctagonal ( N ) ) { document . write ( "" "" ) ; } else { document . write ( "" "" ) ; }";"Program to check if N is a Octagonal Number | Function to check if N is a Octagonal Number ; Condition to check if the number is a octagonal number ; Given Number ; Function call"
Javascript;"function isPentadecagon ( N ) { var n = ( 11 + Math . sqrt ( 104 * N + 121 ) ) / 26 ; return ( n - parseInt ( n ) ) == 0 ; } var N = 15 ; if ( isPentadecagon ( N ) ) { document . write ( "" "" ) ; } else { document . write ( "" "" ) ; }";"Program to check if N is a Pentadecagonal Number | Function to check if N is a Pentadecagon number ; Condition to check if the number is a Pentadecagon number ; Given Number ; Function call"
Javascript;"function istetradecagonal ( N ) { n = ( 10 + Math . sqrt ( 96 * N + 100 ) ) / 24 ; return ( n - parseInt ( n ) ) == 0 ; } N = 11 ; if ( istetradecagonal ( N ) ) { document . write ( "" "" ) ; } else { document . write ( "" "" ) ; }";"Program to check if N is a Tetradecagonal Number | Function to check if N is a Tetradecagonal Number ; Condition to check if the number is a tetradecagonal number ; Given Number ; Function call"
Javascript;"function Icosagonal_num ( n ) { return ( 18 * n * n - 16 * n ) / 2 ; } function sum_Icosagonal_num ( n ) { let summ = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { summ += Icosagonal_num ( i ) ; } return summ ; } let n = 5 ; document . write ( sum_Icosagonal_num ( n ) ) ;";"Find the sum of the first Nth Icosagonal Numbers | Function to calculate the N - th icosagonal number ; Formula to calculate nth icosagonal number & return it ; Function to find the sum of the first N icosagonal numbers ; Variable to store the sum ; Loop to iterate through the first N values and find the sum of first N icosagonal numbers ; Function to get the Icosagonal_num ; Driver code ; Display the sum of first N icosagonal number"
Javascript;"function Centered_Pentagonal_num ( n ) { return ( 5 * n * n - 5 * n + 2 ) / 2 ; } function sum_Centered_Pentagonal_num ( n ) { let summ = 0 ; for ( let i = 1 ; i < n + 1 ; i ++ ) { summ += Centered_Pentagonal_num ( i ) ; } return summ ; } let n = 5 ; document . write ( sum_Centered_Pentagonal_num ( n ) ) ;";"Find the sum of the first N Centered Pentagonal Number | Function to find the Centered_Pentagonal number ; Formula to calculate nth Centered_Pentagonal number & return it into main function . ; Function to find the sum of the first N Centered_Pentagonal numbers ; To get the sum ; Iterating through the range 1 to N ; Driver code ; Display first Nth Centered_Pentagonal number"
Javascript;"function Centered_tridecagonal_num ( n ) { return ( 13 * n * ( n - 1 ) + 2 ) / 2 ; } function sum_Centered_tridecagonal_num ( n ) { let summ = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { summ += Centered_tridecagonal_num ( i ) ; } return summ ; } let n = 5 ; document . write ( sum_Centered_tridecagonal_num ( n ) ) ;";"Find the sum of the first Nth Centered Tridecagonal Numbers | Function to calculate the N - th centered tridecagonal number ; Formula to calculate Nth centered tridecagonal number & return it ; Function to find the sum of the first N centered tridecagonal numbers ; Variable to store the sum ; Loop to iterate and find the sum of first N centered tridecagonal numbers ; Driver code"
Javascript;"var Prime = Array ( 100 ) . fill ( true ) ; function computePrime ( N ) { var i , j ; Prime [ 0 ] = Prime [ 1 ] = false ; for ( i = 2 ; i * i <= N ; i ++ ) { if ( Prime [ i ] ) { for ( j = i * i ; j < N ; j += i ) { Prime [ j ] = false ; } } } } function countSexyPairs ( arr , n ) { var maxE = Math . max . apply ( Math , arr ) ; computePrime ( maxE ) ; var count = 0 ; var freq = Array ( maxE + 1 ) . fill ( 0 ) ; for ( i = 0 ; i < n ; i ++ ) { freq [ arr [ i ] ] ++ ; } arr . sort ( ) ; for ( i = 0 ; i < n ; i ++ ) { if ( Prime [ arr [ i ] ] ) { if ( freq [ arr [ i ] + 6 ] > 0 && Prime [ arr [ i ] + 6 ] ) { count ++ ; } } } return count ; } var arr = [ 6 , 7 , 5 , 11 , 13 ] ; var n = arr . length ; document . write ( countSexyPairs ( arr , n ) ) ;";"Count Sexy Prime Pairs in the given array | To store check the prime number ; A utility function that find the Prime Numbers till N ; Resize the Prime Number ] ; Loop till sqrt ( N ) to find prime numbers and make their multiple false in the bool array Prime ; Function that returns the count of SPP ( Sexy Prime Pair ) Pairs ; Find the maximum element in the given array arr [ ] ; Function to calculate the prime numbers till N ; To store the count of pairs ; To store the frequency of element in the array arr [ ] ; Sort before traversing the array ; Traverse the array and find the pairs with SPP ( Sexy Prime Pair ) ; If current element is Prime , then check for ( current element + 6 ) ; Return the count of pairs ; Driver code ; Function call to find SPP ( Sexy Prime Pair ) pair"
Javascript;"function countWays ( n ) { if ( n <= 2 ) document . write ( "" "" ) ; else { var ans = ( n - 1 ) * ( n - 2 ) / 2 ; document . write ( ans ) ; } } var N = 5 ; countWays ( N ) ;";"Count of ways to write N as a sum of three numbers | Function to find the number of ways ; Check if number is less than 2 ; Calculate the sum ; Driver code"
Javascript;"function isPowerOfTwo ( n ) { return ( Math . ceil ( Math . log ( n ) / Math . log ( 2 ) ) == Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ) ; } let N = 8 ; if ( isPowerOfTwo ( N ) ) { document . write ( "" "" ) ; } else { document . write ( "" "" ) ; }";"Logarithm tricks for Competitive Programming | Function to check if the number is a power of two ; Driver Code"
Javascript;"function count_pairs ( x ) { var ans = 1 ; while ( x > 0 ) { if ( x % 2 == 1 ) ans = ans * 3 ; x = parseInt ( x / 2 ) ; } return ans ; } var X = 6 ; document . write ( count_pairs ( X ) + "" "" ) ;";"Count of pairs having bit size at most X and Bitwise OR equal to X | Function to count the pairs ; Initializing answer with 1 ; Iterating through bits of x ; Check if bit is 1 ; Multiplying ans by 3 if bit is 1 ; Driver code"
Javascript;"function kthNonDivisible ( N , K ) { let L = 1 ; let H = 2147483647 ; let ans = 0 ; while ( L <= H ) { let mid = parseInt ( ( L + H ) / 2 , 10 ) ; let sol = mid - parseInt ( mid / N , 10 ) ; if ( sol > K ) { H = mid - 1 ; } else if ( sol < K ) { L = mid + 1 ; } else { ans = mid ; H = mid - 1 ; } } document . write ( ans ) ; } let N = 3 ; let K = 7 ; kthNonDivisible ( N , K ) ;";"Find the Kth number which is not divisible by N | Function to find the Kth not divisible by N ; Lowest possible value ; Highest possible value ; To store the Kth non divisible number of N ; Using binary search ; Calculating mid value ; Sol would have the value by subtracting all multiples of n till mid ; Check if sol is greater than k ; H should be reduced to find minimum possible value ; Check if sol is less than k then L will be mid + 1 ; Check if sol is equal to k ; ans will be mid ; H would be reduced to find any more possible value ; Print the answer ; Driver code ; Function Call"
Javascript;"function printPair ( n ) { document . write ( 1 + "" "" + ( n - 1 ) ) ; } var n = 14 ; printPair ( n ) ;";"Print any pair of integers with sum of GCD and LCM equals to N | Function to prvar the required pair ; Prvar the pair ; Driver code"
Javascript;"function isAutoBiographyNum ( number ) { let count = 0 , position , size , digit ; let NUM ; NUM = number . toString ( ) ; size = NUM . length ; for ( let i = 0 ; i < size ; i ++ ) { position = NUM [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ; count = 0 ; for ( let j = 0 ; j < size ; j ++ ) { digit = NUM [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ; if ( digit == i ) count ++ ; } if ( position != count ) return false ; } return true ; } function checkArray ( arr , n ) { let current_length = 0 ; let max_length = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( isAutoBiographyNum ( arr [ i ] ) ) current_length ++ ; else current_length = 0 ; max_length = Math . max ( max_length , current_length ) ; } return max_length ; } let arr = [ 21200 , 1 , 1303 , 1210 , 2020 ] ; let n = arr . length ; document . write ( checkArray ( arr , n ) ) ;";"Find the length of largest subarray in which all elements are Autobiographical Numbers | function to check number is autobiographical ; Convert integer to string ; Iterate for every digit to check for their total count ; Check occurrence of every number and count them ; Check if any position mismatches with total count them return with false else continue with loop ; Function to return the length of the largest subarray whose every element is a Autobiographical number ; Utility function which checks every element of array for Autobiographical number ; Check if element arr [ i ] is an Autobiographical number ; Increment the current length ; Update max_length value ; Return the final result ; Driver code"
Javascript;"class pair { constructor ( first , second ) { this . first = first ; this . second = second ; } } function __gcd ( a , b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } function sumOfSquares ( n , vp ) { for ( let i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { let h = n - i * i , h1 = Math . floor ( Math . sqrt ( h ) ) ; if ( h1 * h1 == h ) { let a = Math . max ( h1 , i ) , b = Math . min ( h1 , i ) ; if ( vp . length == 1 && a != vp [ 0 ] . first ) vp . push ( new pair ( a , b ) ) ; if ( vp . length == 0 ) vp . push ( new pair ( a , b ) ) ; if ( vp . length == 2 ) return ; } } } function findFactors ( n ) { let vp = [ ] ; sumOfSquares ( n , vp ) ; if ( vp . length != 2 ) document . write ( "" "" ) ; let a , b , c , d ; a = vp [ 0 ] . first ; b = vp [ 0 ] . second ; c = vp [ 1 ] . first ; d = vp [ 1 ] . second ; if ( a < c ) { let t = a ; a = c ; c = t ; t = b ; b = d ; d = t ; } let k , h , l , m ; k = __gcd ( a - c , d - b ) ; h = __gcd ( a + c , d + b ) ; l = ( a - c ) / k ; m = ( d - b ) / k ; document . write ( "" "" + a + "" "" + ( a - c ) + "" "" + k + "" "" ) ; document . write ( "" "" + b + "" "" + ( a + c ) + "" "" + h + "" "" ) ; document . write ( "" "" + c + "" "" + ( d - b ) + "" "" + l + "" "" ) ; document . write ( "" "" + d + "" "" + ( d + b ) + "" "" + m + "" "" ) ; if ( k % 2 == 0 && h % 2 == 0 ) { k = k / 2 ; h = h / 2 ; document . write ( "" "" + ( ( k ) * ( k ) + ( h ) * ( h ) ) + "" "" + ( l * l + m * m ) + "" "" ) ; } else { l = l / 2 ; m = m / 2 ; document . write ( "" "" + ( ( l ) * ( l ) + ( m ) * ( m ) ) + "" "" + ( k * k + h * h ) + "" "" ) ; } } let n = 100000 ; findFactors ( n ) ;";"Euler 's Factorization method |  ; Recursive function to return gcd of a and b ; Function to return N as the sum of two squares in two possible ways ; Iterate a loop from 1 to Math . sqrt ( n ) ; If i * i is square check if there exists another integer such that h is a perfect square and i * i + h = n ; If h is perfect square ; Store in the sorted way ; If there is already a pair check if pairs are equal or not ; Insert the first pair ; If two pairs are found ; Function to find the factors ; Get pairs where a ^ 2 + b ^ 2 = n ; Number cannot be represented as sum of squares in two ways ; Assign a , b , c , d ; Swap if a < c because if a - c < 0 , GCD cant be computed . ; Compute the values of k , h , l , m using the formula mentioned in the approach ; Print the values of a , b , c , d and k , l , m , h ; Printing the factors ; Driver code"
Javascript;"let MAX = 100000 ; let graph = [ ] for ( let i = 0 ; i < MAX + 1 ; i ++ ) { graph . push ( [ ] ) } let Prime = new Array ( MAX + 1 ) . fill ( true ) ; let height = new Array ( MAX + 1 ) ; function SieveOfEratosthenes ( ) { let i , j ; Prime [ 0 ] = Prime [ 1 ] = false ; for ( i = 2 ; i * i <= MAX ; i ++ ) { if ( Prime [ i ] ) { for ( j = 2 * i ; j < MAX ; j += i ) { Prime [ j ] = false ; } } } } function dfs ( node , parent , h ) { height [ node ] = h ; for ( let to of graph [ node ] ) { if ( to == parent ) continue ; dfs ( to , node , h + 1 ) ; } } function primeHeightNode ( N ) { SieveOfEratosthenes ( ) ; for ( let i = 1 ; i <= N ; i ++ ) { if ( Prime [ height [ i ] ] ) { document . write ( i + "" "" ) ; } } } let N = 5 ; graph [ 1 ] . push ( 2 ) ; graph [ 1 ] . push ( 3 ) ; graph [ 2 ] . push ( 4 ) ; graph [ 2 ] . push ( 5 ) ; dfs ( 1 , 1 , 0 ) ; primeHeightNode ( N ) ;";"Print the nodes of the Binary Tree whose height is a Prime number | Javascript implementation of nodes at prime height in the given tree ; To store Prime Numbers ; To store height of each node ; Function to find the prime numbers till 10 ^ 5 ; Traverse all multiple of i and make it false ; Function to perform dfs ; Store the height of node ; Function to find the nodes at prime height ; To precompute prime number till 10 ^ 5 ; Check if height [ node ] is prime ; Number of nodes ; Edges of the tree"
Javascript;"function reverse ( a ) { let rev = 0 ; while ( a != 0 ) { let r = a % 10 ; rev = rev * 10 + r ; a = parseInt ( a / 10 , 10 ) ; } return ( rev ) ; } function prime ( a ) { let k = 0 ; for ( let i = 2 ; i < a ; i ++ ) { if ( a % i == 0 ) { k = 1 ; break ; } } if ( k == 1 ) { return ( 0 ) ; } else { return ( 1 ) ; } } function adam ( a ) { let r1 = reverse ( a ) ; let s1 = a * a ; let s2 = r1 * r1 ; let r2 = reverse ( s2 ) ; if ( s1 == r2 ) { return ( 1 ) ; } else { return ( 0 ) ; } } function find ( m , n ) { if ( m > n ) { document . write ( "" "" + "" "" ) ; } else { let c = 0 ; for ( let i = m ; i <= n ; i ++ ) { let l = prime ( i ) ; let k = adam ( i ) ; if ( ( l == 1 ) && ( k == 1 ) ) { document . write ( i + "" "" ) ; } } } } let L = 5 , R = 100 ; find ( L , R ) ;";"Find Prime Adam integers in the given range [ L , R ] | JavaScript program to find all prime adam numbers in the given range ; reversing a number by taking remainder at a time ; Function to check if a number is a prime or not ; Iterating till the number ; Checking for factors ; Returning 1 if the there are no factors of the number other than 1 or itself ; Function to check whether a number is an adam number or not ; Reversing given number ; Squaring given number ; Squaring reversed number ; Reversing the square of the reversed number ; Checking if the square of the number and the square of its reverse are equal or not ; Function to find all the prime adam numbers in the given range ; If the first number is greater than the second number , print invalid ; Iterating through all the numbers in the given range ; Checking for prime number ; Checking for Adam number ; Driver code"
Javascript;"function sumDig ( n ) { var s = 0 ; while ( n != 0 ) { s = s + ( n % 10 ) ; n = parseInt ( n / 10 ) ; } return s ; } function Pec ( n ) { var dup = n ; var dig = sumDig ( n ) ; if ( dig * 3 == dup ) return true ; else return false ; } var n = 36 ; if ( Pec ( n ) == true ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Determine whether the given integer N is a Peculiar Number or not | Function to find sum of digits of a number ; Function to check if the number is peculiar ; Store a duplicate of n ; Driver code"
Javascript;"function digit_sum ( n ) { let sum = 0 , m ; while ( n > 0 ) { m = n % 10 ; sum = sum + m ; n = parseInt ( n / 10 , 10 ) ; } return ( sum ) ; } function reverse ( n ) { let r = 0 ; while ( n != 0 ) { r = r * 10 ; r = r + n % 10 ; n = parseInt ( n / 10 , 10 ) ; } return ( r ) ; } function operation ( n ) { let i = 1 , a , count = 0 , r ; while ( count < n ) { a = digit_sum ( i ) ; r = reverse ( i ) ; if ( i % a == 0 && r % a == 0 ) { document . write ( i + "" "" ) ; count ++ ; i ++ ; } else i ++ ; } } let n = 10 ; operation ( n ) ;";"Find N numbers such that a number and its reverse are divisible by sum of its digits | Function to calculate the sum of digits ; Loop to iterate through every digit of the number ; Returning the sum of digits ; Function to calculate the reverse of a number ; Loop to calculate the reverse of the number ; Return the reverse of the number ; Function to print the first N numbers such that every number and the reverse of the number is divisible by its sum of digits ; Loop to continuously check and generate number until there are n outputs ; Variable to hold the sum of the digit of the number ; Computing the reverse of the number ; Checking if the condition satisfies . Increment the count and print the number if it satisfies . ; Driver code"
Javascript;"function createSets ( N ) { if ( N <= 2 ) { document . write ( "" "" ) ; return ; } for ( let i = 2 ; i <= N ; i += 2 ) document . write ( i + "" "" ) ; document . write ( "" "" ) ; for ( let i = 1 ; i <= N ; i += 2 ) { document . write ( i + "" "" ) ; } } let N = 6 ; createSets ( N ) ;";"Split N natural numbers into two sets having GCD of their sums greater than 1 | Function to create and print the two sets ; No such split possible for N <= 2 ; Print the first set consisting of even elements ; Print the second set consisting of odd ones ; Driver Code"
Javascript;"var ans = 0 ; var graph = Array . from ( Array ( 100 ) , ( ) => Array ( ) ) ; var weight = Array . from ( Array ( 100 ) , ( ) => Array ( ) ) ; function isPowerful ( n ) { while ( n % 2 == 0 ) { var power = 0 ; while ( n % 2 == 0 ) { n /= 2 ; power ++ ; } if ( power == 1 ) return false ; } for ( var factor = 3 ; factor <= Math . sqrt ( n ) ; factor += 2 ) { var power = 0 ; while ( n % factor == 0 ) { n = n / factor ; power ++ ; } if ( power == 1 ) return false ; } return ( n == 1 ) ; } function dfs ( node , parent ) { if ( isPowerful ( weight [ node ] ) ) ans += 1 ; graph [ node ] . forEach ( to => { if ( to != parent ) dfs ( to , node ) ; } ) ; } weight [ 1 ] = 5 ; weight [ 2 ] = 10 ; weight [ 3 ] = 11 ; weight [ 4 ] = 8 ; weight [ 5 ] = 6 ; graph [ 1 ] . push ( 2 ) ; graph [ 2 ] . push ( 3 ) ; graph [ 2 ] . push ( 4 ) ; graph [ 1 ] . push ( 5 ) ; dfs ( 1 , 1 ) ; document . write ( ans ) ;";"Count the nodes in the given tree whose weight is a powerful number | Javascript implementation to Count the nodes in the given tree whose weight is a powerful number ; Function to check if the number is powerful ; First divide the number repeatedly by 2 ; Check if only 2 ^ 1 divides n , then return false ; Check if n is not a power of 2 then this loop will execute ; Find highest power of "" factor "" that divides n ; Check if only factor ^ 1 divides n , then return false ; n must be 1 now if it is not a prime number . Since prime numbers are not powerful , we return false if n is not 1. ; Function to perform dfs ; Check if weight of the current node is a powerful number ; Weights of the node ; Edges of the tree"
Javascript;"function CountWays ( N , M ) { var count = 1 ; count = Math . pow ( 3 , M + N ) ; count *= Math . pow ( 2 , M * N ) ; return count ; } var N = 3 ; var M = 2 ; document . write ( CountWays ( N , M ) ) ;";"Number of ways to color boundary of each block of M * N table | Function to compute all way to fill the boundary of all sides of the unit square ; Count possible ways to fill all upper and left side of the rectangle M * N ; Count possible ways to fill all side of the all squares unit size ; Number of rows ; Number of columns"
Javascript;"function findNthNumber ( N ) { let arr = new Array ( N + 1 ) ; let q = [ ] ; for ( let i = 1 ; i <= 9 ; i ++ ) q . push ( i ) ; for ( let i = 1 ; i <= N ; i ++ ) { arr [ i ] = q [ 0 ] ; q . shift ( ) ; if ( arr [ i ] % 10 != 0 ) q . push ( arr [ i ] * 10 + arr [ i ] % 10 - 1 ) ; q . push ( arr [ i ] * 10 + arr [ i ] % 10 ) ; if ( arr [ i ] % 10 != 9 ) q . push ( arr [ i ] * 10 + arr [ i ] % 10 + 1 ) ; } document . write ( arr [ N ] + "" "" ) ; } let N = 21 ; findNthNumber ( N ) ;";"Nth positive number whose absolute difference of adjacent digits is at most 1 | Return Nth number with absolute difference between all adjacent digits at most 1. ; To store all such numbers ; Enqueue all integers from 1 to 9 in increasing order . ; Perform the operation N times so that we can get all such N numbers . ; Store the front element of queue , in array and pop it from queue . ; If the last digit of dequeued integer is not 0 , then enqueue the next such number . ; Enqueue the next such number ; If the last digit of dequeued integer is not 9 , then enqueue the next such number . ; Driver Code"
Javascript;"function findUniqueElements ( arr , N , K ) { var s = new Set ( arr ) ; var arr_sum = arr . reduce ( ( a , b ) => a + b , 0 ) ; var set_sum = 0 ; s . forEach ( function ( value ) { set_sum += value ; } ) document . write ( Math . floor ( ( K * set_sum - arr_sum ) / ( K - 1 ) ) ) ; } var arr = [ 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 ] ; var N = arr . length ; var K = 3 ; findUniqueElements ( arr , N , K ) ;";"Unique element in an array where all elements occur K times except one | Set 2 | Function that find the unique element in the array arr [ ] ; Store all unique element in set ; Sum of all element of the array ; Sum of element in the set ; Print the unique element using formula ; Driver Code ; Function call"
Javascript;"function findEquation ( a , b , c ) { let X = ( a + b + c ) ; let Y = ( a * b ) + ( b * c ) + ( c * a ) ; let Z = a * b * c ; document . write ( "" "" + X + "" "" + Y + "" "" + Z + "" "" ) ; } let a = 5 , b = 2 , c = 3 ; findEquation ( a , b , c ) ;";"Form the Cubic equation from the given roots | Function to find the cubic equation whose roots are a , b and c ; Find the value of coefficient ; Print the equation as per the above coefficients ; Driver Code ; Function Call"
Javascript;"function dydx ( x , y ) { return ( x - y ) / 2 ; } function Gill ( x0 , y0 , x , h ) { let n = ( ( x - x0 ) / h ) ; let k1 , k2 , k3 , k4 ; let y = y0 ; for ( let i = 1 ; i <= n ; i ++ ) { k1 = h * dydx ( x0 , y ) ; k2 = h * dydx ( x0 + 0.5 * h , y + 0.5 * k1 ) ; k3 = h * dydx ( x0 + 0.5 * h , y + 0.5 * ( - 1 + Math . sqrt ( 2 ) ) * k1 + k2 * ( 1 - 0.5 * Math . sqrt ( 2 ) ) ) ; k4 = h * dydx ( x0 + h , y - ( 0.5 * Math . sqrt ( 2 ) ) * k2 + k3 * ( 1 + 0.5 * Math . sqrt ( 2 ) ) ) ; y = y + ( 1.0 / 6 ) * ( k1 + ( 2 - Math . sqrt ( 2 ) ) * k2 + ( 2 + Math . sqrt ( 2 ) ) * k3 + k4 ) ; x0 = x0 + h ; } return y ; } let x0 = 0 , y = 3.0 , x = 5.0 , h = 0.2 ; document . write ( "" "" , Gill ( x0 , y , x , h ) . toFixed ( 6 ) ) ;";"Gill 's 4th Order Method to solve Differential Equations | A sample differential equation "" dy / dx ▁ = ▁ ( x ▁ - ▁ y ) /2"" ; Finds value of y for a given x using step size h and initial value y0 at x0 ; Count number of iterations using step size or height h ; Value of K_i ; Initial value of y ( 0 ) ; Iterate for number of iteration ; Value of K1 ; Value of K2 ; Value of K3 ; Value of K4 ; Find the next value of y ( n + 1 ) using y ( n ) and values of K in the above steps ; Update next value of x ; Return the final value of dy / dx ; Driver Code"
Javascript;"function PrintReverseOrder ( N ) { for ( let i = N ; i > 0 ; i -- ) document . write ( i + "" "" ) ; } let N = 5 ; PrintReverseOrder ( N ) ;";"Program to print numbers from N to 1 in reverse order | Recursive function to print from N to 1 ; Driver code"
Javascript;"function findAns ( a , b , n ) { var lcm = ( a * b ) / __gcd ( a , b ) ; var multiples = ( n / lcm ) + 1 ; var answer = Math . max ( a , b ) * multiples ; var lastvalue = lcm * ( n / lcm ) + Math . max ( a , b ) ; if ( lastvalue > n ) answer = answer - ( lastvalue - n - 1 ) ; return answer ; } function __gcd ( a , b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } var a = 1 , b = 13 , n = 500 ; document . write ( findAns ( a , b , n ) + "" "" ) ;";"Find count of numbers from 0 to n which satisfies the given equation for a value K | Function to find the values ; Calculate the LCM ; Calculate the multiples of lcm ; Find the values which satisfies the given condition ; Subtract the extra values ; Return the final result ; Driver code"
Javascript;"function ArithmeticMean ( A , B ) { return ( ( A + B ) / 2 ) ; } function HarmonicMean ( A , B ) { return ( 2 * A * B ) / ( A + B ) ; } function CheckArithmeticHarmonic ( arr , A , B , N ) { let AM = ArithmeticMean ( A , B ) ; let HM = HarmonicMean ( A , B ) ; let Hash = new Map ( ) ; for ( let i = 0 ; i < N ; i ++ ) { Hash . set ( arr [ i ] , 1 ) ; } if ( Hash . get ( A ) != 0 && Hash . get ( B ) != 0 ) { if ( Hash . get ( AM ) != 0 && Hash . get ( HM ) != 0 ) { document . write ( "" "" ) ; document . write ( Math . sqrt ( AM * HM ) . toFixed ( 2 ) ) ; } else { document . write ( "" "" ) ; } } else { document . write ( "" "" ) ; } } let arr = [ 1.0 , 2.0 , 2.5 , 3.0 , 4.0 , 4.5 , 5.0 , 6.0 ] ; let N = ( arr . length ) ; let A = 3.0 ; let B = 6.0 ; CheckArithmeticHarmonic ( arr , A , B , N ) ;";"Program to find if two numbers and their AM and HM are present in an array using STL | Function to find the Arithmetic Mean of 2 numbers ; Function to find the Harmonic Mean of 2 numbers ; Following function checks and computes the desired results based on the means ; Calculate means ; Hash container ( HashMap ) to store elements ; Insertion of array elements in the Set ; Conditionals to check if numbers are present in array by Hashing ; Conditionals to check if the AM and HM of the numbers are present in array ; If all conditions are satisfied , the Geometric Mean is calculated ; If numbers are found but the respective AM and HM are not found in the array ; If none of the conditions are satisfied ; Driver code"
Javascript;"function movesRequired ( a , b ) { let total_moves = a % b ; document . write ( total_moves ) ; } let A = 10 , B = 3 ; movesRequired ( A , B ) ;";"Minimum decrements to make integer A divisible by integer B | Function that print number of moves required ; calculate modulo ; print the required answer ; initialise A and B"
Javascript;"function PythagoreanTriplet ( n ) { let flag = 0 ; for ( let a = 1 ; a < n ; a ++ ) { let b = ( n * n - 2 * n * a ) / ( 2 * n - 2 * a ) ; let c = n - a - b ; if ( a * a + b * b == c * c && b > 0 && c > 0 ) { document . write ( a + "" "" + b + "" "" + c ) ; flag = 1 ; break ; } } if ( flag == 0 ) { document . write ( "" "" ) ; } return ; } let N = 12 ; PythagoreanTriplet ( N ) ;";"Pythagorean Triplet with given sum using single loop | Function to calculate the Pythagorean triplet in O ( n ) ; Iterate a from 1 to N - 1. ; Calculate value of b ; The value of c = n - a - b ; Driver code ; Function call"
Javascript;"function check ( X , K ) { var prime , temp , sqr , i ; prime = 0 ; temp = X ; sqr = parseInt ( Math . sqrt ( X ) ) ; for ( i = 2 ; i <= sqr ; i ++ ) { while ( temp % i == 0 ) { temp = parseInt ( temp / i ) ; prime ++ ; } } if ( temp > 2 ) prime ++ ; if ( X == 1 ) return false ; if ( prime == 1 && K == 1 ) return true ; else if ( prime >= K ) return true ; else return false ; } var X , K ; X = 4 ; K = 2 ; if ( check ( X , K ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check if there exists a number with X factors out of which exactly K are prime | Function to check if such number exists ; To store the sum of powers of prime factors of X which determines the maximum count of numbers whose product can form X ; Determining the prime factors of X ; To check if the number is prime ; If X is 1 , then we cannot form a number with 1 factor and K prime factor ( as K is atleast 1 ) ; If X itself is prime then it can be represented as a power of only 1 prime factor which is X itself so we return true ; If sum of the powers of prime factors of X is greater than or equal to K , which means X can be represented as a product of K numbers , we return true ; In any other case , we return false as we cannot form a number with X factors and K prime factors ; Driver code"
Javascript;"class Node { constructor ( key ) { this . left = null ; this . right = null ; this . key = key ; } } function newNode ( key ) { let temp = new Node ( key ) ; return ( temp ) ; } let N = 1000000 ; let prime = [ ] ; function SieveOfEratosthenes ( ) { let check = new Array ( N + 1 ) ; check . fill ( true ) ; for ( let p = 2 ; p * p <= N ; p ++ ) { if ( check [ p ] == true ) { prime . push ( p ) ; for ( let i = p * p ; i <= N ; i += p ) check [ i ] = false ; } } } function isPathCo_Prime ( path ) { let max = 0 ; for ( let x = 0 ; x < path . length ; x ++ ) { if ( max < path [ x ] ) max = path [ x ] ; } for ( let i = 0 ; i * prime [ i ] <= parseInt ( max / 2 , 10 ) ; i ++ ) { let ct = 0 ; for ( let x = 0 ; x < path . length ; x ++ ) { if ( path [ x ] % prime [ i ] == 0 ) ct ++ ; } if ( ct > 1 ) { return false ; } } return true ; } function printCoPrimePaths ( path ) { for ( let x = 0 ; x < path . length ; x ++ ) { document . write ( path [ x ] + "" "" ) ; } document . write ( "" "" ) ; } function findCo_PrimePaths ( root , path ) { if ( root == null ) return ; path . push ( root . key ) ; findCo_PrimePaths ( root . left , path ) ; findCo_PrimePaths ( root . right , path ) ; if ( root . left == null && root . right == null ) { if ( isPathCo_Prime ( path ) ) { printCoPrimePaths ( path ) ; } } path . pop ( ) ; } function printCo_PrimePaths ( node ) { SieveOfEratosthenes ( ) ; let path = [ ] ; findCo_PrimePaths ( node , path ) ; } let root = newNode ( 10 ) ; root . left = newNode ( 48 ) ; root . right = newNode ( 3 ) ; root . right . left = newNode ( 11 ) ; root . right . right = newNode ( 37 ) ; root . right . left . left = newNode ( 7 ) ; root . right . left . right = newNode ( 29 ) ; root . right . right . left = newNode ( 42 ) ; root . right . right . right = newNode ( 19 ) ; root . right . right . right . left = newNode ( 7 ) ; printCo_PrimePaths ( root ) ;";"Print all Coprime path of a Binary Tree | A Tree node ; Utility function to create a new node ; Vector to store all the prime numbers ; Function to store all the prime numbers in an array ; Create a boolean array "" prime [ 0 . . N ] "" and initialize all the entries in it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p greater than or equal to the square of it numbers which are multiples of p and are less than p ^ 2 are already marked . ; Function to check whether Path is Co - prime or not ; Iterating through the array to find the maximum element in the array ; Incrementing the variable if any of the value has a factor ; If not co - prime ; Function to print a Co - Prime path ; Function to find co - prime paths of binary tree ; Base case ; Store the value in path vector ; Recursively call for left sub tree ; Recursively call for right sub tree ; Condition to check , if leaf node ; Condition to check , if path co - prime or not ; Print co - prime path ; Remove the last element from the path vector ; Function to find Co - Prime paths In a given binary tree ; To save all prime numbers ; Function call ; Create Binary Tree as shown ; Print Co - Prime Paths"
Javascript;"let mod = 1000000007 ; function countSubsets ( a , n ) { let answer = 0 ; for ( let i = 0 ; i < ( 1 << n ) ; i ++ ) { let bitwiseAND = - 1 ; let bitwiseOR = 0 ; let bitwiseXOR = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( ( i & ( 1 << j ) ) != 0 ) { if ( bitwiseAND == - 1 ) bitwiseAND = a [ j ] ; else bitwiseAND &= a [ j ] ; bitwiseOR |= a [ j ] ; bitwiseXOR ^= a [ j ] ; } } if ( bitwiseAND == bitwiseOR && bitwiseOR == bitwiseXOR ) answer = ( answer + 1 ) % mod ; } return answer ; } let N = 6 ; let A = [ 1 , 3 , 2 , 1 , 2 , 1 ] ; document . write ( countSubsets ( A , N ) ) ;";"Number of subsets with same AND , OR and XOR values in an Array | Javascript implementation to find the number of subsets with equal bitwise AND , OR and XOR values ; Function to find the number of subsets with equal bitwise AND , OR and XOR values ; Traverse through all the subsets ; Finding the subsets with the bits of ' i ' which are set ; Computing the bitwise AND ; Computing the bitwise OR ; Computing the bitwise XOR ; Comparing all the three values ; Driver Code"
Javascript;"function count ( arr , N , K ) { let count = 0 , ans = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == K ) { count = count + 1 ; } else { ans += ( count * ( count + 1 ) ) / 2 ; count = 0 ; } } ans = ans + ( count * ( count + 1 ) ) / 2 ; return ans ; } let arr = [ 1 , 0 , 0 , 1 , 1 , 0 , 0 ] ; let N = arr . length ; let K = 0 ; document . write ( count ( arr , N , K ) ) ;";"Count of Subsets containing only the given value K | Function to find the number of subsets formed by the given value K ; Count is used to maintain the number of continuous K 's ; Iterating through the array ; If the element in the array is equal to K ; count * ( count + 1 ) / 2 is the total number of subsets with only K as their element ; Change count to 0 because other element apart from K has been found ; To handle the last set of K 's ; Driver code"
Javascript;"function convertToTernary ( N ) { if ( N == 0 ) return ; let x = N % 3 ; N = parseInt ( N / 3 , 10 ) ; if ( x < 0 ) N += 1 ; convertToTernary ( N ) ; if ( x < 0 ) document . write ( x + ( 3 * - 1 ) ) ; else document . write ( x ) ; } function convert ( Decimal ) { document . write ( "" "" + Decimal + "" "" ) ; if ( Decimal != 0 ) { convertToTernary ( Decimal ) ; } else document . write ( "" "" + "" "" ) ; } let Decimal = 2747 ; convert ( Decimal ) ;";"Ternary number system or Base 3 numbers | Function to convert a decimal number to a ternary number ; Base case ; Finding the remainder when N is divided by 3 ; Recursive function to call the function for the integer division of the value N / 3 ; Handling the negative cases ; Function to convert the decimal to ternary ; If the number is greater than 0 , compute the ternary representation of the number ; Driver Code"
Javascript;"function get ( x , y , z ) { if ( x > z ) return - 1 ; let val = z - x ; let div = Math . floor ( ( z - x ) / y ) ; let ans = div * y + x ; return ans ; } let x = 1 , y = 5 , z = 8 ; document . write ( get ( x , y , z ) + "" "" ) ;";"Largest number less than or equal to Z that leaves a remainder X when divided by Y | Function to get the number ; remainder can ' t ▁ be ▁ larger ▁ ▁ than ▁ the ▁ largest ▁ number , ▁ ▁ if ▁ so ▁ then ▁ answer ▁ doesn ' t exist . ; reduce number by x ; finding the possible number that is divisible by y ; this number is always <= x as we calculated over z - x ; initialise the three integers"
Javascript;"function solve ( s ) { let z = s ; var l = s . length ; var i ; if ( s . indexOf ( ' ' ) != - 1 ) { i = s . indexOf ( ' ' ) ; s = s . replace ( ' ' , ' ' ) ; } else { i = s . indexOf ( ' ' ) ; s = s . replace ( ' ' , ' ' ) ; } document . write ( "" "" + z + "" "" + s + "" "" ) ; } let s = "" "" ; solve ( s ) ;";"Find the conjugate of a Complex number | Function to find conjugate of a complex number ; store index of ' + ' ; store index of ' - ' ; print the result ; Array of points"
Javascript;"function minOperations ( A , B ) { if ( A > B ) { A = A + B ; B = A - B ; A = A - B ; } B = B / __gcd ( A , B ) ; return B - 1 ; } function __gcd ( a , b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } var A = 7 , B = 15 ; document . write ( minOperations ( A , B ) + "" "" ) ;";"Minimum operations required to make two numbers equal | Function to return the minimum operations required ; Keeping B always greater ; Reduce B such that gcd ( A , B ) becomes 1. ; Driver code"
Javascript;"function quadrant ( s ) { var l = s . length ; var i = 0 ; if ( s . indexOf ( "" "" ) != - 1 ) { i = s . indexOf ( "" "" ) ; } else { i = s . indexOf ( "" "" ) ; } var real = s . substr ( 0 , i ) ; var imaginary = s . substr ( i + 1 , l - 1 ) ; var x = parseInt ( real ) ; var y = parseInt ( imaginary ) ; if ( x > 0 && y > 0 ) document . write ( "" "" ) ; else if ( x < 0 && y > 0 ) document . write ( "" "" ) ; else if ( x < 0 && y < 0 ) document . write ( "" "" ) ; else if ( x > 0 && y < 0 ) document . write ( "" "" ) ; else if ( x == 0 && y > 0 ) document . write ( "" "" + "" "" ) ; else if ( x == 0 && y < 0 ) document . write ( "" "" + "" "" ) ; else if ( y == 0 && x < 0 ) document . write ( "" "" + "" "" ) ; else if ( y == 0 && x > 0 ) document . write ( "" "" + "" "" ) ; else document . write ( "" "" ) ; } var s = "" "" ; quadrant ( s ) ;";"Program to determine the Quadrant of a Complex number | Function to determine the quadrant of a complex number ; Storing the index of ' + ' ; Storing the index of ' - ' ; Finding the real part of the complex number ; Finding the imaginary part of the complex number ; Driver code"
Javascript;"class Node { constructor ( ) { this . data = 0 ; this . next = null ; } } function push ( head_ref , new_data ) { var new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = head_ref ; head_ref = new_node ; return head_ref ; } function largestElement ( head_ref ) { var max = Number . MIN_VALUE ; var head = head_ref ; while ( head != null ) { if ( max < head . data ) max = head . data ; head = head . next ; } return max ; } function createHash ( hash , maxElement ) { var prev = 0 , curr = 1 ; hash . add ( prev ) ; hash . add ( curr ) ; while ( curr <= maxElement ) { var temp = curr + prev ; hash . add ( temp ) ; prev = curr ; curr = temp ; } } function sumAndProduct ( head_ref ) { var maxEle = largestElement ( head_ref ) ; var hash = new Set ( ) ; createHash ( hash , maxEle ) ; var prod = 1 ; var sum = 0 ; var ptr = head_ref ; while ( ptr != null ) { if ( hash . has ( ptr . data ) ) { prod *= ptr . data ; sum += ptr . data ; } ptr = ptr . next ; } document . write ( "" "" + sum + "" "" ) ; document . write ( "" "" + prod ) ; } var head = null ; head = push ( head , 13 ) ; head = push ( head , 6 ) ; head = push ( head , 8 ) ; head = push ( head , 16 ) ; head = push ( head , 15 ) ; sumAndProduct ( head ) ;";"Sum and Product of all Fibonacci Nodes of a Singly Linked List | Node of the singly linked list ; Function to insert a node at the beginning of the singly Linked List ; Allocate new node ; Insert the data ; Link the old list to the new node ; Move the head to povar the new node ; Function that returns the largest element from the linked list . ; Declare a max variable and initialize with Number . MIN_VALUE ; Check loop while head not equal to null ; If max is less then head . data then assign value of head . data to max otherwise node points to next node . ; Function to create a hash table to check Fibonacci numbers ; Inserting the first two numbers in the hash ; Loop to add Fibonacci numbers upto the maximum element present in the linked list ; Function to find the required sum and product ; Find the largest node value in Singly Linked List ; Creating a set containing all the fibonacci numbers upto the maximum data value in the Singly Linked List ; Traverse the linked list ; If current node is fibonacci ; Find the sum and the product ; Driver code ; Create the linked list 15.16 . 8.6 .13"
Javascript;"function product_subarrays ( arr , n ) { let product = 1 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { for ( let k = i ; k <= j ; k ++ ) product *= arr [ k ] ; } } document . write ( product + "" "" ) ; } let arr = [ 10 , 3 , 7 ] ; let n = arr . length ; product_subarrays ( arr , n ) ;";"Product of all Subarrays of an Array | Function to find product of all subarrays ; Variable to store the product ; Compute the product while traversing for subarrays ; Printing product of all subarray ; Driver code ; Function call"
Javascript;"function val ( c ) { if ( c >= ' ' && c <= ' ' ) return c . charCodeAt ( ) - ' ' . charCodeAt ( ) ; else return c . charCodeAt ( ) - ' ' . charCodeAt ( ) + 10 ; } function toDeci ( str , base ) { let len = str . length ; let power = 1 ; let num = 0 ; let i ; for ( i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str [ i ] ) >= base ) { document . write ( "" "" ) ; return - 1 ; } num += val ( str [ i ] ) * power ; power = power * base ; } return num ; } function isEven ( num , N ) { let deci = toDeci ( num , N ) ; return ( deci % 2 == 0 ) ; } let num = "" "" ; let N = 16 ; if ( isEven ( num , N ) ) { document . write ( "" "" ) ; } else { document . write ( "" "" ) ; }";"Check if a N base number is Even or Odd | To return value of a char . ; Function to convert a number from N base to decimal ; power of base ; Decimal equivalent is str [ len - 1 ] * 1 + str [ len - 1 ] * base + str [ len - 1 ] * ( base ^ 2 ) + ... ; A digit in input number must be less than number 's base ; Returns true if n is even , else odd ; Driver Code"
Javascript;"fact = Array ( 21 ) . fill ( 0 ) ; function preCompute ( ) { fact [ 0 ] = 1 ; for ( var i = 1 ; i < 18 ; i ++ ) fact [ i ] = ( fact [ i - 1 ] * i ) ; } function nextFactorial ( N ) { for ( var i = 0 ; i < 21 ; i ++ ) { if ( N < fact [ i ] ) { document . write ( fact [ i ] ) ; break ; } } } preCompute ( ) ; var N = 120 ; nextFactorial ( N ) ;";"Find the next Factorial greater than N | Array that stores the factorial till 20 ; Function to pre - compute the factorial till 20 ; Precomputing factorials ; Function to return the next factorial number greater than N ; Traverse the factorial array ; Find the next just greater factorial than N ; Function to precalculate the factorial till 20 ; Function call"
Javascript;"function findDistinctOddSum ( n , k ) { if ( ( k * k ) <= n && ( n + k ) % 2 == 0 ) { var val = 1 ; var sum = 0 ; for ( var i = 1 ; i < k ; i ++ ) { document . write ( val + "" "" ) ; sum += val ; val += 2 ; } document . write ( n - sum ) ; } else document . write ( "" "" ) ; } var n = 100 ; var k = 4 ; findDistinctOddSum ( n , k ) ;";"Find K distinct positive odd integers with sum N | Function to find K odd positive integers such that their sum is N ; Condition to check if there are enough values to check ; Driver Code"
Javascript;"function checkArray ( a , b , n ) { var operations = 0 ; var i = 0 ; while ( i < n ) { if ( a [ i ] - b [ i ] == 0 ) { i ++ ; continue ; } var diff = a [ i ] - b [ i ] ; i ++ ; while ( i < n && a [ i ] - b [ i ] == diff ) { i ++ ; } operations ++ ; } document . write ( operations ) ; } var a = [ 3 , 7 , 1 , 4 , 1 , 2 ] ; var b = [ 3 , 7 , 3 , 6 , 3 , 2 ] ; var size = a . length ; checkArray ( a , b , size ) ;";"Minimum number of operations to convert array A to array B by adding an integer into a subarray | Function to find the minimum number of operations in which array A can be converted to array B ; Loop to iterate over the array ; if both elements are equal then move to next element ; Calculate the difference between two elements ; loop while the next pair of elements have same difference ; Increase the number of operations by 1 ; Prvar the number of operations required ; Driver Code"
Javascript;"function insertPF ( primeFact , fact ) { if ( primeFact . has ( fact ) ) { primeFact . set ( fact , primeFact . get ( fact ) + 1 ) ; } else { primeFact . set ( fact , 1 ) ; } return primeFact ; } function primeFactors ( n ) { var primeFact = new Map ( ) ; while ( n % 2 == 0 ) { primeFact = insertPF ( primeFact , 2 ) ; n = parseInt ( n / 2 ) ; } for ( var i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { primeFact = insertPF ( primeFact , i ) ; n = parseInt ( n / i ) ; } } if ( n > 2 ) primeFact = insertPF ( primeFact , n ) ; return primeFact ; } function perfectCube ( n ) { var primeFact = new Map ( ) ; primeFact = primeFactors ( n ) ; primeFact . forEach ( ( value , key ) => { if ( value % 3 != 0 ) return "" "" ; } ) ; return "" "" ; } var N = 216 ; document . write ( perfectCube ( N ) ) ;";"Perfect Cube | Inserts the prime factor in HashMap if not present if present updates it 's frequency ; A utility function to find all prime factors of a given number N ; Insert the number of 2 s that divide n ; n must be odd at this point So we can skip one element ; while i divides n , insert i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; Function to check if a number is perfect cube ; Iteration in Map ; Driver Code ; Function to check if N is perfect cube or not"
Javascript;"function factorial ( n ) { return ( n == 1 n == 0 ) ? 1 : n * factorial ( n - 1 ) ; } function ways ( n ) { if ( n < 3 ) { return 0 ; } let c2 = 0 ; let c1 = n - 3 ; let l = c1 + 1 ; let s = 0 ; let exp_c2 = Math . floor ( c1 / 2 ) ; while ( exp_c2 >= c2 ) { let f1 = factorial ( l ) ; let f2 = factorial ( c1 ) ; let f3 = factorial ( c2 ) ; let f4 = ( f2 * f3 ) ; s += Math . floor ( f1 / f4 ) ; c2 += 1 ; c1 -= 2 ; l -= 1 ; } return s ; } let n = 7 ; let ans = ways ( n ) ; document . write ( ans ) ;";"Count ways to reach the Nth stair using multiple 1 or 2 steps and a single step 3 | JavaScript implementation to find the number the number of ways to reach Nth stair by taking 1 or 2 steps at a time and 3 rd step exactly once ; Single line to find factorial ; Function to find the number of ways ; Base Case ; Count of 2 - steps ; Count of 1 - steps ; Initial length of sequence ; Expected count of 2 - steps ; Loop to find the ways for every possible sequence ; Driver code"
Javascript;"var m = { } ; function precompute ( ) { var fact = 1 ; for ( var i = 1 ; i <= 18 ; i ++ ) { fact = fact * i ; m [ fact ] = i ; } } precompute ( ) ; var K = 120 ; document . write ( m [ K ] + "" "" ) ; K = 6 ; document . write ( m [ K ] ) ;";"Find N from the value of N ! | Map to precompute and store the factorials of the numbers ; Function to precompute factorial ; Calculating the factorial for each i and storing in a map ; Driver code"
Javascript;"function calNum ( year ) { return parseInt ( year / 4 , 10 ) - parseInt ( year / 100 , 10 ) + parseInt ( year / 400 , 10 ) ; } function leapNum ( l , r ) { l -- ; let num1 = calNum ( r ) ; let num2 = calNum ( l ) ; document . write ( ( num1 - num2 ) + "" "" ) ; } let l1 = 1 , r1 = 400 ; leapNum ( l1 , r1 ) ; let l2 = 400 , r2 = 2000 ; leapNum ( l2 , r2 ) ;";"Count of Leap Years in a given year range | Function to calculate the number of leap years in range of ( 1 , year ) ; Function to calculate the number of leap years in given range ; Driver Code"
Javascript;"class Cantor { constructor ( ) { this . start = 0 ; this . end = 0 ; this . next = null ; } } ; var cantor = null ; function startList ( head , start_num , end_num ) { if ( head == null ) { head = new Cantor ( ) ; head . start = start_num ; head . end = end_num ; head . next = null ; } return head ; } function propagate ( head ) { var temp = head ; if ( temp != null ) { var newNode = new Cantor ( ) ; var diff = ( ( ( temp . end ) - ( temp . start ) ) / 3 ) ; newNode . end = temp . end ; temp . end = ( ( temp . start ) + diff ) ; newNode . start = ( newNode . end ) - diff ; newNode . next = temp . next ; temp . next = newNode ; propagate ( temp . next . next ) ; } return head ; } function print ( temp ) { while ( temp != null ) { document . write ( "" "" + temp . start . toFixed ( 6 ) + "" "" + temp . end . toFixed ( 6 ) + "" "" ) ; temp = temp . next ; } document . write ( "" "" ) ; } function buildCantorSet ( A , B , L ) { var head = null ; head = startList ( head , A , B ) ; for ( var i = 0 ; i < L ; i ++ ) { document . write ( "" "" + i + "" "" ) ; print ( head ) ; propagate ( head ) ; } document . write ( "" "" + L + "" "" ) ; print ( head ) ; } var A = 0 ; var B = 9 ; var L = 2 ; buildCantorSet ( A , B , L ) ;";"Ternary representation of Cantor set | The Linked List Structure for the Cantor Set ; Function to initialize the Cantor Set List ; Function to propogate the list by adding new nodes for the next levels ; Modifying the start and end values for the next level ; Changing the pointers to the next node ; Recursively call the function to generate the Cantor Set for the entire level ; Function to print a level of the Set ; Function to build and display the Cantor Set for each level ; Driver code"
Javascript;"function countNumber ( N , S ) { let countElements = 0 ; let currSum = 0 ; while ( currSum <= S ) { currSum += N ; N -- ; countElements ++ ; } return countElements ; } let N , S ; N = 5 ; S = 11 ; let count = countNumber ( N , S ) ; document . write ( count + "" "" ) ;";"Length of Smallest subarray in range 1 to N with sum greater than a given value | Function to return the count of minimum elements such that the sum of those elements is > S . ; Initialize currentSum = 0 ; Loop from N to 1 to add the numbers and check the condition . ; Driver code"
Javascript;"let INT_MAX = Number . MAX_VALUE ; function countDistinct ( n ) { let arr = new Array ( 10 ) ; arr . fill ( 0 ) ; let count = 0 ; while ( n != 0 ) { let r = n % 10 ; arr [ r ] = 1 ; n = parseInt ( n / 10 , 10 ) ; } for ( let i = 0 ; i < 10 ; i ++ ) { if ( arr [ i ] != 0 ) count ++ ; } return count ; } function countDigit ( n ) { let c = 0 ; while ( n != 0 ) { let r = n % 10 ; c ++ ; n = parseInt ( n / 10 , 10 ) ; } return c ; } function nextNumberDistinctDigit ( n ) { while ( n < INT_MAX ) { let distinct_digits = countDistinct ( n + 1 ) ; let total_digits = countDigit ( n + 1 ) ; if ( distinct_digits == total_digits ) { return n + 1 ; } else n ++ ; } return - 1 ; } let n = 2019 ; document . write ( nextNumberDistinctDigit ( n ) ) ;";"Next Number with distinct digits | Javascript program to find next consecutive Number with all distinct digits ; Function to count distinct digits in a number ; To count the occurrence of digits in number from 0 to 9 ; Iterate over the digits of the number Flag those digits as found in the array ; Traverse the array arr and count the distinct digits in the array ; Function to return the total number of digits in the number ; Iterate over the digits of the number ; Function to return the next number with distinct digits ; Count the distinct digits in N + 1 ; Count the total number of digits in N + 1 ; Return the next consecutive number ; Increment Number by 1 ; Driver code"
Javascript;"function findNumberOfEvenCells ( n , q , size ) { let row = new Array ( n ) ; row . fill ( 0 ) ; let col = new Array ( n ) ; col . fill ( 0 ) ; for ( let i = 0 ; i < size ; i ++ ) { let x = q [ i ] [ 0 ] ; let y = q [ i ] [ 1 ] ; row [ x - 1 ] ++ ; col [ y - 1 ] ++ ; } let r1 = 0 , r2 = 0 ; let c1 = 0 , c2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( row [ i ] % 2 == 0 ) { r1 ++ ; } if ( row [ i ] % 2 == 1 ) { r2 ++ ; } if ( col [ i ] % 2 == 0 ) { c1 ++ ; } if ( col [ i ] % 2 == 1 ) { c2 ++ ; } } let count = r1 * c1 + r2 * c2 ; return count ; } let n = 2 ; let q = [ [ 1 , 1 ] , [ 1 , 2 ] , [ 2 , 1 ] ] ; let size = q . length ; document . write ( findNumberOfEvenCells ( n , q , size ) ) ;";"Find Number of Even cells in a Zero Matrix after Q queries | Function to find the number of even cell in a 2D matrix ; Maintain two arrays , one for rows operation and one for column operation ; Increment operation on row [ i ] ; Increment operation on col [ i ] ; Count odd and even values in both arrays and multiply them ; Count of rows having even numbers ; Count of rows having odd numbers ; Count of columns having even numbers ; Count of columns having odd numbers ; Driver code"
Javascript;"function maxHeight ( h1 , h2 ) { return ( ( h1 * h2 ) - h1 - h2 ) ; } var h1 = 7 , h2 = 5 ; document . write ( Math . max ( 0 , maxHeight ( h1 , h2 ) ) ) ;";"Find maximum unreachable height using two ladders | Function to return the maximum height which can 't be reached ; Driver code"
Javascript;"function FermatFactors ( n ) { if ( n <= 0 ) { document . write ( "" "" + n + "" "" ) ; return ; } if ( ( n & 1 ) == 0 ) { document . write ( "" "" + ( n / 2.0 ) + "" "" + ( 2 ) + "" "" ) ; return ; } let a = Math . ceil ( Math . sqrt ( n ) ) ; if ( a * a == n ) { document . write ( "" "" + a + "" "" + a + "" "" ) ; return ; } let b ; while ( true ) { let b1 = a * a - n ; b = parseInt ( Math . sqrt ( b1 ) , 10 ) ; if ( b * b == b1 ) break ; else a += 1 ; } document . write ( "" "" + ( a - b ) + "" "" + ( a + b ) + "" "" ) ; return ; } FermatFactors ( 6557 ) ;";"Fermat 's Factorization Method | This function finds the value of a and b and returns a + b and a - b ; since fermat 's factorization applicable  for odd positive integers only ; check if n is a even number ; if n is a perfect root , then both its square roots are its factors ; Driver Code"
Javascript;"function findNums ( arr , n ) { var S = 0 , X = 0 ; for ( i = 0 ; i < n ; i ++ ) { S += arr [ i ] ; X ^= arr [ i ] ; } document . write ( X + "" "" + ( X + S ) ) ; } var arr = [ 1 , 7 ] ; var n = arr . length ; findNums ( arr , n ) ;";"Append two elements to make the array satisfy the given condition | Function to find the required numbers ; Find the sum and xor ; Prvar the required elements ; Driver code"
Javascript;"function solve ( A , B ) { let p = B / 2.0 ; let M = Math . ceil ( 4 * p ) ; let N = 1 ; let O = - 2 * A ; let Q = Math . ceil ( A * A + 4 * p * p ) ; document . write ( M + "" "" + N + "" "" + O + "" "" + Q ) ; } let a = 1 ; let b = 1 ; solve ( a , b ) ;";"Satisfy the parabola when point ( A , B ) and the equation is given | Function to find the required values ; Driver code"
Javascript;"function findLargest ( arr , n ) { var gcd = 0 ; for ( i = 0 ; i < n ; i ++ ) gcd = __gcd ( arr [ i ] , gcd ) ; return gcd ; } function __gcd ( a , b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } var arr = [ 3 , 6 , 9 ] ; var n = arr . length ; document . write ( findLargest ( arr , n ) ) ;";"Largest number dividing maximum number of elements in the array | Function to return the largest number that divides the maximum elements from the given array ; Finding gcd of all the numbers in the array ; Driver code"
Javascript;"function digitSum ( n ) { let sum = 0 ; while ( n > 0 ) { sum += ( n % 10 ) ; n = parseInt ( n / 10 , 10 ) ; } return sum ; } function isPalindrome ( n ) { let divisor = 1 ; while ( parseInt ( n / divisor , 10 ) >= 10 ) divisor *= 10 ; while ( n != 0 ) { let leading = parseInt ( n / divisor , 10 ) ; let trailing = n % 10 ; if ( leading != trailing ) return false ; n = parseInt ( ( n % divisor ) / 10 , 10 ) ; divisor = parseInt ( divisor / 100 , 10 ) ; } return true ; } function isDigitSumPalindrome ( n ) { let sum = digitSum ( n ) ; if ( isPalindrome ( sum ) ) return true ; return false ; } let n = 56 ; if ( isDigitSumPalindrome ( n ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check if the sum of digits of N is palindrome | Function to return the sum of digits of n ; Function that returns true if n is palindrome ; Find the appropriate divisor to extract the leading digit ; If first and last digit not same return false ; Removing the leading and trailing digit from number ; Reducing divisor by a factor of 2 as 2 digits are dropped ; Function that returns true if the digit sum of n is palindrome ; Sum of the digits of n ; If the digit sum is palindrome ; Driver code"
Javascript;"function xorK ( n , k ) { if ( k % 2 == 1 ) return n ; return 0 ; } let n = 123 , k = 3 ; document . write ( xorK ( n , k ) ) ;";"Find the value of N XOR 'ed to itself K times | Function to return n ^ n ^ ... k times ; If k is odd the answer is the number itself ; Else the answer is 0 ; Driver code"
Javascript;"let N = 20 ; let mod = 1000000007 ; let factorial = new Array ( N ) ; factorial . fill ( 0 ) ; let modinverse = new Array ( N ) ; modinverse . fill ( 0 ) ; function power ( a , m1 ) { if ( m1 == 0 ) return 1 ; else if ( m1 == 1 ) return a ; else if ( m1 == 2 ) return ( a * a ) % mod ; else if ( ( m1 & 1 ) != 0 ) return ( a * power ( power ( a , parseInt ( m1 / 2 , 10 ) ) , 2 ) ) % mod ; else return power ( power ( a , parseInt ( m1 / 2 , 10 ) ) , 2 ) % mod ; } function factorialfun ( ) { factorial [ 0 ] = 1 ; for ( let i = 1 ; i < N ; i ++ ) factorial [ i ] = ( factorial [ i - 1 ] * i ) % mod ; } function modinversefun ( ) { modinverse [ N - 1 ] = power ( factorial [ N - 1 ] , mod - 2 ) % mod ; for ( let i = N - 2 ; i >= 0 ; i -- ) modinverse [ i ] = ( modinverse [ i + 1 ] * ( i + 1 ) ) % mod ; } function binomial ( n , r ) { if ( r > n ) return 0 ; let a = ( factorial [ n ] * modinverse [ n - r ] ) % mod ; a = ( a * modinverse [ r ] ) % mod ; return a ; } function arrange ( n , m , k ) { factorialfun ( ) ; modinversefun ( ) ; let ans = 0 ; for ( let i = 1 ; i < n ; i ++ ) ans += ( i * ( n - i ) * m * m ) % mod ; ans = 8 ; for ( let i = 1 ; i < m ; i ++ ) ans += ( i * ( m - i ) * n * n ) % mod ; ans = ( ans * binomial ( n * m - 2 , k - 2 ) * 0 ) % mod + 8 ; return ans ; } let n = 2 , m = 2 , k = 2 ; document . write ( arrange ( n , m , k ) ) ;";"Find the sum of the costs of all possible arrangements of the cells | JavaScript implementation of the approach ; To store the factorials and factorial mod inverse of the numbers ; Function to return ( a ^ m1 ) % mod ; Function to find the factorials of all the numbers ; Function to find factorial mod inverse of all the numbers ; Function to return nCr ; Function to return the sum of the costs of all the possible arrangements of the cells ; For all possible X 's ; For all possible Y 's ; Driver code"
Javascript;"function findNthDigit ( p , q , N ) { var res ; while ( N > 0 ) { N -- ; p *= 10 ; res = parseInt ( p / q ) ; p %= q ; } return res ; } var p = 1 , q = 2 , N = 1 ; document . write ( findNthDigit ( p , q , N ) ) ;";"Find the Nth digit in the proper fraction of two numbers | Function to print the Nth digit in the fraction ( p / q ) ; To store the resultant digit ; While N > 0 compute the Nth digit by dividing p and q and store the result into variable res and go to next digit ; Driver code"
Javascript;"function sumArr ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; return sum ; } function sumModArr ( arr , n ) { var subSum = arr [ n - 1 ] ; for ( var i = n - 2 ; i >= 0 ; i -- ) { var curr = arr [ i ] ; arr [ i ] -= subSum ; subSum += curr ; } return sumArr ( arr , n ) ; } var arr = [ 40 , 25 , 12 , 10 ] ; var n = arr . length ; document . write ( sumModArr ( arr , n ) ) ;";"Sum of the updated array after performing the given operation | Utility function to return the sum of the array ; Function to return the sum of the modified array ; Subtract the subarray sum ; Sum of subarray arr [ i ... n - 1 ] ; Return the sum of the modified array ; Driver code"
Javascript;"let NumUnsignBits = 64 ; function findNum ( x ) { for ( let i = 0 ; i < NumUnsignBits - 1 ; i ++ ) { if ( ( ( x >> i ) & 1 ) != ( ( x >> ( i + 1 ) ) & 1 ) ) { x ^= ( 1 << i ) | ( 1 << ( i + 1 ) ) ; return x ; } } return Number . MIN_VALUE ; } let n = 92 ; document . write ( findNum ( n ) ) ;";"Find closest integer with the same weight | Javascript implementation of the approach ; Function to return the number closest to x which has equal number of set bits as x ; Loop for each bit in x and compare with the next bit ; Driver code"
Javascript;"function cntCakes ( n , m ) { let sum = ( n * ( n + 1 ) ) / 2 ; let quo = m / sum ; let rem = m % sum ; let ans = m - quo * sum + 6 ; let x = ( - 1 + Math . pow ( ( 8 * rem ) + 1 , 0.5 ) ) ; ans = ans - x * ( x + 1 ) / 2 ; return parseInt ( ans , 10 ) ; } let n = 3 ; let m = 8 ; let ans = cntCakes ( n , m ) ; document . write ( ans ) ;";"Cake Distribution Problem | Function to return the remaining count of cakes ; Sum for 1 cycle ; no . of full cycle and remainder ; Driver Code"
Javascript;"function cntSquares ( n ) { return n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ; } document . write ( cntSquares ( 4 ) ) ;";"Find the number of squares inside the given square grid | Function to return the number of squares inside an n * n grid ; Driver code"
Javascript;"function reverse ( num ) { let rev = 0 ; while ( num > 0 ) { rev = rev * 10 + num % 10 ; num = parseInt ( num / 10 , 10 ) ; } return rev ; } function isPalindrome ( num ) { if ( num == reverse ( num ) ) return true ; return false ; } function printPalindromes ( d ) { if ( d <= 0 ) return ; let smallest = Math . pow ( 10 , d - 1 ) ; let largest = Math . pow ( 10 , d ) - 1 ; for ( let i = smallest ; i <= largest ; i ++ ) { if ( isPalindrome ( i ) ) document . write ( i + "" "" ) ; } } let d = 2 ; printPalindromes ( d ) ;";"Find all palindrome numbers of given digits | Function to return the reverse of num ; Function that returns true if num is palindrome ; If the number is equal to the reverse of it then it is a palindrome ; Function to print all the d - digit palindrome numbers ; Smallest and the largest d - digit numbers ; Starting from the smallest d - digit number till the largest ; If the current number is palindrome ; Driver code"
Javascript;"function getXandYintercept ( P , Q ) { let a = P [ 1 ] - Q [ 1 ] ; let b = P [ 0 ] - Q [ 0 ] ; if ( b == 0 ) { document . write ( P [ 0 ] + "" "" ) ; document . write ( "" "" + "" "" ) ; return ; } if ( a == 0 ) { document . write ( "" "" + "" "" ) ; document . write ( P [ 1 ] + "" "" ) ; return ; } let m = a / ( b * 1.0 ) ; let x = P [ 0 ] ; let y = P [ 1 ] ; let c = y - m * x ; y = 0 ; let r = ( y - c ) / ( m * 1.0 ) ; document . write ( r + "" "" ) ; x = 0 ; y = parseInt ( m * x + c , 10 ) ; document . write ( c . toFixed ( 11 ) + "" "" ) ; } let p1 = [ 5 , 2 ] ; let p2 = [ 2 , 7 ] ; getXandYintercept ( p1 , p2 ) ;";"Find X and Y intercepts of a line passing through the given points | Function to find the X and Y intercepts of the line passing through the given points ; if line is parallel to y axis ; x - intercept will be p [ 0 ] ; y - intercept will be infinity ; if line is parallel to x axis ; x - intercept will be infinity ; y - intercept will be p [ 1 ] ; Slope of the line ; y = mx + c in where c is unknown Use any of the given point to find c ; For finding the x - intercept put y = 0 ; For finding the y - intercept put x = 0 ; Driver code"
Javascript;"function min_moves ( n ) { let ans = Number . MAX_VALUE ; for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { ans = Math . min ( ans , i + parseInt ( n / i , 10 ) - 2 ) ; } } return ans ; } let n = 10 ; document . write ( min_moves ( n ) ) ;";"Minimum number of moves to reach N starting from ( 1 , 1 ) | Function to return the minimum number of moves required to reach the cell containing N starting from ( 1 , 1 ) ; To store the required answer ; For all possible values of divisors ; If i is a divisor of n ; Get the moves to reach n ; Return the required answer ; Driver code"
Javascript;"let MOD = 2019 ; function min_modulo ( l , r ) { if ( r - l >= MOD ) return 0 ; else { let ans = MOD - 1 ; for ( let i = l ; i <= r ; i ++ ) { for ( let j = i + 1 ; j <= r ; j ++ ) { ans = Math . min ( ans , ( i * j ) % MOD ) ; } } return ans ; } } let l = 2020 , r = 2040 ; document . write ( min_modulo ( l , r ) ) ;";"Minimum possible value of ( i * j ) % 2019 | JavaScript implementation of the approach ; Function to return the minimum possible value of ( i * j ) % 2019 ; If we can get a number divisible by 2019 ; Find the minimum value by running nested loops ; Driver code"
Javascript;"function find_numbers ( N ) { if ( N == 1 ) { document . write ( - 1 ) ; } else { document . write ( N + "" "" + ( N + 1 ) + "" "" + ( N * ( N + 1 ) ) ) ; } } var N = 5 ; find_numbers ( N ) ;";"Represent ( 2 / N ) as the sum of three distinct positive integers of the form ( 1 / m ) | Function to find the required fractions ; Base condition ; For N > 1 ; Driver code"
Javascript;"function countPairs ( arr , n ) { var map = { } ; for ( var i = 0 ; i < n ; i ++ ) map [ arr [ i ] - i ] = 0 ; for ( var i = 0 ; i < n ; i ++ ) map [ arr [ i ] - i ] ++ ; var res = 0 ; for ( const [ key , value ] of Object . entries ( map ) ) { var cnt = value ; res += ( cnt * ( cnt - 1 ) ) / 2 ; } return res ; } var arr = [ 1 , 5 , 6 , 7 , 9 ] ; var n = arr . length ; document . write ( countPairs ( arr , n ) ) ;";"Count the pairs in an array such that the difference between them and their indices is equal | Function to return the count of all valid pairs ; To store the frequencies of ( arr [ i ] - i ) ; To store the required count ; If cnt is the number of elements whose difference with their index is same then ( ( cnt * ( cnt - 1 ) ) / 2 ) such pairs are possible ; Driver code"
Javascript;"function minInt ( str ) { for ( let i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] . charCodeAt ( ) >= ( ' ' ) . charCodeAt ( ) ) { str [ i ] = String . fromCharCode ( ( ( ' ' ) . charCodeAt ( ) - ( str [ i ] ) . charCodeAt ( ) ) + ( ' ' ) . charCodeAt ( ) ) ; } } if ( str [ 0 ] == ' ' ) str [ 0 ] = ' ' ; let s = str . join ( "" "" ) ; return s ; } let str = "" "" ; document . write ( minInt ( str . split ( ' ' ) ) ) ;";"Minimum possible number with the given operation | Function to return the minimum possible integer that can be obtained from the given integer after performing the given operations ; For every digit ; Digits less than 5 need not to be changed as changing them will lead to a larger number ; The resulting integer cannot have leading zero ; Driver code"
Javascript;"function minOperations ( n ) { var count = 0 ; var d = 0 ; if ( n == 1 ) return 0 ; while ( n > 9 ) { d = Math . max ( n % 10 , d ) ; n /= 10 ; count += 10 ; } d = Math . max ( d , n - 1 ) ; count += Math . abs ( d ) ; return count - 1 ; } var n = 240 ; document . write ( minOperations ( n ) ) ;";"Reduce N to 1 with minimum number of given operations | Function to return the minimum number of given operations required to reduce n to 1 ; To store the count of operations ; To store the digit ; If n is already then no operation is required ; Extract all the digits except the first digit ; Store the maximum of that digits ; for each digit ; First digit ; Add the value to count ; Driver code"
Javascript;"function findMaximumNum ( str , n , k ) { for ( var i = 0 ; i < n ; i ++ ) { if ( k < 1 ) break ; if ( str [ i ] !== "" "" ) { str [ i ] = "" "" ; k -- ; } } return str . join ( "" "" ) ; } var str = "" "" ; var n = str . length ; var k = 3 ; document . write ( findMaximumNum ( str . split ( "" "" ) , n , k ) ) ;";"Find the largest number that can be formed by changing at most K digits | Function to return the maximum number that can be formed by changing at most k digits in str ; For every digit of the number ; If no more digits can be replaced ; If current digit is not already 9 ; Replace it with 9 ; One digit has been used ; Driver code"
Javascript;"function solve ( ang , n ) { if ( ( ang * n ) > ( 180 * ( n - 2 ) ) ) { return 0 ; } else if ( ( ang * n ) % 180 != 0 ) { return 0 ; } var ans = 1 ; var freq = ( ang * n ) / 180 ; ans = ans * ( n - 1 - freq ) ; ans = ans * n ; return ans ; } var ang = 90 , n = 4 ; document . write ( solve ( ang , n ) ) ;";"Number of occurrences of a given angle formed using 3 vertices of a n | Function that calculates occurrences of given angle that can be created using any 3 sides ; Maximum angle in a regular n - gon is equal to the interior angle If the given angle is greater than the interior angle then the given angle cannot be created ; The given angle times n should be divisible by 180 else it cannot be created ; Initialise answer ; Calculate the frequency of given angle for each vertex ; Multiply answer by frequency . ; Multiply answer by the number of vertices . ; Driver code"
Javascript;"function prime ( n ) { for ( let i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } function thirdNumber ( a , b ) { let sum = 0 , temp = 0 ; sum = a + b ; temp = 1 ; if ( ( sum & 1 ) != 0 ) { temp = 2 ; } while ( ! prime ( sum + temp ) ) { temp += 2 ; } document . write ( temp ) ; } let a = 3 , b = 5 ; thirdNumber ( a , b ) ;";"Find third number such that sum of all three number becomes prime | Function that will check whether number is prime or not ; Function to print the 3 rd number ; If the sum is odd ; If sum is not prime ; Driver code"
Javascript;"function nCr ( n , r ) { let ans = 1 ; for ( let i = 1 ; i <= r ; i += 1 ) { ans *= ( n - r + i ) ; ans /= i ; } return ans ; } function total_ways ( N , X ) { return ( nCr ( N - 1 , X - 1 ) + nCr ( N - 1 , X ) ) ; } let N = 5 , X = 3 ; document . write ( total_ways ( N , X ) ) ;";"Total ways of selecting a group of X men from N men with or without including a particular man | Function to return the value of nCr ; Initialize the answer ; Divide simultaneously by i to avoid overflow ; Function to return the count of ways ; Driver code"
Javascript;"function calculate ( n , k , m , power ) { if ( n > m ) { if ( power == 0 ) return 0 ; else return power - 1 ; } else if ( n == m ) return power ; else return calculate ( n * k , k , m , power + 1 ) ; } var N = 1 , K = 2 , M = 5 ; document . write ( calculate ( N , K , M , 0 ) ) ;";"Compute the maximum power with a given condition | Function to return the largest power ; If n is greater than given M ; If n == m ; Checking for the next power ; Driver Code"
Javascript;"function printNumber ( holes ) { if ( holes == 0 ) document . write ( "" "" ) ; else if ( holes == 1 ) document . write ( "" "" ) ; else { let rem = 0 , quo = 0 ; rem = holes % 2 ; quo = parseInt ( holes / 2 , 10 ) ; if ( rem == 1 ) document . write ( "" "" ) ; for ( let i = 0 ; i < quo ; i ++ ) document . write ( "" "" ) ; } } let holes = 3 ; printNumber ( holes ) ;";"Program to find the number from given holes | Function that will find out the number ; If number of holes equal 0 then return 1 ; If number of holes equal 0 then return 0 ; If number of holes is more than 0 or 1. ; If number of holes is odd ; Driver code ; Calling Function"
Javascript;"function minCost ( arr , n ) { var count_even = 0 ; var count_odd = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) count_even ++ ; else count_odd ++ ; } return Math . min ( count_even , count_odd ) ; } var arr = [ 2 , 4 , 3 , 1 , 5 ] ; var n = arr . length ; document . write ( minCost ( arr , n ) ) ;";"Minimum cost to make all array elements equal | Function to return the minimum cost to make each array element equal ; To store the count of even numbers present in the array ; To store the count of odd numbers present in the array ; Iterate through the array and find the count of even numbers and odd numbers ; Driver code"
Javascript;"function negProdSubArr ( arr , n ) { let positive = 1 , negative = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) arr [ i ] = 1 ; else arr [ i ] = - 1 ; if ( i > 0 ) arr [ i ] *= arr [ i - 1 ] ; if ( arr [ i ] == 1 ) positive ++ ; else negative ++ ; } return ( positive * negative ) ; } function posProdSubArr ( arr , n ) { let total = parseInt ( ( n * ( n + 1 ) ) / 2 ) ; let cntNeg = negProdSubArr ( arr , n ) ; return ( total - cntNeg ) ; } let arr = [ 5 , - 4 , - 3 , 2 , - 5 ] ; let n = arr . length ; document . write ( posProdSubArr ( arr , n ) ) ;";"Number of Subarrays with positive product | Function to return the count of subarrays with negative product ; Replace current element with 1 if it is positive else replace it with - 1 instead ; Take product with previous element to form the prefix product ; Count positive and negative elements in the prefix product array ; Return the required count of subarrays ; Function to return the count of subarrays with positive product ; Total subarrays possible ; Count to subarrays with negative product ; Return the count of subarrays with positive product ; Driver code"
Javascript;"let MAX = 10000 ; let prime = new Array ( MAX + 1 ) ; function SieveOfEratosthenes ( ) { let i ; for ( i = 0 ; i < MAX + 1 ; i ++ ) { prime [ i ] = true ; } prime [ 1 ] = false ; for ( let p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } } function xorFirstNPrime ( n ) { let count = 0 , num = 1 ; let xorVal = 0 ; while ( count < n ) { if ( prime [ num ] ) { xorVal ^= num ; count ++ ; } num ++ ; } return xorVal ; } SieveOfEratosthenes ( ) ; let n = 4 ; document . write ( xorFirstNPrime ( n ) ) ;";"Find the XOR of first N Prime Numbers | Javascript implementation of the approach ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Set all multiples of p to non - prime ; Function to return the xor of 1 st N prime numbers ; Count of prime numbers ; XOR of prime numbers ; If the number is prime xor it ; Increment the count ; Get to the next number ; Create the sieve ; Find the xor of 1 st n prime numbers"
Javascript;"let mod = 1000000007 ; let inv2 = 500000004 ; function modulo ( num ) { let res = 0 ; for ( let i = 0 ; i < num . length ; i ++ ) res = ( res * 10 + num [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) % mod ; return res ; } function findSum ( L , R ) { let a , b , l , r , ret ; a = modulo ( L ) ; b = modulo ( R ) ; l = ( ( a * ( a - 1 ) ) % mod * inv2 ) % mod ; r = ( ( b * ( b + 1 ) ) % mod * inv2 ) % mod ; ret = ( r % mod - l % mod ) ; if ( ret < 0 ) ret = ret + mod ; else ret = ret % mod - 6 ; return ret ; } let L = "" "" ; let R = "" "" ; document . write ( findSum ( L , R ) ) ;";"Sum of all natural numbers from L to R ( for large values of L and R ) | Javascript implementation of the approach ; Value of inverse modulo 2 with 10 ^ 9 + 7 ; Function to return num % 1000000007 where num is a large number ; Initialize result ; One by one process all the digits of string ' num ' ; Function to return the sum of the longegers from the given range modulo 1000000007 ; a stores the value of L modulo 10 ^ 9 + 7 ; b stores the value of R modulo 10 ^ 9 + 7 ; l stores the sum of natural numbers from 1 to ( a - 1 ) ; r stores the sum of natural numbers from 1 to b ; If the result is negative ; Driver code"
Javascript;"function maxSubArraySum ( a , n , k , i ) { let max_so_far = Number . MIN_VALUE , max_ending_here = 0 ; while ( i < n ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; i += k ; } return max_so_far ; } function find ( arr , n , k ) { let maxSum = 0 ; for ( let i = 0 ; i <= Math . min ( n , k ) ; i ++ ) { let sum = 0 ; maxSum = Math . max ( maxSum , maxSubArraySum ( arr , n , k , i ) ) ; } return maxSum ; } let arr = [ 2 , - 3 , - 1 , - 1 , 2 ] ; let n = arr . length ; let k = 2 ; document . write ( find ( arr , n , k ) ) ;";"Maximum subsequence sum such that all elements are K distance apart | Function to return the maximum subarray sum for the array { a [ i ] , a [ i + k ] , a [ i + 2 k ] , ... } ; Function to return the sum of the maximum required subsequence ; To store the result ; Run a loop from 0 to k ; Find the maximum subarray sum for the array { a [ i ] , a [ i + k ] , a [ i + 2 k ] , ... } ; Return the maximum value ; Driver code"
Javascript;"const MAX = 1000000 ; let prime = new Array ( MAX + 1 ) . fill ( true ) ; function SieveOfEratosthenes ( ) { prime [ 1 ] = false ; for ( let p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } } function solve ( n ) { let count = 0 ; for ( let i = 3 ; count < n ; i ++ ) { if ( prime [ i ] ) { document . write ( i + "" "" ) ; count ++ ; } } } SieveOfEratosthenes ( ) ; let n = 6 ; solve ( n ) ;";"Generate N integers satisfying the given conditions | Javascript implementation of the approach ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Set all multiples of p to non - prime ; Function to find the first n odd prime numbers ; To store the current count of prime numbers ; Starting with 3 as 2 is an even prime number ; If i is prime ; Print i and increment count ; Create the sieve"
Javascript;"function solve ( n ) { let n_2 = parseInt ( n / 2 , 10 ) ; let den ; den = "" "" ; while ( n_2 -- > 0 ) den += ' ' ; document . write ( 1 + "" "" + den + "" "" ) ; } let N = 5 ; solve ( N ) ;";"Probability that a N digit number is palindrome | Find the probability that a n digit number is palindrome ; Denominator ; Assign 10 ^ ( floor ( n / 2 ) ) to denominator ; Display the answer ; Driver code"
Javascript;"MOD = 1000000007 ; function countWays ( n ) { var ans = 1 ; for ( i = 0 ; i < n ; i ++ ) { ans *= 2 ; ans %= MOD ; } return ( ( ans - 1 + MOD ) % MOD ) ; } var n = 3 ; document . write ( countWays ( n ) ) ;";"Ways to choose balls such that at least one ball is chosen | javascript implementation of the approach ; Function to return the count of ways to choose the balls ; Calculate ( 2 ^ n ) % MOD ; Subtract the only where no ball was chosen ; Driver code"
Javascript;"function findMin ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; arr . sort ( ) ; let min = arr [ 0 ] ; let max = 0 ; for ( let i = n - 1 ; i >= 1 ; i -- ) { let num = arr [ i ] ; let total = num + min ; let j ; for ( j = 2 ; j <= num ; j ++ ) { if ( num % j == 0 ) { let d = j ; let now = parseInt ( num / d ) + ( min * d ) ; let reduce = total - now ; if ( reduce > max ) max = reduce ; } } } document . write ( sum - max ) ; } let arr = [ 1 , 2 , 3 , 4 , 5 ] ; let n = arr . length ; findMin ( arr , n ) ;";"Minimize the sum of the array according the given condition | Function to return the minimum sum ; sort the array to find the minimum element ; finding the number to divide ; Checking to what instance the sum has decreased ; getting the max difference ; Driver Code"
Javascript;"function convert_To_Len_th_base ( n , arr , len , L ) { for ( i = 0 ; i < L ; i ++ ) { document . write ( parseInt ( arr [ n % len ] ) ) ; n = parseInt ( n / len ) ; } document . write ( "" "" ) ; } function print ( arr , len , L ) { for ( var i = 0 ; i < parseInt ( Math . pow ( len , L ) ) ; i ++ ) { convert_To_Len_th_base ( i , arr , len , L ) ; } } var arr = [ 1 , 2 , 3 ] ; var len = arr . length ; var L = 2 ; print ( arr , len , L ) ;";"Print all the permutation of length L using the elements of an array | Iterative | Convert the number to Lth base and print the sequence ; Sequence is of length L ; Print the ith element of sequence ; Print all the permuataions ; There can be ( len ) ^ l permutations ; Convert i to len th base ; Driver code ; function call"
Javascript;"function totalways ( arr , n ) { var cnt = { } ; for ( var i = 0 ; i < n ; i ++ ) { if ( cnt . hasOwnProperty ( arr [ i ] ) ) { cnt [ arr [ i ] ] = cnt [ arr [ i ] ] + 1 ; } else { cnt [ arr [ i ] ] = 1 ; } } if ( n % 2 === 1 ) { var start = 0 , endd = n - 1 ; for ( var i = start ; i <= endd ; i = i + 2 ) { if ( i === 0 ) { if ( cnt [ i ] !== 1 ) { return 0 ; } } else { if ( cnt [ i ] !== 2 ) { return 0 ; } } } var ways = 1 ; start = 2 ; endd = n - 1 ; for ( var i = start ; i <= endd ; i = i + 2 ) { ways = ways * 2 ; } return ways ; } else if ( n % 2 === 0 ) { var start = 1 , endd = n - 1 ; for ( var i = 1 ; i <= endd ; i = i + 2 ) { if ( cnt [ i ] !== 2 ) return 0 ; } var ways = 1 ; for ( var i = start ; i <= endd ; i = i + 2 ) { ways = ways * 2 ; } return ways ; } return - 2147483648 ; } var N = 5 ; var arr = [ 2 , 4 , 4 , 0 , 2 ] ; document . write ( totalways ( arr , N ) ) ;";"Number of possible permutations when absolute difference between number of elements to the right and left are given | Function to find the number of permutations possible of the original array to satisfy the given absolute differences ; To store the count of each a [ i ] in a map ; if n is odd ; check the count of each whether it satisfy the given criteria or not ; there is only 1 way for middle element . ; for others there are 2 ways . ; now find total ways ; When n is even . ; there will be no middle element so for each a [ i ] there will be 2 ways ; Driver Code"
Javascript;"function proizvolov ( a , b , n ) { return n * n ; } let a = [ 1 , 5 , 6 , 8 , 10 ] , b = [ 9 , 7 , 4 , 3 , 2 ] ; let n = a . length ; document . write ( proizvolov ( a , b , n ) ) ;";"Proizvolov 's Identity | Function to implement proizvolov 's identity ; According to proizvolov 's identity ; Driver code ; Function call"
Javascript;"function calculateLnx ( n ) { let num , mul , cal , sum = 0 ; num = ( n - 1 ) / ( n + 1 ) ; for ( let i = 1 ; i <= 1000 ; i ++ ) { mul = ( 2 * i ) - 1 ; cal = Math . pow ( num , mul ) ; cal = cal / mul ; sum = sum + cal ; } sum = 2 * sum ; return sum ; } function calculateLogx ( lnx ) { return ( lnx / 2.303 ) ; } let lnx , logx , n = 5 ; lnx = calculateLnx ( n ) ; logx = calculateLogx ( lnx ) ; document . write ( "" "" + n + "" "" + lnx + "" "" ) ; document . write ( "" "" + n + "" "" + logx + "" "" ) ;";"Find the ln ( X ) and log10X with the help of expansion | Function to calculate ln x using expansion ; Terminating value of the loop can be increased to improve the precision ; Function to calculate log10 x ; Driver Code ; setprecision ( 3 ) is used to display the output up to 3 decimal places"
Javascript;"function sum ( A , B , R ) { let sum = 0 ; for ( let i = 1 ; i <= R ; i ++ ) { sum = sum + ( i * A ) ; A = A + B ; } return sum ; } let A = 5 , B = 3 , R = 3 ; document . write ( sum ( A , B , R ) ) ;";"Find the sum of elements of the Matrix generated by the given rules | Function to return the required sum ; To store the sum ; For every row ; Update the sum as A appears i number of times in the current row ; Update A for the next row ; Return the sum ; Driver code"
Javascript;"function countSetBits ( n ) { n ++ ; var powerOf2 = 2 ; var cnt = n / 2 ; while ( powerOf2 <= n ) { var totalPairs = n / powerOf2 ; cnt += ( totalPairs / 2 ) * powerOf2 ; cnt += ( totalPairs % 2 == 1 ) ? ( n % powerOf2 ) : 0 ; powerOf2 <<= 1 ; } return cnt ; } var n = 14 ; document . write ( countSetBits ( n ) ) ;";"Count total set bits in all numbers from 1 to n | Set 2 | Function to return the sum of the count of set bits in the integers from 1 to n ; Ignore 0 as all the bits are unset ; To store the powers of 2 ; To store the result , it is initialized with n / 2 because the count of set least significant bits in the integers from 1 to n is n / 2 ; Loop for every bit required to represent n ; Total count of pairs of 0 s and 1 s ; totalPairs / 2 gives the complete count of the pairs of 1 s Multiplying it with the current power of 2 will give the count of 1 s in the current bit ; If the count of pairs was odd then add the remaining 1 s which could not be groupped together ; Next power of 2 ; Return the result ; Driver code"
Javascript;"function getHeight ( X ) { return ( 2 * X ) ; } var X = 35 ; document . write ( getHeight ( X ) ) ;";"Find the height of a right | Function to return the height of the right - angled triangle whose area is X times its base ; Driver code"
Javascript;"function SumofInverseDivisors ( N , Sum ) { let ans = ( Sum ) * 1.0 / ( N ) ; return ans ; } let N = 9 ; let Sum = 13 ; document . write ( SumofInverseDivisors ( N , Sum ) . toFixed ( 2 ) ) ;";"Find sum of inverse of the divisors when sum of divisors and the number is given | Function to return the sum of inverse of divisors ; Calculating the answer ; Return the answer ; Driver code ; Function call"
Javascript;"function NoofTriplets ( N , K ) { let cnt = Array ( K ) ; for ( let i = 0 ; i < K ; i ++ ) cnt [ i ] = 0 ; for ( let i = 1 ; i <= N ; i += 1 ) { cnt [ i % K ] += 1 ; } if ( K & 1 ) return cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] ; else { return ( cnt [ 0 ] * cnt [ 0 ] * cnt [ 0 ] + cnt [ K / 2 ] * cnt [ K / 2 ] * cnt [ K / 2 ] ) ; } } let N = 3 ; let K = 2 ; document . write ( NoofTriplets ( N , K ) ) ;";"Number of triplets such that each value is less than N and each pair sum is a multiple of K | Function to return the number of triplets ; Initializing the count array ; Storing the frequency of each modulo class ; If K is odd ; If K is even ; Driver Code ; Function Call"
Javascript;"function findNumber ( n ) { let num = n - 1 ; num = 2 * Math . pow ( 4 , num ) ; num = Math . floor ( num / 3.0 ) ; return num ; } let n = 5 ; document . write ( findNumber ( n ) ) ;";"Find a number containing N | Function to compute number using our deduced formula ; Initialize num to n - 1 ; Driver code"
Javascript;"function findxOR ( n ) { let mod = n % 4 ; if ( mod == 0 ) return n ; else if ( mod == 1 ) return 1 ; else if ( mod == 2 ) return n + 1 ; else if ( mod == 3 ) return 0 ; } function findXOR ( l , r ) { return ( findxOR ( l - 1 ) ^ findxOR ( r ) ) ; } let l = 4 , r = 8 ; document . write ( findXOR ( l , r ) ) ;";"Find XOR of numbers from the range [ L , R ] | Function to return the XOR of elements from the range [ 1 , n ] ; If n is a multiple of 4 ; If n % 4 gives remainder 1 ; If n % 4 gives remainder 2 ; If n % 4 gives remainder 3 ; Function to return the XOR of elements from the range [ l , r ] ; Driver code"
Javascript;"function GCD ( a , b ) { if ( b == 0 ) return a ; return GCD ( b , a % b ) ; } function findReachable ( arr , D , A , B , n ) { var gcd_AB = GCD ( A , B ) ; var count = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] - D ) % gcd_AB == 0 ) count ++ ; } return count ; } var arr = [ 4 , 5 , 6 , 7 , 8 , 9 ] ; var n = arr . length ; var D = 4 , A = 4 , B = 6 ; document . write ( findReachable ( arr , D , A , B , n ) ) ;";"Number of elements from the array which are reachable after performing given operations on D | Function to return the GCD of a and b ; Function to return the count of reachable integers from the given array ; GCD of A and B ; To store the count of reachable integers ; If current element can be reached ; Return the count ; Driver code"
Javascript;"function power ( x , y ) { var res = 1 ; while ( y > 0 ) { if ( y & 1 ) res = ( res * x ) ; y = y >> 1 ; x = ( x * x ) ; } return res ; } function solve ( L ) { var n = L / 2 + 1 ; var ans = power ( n , n - 2 ) ; return ans ; } var L = 6 ; document . write ( solve ( L ) ) ;";"Number of trees whose sum of degrees of all the vertices is L | Iterative Function to calculate ( x ^ y ) in O ( log y ) ; Initialize result ; If y is odd , multiply x with result ; y must be even now y = y / 2 ; Function to return the count of required trees ; number of nodes ; Return the result ; Driver code"
Javascript;"function getfactor ( n , p ) { let pw = 0 ; while ( n != 0 ) { n = parseInt ( n / p , 10 ) ; pw += n ; } return pw ; } function isDivisible ( n , r , p ) { let x1 = getfactor ( n , p ) ; let x2 = getfactor ( r , p ) ; let x3 = getfactor ( n - r , p ) ; if ( x1 > x2 + x3 ) return 1 ; return 0 ; } let n = 7 , r = 2 , p = 7 ; if ( isDivisible ( n , r , p ) == 1 ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Find if nCr is divisible by the given prime | Function to return the highest power of p that divides n ! implementing Legendre Formula ; Return the highest power of p which divides n ! ; Function to return N digits number which is divisible by D ; Find the highest powers of p that divide n ! , r ! and ( n - r ) ! ; If nCr is divisible by p ; Driver code"
Javascript;"function isEven ( arr , n , r ) { if ( r % 2 == 0 ) { if ( arr [ n - 1 ] % 2 == 0 ) return true ; } else { let oddCount = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( arr [ i ] % 2 != 0 ) oddCount ++ ; } if ( oddCount % 2 == 0 ) return true ; } return false ; } let arr = [ 1 , 0 ] ; let n = arr . length ; let r = 2 ; if ( isEven ( arr , n , r ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check if the number is even or odd whose digits and base ( radix ) is given | Function that returns true if the number represented by arr [ ] is even in base r ; If the base is even , then the last digit is checked ; If base is odd , then the number of odd digits are checked ; To store the count of odd digits ; Number is odd ; Driver code"
Javascript;"function closetAND ( arr , n , k ) { let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; i ++ ) { let X = arr [ i ] ; for ( let j = i ; j < n ; j ++ ) { X &= arr [ j ] ; ans = Math . min ( ans , Math . abs ( k - X ) ) ; if ( X <= k ) break ; } } return ans ; } let arr = [ 4 , 7 , 10 ] ; let n = arr . length ; let k = 2 ; document . write ( closetAND ( arr , n , k ) ) ;";"Bitwise AND of sub | Function to return the minimum possible value of | K - X | where X is the bitwise AND of the elements of some sub - array ; Check all possible sub - arrays ; Find the overall minimum ; No need to perform more AND operations as | k - X | will increase ; Driver code"
Javascript;"function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } function countQuadruplets ( l , r , k ) { let frequency = new Array ( r + 1 ) ; frequency . fill ( 0 ) ; for ( let i = l ; i <= r ; i ++ ) { for ( let j = l ; j <= r ; j ++ ) { frequency [ gcd ( i , j ) ] ++ ; } } let answer = 0 ; for ( let i = 1 ; i <= r ; i ++ ) { for ( let j = 1 ; j <= r ; j ++ ) { if ( gcd ( i , j ) == k ) { answer += ( frequency [ i ] * frequency [ j ] ) ; } } } return answer ; } let l = 1 , r = 10 , k = 2 ; document . write ( countQuadruplets ( l , r , k ) ) ;";"Count of quadruplets from range [ L , R ] having GCD equal to K | Function to return the gcd of a and b ; Function to return the count of quadruplets having gcd = k ; Count the frequency of every possible gcd value in the range ; To store the required count ; Calculate the answer using frequency values ; Return the required count ; Driver code"
Javascript;"function solve ( a , n ) { let ones = 0 , twos = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ones ++ ; else twos ++ ; } let ind = 0 ; if ( twos > 0 ) a [ ind ++ ] = 2 ; let evenOnes = ( ones % 2 == 0 ) ? true : false ; if ( evenOnes ) ones -= 1 ; for ( let i = 0 ; i < ones ; i ++ ) a [ ind ++ ] = 1 ; for ( let i = 0 ; i < twos - 1 ; i ++ ) a [ ind ++ ] = 2 ; if ( evenOnes ) a [ ind ++ ] = 1 ; for ( let i = 0 ; i < n ; i ++ ) document . write ( a [ i ] + "" "" ) ; } let a = [ 1 , 2 , 1 , 2 , 1 ] ; let n = a . length ; solve ( a , n ) ;";"Rearrange the array to maximize the number of primes in prefix sum of the array | Function to print the re - arranged array ; Count the number of ones and twos in a [ ] ; If the array element is 1 ; Array element is 2 ; If it has at least one 2 Fill up first 2 ; Decrease the cnt of ones if even ; Fill up with odd count of ones ; Fill up with remaining twos ; If even ones , then fill last position ; Print the rearranged array ; Driver code"
Javascript;"function CreateArray ( N , even , odd ) { let EvenPreSums = 1 ; let temp = - 1 ; let OddPreSums = 0 ; for ( let i = 0 ; i <= N + 1 ; i ++ ) { if ( i * ( ( N + 1 ) - i ) == odd ) { temp = 0 ; OddPreSums = i ; break ; } } if ( temp == - 1 ) { document . write ( temp ) ; } else { EvenPreSums = ( ( N + 1 ) - OddPreSums ) ; let e = 1 ; let o = 0 ; let CurrSum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( CurrSum % 2 == 0 ) { if ( e < EvenPreSums ) { e ++ ; document . write ( "" "" ) ; } else { o ++ ; document . write ( "" "" ) ; CurrSum ++ ; } } else { if ( e < EvenPreSums ) { e ++ ; document . write ( "" "" ) ; CurrSum ++ ; } else { o ++ ; document . write ( "" "" ) ; } } } document . write ( ) ; } } let N = 15 ; let even = 60 , odd = 60 ; CreateArray ( N , even , odd ) ;";"Generate an Array in which count of even and odd sum sub | Function to generate and print the required array ; Find the number of odd prefix sums ; If no odd prefix sum found ; Calculating the number of even prefix sums ; Stores the current prefix sum ; If current prefix sum is even ; Print 0 until e = EvenPreSums - 1 ; Print 1 when e = EvenPreSums ; Print 0 for rest of the values ; Driver code"
Javascript;"function changeTheArray ( arr , n ) { let minEle = Math . min ( ... arr ) ; let maxEle = Math . max ( ... arr ) ; let minOperations = Number . MAX_VALUE ; for ( let num = minEle ; num <= maxEle ; num ++ ) { let operations = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] != num ) { operations += ( Math . abs ( num - arr [ i ] ) - 1 ) ; } } minOperations = Math . min ( minOperations , operations ) ; } return minOperations ; } let arr = [ 10 , 1 , 4 ] ; let n = arr . length ; document . write ( changeTheArray ( arr , n ) ) ;";"Minimum operations required to change the array such that | arr [ i ] | Function to return the minimum number of operations required ; Minimum and maximum elements from the array ; To store the minimum number of operations required ; To store the number of operations required to change every element to either ( num - 1 ) , num or ( num + 1 ) ; If current element is not already num ; Add the count of operations required to change arr [ i ] ; Update the minimum operations so far ; Driver code"
Javascript;"function findX ( A , B ) { let j = 0 , x = 0 ; while ( A != 0 B != 0 ) { if ( ( A % 2 == 1 ) && ( B % 2 == 1 ) ) { x += ( 1 << j ) ; } A >>= 1 ; B >>= 1 ; j += 1 ; } return x ; } let A = 2 , B = 3 ; let X = findX ( A , B ) ; document . write ( "" "" + X + "" "" + ( ( A ^ X ) + ( B ^ X ) ) ) ;";"Choose X such that ( A xor X ) + ( B xor X ) is minimized | Function to return the integer X such that ( A xor X ) + ( B ^ X ) is minimized ; While either A or B is non - zero ; Position at which both A and B have a set bit ; Inserting a set bit in x ; Right shifting both numbers to traverse all the bits ; Driver code"
Javascript;"function findX ( A , B ) { return A & B ; } function findSum ( A , B ) { return A ^ B ; } let A = 2 , B = 3 ; document . write ( "" "" + findX ( A , B ) + "" "" + findSum ( A , B ) ) ;";"Choose X such that ( A xor X ) + ( B xor X ) is minimized | finding X ; finding Sum ; Driver Code"
Javascript;"function isSumEqual ( ar , n ) { let sum = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) sum += ar [ i ] ; if ( sum == ar [ n - 1 ] ) return true ; return false ; } let arr = [ 1 , 2 , 3 , 4 , 10 ] ; let n = arr . length ; if ( isSumEqual ( arr , n ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Compare sum of first N | Function that returns true if sum of first n - 1 elements of the array is equal to the last element ; Find the sum of first n - 1 elements of the array ; If sum equals to the last element ; Driver code"
Javascript;"function perfectSquares ( a , b ) { return ( Math . floor ( Math . sqrt ( b ) ) - Math . ceil ( Math . sqrt ( a ) ) + 1 ) ; } function countOnes ( arr , n ) { return perfectSquares ( 1 , n ) ; } var N = 10 ; var arr = [ 0 ] ; document . write ( countOnes ( arr , N ) ) ;";"Count number of 1 s in the array after N moves | Function to count number of perfect squares ; Counting number of perfect squares between a and b ; Function to count number of 1 s in array after N moves ; Initialize array size ; Initialize all elements to 0"
Javascript;"function printPosition ( A , B , sizeOfA , sizeOfB ) { for ( i = 1 ; i < sizeOfA ; i ++ ) { A [ i ] += A [ i - 1 ] ; } for ( i = 0 ; i < sizeOfB ; i ++ ) { var row = lower_bound ( A , 0 , A . length , B [ i ] ) ; var boxNumber = ( row >= 1 ) ? B [ i ] - A [ row - 1 ] : B [ i ] ; document . write ( row + 1 + "" "" + boxNumber + "" "" ) ; } } function lower_bound ( a , low , high , element ) { while ( low < high ) { var middle = low + ( high - low ) / 2 ; if ( element > a [ middle ] ) { low = middle + 1 ; } else { high = middle ; } } return low ; } var A = [ 2 , 2 , 2 , 2 ] ; var B = [ 1 , 2 , 3 , 4 ] ; var sizeOfA = A . length ; var sizeOfB = B . length ; printPosition ( A , B , sizeOfA , sizeOfB ) ;";"Find the position of box which occupies the given ball | Function to print the position of each boxes where a ball has to be placed ; Find the cumulative sum of array A ; Find the position of box for each ball ; Row number ; Column ( position of box in particular row ) ; Row + 1 denotes row if indexing of array start from 1 ; Driver code"
Javascript;"function primeFactors ( n , freq ) { var cnt = 0 ; while ( n % 2 == 0 ) { cnt ++ ; n = n / 2 ; } freq [ 2 ] = cnt ; var i ; for ( i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { cnt = 0 ; while ( n % i == 0 ) { cnt ++ ; n = n / i ; } freq [ i ] = cnt ; } if ( n > 2 ) freq [ n ] = 1 ; } function getMaximumPower ( n , m ) { var freq1 = new Array ( n + 1 ) ; var freq2 = new Array ( m + 1 ) ; primeFactors ( n , freq1 ) ; primeFactors ( m , freq2 ) ; var maxi = 0 ; for ( i = 2 ; i <= m ; i ++ ) { if ( freq1 [ i ] == 0 && freq2 [ i ] == 0 ) continue ; if ( freq2 [ i ] > freq1 [ i ] ) return 0 ; if ( freq2 [ i ] ) { maxi = Math . max ( maxi , freq1 [ i ] / freq2 [ i ] ) ; } } return maxi ; } var n = 48 , m = 4 ; document . write ( getMaximumPower ( n , m ) ) ;";"Highest power of a number that divides other number | Function to get the prime factors and its count of times it divides ; Count the number of 2 s that divide n ; n must be odd at this point . So we can skip one element ( Note i = i + 2 ) ; While i divides n , count i and divide n ; This condition is to handle the case when n is a prime number greater than 2 ; Function to return the highest power ; Initialize two arrays ; Get the prime factors of n and m ; Iterate and find the maximum power ; If i not a prime factor of n and m ; If i is a prime factor of n and m If count of i dividing m is more than i dividing n , then power will be 0 ; If i is a prime factor of M ; get the maximum power ; Drivers code"
Javascript;"function findDivisors ( n ) { let div = new Array ( n + 1 ) . fill ( 0 ) ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j * i <= n ; j ++ ) div [ i * j ] ++ ; } for ( let i = 1 ; i <= n ; i ++ ) document . write ( div [ i ] + "" "" ) ; } let n = 10 ; findDivisors ( n ) ;";"Find the number of divisors of all numbers in the range [ 1 , n ] | Function to find the number of divisors of all numbers in the range [ 1 , n ] ; Array to store the count of divisors ; For every number from 1 to n ; Increase divisors count for every number divisible by i ; Print the divisors ; Driver code"
Javascript;"function decideWinner ( a , n ) { var count0 = 0 ; var count1 = 0 ; var count2 = 0 ; var count3 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 4 == 0 ) count0 ++ ; else if ( a [ i ] % 4 == 1 ) count1 ++ ; else if ( a [ i ] % 4 == 2 ) count2 ++ ; else if ( a [ i ] % 4 == 3 ) count3 ++ ; } if ( count0 % 2 == 0 && count1 % 2 == 0 && count2 % 2 == 0 && count3 == 0 ) return 1 ; else return 2 ; } var a = [ 4 , 8 , 5 , 9 ] ; var n = a . length ; if ( decideWinner ( a , n ) == 1 ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Predict the winner of the game on the basis of absolute difference of sum by selecting numbers | Function to decide the winner ; Iterate for all numbers in the array ; If mod gives 0 ; If mod gives 1 ; If mod gives 2 ; If mod gives 3 ; Check the winning condition for X ; Driver code"
Javascript;"function CntDivbyX ( arr , n , x ) { let number = 0 ; let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { number = ( number * 2 + arr [ i ] ) % x ; if ( number == 0 ) count += 1 ; } return count ; } let arr = [ 1 , 0 , 1 , 0 , 1 , 1 , 0 ] ; let n = arr . length ; let x = 2 ; document . write ( CntDivbyX ( arr , n , x ) ) ;";"Count all prefixes of the given binary array which are divisible by x | Function to return the count of total binary prefix which are divisible by x ; Initialize with zero ; Instead of converting all prefixes to decimal , take reminder with x ; If number is divisible by x then reminder = 0 ; Driver code"
Javascript;"function numLen ( K ) { if ( K % 2 == 0 K % 5 == 0 ) return - 1 ; var number = 0 ; var len = 1 ; for ( len = 1 ; len <= K ; len ++ ) { number = ( number * 10 + 1 ) % K ; if ( number == 0 ) return len ; } return - 1 ; } var K = 7 ; document . write ( numLen ( K ) ) ;";"Length of the smallest number which is divisible by K and formed by using 1 's only | Function to return length of the resultant number ; If K is a multiple of 2 or 5 ; Instead of generating all possible numbers 1 , 11 , 111 , 111 , ... , K 1 's  Take remainder with K ; If number is divisible by k then remainder will be 0 ; Driver code"
Javascript;"var max_Element = 1e6 + 5 ; var sum1 = new Array ( max_Element ) . fill ( 0 ) ; var sum2 = new Array ( max_Element ) . fill ( 0 ) ; var sum3 = new Array ( max_Element ) . fill ( 0 ) ; function precomputation ( arr , n ) { for ( var i = 1 ; i < max_Element ; i ++ ) for ( var j = i ; j < max_Element ; j += i ) sum1 [ j ] += i ; for ( var i = 1 ; i < max_Element ; i ++ ) for ( var j = i ; j < max_Element ; j += i ) sum2 [ j ] += ( sum1 [ j ] - i ) * i ; for ( var i = 1 ; i < max_Element ; i ++ ) sum2 [ i ] /= 2 ; for ( var i = 1 ; i < max_Element ; i ++ ) for ( var j = i ; j < max_Element ; j += i ) sum3 [ j ] += i * ( sum2 [ j ] - i * ( sum1 [ j ] - i ) ) ; for ( var i = 1 ; i < max_Element ; i ++ ) sum3 [ i ] /= 3 ; for ( var i = 0 ; i < n ; i ++ ) document . write ( sum3 [ arr [ i ] ] + "" "" ) ; } var arr = [ 9 , 5 , 6 ] ; var n = 3 ; precomputation ( arr , n ) ;";"Sum of multiplication of triplet of divisors of a number | JavaScript implementation of the approach ; Global array declaration ; Function to find the sum of multiplication of every triplet in the divisors of a number ; sum1 [ x ] represents the sum of all the divisors of x ; Adding i to sum1 [ j ] because i is a divisor of j ; sum2 [ x ] represents the sum of all the divisors of x ; Here i is divisor of j and sum1 [ j ] - i represents sum of all divisors of j which do not include i so we add i * ( sum1 [ j ] - i ) to sum2 [ j ] ; In the above implementation we have considered every pair two times so we have to divide every sum2 array element by 2 ; Here i is the divisor of j and we are trying to add the sum of multiplication of all triplets of divisors of j such that one of the divisors is i ; In the above implementation we have considered every triplet three times so we have to divide every sum3 array element by 3 ; Print the results ; Driver code ; Precomputing"
Javascript;"function fib ( n ) { var phi = ( 1 + Math . sqrt ( 5 ) ) / 2 ; return parseInt ( Math . round ( Math . pow ( phi , n ) / Math . sqrt ( 5 ) ) ) ; } function calculateSum ( l , r ) { var sum = fib ( r + 2 ) - fib ( l + 1 ) ; return sum ; } var l = 4 , r = 8 ; document . write ( calculateSum ( l , r ) ) ;";"Sum of Fibonacci Numbers in a range | Function to return the nth Fibonacci number ; Function to return the required sum ; Using our deduced result ; Driver code"
Javascript;"function printBalancedExpression ( a , b , c , d ) { if ( ( ( a == d ) && ( a != 0 ) ) || ( ( a == 0 ) && ( c == 0 ) && ( d == 0 ) ) ) { for ( i = 1 ; i <= a ; i ++ ) document . write ( "" "" ) ; for ( i = 1 ; i <= c ; i ++ ) document . write ( "" "" ) ; for ( i = 1 ; i <= d ; i ++ ) document . write ( "" "" ) ; for ( i = 1 ; i <= b ; i ++ ) document . write ( "" "" ) ; } else document . write ( - 1 ) ; } var a = 3 , b = 1 , c = 4 , d = 3 ; printBalancedExpression ( a , b , c , d ) ;";"Print the balanced bracket expression using given brackets | Function to print balanced bracket expression if it is possible ; If the condition is met ; Print brackets of type - 1 ; Print brackets of type - 3 ; Print brackets of type - 4 ; Print brackets of type - 2 ; If the condition is not met ; Driver code"
Javascript;"function factorial ( f ) { var fact = 1 ; for ( var i = 2 ; i <= f ; i ++ ) fact *= i ; return fact ; } function findPermutation ( N , M ) { var permutation = factorial ( N + M - 1 ) / ( factorial ( N ) * factorial ( M - 1 ) ) ; return permutation ; } var N = 3 , M = 3 ; document . write ( findPermutation ( N , M ) ) ;";"Count numbers having N 0 ' s ▁ and ▁ and ▁ M ▁ 1' s with no leading zeros | Function to return the factorial of a number ; Function to return the count of distinct ( N + M ) digit numbers having N 0 ' s ▁ and ▁ and ▁ M ▁ 1' s with no leading zeros ; Driver code"
Javascript;"function maxValue ( n ) { if ( n == 1 ) return 0 ; return ( parseInt ( n * n / 2 ) - 1 ) ; } var n = 4 ; document . write ( maxValue ( n ) ) ;";"Maximum value of | arr [ 0 ] | Function to return the maximum required value ; Driver code"
Javascript;"function findCount ( n ) { var a = 1 , b = 0 , c = 0 ; var x = parseInt ( n / 60 ) ; a = Math . pow ( 32 , x ) ; x = 60 * x ; for ( i = x + 1 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) { b += a ; a = 0 ; } if ( i % 5 == 0 ) { c += b ; b = 0 ; } if ( i % 12 == 0 ) { a += ( 2 * c ) ; c = 0 ; } } document . write ( "" "" + a + "" "" + b + "" "" + c ) ; } var n = 72 ; findCount ( n ) ;";"Count of a , b & c after n seconds for given reproduction rate | Function to prvar the count of a , b and c after n seconds ; Number of multiples of 60 below n ; Multiple of 60 nearest to n ; Change all a to b ; Change all b to c ; Change each c to two a ; Print the updated values of a , b and c ; Driver code"
Javascript;"function factorial ( n ) { return ( n == 1 n == 0 ) ? 1 : factorial ( n - 1 ) * n ; } function gcdOfFactorial ( arr , n ) { var minm = arr [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) minm = minm > arr [ i ] ? arr [ i ] : minm ; return factorial ( minm ) ; } var arr = [ 9 , 12 , 122 , 34 , 15 ] ; var n = arr . length ; document . write ( gcdOfFactorial ( arr , n ) ) ;";"Find GCD of factorial of elements of given array | Implementation of factorial function ; Function to find GCD of factorial of elements from array ; find the minimum element of array ; return the factorial of minimum element ; Driver Code"
Javascript;"function sum ( n ) { if ( n == 1 ) return 1 ; else return ( Math . pow ( n , n ) + sum ( n - 1 ) ) ; } var n = 2 ; document . write ( sum ( n ) ) ;";"Sum of the series 1 ^ 1 + 2 ^ 2 + 3 ^ 3 + ... . . + n ^ n using recursion | Recursive function to return the sum of the given series ; 1 ^ 1 = 1 ; Recursive call ; Driver code"
Javascript;"let mod = 1000000007 ; function power ( a , n ) { if ( n == 0 ) return 1 ; let p = power ( a , parseInt ( n / 2 , 10 ) ) % mod ; p = ( p * p ) % mod ; if ( ( n & 1 ) == 1 ) p = ( p * a ) % mod ; return p ; } function countPermutations ( n ) { if ( n == 1 ) { return 0 ; } return ( power ( 2 , n - 1 ) - 2 ) % mod ; } let n = 5 ; document . write ( countPermutations ( n ) ) ;";"Count permutations that are first decreasing then increasing . | Javascript implementation of the above approach ; Function to compute a ^ n % mod ; Function to count permutations that are first decreasing and then increasing ; For n = 1 return 0 ; Calculate and return result ; Driver Code"
Javascript;"function numbers ( n ) { return ( Math . pow ( 2 , n + 1 ) ) - 2 ; } var n = 2 ; document . write ( numbers ( n ) ) ;";"Find the count of numbers that can be formed using digits 3 , 4 only and having length at max N . | Function to find the count of numbers that can be formed using digits 3 , 4 only and having length at max N . ; Driver code"
Javascript;"function NumberofWays ( n ) { var x = ( 1 * n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ) / ( 4 * 3 * 2 * 1 ) ; var y = 1 * n * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) ; return 1 * x * y ; } var n = 4 ; document . write ( NumberofWays ( n ) ) ;";"Ways to place 4 items in n ^ 2 positions such that no row / column contains more than one | Function to return the number of ways to place 4 items in n ^ 2 positions ; Driver code"
Javascript;"function nthTerm ( N ) { let nth = 0 ; nth = parseInt ( ( N * N * ( N + 1 ) ) / 2 ) ; return nth ; } let N = 5 ; document . write ( nthTerm ( N ) ) ;";"Find Nth term of the series 1 , 6 , 18 , 40 , 75 , ... . | Function to generate a fixed number ; ( N ^ 2 * ( N + 1 ) ) / 2 ; Driver Method"
Javascript;"function findNumbers ( n ) { var i = 1 ; while ( i <= n ) { document . write ( ( ( 2 * i ) - 1 ) + "" "" ) ; i ++ ; } } var n = 3 ; findNumbers ( n ) ;";"Print n numbers such that their sum is a perfect square | Function to print n numbers such that their sum is a perfect square ; Print ith odd number ; Driver code"
Javascript;"function findMissingNums ( even , sizeEven , odd , sizeOdd ) { let minEven = Number . MAX_VALUE ; let maxEven = Number . MIN_VALUE ; let minOdd = Number . MAX_VALUE ; let maxOdd = Number . MIN_VALUE ; let sumEvenArr = 0 , sumOddArr = 0 ; for ( let i = 0 ; i < sizeEven ; i ++ ) { minEven = Math . min ( minEven , even [ i ] ) ; maxEven = Math . max ( maxEven , even [ i ] ) ; sumEvenArr += even [ i ] ; } for ( let i = 0 ; i < sizeOdd ; i ++ ) { minOdd = Math . min ( minOdd , odd [ i ] ) ; maxOdd = Math . max ( maxOdd , odd [ i ] ) ; sumOddArr += odd [ i ] ; } let totalTerms = 0 , reqSum = 0 ; totalTerms = parseInt ( minEven / 2 , 10 ) ; let evenSumMin = ( totalTerms * ( totalTerms + 1 ) ) ; totalTerms = parseInt ( maxEven / 2 , 10 ) ; let evenSumMax = ( totalTerms * ( totalTerms + 1 ) ) ; reqSum = evenSumMax - evenSumMin + minEven ; document . write ( "" "" + ( reqSum - sumEvenArr ) + "" "" ) ; totalTerms = parseInt ( minOdd / 2 , 10 ) + 1 ; let oddSumMin = totalTerms * totalTerms ; totalTerms = parseInt ( maxOdd / 2 , 10 ) + 1 ; let oddSumMax = totalTerms * totalTerms ; reqSum = oddSumMax - oddSumMin + minOdd ; document . write ( "" "" + ( reqSum - sumOddArr ) ) ; } let even = [ 6 , 4 , 8 , 14 , 10 ] ; let sizeEven = even . length ; let odd = [ 7 , 5 , 3 , 11 , 13 ] ; let sizeOdd = odd . length ; findMissingNums ( even , sizeEven , odd , sizeOdd ) ;";"Missing even and odd elements from the given arrays | Function to find the missing numbers ; To store the minimum and the maximum odd and even elements from the arrays ; To store the sum of the array elements ; Get the minimum and the maximum even elements from the array ; Get the minimum and the maximum odd elements from the array ; To store the total terms in the series and the required sum of the array ; Total terms from 2 to minEven ; Sum of all even numbers from 2 to minEven ; Total terms from 2 to maxEven ; Sum of all even numbers from 2 to maxEven ; Required sum for the even array ; Missing even number ; Total terms from 1 to minOdd ; Sum of all odd numbers from 1 to minOdd ; Total terms from 1 to maxOdd ; Sum of all odd numbers from 1 to maxOdd ; Required sum for the odd array ; Missing odd number ; Driver code"
Javascript;"function findMinimum ( x , y ) { let low = 0 , high = y ; while ( low <= high ) { let mid = ( low + high ) >> 1 ; if ( ( mid * 2 + ( y - mid ) ) >= x ) high = mid - 1 ; else low = mid + 1 ; } return low ; } let x = 6 , y = 5 ; document . write ( findMinimum ( x , y ) ) ;";"Minimum matches the team needs to win to qualify | Function to return the minimum number of matches to win to qualify for next round ; Do a binary search to find ; Find mid element ; Check for condition to qualify for next round ; Driver Code"
Javascript;"function getResult ( n ) { let proOdd = 1 ; let proEven = 1 ; let num = n . toString ( ) ; for ( let i = 0 ; i < num . length ; i ++ ) if ( i % 2 == 0 ) proOdd = proOdd * ( num [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; else proEven = proEven * ( num [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; if ( proOdd == proEven ) document . write ( "" "" ) ; else document . write ( "" "" ) ; } let n = 4324 ; getResult ( n ) ;";"Check if product of digits of a number at even and odd places is equal | Javascript implementation of the approach ; To store the respective product ; Converting integer to String ; Traversing the String ; Driver code"
Javascript;"function sumOfDigits ( x ) { let sum = 0 ; while ( x != 0 ) { sum += x % 10 ; x = Math . floor ( x / 10 ) ; } return sum ; } function countNumbers ( l , r ) { let count = 0 ; for ( let i = l ; i <= r ; i ++ ) { if ( i % 2 == 0 && sumOfDigits ( i ) % 3 === 0 ) count ++ ; } return count ; } let l = 1000 , r = 6000 ; document . write ( countNumbers ( l , r ) ) ;";"Count of all even numbers in the range [ L , R ] whose sum of digits is divisible by 3 | Function to return the sum of digits of x ; Function to return the count of required numbers ; If i is divisible by 2 and sum of digits of i is divisible by 3 ; Return the required count ; Driver code"
Javascript;"function findMinSum ( arr , n ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += arr [ i ] * ( n - i ) ; return sum ; } var arr = [ 3 , 5 , 7 , 8 ] ; var n = arr . length ; document . write ( findMinSum ( arr , n ) ) ;";"Sum of minimum element of all subarrays of a sorted array | Function to find the sum of minimum of all subarrays ; Driver code"
Javascript;"function maxLenSubArr ( a , n ) { let count , j ; let cm = 1 , max = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > max ) max = a [ i ] ; } for ( let i = 0 ; i < n - 1 ; ) { count = 1 ; if ( a [ i ] == a [ i + 1 ] && a [ i ] == max ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] == max ) { count ++ ; i ++ ; } else break ; } if ( count > cm ) cm = count ; } else i ++ ; } return cm ; } let arr = [ 6 , 1 , 6 , 6 , 0 ] ; let n = arr . length ; document . write ( maxLenSubArr ( arr , n ) ) ;";"Longest Sub | Function to return the max length of the sub - array that have the maximum average ( average value of the elements ) ; Finding the maximum value ; If consecutive maximum found ; Find the max length of consecutive max ; Driver code"
Javascript;"function minSum ( arr , n , x ) { var sum = 0 ; var largestDivisible = - 1 , minimum = arr [ 0 ] ; for ( i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % x == 0 && largestDivisible < arr [ i ] ) largestDivisible = arr [ i ] ; if ( arr [ i ] < minimum ) minimum = arr [ i ] ; } if ( largestDivisible == - 1 ) return sum ; var sumAfterOperation = sum - minimum - largestDivisible + ( x * minimum ) + ( largestDivisible / x ) ; return Math . min ( sum , sumAfterOperation ) ; } var arr = [ 5 , 5 , 5 , 5 , 6 ] ; var n = arr . length ; var x = 3 ; document . write ( minSum ( arr , n , x ) ) ;";"Minimum possible sum of array elements after performing the given operation | Function to return the minimized sum ; To store the largest element from the array which is divisible by x ; Sum of array elements before performing any operation ; If current element is divisible by x and it is maximum so far ; Update the minimum element ; If no element can be reduced then there 's no povar in performing the  operation as we will end up increasing  the sum when an element is multiplied by x ; Subtract the chosen elements from the sum and then add their updated values ; Return the minimized sum ; Driver code"
Javascript;"function maxAND ( L , R ) { if ( L == R ) return L ; else if ( ( R - L ) == 1 ) return ( R & L ) ; else { if ( ( ( R - 1 ) & R ) > ( ( R - 2 ) & ( R - 1 ) ) ) return ( ( R - 1 ) & R ) ; else return ( ( R - 2 ) & ( R - 1 ) ) ; } } let L = 1 , R = 632 ; document . write ( maxAND ( L , R ) ) ;";"Maximum Bitwise AND pair from given range | Function to return the maximum bitwise AND possible among all the possible pairs ; If there is only a single value in the range [ L , R ] ; If there are only two values in the range [ L , R ] ; Driver code"
Javascript;"function checkSpecialPrime ( sieve , num ) { while ( num > 0 ) { if ( sieve [ num ] ) { return false ; } num = parseInt ( num / 10 ) ; } return true ; } function findSpecialPrime ( N ) { var sieve = Array . from ( { length : N * 10 + 1 } , ( _ , i ) => false ) ; sieve [ 0 ] = true ; sieve [ 1 ] = true ; var i = 0 , j = 0 ; for ( i = 2 ; i <= N * 10 ; i ++ ) { if ( ! sieve [ i ] ) { for ( j = i * i ; j <= N * 10 ; j += i ) { sieve [ j ] = true ; } } } while ( true ) { if ( checkSpecialPrime ( sieve , N ) ) { document . write ( N + "" "" ) ; break ; } else N ++ ; } } var N = 379 ; findSpecialPrime ( N ) ; N = 100 ; findSpecialPrime ( N ) ;";"Smallest Special Prime which is greater than or equal to a given number | Function to check whether the number is a special prime or not ; While number is not equal to zero ; If the number is not prime return false . ; Else remove the last digit by dividing the number by 10. ; If the number has become zero then the number is special prime , hence return true ; Function to find the Smallest Special Prime which is greater than or equal to a given number ; Initially all numbers are considered Primes . ; There is always an answer possible ; Checking if the number is a special prime or not ; If yes prvar the number and break the loop . ; Else increment the number . ; Driver code"
Javascript;"function minMoves ( n ) { let s = n . toString ( ) ; let ans = Number . MAX_VALUE ; let len = s . length ; for ( let i = 0 ; i < len ; ++ i ) { for ( let j = 0 ; j < len ; ++ j ) { if ( i == j ) continue ; let t = s . split ( ' ' ) ; let cur = 0 ; for ( let k = i ; k < len - 1 ; ++ k ) { swap ( t , k , k + 1 ) ; ++ cur ; } for ( let k = j - ( ( j > i ) ? 1 : 0 ) ; k < len - 2 ; ++ k ) { swap ( t , k , k + 1 ) ; ++ cur ; } let pos = - 1 ; for ( let k = 0 ; k < len ; ++ k ) { if ( t [ k ] != ' ' ) { pos = k ; break ; } } for ( let k = pos ; k > 0 ; -- k ) { swap ( t , k , k - 1 ) ; ++ cur ; } let nn = parseInt ( t . join ( "" "" ) ) ; if ( nn % 25 == 0 ) ans = Math . min ( ans , cur ) ; } } if ( ans == Number . MAX_VALUE ) return - 1 ; return ans ; } function swap ( t , i , j ) { let temp = t [ i ] ; t [ i ] = t [ j ] ; t [ j ] = temp ; } let n = 509201 ; document . write ( minMoves ( n ) ) ;";"Minimum number of given moves required to make N divisible by 25 | Function to return the minimum number of moves required to make n divisible by 25 ; Convert number into string ; To store required answer ; Length of the string ; To check all possible pairs ; Make a duplicate string ; Number of swaps required to place ith digit in last position ; Number of swaps required to place jth digit in 2 nd last position ; Find first non zero digit ; Place first non zero digit in the first position ; Convert string to number ; If this number is divisible by 25 then cur is one of the possible answer ; If not possible ; Driver code"
Javascript;"function getMaxNum ( a , b , c ) { if ( b % c == 0 ) return b ; var x = ( parseInt ( b / c ) * c ) ; if ( x >= a && x <= b ) return x ; else return - 1 ; } var a = 2 , b = 10 , c = 3 ; document . write ( getMaxNum ( a , b , c ) ) ;";"Maximum positive integer divisible by C and is in the range [ A , B ] | Function to return the required number ; If b % c = 0 then b is the required number ; Else get the maximum multiple of c smaller than b ; Driver code"
Javascript;"function getPairs ( a ) { let n = a . length ; let count = parseInt ( ( n * ( n - 1 ) ) / 2 , 10 ) ; return count ; } let a = [ 2 , 4 , 3 , 1 ] ; document . write ( getPairs ( a ) ) ;";"Count of pairs ( x , y ) in an array such that x < y | Function to return the number of pairs ( x , y ) such that x < y ; Length of the array ; Calculate the number of valid pairs ; Return the count of valid pairs ; Driver code"
Javascript;"function countSquares ( row , column ) { var topLeft = Math . min ( row , column ) - 1 ; var bottomRight = 8 - Math . max ( row , column ) ; var topRight = Math . min ( row , 9 - column ) - 1 ; var bottomLeft = 8 - Math . max ( row , 9 - column ) ; return ( topLeft + topRight + bottomRight + bottomLeft ) ; } var row = 4 , column = 4 ; document . write ( countSquares ( row , column ) ) ;";"Count the total number of squares that can be visited by Bishop in one move | Function to return the count of total positions the Bishop can visit in a single move ; Count top left squares ; Count bottom right squares ; Count top right squares ; Count bottom left squares ; Return total count ; Bishop 's Position"
Javascript;"function canTakeDown ( bishopX , bishopY , pawnX , pawnY ) { if ( pawnX - bishopX == pawnY - bishopY ) return true ; else if ( - pawnX + bishopX == pawnY - bishopY ) return true ; else return false ; } var bishopX = 5 , bishopY = 5 ; var pawnX = 1 , pawnY = 1 ; if ( canTakeDown ( bishopX , bishopY , pawnX , pawnY ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check whether Bishop can take down Pawn or not | Function that return true if the Bishop can take down the pawn ; If pawn is at angle 45 or 225 degree from bishop 's Position ; If pawn is at angle 135 or 315 degree from bishop 's Position ; Bishop 's Position ; Pawn 's Position"
Javascript;"let N = 1000005 ; let primeFactors = new Array ( N ) ; primeFactors . fill ( 0 ) ; function findPrimeFactors ( ) { for ( let i = 2 ; i < N ; i ++ ) if ( primeFactors [ i ] == 0 ) for ( let j = i ; j < N ; j += i ) primeFactors [ j ] = primeFactors [ parseInt ( j / i , 10 ) ] + 1 ; for ( let i = 1 ; i < N ; i ++ ) primeFactors [ i ] += primeFactors [ i - 1 ] ; } findPrimeFactors ( ) ; let a = 6 , b = 3 ; document . write ( primeFactors [ a ] - primeFactors [ b ] ) ;";"Find maximum operations to reduce N to 1 | Javascript program to find maximum number moves possible ; To store number of prime factors of each number ; Function to find number of prime factors of each number ; if i is a prime number ; increase value by one from it 's preveious multiple ; make prefix sum this will be helpful for multiple test cases ; Generate primeFactors array ; required answer"
Javascript;"function digitSum ( n ) { var ans = 0 ; while ( n ) { ans += n % 10 ; n = parseInt ( n / 10 ) ; } return ans ; } function findInt ( n , m ) { var minDigit = Math . floor ( m / 9 ) ; var start = Math . pow ( 10 , minDigit ) - Math . pow ( 10 , minDigit ) % n ; while ( start < 1000000000 ) { if ( digitSum ( start ) == m ) return start ; else start += n ; } return - 1 ; } var n = 13 , m = 32 ; document . write ( findInt ( n , m ) ) ;";"Smallest integer with digit sum M and multiple of N | Function to return digit sum ; Function to find out the smallest integer ; Start of the iterator ( Smallest multiple of n ) ; Driver code"
Javascript;"function smallestDivisor ( n ) { var mx = Math . sqrt ( n ) ; for ( i = 2 ; i <= mx ; i ++ ) if ( n % i == 0 ) return i ; return n ; } function maxSum ( n ) { var res = n ; while ( n > 1 ) { var divi = smallestDivisor ( n ) ; n /= divi ; res += n ; } return res ; } var n = 34 ; document . write ( maxSum ( n ) ) ;";"Maximum sum after repeatedly dividing N by a divisor | Function to find the smallest divisor ; Function to find the maximum sum ; Driver Code"
Javascript;"function isPossible ( n , k , arr ) { let sum = arr [ 0 ] ; let maxVal = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { sum += arr [ i ] ; maxVal = Math . max ( maxVal , arr [ i ] ) ; } if ( maxVal > ( sum + k ) / n ) return false ; return true ; } let k = 8 ; let arr = [ 1 , 2 , 3 , 4 ] ; let n = arr . length ; if ( isPossible ( n , k , arr ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Make all elements of an array equal with the given operation | Function that returns true if all the elements of the array can be made equal with the given operation ; To store the sum of the array elements and the maximum element from the array ; driver program"
Javascript;"function maxResult ( n , a , b , c ) { let maxVal = 0 ; for ( let i = 0 ; i <= n ; i += a ) for ( let j = 0 ; j <= n - i ; j += b ) { let z = ( n - ( i + j ) ) / c ; if ( Math . floor ( z ) == Math . ceil ( z ) ) { let x = i / a ; let y = j / b ; maxVal = Math . max ( maxVal , x + y + z ) ; } } return maxVal ; } let n = 10 , a = 5 , b = 3 , c = 4 ; document . write ( maxResult ( n , a , b , c ) ) ;";"Maximize the value of x + y + z such that ax + by + cz = n | Function to return the maximum value of ( x + y + z ) such that ( ax + by + cz = n ) ; i represents possible values of a * x ; j represents possible values of b * y ; If z is an integer ; driver program ; Function Call"
Javascript;"function EqualNumbers ( a , n ) { for ( let i = 0 ; i < n ; i ++ ) { while ( a [ i ] % 2 == 0 ) { a [ i ] = parseInt ( a [ i ] / 2 , 10 ) ; } while ( a [ i ] % 3 == 0 ) { a [ i ] = parseInt ( a [ i ] / 3 , 10 ) ; } if ( a [ i ] != a [ 0 ] ) { return false ; } } return true ; } let a = [ 50 , 75 , 150 ] ; let n = a . length ; if ( EqualNumbers ( a , n ) ) { document . write ( "" "" ) ; } else { document . write ( "" "" ) ; }";"Make all numbers of an array equal | Function that returns true if all the array elements can be made equal with the given operation ; Divide number by 2 ; Divide number by 3 ; Driver code"
Javascript;"function max_gcd ( n , p ) { let count = 0 ; let gcd = 1 ; while ( p % 2 == 0 ) { p >>= 1 ; count ++ ; } if ( count > 0 ) gcd *= Math . pow ( 2 , parseInt ( count / n , 10 ) ) ; for ( let i = 3 ; i <= parseInt ( Math . sqrt ( p ) , 10 ) ; i += 2 ) { count = 0 ; while ( p % i == 0 ) { count ++ ; p = parseInt ( p / i , 10 ) ; } if ( count > 0 ) { gcd *= Math . pow ( i , parseInt ( count / n , 10 ) ) ; } } if ( p > 2 ) gcd *= Math . pow ( p , parseInt ( 1 / n , 10 ) ) ; return gcd ; } let n = 3 ; let p = 80 ; document . write ( max_gcd ( n , p ) ) ;";"Maximum GCD from Given Product of Unknowns | Function to return the required gcd ; Count the number of times 2 divides p ; Equivalent to p = p / 2 ; ; If 2 divides p ; Check all the possible numbers that can divide p ; If n in the end is a prime number ; Return the required gcd ; Driver code"
Javascript;"function getMinNum ( a , b , c ) { if ( c < a c > b ) return c ; let x = ( parseInt ( b / c ) * c ) + c ; return x ; } let a = 2 , b = 4 , c = 4 ; document . write ( getMinNum ( a , b , c ) ) ;";"Minimum positive integer divisible by C and is not in range [ A , B ] | Function to return the required number ; If doesn 't belong to the range  then c is the required number ; Else get the next multiple of c starting from b + 1 ; Driver code"
Javascript;"function countPairs ( n ) { if ( n == 2 ) return 4 ; let num = ( parseInt ( n / 2 , 10 ) + 1 ) ; let max = n % num ; let count = n - max ; return count ; } let n = 5 ; document . write ( countPairs ( n ) ) ;";"Count of pairs of ( i , j ) such that ( ( n % i ) % j ) % n is maximized | Function to return the count of required pairs ; Special case ; Number which will give the max value for ( ( n % i ) % j ) % n ; To store the maximum possible value of ( ( n % i ) % j ) % n ; Count of possible pairs ; Driver code"
Javascript;"function checkSub ( sub , s ) { let j = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) if ( sub [ j ] == s [ i ] ) j ++ ; return j == sub . length ; } function getMultiple ( s ) { for ( let i = 0 ; i < 1e3 ; i += 8 ) { if ( checkSub ( i . toString ( ) , s ) ) return i ; } return - 1 ; } let s = "" "" ; document . write ( getMultiple ( s ) ) ;";"Remove characters from a numeric string such that string becomes divisible by 8 | Function that return true if sub is a sub - sequence in s ; Function to return a multiple of 8 formed after removing 0 or more characters from the given string ; Iterate over all multiples of 8 ; If current multiple exists as a subsequence in the given string ; Driver Code"
Javascript;"function getResult ( n ) { let st = n . toString ( ) ; for ( let i = 0 ; i < st . length ; i ++ ) { let d = st [ i ] . charCodeAt ( 0 ) - 48 ; if ( n % d == 0 ) { return "" "" ; } } return "" "" ; } let n = 9876543 ; document . write ( getResult ( n ) ) ;";"Program to check if a number is divisible by any of its digits | JavaScript implementation of above approach ; Converting integer to string ; Traversing the string ; find the actual digit ; If the number is divisible by digits then return yes ; If no digits are dividing the number then return no ; Driver Code ; passing this number to get result function"
Javascript;"function sum ( n ) { if ( n < 2 ) { return 1 } else { return 1 / n + ( sum ( n - 1 ) ) } } document . write ( sum ( 8 ) ) ; document . write ( "" "" ) ; document . write ( sum ( 10 ) ) ;";"Program to find sum of harmonic series | Javascript program to find sum of harmonic series using recursion ; Base condition ; Driver code"
Javascript;"function findingValues ( m , n , mth , nth ) { let d = parseInt ( ( Math . abs ( mth - nth ) ) / Math . abs ( ( m - 1 ) - ( n - 1 ) ) , 10 ) ; let a = mth - ( ( m - 1 ) * d ) ; let res = [ ] ; res . push ( a ) ; res . push ( d ) ; return res ; } function findSum ( m , n , mth , nth , p ) { let ad = findingValues ( m , n , mth , nth ) ; let a = ad [ 0 ] ; let d = ad [ 1 ] ; let sum = parseInt ( ( p * ( 2 * a + ( p - 1 ) * d ) ) / 2 , 10 ) ; return sum ; } let m = 6 , n = 10 , mTerm = 12 , nTerm = 20 , p = 5 ; document . write ( findSum ( m , n , mTerm , nTerm , p ) ) ;";"Sum of P terms of an AP if Mth and Nth terms are given | Function to calculate the value of the ; Calculate value of d using formula ; Calculate value of a using formula ; Return pair ; Function to calculate value sum of first p numbers of the series ; First calculate value of a and d ; Calculate the sum by using formula ; Return the sum ; Driver Code"
Javascript;"function powerfulIntegers ( x , y , bound ) { var s = new Set ( ) ; var powersOfY = [ ] ; var i ; powersOfY . push ( 1 ) ; for ( i = y ; i < bound && y != 1 ; i = i * y ) powersOfY . push ( i ) ; i = 0 ; while ( true ) { var xPowI = Math . pow ( x , i ) ; powersOfY . forEach ( j => { var num = xPowI + j ; if ( num <= bound ) s . add ( num ) ; } ) ; if ( xPowI >= bound x == 1 ) break ; i ++ ; } [ ... s ] . sort ( ( a , b ) => a - b ) . forEach ( itr => { document . write ( itr + "" "" ) } ) ; } var x = 2 , y = 3 , bound = 10 ; powerfulIntegers ( x , y , bound ) ;";"Print all integers that are sum of powers of two given numbers | Function to print powerful integers ; Set is used to store distinct numbers in sorted order ; Store all the powers of y < bound in a vector to avoid calculating them again and again ; x ^ i ; If num is within limits insert it into the set ; Adding any number to it will be out of bounds ; Increment i ; Print the contents of the set ; Driver code ; Print powerful integers"
Javascript;"function candies ( n , k ) { var count = 0 ; var ind = 1 ; var arr = Array ( k ) ; for ( i = 0 ; i < k ; i ++ ) arr [ i ] = 0 ; while ( n > 0 ) { var f1 = ( ind - 1 ) * k ; var f2 = ind * k ; var sum1 = ( f1 * ( f1 + 1 ) ) / 2 ; var sum2 = ( f2 * ( f2 + 1 ) ) / 2 ; var res = sum2 - sum1 ; if ( res <= n ) { count ++ ; n -= res ; ind ++ ; { var i = 0 ; var term = ( ( ind - 1 ) * k ) + 1 ; while ( n > 0 ) { if ( term <= n ) { arr [ i ++ ] = term ; n -= term ; term ++ ; } else { arr [ i ++ ] = n ; n = 0 ; } } } } for ( i = 0 ; i < k ; i ++ ) arr [ i ] += ( count * ( i + 1 ) ) + ( k * ( count * ( count - 1 ) ) / 2 ) ; for ( i = 0 ; i < k ; i ++ ) document . write ( arr [ i ] + "" "" ) ; } var n = 10 , k = 3 ; candies ( n , k ) ;";"Distribute N candies among K people | Function to find out the number of candies every person received ; Count number of complete turns ; Get the last term ; Stores the number of candies ; Last term of last and current series ; Sum of current and last series ; Sum of current series only ; If sum of current is less than N ; } else Individually distribute ; First term ; Distribute candies till there ; Candies available ; Not available ; Count the total candies ; Print the total candies ; Driver Code"
Javascript;"function candies ( n , k ) { var count = 0 ; var ind = 1 ; var arr = Array ( k ) . fill ( 0 ) ; for ( i = 0 ; i < k ; i ++ ) arr [ i ] = 0 ; var low = 0 , high = n ; while ( low <= high ) { var mid = parseInt ( ( low + high ) / 2 ) ; var sum = parseInt ( ( mid * ( mid + 1 ) ) / 2 ) ; if ( sum <= n ) { count = parseInt ( mid / k ) ; low = mid + 1 ; } else { high = mid - 1 ; } } var last = ( count * k ) ; n -= ( last * ( last + 1 ) ) / 2 ; var j = 0 ; var term = ( count * k ) + 1 ; while ( n > 0 ) { if ( term <= n ) { arr [ j ++ ] = term ; n -= term ; term ++ ; } else { arr [ j ] += n ; n = 0 ; } } for ( i = 0 ; i < k ; i ++ ) arr [ i ] += ( count * ( i + 1 ) ) + ( k * ( count * ( count - 1 ) ) / 2 ) ; for ( i = 0 ; i < k ; i ++ ) document . write ( arr [ i ] + "" "" ) ; } var n = 7 , k = 4 ; candies ( n , k ) ;";"Distribute N candies among K people | Function to find out the number of candies every person received ; Count number of complete turns ; Get the last term ; Stores the number of candies ; Do a binary search to find the number whose sum is less than N . ; Get mide ; If sum is below N ; Find number of complete turns ; Right halve ; Left halve ; Last term of last complete series ; Subtract the sum till ; First term of incomplete series ; Count the total candies ; Prvar the total candies ; Driver Code"
Javascript;"function printSmallest ( a ) { a . sort ( function ( a , b ) { return a - b } ) ; let i , j , num ; for ( i = 0 ; i < 3 ; i ++ ) { if ( a [ i ] % 3 == 0 ) { return a [ i ] ; } } for ( i = 0 ; i < 3 ; i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) { num = ( a [ i ] * 10 ) + a [ j ] ; if ( num % 3 == 0 ) { return num ; } } } return a [ 0 ] * 100 + a [ 0 ] * 10 + a [ 0 ] ; } let arr = [ 7 , 7 , 1 ] ; document . write ( printSmallest ( arr ) ) ;";"Smallest multiple of 3 which consists of three given non | Function to return the minimum number divisible by 3 formed by the given digits ; Sort the given array in ascending ; Check if any single digit is divisible by 3 ; Check if any two digit number formed by the given digits is divisible by 3 starting from the minimum ; Generate the two digit number ; If none of the above is true , we can form three digit number by taking a [ 0 ] three times . ; Driver code"
Javascript;"function updateMatrix ( n , q , mat ) { let i , j ; for ( i = 0 ; i < q . length ; i ++ ) { let X1 = q [ i ] [ 0 ] ; let Y1 = q [ i ] [ 1 ] ; let X2 = q [ i ] [ 2 ] ; let Y2 = q [ i ] [ 3 ] ; mat [ X1 ] [ Y1 ] ++ ; if ( Y2 + 1 < n ) mat [ X2 ] [ Y2 + 1 ] -- ; else if ( X2 + 1 < n ) mat [ X2 + 1 ] [ 0 ] -- ; } let sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { sum += mat [ i ] [ j ] ; document . write ( sum + "" "" ) ; } document . write ( "" "" ) ; } } let n = 5 ; let mat = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { mat [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { mat [ i ] [ j ] = 0 ; } } let q = [ [ 0 , 0 , 1 , 2 ] , [ 1 , 2 , 3 , 4 ] , [ 1 , 4 , 3 , 4 ] ] ; updateMatrix ( n , q , mat ) ;";"Print matrix after applying increment operations in M ranges | Function to update and print the matrix after performing queries ; Add 1 to the first element of the sub - matrix ; If there is an element after the last element of the sub - matrix then decrement it by 1 ; Calculate the running sum ; Print the updated element ; Next line ; Size of the matrix ; Queries"
Javascript;"function printArr ( arr , n ) { for ( let i = 0 ; i < n - 1 ; i ++ ) document . write ( arr [ i ] + "" "" ) ; document . write ( arr [ n - 1 ] . toFixed ( 6 ) ) ; } function replaceMax ( arr , n ) { let max = arr [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) max = arr [ i ] ; } let min = arr [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < min ) min = arr [ i ] ; } let range = max - min ; let coeffOfRange = range / ( max + min ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == max ) { arr [ i ] = coeffOfRange ; break ; } } printArr ( arr , n ) ; } let arr = [ 15 , 16 , 10 , 9 , 6 , 7 , 17 ] ; let n = arr . length ; replaceMax ( arr , n ) ;";"Replace the maximum element in the array by coefficient of range | Utility function to print the contents of the array ; Function to replace the maximum element from the array with the coefficient of range of the array ; Maximum element from the array ; Minimum element from the arra ; Calculate the coefficient of range for the array ; Assuming all the array elements are distinc Replace the maximum element with the coefficient of range of the array ; Print the updated array ; Driver code"
Javascript;"function divide ( a , b ) { for ( let i = 2 ; i <= Math . min ( a , b ) ; i ++ ) { while ( a % i == 0 && b % i == 0 ) { a = a / i ; b = b / i ; } } document . write ( "" "" + a + "" "" + b + "" "" ) ; } let A = 10 , B = 15 ; divide ( A , B ) ;";"Divide the two given numbers by their common divisors | print the numbers after dividing them by their common factors ; iterate from 1 to minimum of a and b ; if i is the common factor of both the numbers ; Driver code ; divide A and B by their common factors"
Javascript;"function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function commDiv ( a , b ) { let n = gcd ( a , b ) ; a = parseInt ( a / n , 10 ) ; b = parseInt ( b / n , 10 ) ; document . write ( "" "" + a + "" "" + b ) ; } let a = 10 , b = 15 ; commDiv ( a , b ) ;";"Divide the two given numbers by their common divisors | Function to calculate gcd of two numbers ; Function to calculate all common divisors of two given numbers a , b -- > input integer numbers ; find gcd of a , b ; Driver code"
Javascript;"function minAbsDiff ( n ) { let left = 1 << ( Math . floor ( Math . log ( n ) / Math . log ( 2 ) ) ) ; let right = left * 2 ; return Math . min ( ( n - left ) , ( right - n ) ) ; } let n = 15 ; document . write ( minAbsDiff ( n ) ) ;";"Minimum absolute difference between N and a power of 2 | Function to return the minimum difference between N and a power of 2 ; Power of 2 closest to n on its left ; Power of 2 closest to n on its right ; Return the minimum abs difference ; Driver code"
Javascript;"function find_probability ( p , q , r , s ) { var t = ( 1 - p / q ) * ( 1 - r / s ) ; var ans = ( p / q ) / ( 1 - t ) ; return ans ; } var p = 1 , q = 2 , r = 1 , s = 2 ; document . write ( find_probability ( p , q , r , s ) . toFixed ( 9 ) ) ;";"Find probability that a player wins when probabilities of hitting the target are given | Function to return the probability of the winner ; Driver Code ; Will print 9 digits after the decimal point"
Javascript;"function FindAllElements ( n , k ) { let sum = k ; let A = new Array ( k ) . fill ( 1 ) ; for ( let i = k - 1 ; i >= 0 ; -- i ) { while ( sum + A [ i ] <= n ) { sum += A [ i ] ; A [ i ] *= 2 ; } } if ( sum != n ) { document . write ( "" "" ) ; } else { for ( let i = 0 ; i < k ; ++ i ) document . write ( A [ i ] + "" "" ) ; } } let n = 12 ; let k = 6 ; FindAllElements ( n , k ) ;";"Represent n as the sum of exactly k powers of two | Set 2 | Function to print k numbers which are powers of two and whose sum is equal to n ; Initialising the sum with k ; Initialising an array A with k elements and filling all elements with 1 ; Iterating A [ ] from k - 1 to 0 ; Update sum and A [ i ] till sum + A [ i ] is less than equal to n ; Impossible to find the combination ; Possible solution is stored in A [ ] ; Driver Code"
Javascript;"function removeZero ( n ) { let res = 0 ; let d = 1 ; while ( n > 0 ) { if ( n % 10 != 0 ) { res += ( n % 10 ) * d ; d *= 10 ; } n = Math . floor ( n / 10 ) ; } return res ; } function isEqual ( a , b ) { if ( removeZero ( a ) + removeZero ( b ) == removeZero ( a + b ) ) return true ; return false ; } let a = 105 , b = 106 ; if ( isEqual ( a , b ) == true ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check whether a + b = c or not after removing all zeroes from a , b and c | Function to remove zeroes ; Initialize result to zero holds the Result after removing zeroes from no ; Initialize variable d to 1 that holds digits of no ; Loop while n is greater then zero ; Check if n mod 10 is not equal to zero ; store the result by removing zeroes And increment d by 10 ; Go to the next digit ; Return the result ; Function to check if sum is true after Removing all zeroes . ; Call removeZero ( ) for both sides and check whether they are equal After removing zeroes . ; Driver Code"
Javascript;"function sumArray ( arr , n ) { let leftSum = new Array ( n ) ; let rightSum = new Array ( n ) ; let Sum = new Array ( n ) ; let i = 0 , j = 0 ; leftSum [ 0 ] = 0 ; rightSum [ n - 1 ] = 0 ; for ( i = 1 ; i < n ; i ++ ) leftSum [ i ] = arr [ i - 1 ] + leftSum [ i - 1 ] ; for ( j = n - 2 ; j >= 0 ; j -- ) rightSum [ j ] = arr [ j + 1 ] + rightSum [ j + 1 ] ; for ( i = 0 ; i < n ; i ++ ) Sum [ i ] = leftSum [ i ] + rightSum [ i ] ; for ( i = 0 ; i < n ; i ++ ) document . write ( Sum [ i ] + "" "" ) ; } let arr = [ 3 , 6 , 4 , 8 , 9 ] ; let n = arr . length ; sumArray ( arr , n ) ;";"A Sum Array Puzzle | JavaScript implementation of above approach ; Allocate memory for temporary arrays leftSum [ ] , rightSum [ ] and Sum [ ] ; Left most element of left array is always 0 ; Right most element of right array is always 0 ; Construct the left array ; Construct the right array ; Construct the sum array using left [ ] and right [ ] ; print the sum array ; Driver Code"
Javascript;"function minimumX ( n , k ) { let mini = Number . MAX_VALUE ; for ( let i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { let fir = i ; let sec = parseInt ( n / i , 10 ) ; let num1 = fir * k + sec ; let res = parseInt ( ( num1 / k ) , 10 ) * ( num1 % k ) ; if ( res == n ) mini = Math . min ( num1 , mini ) ; let num2 = sec * k + fir ; res = parseInt ( ( num2 / k ) , 10 ) * ( num2 % k ) ; if ( res == n ) mini = Math . min ( num2 , mini ) ; } } return mini ; } let n = 4 , k = 6 ; document . write ( minimumX ( n , k ) + "" "" ) ; n = 5 , k = 5 ; document . write ( minimumX ( n , k ) ) ;";"Find minimum x such that ( x % k ) * ( x / k ) == n | Set | This function gives the required answer ; Iterate for all the factors ; Check if i is a factor ; Consider i to be A and n / i to be B ; Consider i to be B and n / i to be A ; Driver Code"
Javascript;"function minimumX ( n , k ) { let ans = Number . MAX_VALUE ; for ( let rem = k - 1 ; rem > 0 ; rem -- ) { if ( n % rem == 0 ) ans = Math . min ( ans , rem + ( n / rem ) * k ) ; } return ans ; } let n = 4 , k = 6 ; document . write ( minimumX ( n , k ) + "" "" ) ; n = 5 , k = 5 ; document . write ( minimumX ( n , k ) ) ;";"Find minimum x such that ( x % k ) * ( x / k ) == n | This function gives the required answer ; Iterate over all possible remainders ; it must divide n ; Driver code to test above function"
Javascript;"function getHermiteNumber ( n ) { if ( n == 0 ) return 1 ; else if ( n == 1 ) return 1 ; else return - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; } let n = 6 ; document . write ( getHermiteNumber ( n ) ) ;";"Find nth Hermite number | Function to return nth Hermite number ; Base condition ; Driver Code ; Print nth Hermite number"
Javascript;"function find ( n ) { let b = n ; let a = b * ( n - 1 ) ; if ( a * b > n && a / b < n ) { document . write ( "" "" + a + "" "" + b ) ; } else document . write ( - 1 ) ; } let n = 10 ; find ( n ) ;";"Find numbers a and b that satisfy the given conditions | Function to print the required numbers ; Suppose b = n and we want a % b = 0 and also ( a / b ) < n so a = b * ( n - 1 ) ; Special case if n = 1 we get a = 0 so ( a * b ) < n ; If no pair satisfies the conditions ; Driver code"
Javascript;"function isPerfect ( N ) { if ( ( Math . sqrt ( N ) - Math . floor ( Math . sqrt ( N ) ) ) != 0 ) return false ; return true ; } function getClosestPerfectSquare ( N ) { if ( isPerfect ( N ) ) { document . write ( N + "" "" + "" "" + "" "" ) ; return ; } let aboveN = - 1 , belowN = - 1 ; let n1 ; n1 = N + 1 ; while ( true ) { if ( isPerfect ( n1 ) ) { aboveN = n1 ; break ; } else n1 ++ ; } n1 = N - 1 ; while ( true ) { if ( isPerfect ( n1 ) ) { belowN = n1 ; break ; } else n1 -- ; } let diff1 = aboveN - N ; let diff2 = N - belowN ; if ( diff1 > diff2 ) document . write ( belowN + "" "" + diff2 ) ; else document . write ( aboveN + "" "" + diff1 ) ; } let N = 1500 ; getClosestPerfectSquare ( N ) ;";"Closest perfect square and its distance | Function to check if a number is perfect square or not ; Function to find the closest perfect square taking minimum steps to reach from a number ; Variables to store first perfect square number above and below N ; Finding first perfect square number greater than N ; Finding first perfect square number less than N ; Variables to store the differences ; Driver code"
Javascript;"function gcd ( a , b ) { if ( a === 0 ) return b ; return gcd ( b % a , a ) ; } function lowest ( den3 , num3 ) { var common_factor = gcd ( num3 , den3 ) ; den3 = parseInt ( den3 / common_factor ) ; num3 = parseInt ( num3 / common_factor ) ; return [ den3 , num3 ] ; } function addFraction ( num1 , den1 , num2 , den2 , num3 , den3 ) { den3 = gcd ( den1 , den2 ) ; den3 = ( den1 * den2 ) / den3 ; num3 = num1 * ( den3 / den1 ) + num2 * ( den3 / den2 ) ; return lowest ( den3 , num3 ) ; } var num1 = 1 , den1 = 500 , num2 = 2 , den2 = 1500 , den3 , num3 ; var [ den3 , num3 ] = addFraction ( num1 , den1 , num2 , den2 , num3 , den3 ) ; document . write ( num1 + "" "" + den1 + "" "" + num2 + "" "" + den2 + "" "" + num3 + "" "" + den3 + "" "" ) ;";"Fraction | Function to return gcd of a and b ; Function to convert the obtained fraction into it 's simplest form ; Finding gcd of both terms ; Converting both terms into simpler terms by dividing them by common factor ; Function to add two fractions ; Finding gcd of den1 and den2 ; Denominator of final fraction obtained finding LCM of den1 and den2 LCM * GCD = a * b ; Changing the fractions to have same denominator Numerator of the final fraction obtained ; Calling function to convert final fraction into it 's  simplest form ; Driver Code"
Javascript;"function findLargestDivisor ( n ) { for ( let i = 2 ; i < Math . sqrt ( n ) + 1 ; i ++ ) { while ( n % ( i * i ) == 0 ) { n = n / i ; } } return n ; } let n = 12 ; document . write ( findLargestDivisor ( n ) + "" "" ) ; n = 97 ; document . write ( findLargestDivisor ( n ) + "" "" ) ;";"Largest Divisor of a Number not divisible by a perfect square | Function to find the largest divisor not divisible by any perfect square greater than 1 ; If the number is divisible by i * i , then remove one i ; Now all squares are removed from n ; Driver Code"
Javascript;"function compare ( a , b ) { if ( a < b ) { return - 1 ; } else if ( a > b ) { return 1 ; } else { return 0 ; } } function checkIsAP ( arr , n ) { if ( n == 1 ) return true ; arr . sort ( compare ) ; let d = arr [ 1 ] - arr [ 0 ] ; for ( let i = 2 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] != d ) return false ; return true ; } let arr = [ 20 , 15 , 5 , 0 , 10 ] ; let n = arr . length ; ( checkIsAP ( arr , n ) ) ? document . write ( "" "" ) : document . write ( "" "" ) ;";"Arithmetic Progression | Returns true if a permutation of arr [ 0. . n - 1 ] can form arithmetic progression ; Sort array ; After sorting , difference between consecutive elements must be same . ; Driven Program"
Javascript;"function isTriPerfect ( n ) { let sum = 1 + n ; let i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) { if ( parseInt ( n / i , 10 ) == i ) sum = sum + i ; else sum = sum + i + parseInt ( n / i , 10 ) ; } i += 1 ; } if ( sum == 3 * n & n != 1 ) return true ; else return false ; } let n = 120 ; if ( isTriPerfect ( n ) ) document . write ( n + "" "" ) ;";"Check if a number is Triperfect Number | Returns true if n is Triperfect ; To store sum of divisors . Adding 1 and n since they are divisors of n . ; Find all divisors and add them ; If sum of divisors is equal to 3 * n , then n is a Triperfect number ; Driver Code"
Javascript;"function sum ( N , X , Y ) { var S1 , S2 , S3 ; S1 = ( parseInt ( N / X ) ) * ( 2 * X + parseInt ( N / X - 1 ) * X ) / 2 ; S2 = ( parseInt ( N / Y ) ) * ( 2 * Y + parseInt ( N / Y - 1 ) * Y ) / 2 ; S3 = ( parseInt ( N / ( X * Y ) ) ) * ( 2 * ( X * Y ) + parseInt ( N / ( X * Y ) - 1 ) * ( X * Y ) ) / 2 ; return S1 + S2 - S3 ; } var N = 14 ; var X = 3 , Y = 5 ; document . write ( sum ( N , X , Y ) ) ;";"Sum of first N natural numbers which are divisible by X or Y | Function to calculate the sum of numbers divisible by X or Y ; Driver code"
Javascript;"function findTwoThreePrime ( l , r ) { if ( l == 1 ) l ++ ; let count = 0 ; for ( let i = l ; i <= r ; i ++ ) { let num = i ; while ( num % 2 == 0 ) num = parseInt ( num / 2 , 10 ) ; while ( num % 3 == 0 ) num = parseInt ( num / 3 , 10 ) ; if ( num == 1 ) count ++ ; } return count ; } let l = 1 , r = 10 ; document . write ( findTwoThreePrime ( l , r ) ) ;";"Count numbers from range whose prime factors are only 2 and 3 | Function to count the number within a range whose prime factors are only 2 and 3 ; Start with 2 so that 1 doesn 't get counted ; While num is divisible by 2 , divide it by 2 ; While num is divisible by 3 , divide it by 3 ; If num got reduced to 1 then it has only 2 and 3 as prime factors ; Driver code"
Javascript;"function getNumber ( s ) { let number_of_digits = s . length ; let freq = new Array ( 10 ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < number_of_digits ; i ++ ) { if ( s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' ) { freq [ s [ i ] . charCodeAt ( ) - 48 ] += 1 ; } if ( s [ i ] == ' ' ) { freq [ 2 ] += 2 ; freq [ 3 ] ++ ; } if ( s [ i ] == ' ' ) { freq [ 5 ] ++ ; freq [ 3 ] ++ ; } if ( s [ i ] == ' ' ) { freq [ 7 ] ++ ; freq [ 2 ] += 3 ; } if ( s [ i ] == ' ' ) { freq [ 7 ] ++ ; freq [ 3 ] += 2 ; freq [ 2 ] ++ ; } } let t = "" "" ; if ( freq [ 1 ] == number_of_digits || freq [ 0 ] == number_of_digits || ( freq [ 0 ] + freq [ 1 ] ) == number_of_digits ) { return s ; } else { for ( let i = 9 ; i >= 2 ; i -- ) { let ctr = freq [ i ] ; while ( ( ctr -- ) > 0 ) { t += String . fromCharCode ( i + 48 ) ; } } return t ; } } let s = "" "" ; document . write ( getNumber ( s ) ) ;";"Maximum number with same digit factorial product | Function to return the required number ; Count the frequency of each digit ; 4 ! can be expressed as 2 ! * 2 ! * 3 ! ; 6 ! can be expressed as 5 ! * 3 ! ; 8 ! can be expressed as 7 ! * 2 ! * 2 ! * 2 ! ; 9 ! can be expressed as 7 ! * 3 ! * 3 ! * 2 ! ; To store the required number ; If number has only either 1 and 0 as its digits ; Generate the greatest number possible ; Driver code"
Javascript;"function reversDigits ( num ) { let rev_num = 0 ; while ( num > 0 ) { rev_num = rev_num * 10 + num % 10 ; num = parseInt ( num / 10 , 10 ) ; } return rev_num ; } function icanobifNumbers ( N ) { let first = 0 , second = 1 ; if ( N == 1 ) document . write ( first ) ; else if ( N == 2 ) document . write ( first + "" "" + second ) ; else { document . write ( first + "" "" + second + "" "" ) ; for ( let i = 3 ; i <= N ; i ++ ) { let x = reversDigits ( first ) ; let y = reversDigits ( second ) ; document . write ( x + y + "" "" ) ; let temp = second ; second = x + y ; first = temp ; } } } let N = 12 ; icanobifNumbers ( N ) ;";"Program to find first N Iccanobif Numbers | Iterative function to reverse digits of num ; Function to print first N Icanobif Numbers ; Initialize first , second numbers ; Print first two numbers ; Reversing digit of previous two terms and adding them ; Driver Code"
Javascript;"function addNDigits ( a , b , n ) { let num = a ; for ( let i = 0 ; i <= 9 ; i ++ ) { let tmp = a * 10 + i ; if ( tmp % b == 0 ) { a = tmp ; break ; } } if ( num == a ) return - 1 ; for ( let j = 0 ; j < n - 1 ; j ++ ) a *= 10 ; return a ; } let a = 5 , b = 3 , n = 3 ; document . write ( addNDigits ( a , b , n ) ) ;";"Add N digits to A such that it is divisible by B after each addition | Javascript implementation of the approach ; Try all digits from ( 0 to 9 ) ; Fails in the first move itself ; Add ( n - 1 ) 0 's ; Driver Code"
Javascript;"function Triplets ( n ) { var ans = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { for ( let j = i ; j <= n ; ++ j ) { var x = i * i + j * j ; var y = parseInt ( Math . sqrt ( x ) ) ; if ( y * y == x && y <= n ) ++ ans ; } } return ans ; } var n = 10 ; document . write ( Triplets ( n ) ) ;";"Count number of triplets ( a , b , c ) such that a ^ 2 + b ^ 2 = c ^ 2 and 1 <= a <= b <= c <= n | function to ind number of Triplets 1 <= a <= b <= c <= n , Such that a ^ 2 + b ^ 2 = c ^ 2 ; to store required answer ; run nested loops for first two numbers . ; third number ; check if third number is perfect square and less than n ; Driver code ; function call"
Javascript;"function solve ( n , base ) { var sum = 0 ; while ( n > 0 ) { var remainder = n % base ; sum += remainder ; n = parseInt ( n / base ) ; } return sum ; } function SumsOfDigits ( n ) { var sum = 0 ; for ( base = 2 ; base <= n / 2 ; ++ base ) sum += solve ( n , base ) ; document . write ( sum ) ; } var n = 8 ; SumsOfDigits ( n ) ;";"Sum of the digits of a number N written in all bases from 2 to N / 2 | Function to calculate the sum of the digits of n in the given base ; Sum of digits ; Digit of n in the given base ; Add the digit ; Function to calculate the sum of digits of n in bases from 2 to n / 2 ; to store digit sum in all bases ; function call for multiple bases ; Driver program"
Javascript;"function checkPerfectcube ( n ) { let d = Math . cbrt ( n ) ; if ( d * d * d == n ) return true ; return false ; } function largestNonPerfectcubeNumber ( a , n ) { let maxi = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! checkPerfectcube ( a [ i ] ) ) maxi = Math . max ( a [ i ] , maxi ) ; } return maxi ; } let a = [ 16 , 64 , 25 , 2 , 3 , 10 ] ; let n = a . length ; document . write ( largestNonPerfectcubeNumber ( a , n ) ) ;";"Largest number in an array that is not a perfect cube | Function to check if a number is perfect cube number or not ; takes the sqrt of the number ; checks if it is a perfect cube number ; Function to find the largest non perfect cube number in the array ; stores the maximum of all perfect cube numbers ; Traverse all elements in the array ; store the maximum if current element is a non perfect cube ; Driver Code"
Javascript;"function checkIfPossibleRec ( x , a , b , isPossible , n ) { if ( x > n ) return ; if ( isPossible [ x ] ) return ; isPossible [ x ] = true ; checkIfPossibleRec ( x + a , a , b , isPossible , n ) ; checkIfPossibleRec ( x + b , a , b , isPossible , n ) ; } function checkPossible ( n , a , b ) { var isPossible = Array ( n + 1 ) . fill ( false ) ; checkIfPossibleRec ( 0 , a , b , isPossible , n ) ; return isPossible [ n ] ; } var a = 3 , b = 7 , n = 8 ; if ( checkPossible ( a , b , n ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check if N can be represented as sum of integers chosen from set { A , B } | Function to find if number N can be represented as sum of a ' s ▁ and ▁ b ' s ; Base condition ; If x is already visited ; Set x as possible ; Recursive call ; Driver code"
Javascript;"function sumOdd ( n ) { terms = ( n + 1 ) / 2 ; sum = terms * terms ; return sum ; } function suminRange ( l , r ) { return sumOdd ( r ) - sumOdd ( l - 1 ) ; } let l = 2 ; let r = 5 ; document . write ( "" "" + suminRange ( l , r ) ) ;";"Sum of all odd natural numbers in range L and R | Function to return the sum of all odd natural numbers ; Function to return the sum of all odd numbers in range L and R ; Driver Code"
Javascript;"function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function sumcommDiv ( a , b ) { var n = gcd ( a , b ) ; var sum = 0 ; for ( var i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) sum += i ; else sum += ( n / i ) + i ; } } return sum ; } var a = 10 , b = 15 ; document . write ( "" "" + sumcommDiv ( a , b ) ) ;";"Sum of common divisors of two numbers A and B | Function to calculate gcd of two numbers ; Function to calculate all common divisors of two given numbers a , b -- > input integer numbers ; find gcd of a , b ; Find the sum of divisors of n . ; if ' i ' is factor of n ; check if divisors are equal ; Driver program to run the case"
Javascript;"function checkNumber ( N ) { let temp = N ; while ( temp > 0 ) { if ( temp % 1000 == 144 ) temp = parseInt ( temp / 1000 , 10 ) ; else if ( temp % 100 == 14 ) temp = parseInt ( temp / 100 , 10 ) ; else if ( temp % 10 == 1 ) temp = parseInt ( temp / 10 , 10 ) ; else { return "" "" ; } } return "" "" ; } let N = 1414 ; document . write ( checkNumber ( N ) ) ;";"Check if a number is formed by Concatenation of 1 , 14 or 144 only | Function to check if a number is formed by Concatenation of 1 , 14 or 144 only ; check for each possible digit if given number consist other then 1 , 14 , 144 print NO else print YES ; Driver Code"
Javascript;"function getResult ( n ) { if ( ( n & 1 ) > 0 ) return 1 ; return - 1 ; } let n = 3 ; document . write ( getResult ( n ) ) ;";"Fibonacci problem ( Value of Fib ( N ) * Fib ( N ) | Javascript implementation of the approach ; Driver code"
Javascript;"function findAandB ( N ) { let val = N * N - 4.0 * N ; if ( val < 0 ) { document . write ( "" "" ) ; return ; } let a = ( N + Math . sqrt ( val ) ) / 2.0 ; let b = ( N - Math . sqrt ( val ) ) / 2.0 ; document . write ( "" "" + a . toFixed ( 4 ) + "" "" ) ; document . write ( "" "" + b . toFixed ( 5 ) ) ; } let N = 69.0 ; findAandB ( N ) ;";"Find two numbers with sum and product both same as N | Function to return the smallest string ; Not possible ; find a and b ; Driver Code"
Javascript;"function minOperations ( A , n ) { if ( ( n & 1 ) > 0 ) return - 1 ; let zeros = 0 , consZeros = 0 , ones = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( A [ i ] == 0 ) zeros ++ ; else ones ++ ; if ( i + 1 < n ) { if ( A [ i ] == 0 && A [ i + 1 ] == 0 ) consZeros ++ ; } } if ( A [ 0 ] == A [ n - 1 ] && A [ 0 ] == 0 ) consZeros ++ ; if ( zeros == ones ) return consZeros ; else return - 1 ; } let A = [ 1 , 1 , 0 , 0 ] ; let n = A . length ; document . write ( minOperations ( A , n ) ) ;";"Find minimum operations needed to make an Array beautiful | Function to find minimum operations required to make array beautiful ; counting consecutive zeros . ; check that start and end are same ; check is zero and one are equal ; Driver program"
Javascript;"function countdig ( m ) { if ( m == 0 ) return 0 ; else return 1 + countdig ( parseInt ( m / 10 ) ) ; } function countSteps ( x ) { var c = 0 ; var last = x ; while ( last > 0 ) { var digits = countdig ( last ) ; digits -= 1 ; var divisor = parseInt ( Math . pow ( 10 , digits ) ) ; var first = parseInt ( last / divisor ) ; var lastnumber = first * divisor ; var skipped = parseInt ( ( last - lastnumber ) / first ) ; skipped += 1 ; c += skipped ; last = last - ( first * skipped ) ; } return c ; } var n = 14 ; document . write ( countSteps ( n ) ) ;";"Steps to reduce N to zero by subtracting its most significant digit at every step | Function to count the number of digits in a number m ; Function to count the number of steps to reach 0 ; count the total number of stesp ; iterate till we reach 0 ; count the digits in last ; decrease it by 1 ; find the number on whose division , we get the first digit ; first digit in last ; find the first number less than last where the first digit changes ; find the number of numbers with same first digit that are jumped ; count the steps ; the next number with a different first digit ; Driver code"
Javascript;"function power ( x , y , p ) { while ( y > 0 ) { if ( ( y & 1 ) != 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function powerGCD ( a , b , n ) { var e = power ( a , n , b ) ; return gcd ( e , b ) ; } var a = 5 , b = 4 , n = 2 ; document . write ( powerGCD ( a , b , n ) ) ;";"GCD of a number raised to some power and another number | Calculates modular exponentiation , i . e . , ( x ^ y ) % p in O ( log y ) ; x = x % p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 ; y = y / 2 ; Returns GCD of a ^ n and b ; Driver code"
Javascript;"function allOddDigits ( n ) { while ( n != 0 ) { if ( ( n % 10 ) % 2 == 0 ) return false ; n = parseInt ( n / 10 ) ; } return true ; } function largestNumber ( n ) { if ( parseInt ( n % 2 ) == 0 ) n -- ; for ( i = n ; i > 0 ; i -= 2 ) if ( allOddDigits ( i ) ) return i ; } var N = 23 ; document . write ( largestNumber ( N ) ) ;";"Largest number not greater than N all the digits of which are odd | Function to check if all digits of a number are odd ; iterate for all digits ; if digit is even ; all digits are odd ; function to return the largest number with all digits odd ; iterate till we find a number with all digits odd ; Driver code"
Javascript;"function largestNumber ( n ) { var s = "" "" ; var duplicate = n ; while ( n > 0 ) { s = String . fromCharCode ( n % 10 + 48 ) + s ; n = parseInt ( n / 10 ) ; } var index = - 1 ; for ( i = 0 ; i < s . length ; i ++ ) { if ( ( ( s . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) % 2 & 1 ) == 0 ) { index = i ; break ; } } if ( index == - 1 ) return duplicate ; var num = 0 ; for ( i = 0 ; i < index ; i ++ ) num = num * 10 + ( s . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ; num = num * 10 + ( s . charAt ( index ) . charCodeAt ( 0 ) - ( ' ' ) . charCodeAt ( 0 ) - 1 ) ; for ( i = index + 1 ; i < s . length ; i ++ ) num = num * 10 + 9 ; return num ; } var N = 24578 ; document . write ( largestNumber ( N ) ) ;";"Largest number not greater than N all the digits of which are odd | function to return the largest number with all digits odd ; convert the number to a string for easy operations ; find first even digit ; if no even digit , then N is the answer ; till first even digit , add all odd numbers ; decrease 1 from the even digit ; add 9 in the rest of the digits ; Driver Code"
Javascript;"function countNumbers ( N ) { return parseInt ( Math . sqrt ( N ) , 10 ) - 1 ; } let N = 36 ; document . write ( countNumbers ( N ) ) ;";"Count number less than N which are product of perfect squares | Function to count number less than N which are product of any two perfect squares ; Driver Code"
Javascript;"function countOrderedPairs ( N ) { var count_pairs = 0 ; for ( var i = 1 ; i <= Math . sqrt ( N - 1 ) ; ++ i ) { for ( var j = i ; j * i < N ; ++ j ) ++ count_pairs ; } count_pairs *= 2 ; count_pairs -= parseInt ( Math . sqrt ( N - 1 ) ) ; return count_pairs ; } var N = 5 ; document . write ( countOrderedPairs ( N ) ) ;";"Count ordered pairs with product less than N | Function to return count of Ordered pairs whose product are less than N ; Initialize count to 0 ; count total pairs ; multiply by 2 to get ordered_pairs ; subtract redundant pairs ( a , b ) where a == b . ; return answer ; Driver code ; function call to print required answer"
Javascript;"function pairwiseDifference ( arr , n ) { var diff ; for ( i = 0 ; i < n - 1 ; i ++ ) { diff = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; document . write ( diff + "" "" ) ; } } var arr = [ 4 , 10 , 15 , 5 , 6 ] ; var n = arr . length ; pairwiseDifference ( arr , n ) ;";"Absolute Difference of all pairwise consecutive elements in an array | Function to print pairwise absolute difference of consecutive elements ; absolute difference between consecutive numbers ; Driver Code"
Javascript;"function sumAP ( n , d ) { n = parseInt ( n / d ) ; return ( n ) * ( ( 1 + n ) * parseInt ( d ) / 2 ) ; } function sumMultiples ( n ) { n -- ; return sumAP ( n , 2 ) + sumAP ( n , 5 ) - sumAP ( n , 10 ) ; } n = 20 ; document . write ( sumMultiples ( n ) ) ;";"Find the sum of all multiples of 2 and 5 below N | Function to find sum of AP series ; Number of terms ; Function to find the sum of all multiples of 2 and 5 below N ; Since , we need the sum of multiples less than N ; Driver code"
Javascript;"function markingScheme ( N , answerKey , studentAnswer ) { var positive = 0 , negative = 0 , notattempt = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( studentAnswer [ i ] == 0 ) notattempt ++ ; else if ( answerKey [ i ] == studentAnswer [ i ] ) positive ++ ; else if ( answerKey [ i ] != studentAnswer [ i ] ) negative ++ ; } return ( positive * 3 ) + ( negative * - 1 ) ; } var answerKey = [ 1 , 2 , 3 , 4 , 1 ] ; var studentAnswer = [ 1 , 2 , 3 , 4 , 0 ] ; var N = answerKey . length ; document . write ( markingScheme ( N , answerKey , studentAnswer ) ) ;";"Find the total marks obtained according to given marking scheme | Function that calculates marks . ; for not attempt score + 0 ; for each correct answer score + 3 ; for each wrong answer score - 1 ; calculate total marks ; Driver code"
Javascript;"let MAX = 10000 ; let prime = new Array ( MAX + 1 ) . fill ( true ) ; function SieveOfEratosthenes ( ) { prime [ 1 ] = false ; for ( let p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } } function solve ( n ) { let count = 0 ; let num = 1 ; let prod = 1 ; while ( count < n ) { if ( prime [ num ] == true ) { prod *= num ; count ++ ; } num ++ ; } return prod ; } SieveOfEratosthenes ( ) ; let n = 5 ; document . write ( solve ( n ) ) ;";"Find the Product of first N Prime Numbers | Javascript implementation of above solution ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Set all multiples of p to non - prime ; find the product of 1 st N prime numbers ; count of prime numbers ; product of prime numbers ; if the number is prime add it ; increase the count ; get to next number ; create the sieve ; find the value of 1 st n prime numbers"
Javascript;"function divisor ( a ) { let div = 1 , count = 0 ; for ( let i = 2 ; i <= Math . sqrt ( a ) ; i ++ ) { while ( a % i == 0 ) { count ++ ; a = parseInt ( a / i , 10 ) ; } div = div * ( count + 1 ) ; count = 0 ; } if ( a > 1 ) { div = div * ( 2 ) ; } return div ; } function OddDivCount ( a , b ) { let res = 0 ; for ( let i = a ; i <= b ; ++ i ) { let divCount = divisor ( i ) ; if ( divCount % 2 == 1 ) { ++ res ; } } return res ; } let a = 1 , b = 10 ; document . write ( OddDivCount ( a , b ) ) ;";"Program to find count of numbers having odd number of divisors in given range | Function to return the count of divisors of a number ; Count the powers of the current prime i which divides a ; Update the count of divisors ; Reset the count ; If the remaining a is prime then a ^ 1 will be one of its prime factors ; Function to count numbers having odd number of divisors in range [ A , B ] ; To store the count of elements having odd number of divisors ; Iterate from a to b and find the count of their divisors ; To store the count of divisors of i ; If the divisor count of i is odd ; Driver code"
Javascript;"function Check_is_possible ( l , r , k ) { var div_count = ( r / k ) - ( l / k ) ; if ( l % k == 0 ) { div_count ++ ; } return ( div_count > 1 ) ; } var l = 30 , r = 70 , k = 10 ; if ( Check_is_possible ( l , r , k ) ) { document . write ( "" "" ) ; } else { document . write ( "" "" ) ; }";"Check if there is any pair in a given range with GCD is divisible by k | Returns count of numbers in [ l r ] that are divisible by k . ; Add 1 explicitly as l is divisible by k ; l is not divisible by k ; Driver Code"
Javascript;"function nth_group ( n ) { return n * ( 2 * Math . pow ( n , 2 ) + 1 ) ; } let N = 5 ; document . write ( nth_group ( N ) ) ;";"Find sum of N | calculate sum of Nth group ; Driver code"
Javascript;"function printPossible ( a , b , c ) { if ( ( a + b + c ) % 2 != 0 a + b < c ) document . write ( "" "" ) ; else document . write ( "" "" ) ; } let a = 2 , b = 4 , c = 2 ; printPossible ( a , b , c ) ;";"Find if a molecule can be formed from 3 atoms using their valence numbers | Function to check if it is possible ; Driver code"
Javascript;"function isPerfectPower ( n ) { if ( n == 1 ) { return true ; } for ( var x = 2 ; x <= Math . sqrt ( n ) ; x ++ ) { var y = 2 ; var p = parseInt ( Math . pow ( x , y ) ) ; while ( p <= n && p > 0 ) { if ( p == n ) { return true ; } y ++ ; p = parseInt ( Math . pow ( x , y ) ) ; } } return false ; } function isStrongNumber ( n ) { var count = new Map ( ) ; while ( n % 2 == 0 ) { n = n / 2 ; if ( count . has ( 2 ) ) { count . set ( 2 , count . get ( 2 ) + 1 ) ; } else { count . set ( 2 , 1 ) ; } } for ( var i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { n = n / i ; if ( count . has ( i ) ) { count . set ( i , count . get ( i ) + 1 ) ; } else { count . set ( i , 1 ) ; } } } if ( n > 2 ) { if ( count . has ( n ) ) { count . set ( n , count . get ( n ) + 1 ) ; } else { count . set ( n , 1 ) ; } } var flag = 0 ; const iterator = count [ Symbol . iterator ] ( ) ; let itr = iterator . next ( ) for ( let i = 0 ; i < count . size ; i ++ ) { console . log ( itr . value , itr . done ) if ( itr . value == 1 ) { flag = 1 ; break ; } itr = iterator . next ( ) } if ( flag == 1 ) { return false ; } else { return true ; } } function isTrojan ( n ) { if ( ! isPerfectPower ( n ) && isStrongNumber ( n ) ) { return true ; } else { return false ; } } var n = 108 ; if ( isTrojan ( n ) ) { document . write ( "" "" ) ; } else { document . write ( "" "" ) ; }";"Check if a number is a Trojan Number | Function to check if a number can be expressed as x ^ y ; Try all numbers from 2 to sqrt ( n ) as base ; Keep increasing y while power ' p ' is smaller than n . ; Function to check if a number is Strong ; count the number for each prime factor ; minimum number of prime divisors should be 2 ; Function to check if a number is Trojan Number ; Driver Code"
Javascript;"function Sum_upto_nth_Term ( n ) { let r = n * ( n + 1 ) * ( 2 * n + 7 ) / 3 ; document . write ( r ) ; } let N = 5 ; Sum_upto_nth_Term ( N ) ;";"Find the sum of first N terms of the series 2 Ã — 3 + 4 Ã — 4 + 6 Ã — 5 + 8 Ã — 6 + ... | calculate sum upto N term of series ; Driver code"
Javascript;"function CalculateDifference ( arr , n ) { var max_val = Number . MIN_VALUE ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max_val ) max_val = arr [ i ] ; } var prime = Array ( max_val + 1 ) ; for ( i = 0 ; i <= max_val ; i ++ ) prime [ i ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } var S1 = 0 , S2 = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] ) { S1 += arr [ i ] ; } else if ( arr [ i ] != 1 ) { S2 += arr [ i ] ; } } return Math . abs ( S2 - S1 ) ; } var arr = [ 1 , 3 , 5 , 10 , 15 , 7 ] ; var n = arr . length ; document . write ( CalculateDifference ( arr , n ) ) ;";"Absolute Difference between the Sum of Non | Function to find the difference between the sum of non - primes and the sum of primes of an array . ; Find maximum value in the array ; USE SIEVE TO FIND ALL PRIME NUMBERS LESS THAN OR EQUAL TO max_val Create a boolean array "" prime [ 0 . . n ] "" . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; Remaining part of SIEVE ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Store the sum of primes in S1 and the sum of non primes in S2 ; the number is prime ; the number is non - prime ; Return the absolute difference ; Get the array ; Find the absolute difference"
Javascript;"function sum ( x , n ) { let total = 1.0 ; let previous = 1.0 ; for ( let i = 1 ; i <= n ; i ++ ) { previous = ( ( previous * x ) / ( i + 1 ) ) ; total = total + previous ; } return total ; } let x = 5 , n = 4 ; document . write ( "" "" + sum ( x , n ) ) ;";"Program to find sum of 1 + x / 2 ! + x ^ 2 / 3 ! + ... + x ^ n / ( n + 1 ) ! | Function to compute the series sum ; To store the value of S [ i - 1 ] ; Iterate over n to store sum in total ; Update previous with S [ i ] ; Get x and n ; Find and print the sum"
Javascript;"function numberOfDivisors ( num ) { let c = 0 ; for ( let i = 1 ; i <= num ; i ++ ) { if ( num % i == 0 ) { c += 1 ; } } return c ; } function countNumbers ( n ) { let c = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { if ( numberOfDivisors ( i ) == 9 ) c += 1 ; } return c ; } let n = 1000 ; document . write ( countNumbers ( n ) ) ;";"Count number of integers less than or equal to N which has exactly 9 divisors | Function to count factors in O ( N ) ; iterate and check if factor or not ; Function to count numbers having exactly 9 divisors ; check for all numbers <= N ; check if exactly 9 factors or not ; Driver Code"
Javascript;"function numberOfDistinct ( n ) { var ans = 0 ; for ( i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { ans ++ ; if ( ( n / i ) != i ) ans ++ ; } } return ans ; } var n = 3 ; document . write ( numberOfDistinct ( n ) ) ;";"Number of distinct integers obtained by lcm ( X , N ) / X | Function to count the number of distinct integers ontained by lcm ( x , num ) / x ; iterate to count the number of factors ; Driver Code"
Javascript;"var MAX = 10000 ; var arr = [ ] ; function ulam ( ) { arr . push ( 1 ) ; arr . push ( 2 ) ; for ( var i = 3 ; i < MAX ; i ++ ) { var count = 0 ; for ( var j = 0 ; j < arr . length - 1 ; j ++ ) { for ( var k = j + 1 ; k < arr . length ; k ++ ) { if ( arr [ j ] + arr [ k ] == i ) { count ++ ; } if ( count > 1 ) break ; } if ( count > 1 ) break ; } if ( count == 1 ) { arr . push ( i ) ; } } } ulam ( ) ; var n = 9 ; document . write ( arr [ n - 1 ] ) ;";"Ulam Number Sequence | Javascript code to print nth Ulam number ; Array to store Ulam Number ; function to compute ulam Number ; push First 2 two term of the sequence in the array for further calculation ; loop to generate Ulam number ; traverse the array and check if i can be represented as sum of two distinct element of the array ; If count is 1 that means i can be represented as sum of two distinct terms of the sequence ; i is ulam number ; Pre compute Ulam Number sequence ; Print nth Ulam number"
Javascript;"function NumberOfRectangles ( n , m ) { if ( n % 2 == 0 ) return ( n / 2 ) * m ; else if ( m % 2 == 0 ) return ( m / 2 ) * n ; return ( n * m - 1 ) / 2 ; } var n = 3 , m = 3 ; document . write ( NumberOfRectangles ( n , m ) ) ;";"Find the number of rectangles of size 2 * 1 which can be placed inside a rectangle of size n * m | Function to Find the number of rectangles of size 2 * 1 can be placed inside a rectangle of size n * m ; If n is even ; If m is even ; If both are odd ; Driver Code ; Function call"
Javascript;"function findNumUtil ( res , a , aCount , b , bCount , n ) { if ( res > 1e11 ) return 1e11 ; if ( aCount == bCount && res >= n ) return res ; return Math . min ( findNumUtil ( res * 10 + a , a , aCount + 1 , b , bCount , n ) , findNumUtil ( res * 10 + b , a , aCount , b , bCount + 1 , n ) ) ; } function findNum ( n , a , b ) { let result = 0 ; let aCount = 0 ; let bCount = 0 ; return findNumUtil ( result , a , aCount , b , bCount , n ) ; } let N = 4500 ; let A = 4 ; let B = 7 ; document . write ( findNum ( N , A , B ) ) ;";"Next greater Number than N with the same quantity of digits A and B | Recursive function to find the required number ; If the resulting number is >= n and count of a = count of b , return the number ; select minimum of two and call the function again ; Function to find the number next greater Number than N with the same quantity of digits A and B ; Driver code"
Javascript;"var n = 7 ; var k = 3 ; if ( n % k == 0 ) document . write ( n / k + "" "" + n / k ) ; else document . write ( ( n - ( n % k ) ) / k + "" "" + ( ( ( n - ( n % k ) ) / k ) + 1 ) ) ;";Minimum and maximum number of N chocolates after distribution among K students | Driver code
Javascript;"var m = 50 , n = 5 , x = 67 , h = 2927 ; var z = ( Math . ceil ( h / 60 * 1.0 ) ) ; if ( z <= n ) document . write ( z * m ) ; else document . write ( n * m + ( z - n ) * x ) ;";"Total money to be paid after traveling the given number of hours | JavaScript implementation of the above approach ; calculating hours travelled"
Javascript;"function sumProductDifference ( a , b , c , d , e ) { var rootSum = ( - 1 * b ) / a ; var rootProduct = e / a ; return Math . abs ( rootSum - rootProduct ) ; } document . write ( sumProductDifference ( 8 , 4 , 6 , 4 , 1 ) ) ;";"Absolute difference between sum and product of roots of a quartic equation | Function taking coefficient of each term of equation as input ; Finding sum of roots ; Finding product of roots ; Absolute difference ; Driver Code"
Javascript;"function numberOfSolutions ( n ) { let c = 0 ; for ( let x = 0 ; x <= n ; ++ x ) if ( n == x + n ^ x ) ++ c ; return c ; } let n = 3 ; document . write ( numberOfSolutions ( n ) ) ;";"Number of solutions of n = x + n âŠ • x | Function to find the number of solutions of n = n xor x ; Counter to store the number of solutions found ; Driver code"
Javascript;"function minimumLectures ( m , n ) { let ans = 0 ; if ( n < Math . ceil ( 0.75 * m ) ) ans = Math . ceil ( ( ( 0.75 * m ) - n ) / 0.25 ) ; else ans = 0 ; return ans ; } let M = 9 , N = 1 ; document . write ( minimumLectures ( M , N ) ) ;";"Program to find minimum number of lectures to attend to maintain 75 % | Method to compute minimum lecture ; Formula to compute ; Driver Code"
Javascript;"function countNumbers ( N ) { return parseInt ( ( Math . pow ( 10 , N ) - Math . pow ( 8 , N ) ) / 2 , 10 ) ; } let n = 5 ; document . write ( countNumbers ( n ) ) ;";"Count Numbers with N digits which consists of odd number of 0 's | Function to count Numbers with N digits which consists of odd number of 0 's ; Driver code"
Javascript;"MAX = 10000 ; prefix = new Array ( MAX + 1 ) ; function buildPrefix ( ) { prime = new Array ( MAX + 1 ) ; prime . fill ( true ) ; for ( var p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( var i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } prefix [ 0 ] = prefix [ 1 ] = 0 ; for ( var p = 2 ; p <= MAX ; p ++ ) { prefix [ p ] = prefix [ p - 1 ] ; if ( prime [ p ] ) prefix [ p ] += p ; } } function sumPrimeRange ( L , R ) { buildPrefix ( ) ; return prefix [ R ] - prefix [ L - 1 ] ; } var L = 10 , R = 20 ; document . write ( sumPrimeRange ( L , R ) + "" "" ) ;";"Sum of all Primes in a given range using Sieve of Eratosthenes | Jacascript program to find sum of primes ; prefix [ i ] is going to store sum of primes till i ( including i ) . ; Function to build the prefix sum array ; Create a boolean array "" prime [ 0 . . n ] "" . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Build prefix array ; Function to return sum of prime in range ; Driver code"
Javascript;"function calculateSum ( n ) { return 2 * ( n * ( n + 1 ) * ( 2 * n + 1 ) / 6 ) + n * ( n + 1 ) / 2 + 2 * ( n ) ; } let n = 3 ; document . write ( "" "" + calculateSum ( n ) ) ;";"Sum of the first N terms of the series 5 , 12 , 23 , 38. ... | Function to calculate the sum ; number of terms to be included in sum ; find the Sn"
Javascript;"function checkSolution ( a , b , c ) { if ( ( ( b * b ) - ( 4 * a * c ) ) > 0 ) document . write ( "" "" ) ; else if ( ( ( b * b ) - ( 4 * a * c ) ) == 0 ) document . write ( "" "" ) ; else document . write ( "" "" ) ; } var a = 2 , b = 5 , c = 2 ; checkSolution ( a , b , c ) ;";"Program to find number of solutions in Quadratic Equation | Method to check for solutions of equations ; If the expression is greater than 0 , then 2 solutions ; If the expression is equal 0 , then 2 solutions ; Else no solutions ; Driver Code"
Javascript;"function Bits ( kilobytes ) { var Bits = 0 ; Bits = kilobytes * 8192 ; return Bits ; } function Bytes ( kilobytes ) { var Bytes = 0 ; Bytes = kilobytes * 1024 ; return Bytes ; } var kilobytes = 1 ; document . write ( kilobytes + "" "" + Bytes ( kilobytes ) + "" "" + Bits ( kilobytes ) + "" "" ) ;";"Program to convert KiloBytes to Bytes and Bits | Function to calculates the bits ; Calculates Bits 1 kilobytes ( s ) = 8192 bits ; Function to calculates the bytes ; Calculates Bytes 1 KB = 1024 bytes ; Driver code"
Javascript;"let n = 3 ; let a = [ 1 , 2 , 3 ] ; let i = 0 ; let sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } let x = sum / n ; if ( x * n == sum ) document . write ( x ) ; else document . write ( "" "" ) ;";"Program to find the Hidden Number | Getting the size of array ; Getting the array of size n ; Solution ; Finding sum of the array elements ; Dividing sum by size n ; Print x , if found"
Javascript;"function findSum ( n ) { return Math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; } let n = 10 ; document . write ( findSum ( n ) . toFixed ( 4 ) ) ;";"Find sum of the series ? 3 + ? 12 + ... ... ... upto N terms | Function to find the sum ; Apply AP formula ; number of terms"
Javascript;"function sum ( x , y , n ) { sum1 = ( Math . pow ( x , 2 ) * ( Math . pow ( x , 2 * n ) - 1 ) ) / ( Math . pow ( x , 2 ) - 1 ) ; sum2 = ( x * y * ( Math . pow ( x , n ) * Math . pow ( y , n ) - 1 ) ) / ( x * y - 1 ) ; return sum1 + sum2 ; } let x = 2 ; let y = 2 ; let n = 2 ; document . write ( sum ( x , y , n ) ) ;";"Find the sum of the series x ( x + y ) + x ^ 2 ( x ^ 2 + y ^ 2 ) + x ^ 3 ( x ^ 3 + y ^ 3 ) + ... + x ^ n ( x ^ n + y ^ n ) | Function to return required sum ; sum of first series ; sum of second series ; Driver code ; function call to print sum"
Javascript;"function printPair ( g , l ) { document . write ( g + "" "" + l ) ; } var g = 3 , l = 12 ; printPair ( g , l ) ;";"Find any pair with given GCD and LCM | Function to print the pairs ; Driver Code"
Javascript;"function calculateSum ( n ) { let a1 = 1 , a2 = 2 ; let r = 2 ; let d = 1 ; return ( n ) * ( 2 * a1 + ( n - 1 ) * d ) / 2 + a2 * ( Math . pow ( r , n ) - 1 ) / ( r - 1 ) ; } let n = 5 ; document . write ( "" "" + calculateSum ( n ) ) ;";"Sum of first n terms of a given series 3 , 6 , 11 , ... . . | Function to calculate the sum ; starting number ; Common Ratio ; Common difference ; N th term to be find ; find the Sn"
Javascript;"function repeatedSum ( n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; } function repeatedProduct ( n ) { var prod = 1 ; while ( n > 0 prod > 9 ) { if ( n == 0 ) { n = prod ; prod = 1 ; } prod *= n % 10 ; n = parseInt ( n / 10 ) ; } return prod ; } function maxSumProduct ( N ) { if ( N < 10 ) return N ; return Math . max ( repeatedSum ( N ) , repeatedProduct ( N ) ) ; } var n = 631 ; document . write ( maxSumProduct ( n ) ) ;";"Maximum of sum and product of digits until number is reduced to a single digit | Function to sum the digits until it becomes a single digit ; Function to product the digits until it becomes a single digit ; Loop to do sum while sum is not less than or equal to 9 ; Function to find the maximum among repeated sum and repeated product ; Driver code"
Javascript;"function max_value ( array , M , K , N ) { var time = Array ( M ) . fill ( 0 ) ; for ( var i = 0 ; i < N ; i ++ ) { time [ array [ i ] [ 0 ] ] = array [ i ] [ 1 ] ; } var dp = Array . from ( Array ( M ) , ( ) => Array ( 2 ) ) ; dp [ 0 ] [ 0 ] = 0 ; dp [ 0 ] [ 1 ] = time [ 0 ] ; for ( var i = 1 ; i < M ; i ++ ) { dp [ i ] [ 0 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) ; dp [ i ] [ 1 ] = time [ i ] ; if ( i - K >= 0 ) { dp [ i ] [ 1 ] += Math . max ( dp [ i - K ] [ 0 ] , dp [ i - K ] [ 1 ] ) ; } } return Math . max ( dp [ M - 1 ] [ 0 ] , dp [ M - 1 ] [ 1 ] ) ; } var array = [ [ 0 , 10 ] , [ 4 , 110 ] , [ 5 , 30 ] ] ; var N = 3 ; var K = 4 ; var M = 6 ; document . write ( max_value ( array , M , K , N ) ) ;";"Find maximum possible value of advertising | Function to find maximum possible advertising value ; To store advertising value at i - th minute ; Base Case ; If no advertisement is taken on ith minute ; If advertisement is taken on i - th minute ; array [ ] [ 0 ] start time array [ ] [ 1 ] advertising value"
Javascript;"let digits = [ ] ; let vis = new Array ( 170 ) ; vis . fill ( false ) ; let dp = new Array ( 19 ) ; for ( let i = 0 ; i < 19 ; i ++ ) { dp [ i ] = new Array ( 19 ) ; for ( let j = 0 ; j < 19 ; j ++ ) { dp [ i ] [ j ] = new Array ( 2 ) ; for ( let k = 0 ; k < 2 ; k ++ ) { dp [ i ] [ j ] [ k ] = new Array ( 170 ) ; for ( let l = 0 ; l < 170 ; l ++ ) { dp [ i ] [ j ] [ k ] [ l ] = 0 ; } } } } function ConvertIntoDigit ( n ) { while ( n > 0 ) { let dig = n % 10 ; digits . push ( dig ) ; n = parseInt ( n / 10 , 10 ) ; } digits . reverse ( ) ; } function solve ( idx , k , tight , sum ) { if ( idx == digits . length && k == 0 && sum % 2 == 1 ) { if ( ! vis [ sum ] ) { vis [ sum ] = true ; return 1 ; } return 0 ; } if ( idx > digits . length ) { return 0 ; } if ( dp [ idx ] [ k ] [ tight ] [ sum ] > 0 ) { return dp [ idx ] [ k ] [ tight ] [ sum ] ; } let j ; if ( idx < digits . length && tight == 0 ) { j = digits [ idx ] ; } else { j = 9 ; } let cnt = 0 ; for ( let i = ( k > 0 ? 0 : 1 ) ; i <= j ; i ++ ) { let newtight = tight ; if ( i < j ) { newtight = 1 ; } if ( i == 0 ) cnt += solve ( idx + 1 , k - 1 , newtight , sum ) ; else cnt += solve ( idx + 1 , k , newtight , sum + i ) ; } dp [ idx ] [ k ] [ tight ] [ sum ] = cnt ; return dp [ idx ] [ k ] [ tight ] [ sum ] ; } let N , k ; N = 169 ; k = 2 ; ConvertIntoDigit ( N ) ; k = digits . length - k ; document . write ( solve ( 0 , k , 0 , 0 ) ) ;";"Count numbers with exactly K non | To store digits of N ; visited map ; DP Table ; Push all the digits of N into digits vector ; Function returns the count ; If desired number is formed whose sum is odd ; If it is not present in map , mark it as true and return 1 ; Sum is present in map already ; Desired result not found ; If that state is already calculated just return that state value ; Upper limit ; To store the count of desired numbers ; If k is non - zero , i ranges from 0 to j else [ 1 , j ] ; If current digit is 0 , decrement k and recurse sum is not changed as we are just adding 0 that makes no difference ; If i is non zero , then k remains unchanged and value is added to sum ; Memoize and return ; K is the number of exact non - zero elements to have in number ; break N into its digits ; We keep record of 0 s we need to place in the number"
Javascript;"function countSubsets ( N ) { if ( N <= 2 ) return N ; if ( N == 3 ) return 2 ; var DP = Array ( N + 1 ) . fill ( 0 ) ; DP [ 0 ] = 0 ; DP [ 1 ] = 1 ; DP [ 2 ] = 2 ; DP [ 3 ] = 2 ; for ( i = 4 ; i <= N ; i ++ ) { DP [ i ] = DP [ i - 2 ] + DP [ i - 3 ] ; } return DP [ N ] ; } var N = 20 ; document . write ( countSubsets ( N ) ) ;";"Count of subsets of integers from 1 to N having no adjacent elements | Function to count subsets ; Driver code"
Javascript;"var dp = Array . from ( Array ( 500 ) , ( ) => Array ( 500 ) ) ; function CountSets ( x , pos ) { if ( x <= 0 ) { if ( pos == 0 ) return 1 ; else return 0 ; } if ( pos == 0 ) return 1 ; if ( dp [ x ] [ pos ] != - 1 ) return dp [ x ] [ pos ] ; var answer = CountSets ( x - 1 , pos ) + CountSets ( x - 2 , pos - 1 ) ; return dp [ x ] [ pos ] = answer ; } function CountOrderedSets ( n ) { var factorial = Array ( 10000 ) . fill ( 0 ) ; factorial [ 0 ] = 1 ; for ( var i = 1 ; i < 10000 ; i ++ ) factorial [ i ] = factorial [ i - 1 ] * i ; var answer = 0 ; dp = Array . from ( Array ( 500 ) , ( ) => Array ( 500 ) . fill ( - 1 ) ) ; for ( var i = 1 ; i <= n ; i ++ ) { var sets = CountSets ( n , i ) * factorial [ i ] ; answer = answer + sets ; } return answer ; } var N = 3 ; document . write ( CountOrderedSets ( N ) ) ;";"Count the number of ordered sets not containing consecutive numbers | DP table ; Function to calculate the count of ordered set for a given size ; Base cases ; If subproblem has been soved before ; Store and return answer to this subproblem ; Function returns the count of all ordered sets ; Prestore the factorial value ; Initialise the dp table ; Iterate all ordered set sizes and find the count for each one maximum ordered set size will be smaller than N as all elements are distinct and non consecutive . ; Multiply ny size ! for all the arrangements because sets are ordered . ; Add to total answer ; Driver code"
Javascript;"function numberOfArithmeticSequences ( L , N ) { if ( N <= 2 ) return 0 ; var count = 0 ; var res = 0 ; for ( var i = 2 ; i < N ; ++ i ) { if ( L [ i ] - L [ i - 1 ] == L [ i - 1 ] - L [ i - 2 ] ) { ++ count ; } else { count = 0 ; } res += count ; } return res ; } var L = [ 1 , 3 , 5 , 6 , 7 , 8 ] ; var N = L . length ; document . write ( numberOfArithmeticSequences ( L , N ) ) ;";"Count the Arithmetic sequences in the Array of size at least 3 | Function to find all arithmetic sequences of size atleast 3 ; If array size is less than 3 ; Finding arithmetic subarray length ; To store all arithmetic subarray of length at least 3 ; Check if current element makes arithmetic sequence with previous two elements ; Begin with a new element for new arithmetic sequences ; Accumulate result in till i . ; Return final count ; Driver code ; Function to find arithmetic sequences"
Javascript;"function CountOfTriplets ( a , n ) { let answer = 0 ; let x = 0 ; let count = new Array ( 100005 ) ; let ways = new Array ( 100005 ) ; count . fill ( 0 ) ; ways . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { x ^= a [ i ] ; answer += count [ x ] * i - ways [ x ] ; count [ x ] ++ ; ways [ x ] = ways [ x ] + i + 1 ; } return answer ; } let Arr = [ 3 , 6 , 12 , 8 , 6 , 2 , 1 , 5 ] ; let N = Arr . length ; document . write ( CountOfTriplets ( Arr , N ) ) ;";"Count triplet of indices ( i , j , k ) such that XOR of elements between [ i , j ) equals [ j , k ] | Function return the count of triplets having subarray XOR equal ; XOR value till i ; Count and ways array as defined above ; Using the formula stated ; Increase the frequency of x ; Add i + 1 to ways [ x ] for upcoming indices ; Driver code"
Javascript;"var dp = Array . from ( Array ( 5000 ) , ( ) => Array ( ( 1 << 10 ) + 5 ) . fill ( - 1 ) ) ; function getmask ( val ) { var mask = 0 ; if ( val == 0 ) return 1 ; while ( val ) { var d = val % 10 ; mask |= ( 1 << d ) ; val = parseInt ( val / 10 ) ; } return mask ; } function countWays ( pos , mask , a , n ) { if ( pos == n ) return ( mask > 0 ? 1 : 0 ) ; if ( dp [ pos ] [ mask ] != - 1 ) return dp [ pos ] [ mask ] ; var count = 0 ; count = count + countWays ( pos + 1 , mask , a , n ) ; if ( ( getmask ( a [ pos ] ) & mask ) == 0 ) { var new_mask = ( mask | ( getmask ( a [ pos ] ) ) ) ; count = count + countWays ( pos + 1 , new_mask , a , n ) ; } return dp [ pos ] [ mask ] = count ; } function numberOfSubarrays ( a , n ) { dp = Array . from ( Array ( 5000 ) , ( ) => Array ( ( 1 << 10 ) + 5 ) . fill ( - 1 ) ) ; return countWays ( 0 , 0 , a , n ) ; } var N = 4 ; var A = [ 1 , 12 , 23 , 34 ] ; document . write ( numberOfSubarrays ( A , N ) ) ;";"Count of subarrays of an Array having all unique digits | Dynamic programming table ; Function to obtain the mask for any integer ; Function to count the number of ways ; Subarray must not be empty ; If subproblem has been solved ; Excluding this element in the subarray ; If there are no common digits then only this element can be included ; Calculate the new mask if this element is included ; Store and return the answer ; Function to find the count of subarray with all digits unique ; initializing dp ; Driver code"
Javascript;"let fib = [ ] ; class node { constructor ( data ) { this . left = null ; this . right = null ; this . data = data ; } } ; function newNode ( data ) { let temp = new node ( data ) ; return temp ; } function height ( root ) { if ( root == null ) return 0 ; return ( Math . max ( height ( root . left ) , height ( root . right ) ) + 1 ) ; } function FibonacciSeries ( n ) { fib . push ( 0 ) ; fib . push ( 1 ) ; for ( let i = 2 ; i < n ; i ++ ) fib . push ( fib [ i - 1 ] + fib [ i - 2 ] ) ; } function CountPathUtil ( root , i , count ) { if ( root == null || ! ( fib [ i ] == root . data ) ) { return count ; } if ( root . left != null && root . right != null ) { count ++ ; } count = CountPathUtil ( root . left , i + 1 , count ) ; return CountPathUtil ( root . right , i + 1 , count ) ; } function CountPath ( root ) { let ht = height ( root ) ; FibonacciSeries ( ht ) ; document . write ( CountPathUtil ( root , 0 , 0 ) ) ; } let root = newNode ( 0 ) ; root . left = newNode ( 1 ) ; root . right = newNode ( 1 ) ; root . left . left = newNode ( 1 ) ; root . left . right = newNode ( 4 ) ; root . right . right = newNode ( 1 ) ; root . right . right . left = newNode ( 2 ) ; CountPath ( root ) ;";"Count of Fibonacci paths in a Binary tree | Vector to store the fibonacci series ; Binary Tree Node ; Function to create a new tree node ; Function to find the height of the given tree ; Function to make fibonacci series upto n terms ; Preorder Utility function to count exponent path in a given Binary tree ; Base Condition , when node pointer becomes null or node value is not a number of Math . pow ( x , y ) ; Increment count when encounter leaf node ; Left recursive call save the value of count ; Right recursive call and return value of count ; Function to find whether fibonacci path exists or not ; To find the height ; Making fibonacci series upto ht terms ; Create binary tree ; Function Call"
Javascript;"function maximumOccurrence ( s ) { var n = s . length ; var freq = Array ( 26 ) . fill ( 0 ) ; var dp = Array ( 26 ) . fill ( ) . map ( ( ) => Array ( 26 ) . fill ( 0 ) ) ; for ( var i = 0 ; i < n ; i ++ ) { var c = ( s . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ) ; for ( var j = 0 ; j < 26 ; j ++ ) dp [ j ] += freq [ j ] ; freq ++ ; } var answer = Number . MIN_VALUE ; for ( var i = 0 ; i < 26 ; i ++ ) answer = Math . max ( answer , freq [ i ] ) ; for ( var i = 0 ; i < 26 ; i ++ ) { for ( var j = 0 ; j < 26 ; j ++ ) { answer = Math . max ( answer , dp [ i ] [ j ] ) ; } } return answer ; } var s = "" "" ; document . write ( maximumOccurrence ( s ) ) ;";"Count maximum occurrence of subsequence in string such that indices in subsequence is in A . P . | Function to find the maximum occurrence of the subsequence such that the indices of characters are in arithmetic progression ; Frequency for characters ; Loop to count the occurrence of ith character before jth character in the given String ; Increase the frequency of s [ i ] or c of String ; Maximum occurrence of subsequence of length 1 in given String ; Maximum occurrence of subsequence of length 2 in given String ; Driver Code"
Javascript;"var mod = 1000000007 ; var dp = Array . from ( Array ( 1005 ) , ( ) => Array ( 105 ) ) ; for ( var i = 0 ; i < 1005 ; i ++ ) { for ( var j = 0 ; j < 105 ; j ++ ) { dp [ i ] [ j ] = Array ( 2 ) . fill ( - 1 ) ; } } var powers = Array ( 1005 ) ; var powersModk = Array ( 1005 ) ; function calculate ( pos , rem , z , k , n ) { if ( rem == 0 && z ) { if ( pos != n ) return ( powers [ n - pos - 1 ] * 9 ) % mod ; else return 1 ; } if ( pos == n ) return 0 ; if ( dp [ pos ] [ rem ] [ z ] != - 1 ) return dp [ pos ] [ rem ] [ z ] ; var count = 0 ; for ( var i = 0 ; i < 10 ; i ++ ) { if ( i == 0 ) count = ( count + ( calculate ( pos + 1 , ( rem + ( i * powersModk [ pos ] ) % k ) % k , z , k , n ) ) ) % mod ; else count = ( count + ( calculate ( pos + 1 , ( rem + ( i * powersModk [ pos ] ) % k ) % k , 1 , k , n ) ) ) % mod ; } return dp [ pos ] [ rem ] [ z ] = count ; } function countNumbers ( n , k ) { var st = 1 ; for ( var i = 0 ; i <= n ; i ++ ) { powers [ i ] = st ; st *= 10 ; st %= mod ; } st = 1 ; for ( var i = 0 ; i <= n ; i ++ ) { powersModk [ i ] = st ; st *= 10 ; st %= mod ; } return calculate ( 0 , 0 , 0 , k , n ) ; } var N = 2 ; var K = 2 ; document . write ( countNumbers ( N , K ) ) ;";"Count the numbers with N digits and whose suffix is divisible by K | Javascript implementation to Count the numbers with N digits and whose suffix is divisible by K ; Suffix of length pos with remainder rem and Z representing whether the suffix has a non zero digit until now ; Base case ; If count of digits is less than n ; Placing all possible digits in remaining positions ; If remainder non zero and suffix has n digits ; If the subproblem is already solved ; Placing all digits at MSB of suffix and increasing it 's length by 1 ; Non zero digit is placed ; Store and return the solution to this subproblem ; Function to Count the numbers with N digits and whose suffix is divisible by K ; Since we need powers of 10 for counting , it 's better to  pre store them along with their  modulo with 1e9 + 7 for counting ; Since at each recursive step we increase the suffix length by 1 by placing digits at its leftmost position , we need powers of 10 modded with k , in order to fpos the new remainder efficiently ; Driver Code"
Javascript;"let inf = 100000000 ; function smPath ( s , d , ed , n , k ) { let dis = new Array ( n + 1 ) ; for ( let i = 0 ; i < ( n + 1 ) ; i ++ ) { dis [ i ] = inf ; } dis [ s ] = 0 ; for ( let i = 0 ; i < k ; i ++ ) { let dis1 = new Array ( n + 1 ) ; for ( let i = 0 ; i < ( n + 1 ) ; i ++ ) { dis1 [ i ] = inf ; } for ( let it = 0 ; it < ed . length ; it ++ ) dis1 [ ed [ it ] [ 1 ] ] = Math . min ( dis1 [ ed [ it ] [ 1 ] ] , dis [ ed [ it ] [ 0 ] ] + ed [ it ] [ 2 ] ) ; document . write ( ) for ( let j = 0 ; j <= n ; j ++ ) dis [ j ] = dis1 [ j ] ; } if ( dis [ d ] == inf ) return - 1 ; else return dis [ d ] ; } let n = 4 ; let ed = [ [ 0 , 1 , 10 ] , [ 0 , 2 , 3 ] , [ 0 , 3 , 2 ] , [ 1 , 3 , 7 ] , [ 2 , 3 , 7 ] ] ; let s = 0 , d = 3 ; let k = 2 ; document . write ( smPath ( s , d , ed , n , k ) ) ;";"Shortest path with exactly k edges in a directed and weighted graph | Set 2 | Javascript implementation of the above approach ; Function to find the smallest path with exactly K edges ; Array to store dp ; Initialising the array ; Loop to solve DP ; Initialising next state ; Recurrence relation ; Returning final answer ; Driver code ; Input edges ; Source and Destination ; Number of edges in path ; Calling the function"
Javascript;"var inf = 1000000000 ; function bellman ( s , d , ed , n ) { if ( s == d ) return 0 ; var dis = Array ( n + 1 ) . fill ( inf ) ; dis [ s ] = 1 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { for ( var j = 0 ; j < ed . length ; j ++ ) { dis [ ed [ j ] [ 0 ] [ 1 ] ] = Math . min ( dis [ ed [ j ] [ 0 ] [ 1 ] ] , dis [ ed [ j ] [ 0 ] [ 0 ] ] * ed [ j ] [ 1 ] ) ; } } for ( var it in ed ) { if ( dis [ it [ 0 ] [ 1 ] ] > dis [ it [ 0 ] [ 0 ] ] * it [ 1 ] ) return - 2 ; } if ( dis [ d ] == inf ) return - 1 ; else return dis [ d ] ; } var n = 3 ; var ed ; ed = [ [ [ 1 , 2 ] , 0.5 ] , [ [ 1 , 3 ] , 1.9 ] , [ [ 2 , 3 ] , 3 ] ] ; var s = 1 , d = 3 ; var get = bellman ( s , d , ed , n ) ; if ( get == - 2 ) document . write ( "" "" ) ; else document . write ( get ) ;";"Path with smallest product of edges with weight > 0 | Javascript implementation of the approach . ; Function to return the smallest product of edges ; If the source is equal to the destination ; Initialising the array ; Bellman ford algorithm ; Loop to detect cycle ; Returning final answer ; Driver code ; Input edges ; Source and Destination ; Bellman ford"
Javascript;"function maxLengthSquare ( row , column , arr , k ) { let sum = new Array ( ) ; [ row + 1 ] [ column + 1 ] ; for ( let i = 0 ; i < row + 1 ; i ++ ) { let temp = new Array ( ) ; for ( let j = 0 ; j < column + 1 ; j ++ ) { temp . push ( [ ] ) } sum . push ( temp ) } for ( let i = 1 ; i <= row ; i ++ ) for ( let j = 0 ; j <= column ; j ++ ) sum [ i ] [ j ] = 0 ; let cur_max = 1 ; let max = 0 ; for ( let i = 1 ; i <= row ; i ++ ) { for ( let j = 1 ; j <= column ; j ++ ) { sum [ i ] [ j ] = sum [ i - 1 ] [ j ] + sum [ i ] [ j - 1 ] + arr [ i - 1 ] [ j - 1 ] - sum [ i - 1 ] [ j - 1 ] ; if ( i >= cur_max && j >= cur_max && sum [ i ] [ j ] - sum [ i - cur_max ] [ j ] - sum [ i ] [ j - cur_max ] + sum [ i - cur_max ] [ j - cur_max ] <= k ) { max = cur_max ++ ; } } } return max ; } let row = 4 , column = 4 ; let matrix = [ [ 1 , 1 , 1 , 1 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 0 ] ] ; let k = 6 ; let ans = maxLengthSquare ( row , column , matrix , k ) ; document . write ( ans ) ;";"Find Maximum Length Of A Square Submatrix Having Sum Of Elements At | Function to return maximum length of square submatrix having sum of elements at - most K ; Matrix to store prefix sum ; Current maximum length ; Variable for storing maximum length of square ; Calculating prefix sum ; Checking whether there exits square with length cur_max + 1 or not ; Returning the maximum length ; Driver code"
Javascript;"let N = 101 ; let mod = 1e9 + 7 ; let exactsum = new Array ( N ) ; let exactnum = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { exactsum [ i ] = new Array ( N ) ; exactnum [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { exactsum [ i ] [ j ] = new Array ( N ) ; exactnum [ i ] [ j ] = new Array ( N ) ; for ( let k = 0 ; k < N ; k ++ ) { exactsum [ i ] [ j ] [ k ] = 0 ; exactnum [ i ] [ j ] [ k ] = 0 ; } } } function getSum ( x , y , z ) { let ans = 0 ; exactnum [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( let i = 0 ; i <= x ; ++ i ) { for ( let j = 0 ; j <= y ; ++ j ) { for ( let k = 0 ; k <= z ; ++ k ) { if ( i > 0 ) { exactsum [ i ] [ j ] [ k ] += ( exactsum [ i - 1 ] [ j ] [ k ] * 10 + 4 * exactnum [ i - 1 ] [ j ] [ k ] ) % mod ; exactnum [ i ] [ j ] [ k ] += exactnum [ i - 1 ] [ j ] [ k ] % mod ; } if ( j > 0 ) { exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j - 1 ] [ k ] * 10 + 5 * exactnum [ i ] [ j - 1 ] [ k ] ) % mod ; exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j - 1 ] [ k ] % mod ; } if ( k > 0 ) { exactsum [ i ] [ j ] [ k ] += ( exactsum [ i ] [ j ] [ k - 1 ] * 10 + 6 * exactnum [ i ] [ j ] [ k - 1 ] ) % mod ; exactnum [ i ] [ j ] [ k ] += exactnum [ i ] [ j ] [ k - 1 ] % mod ; } ans += exactsum [ i ] [ j ] [ k ] % mod ; ans %= mod ; } } } return ans ; } let x = 1 , y = 1 , z = 1 ; document . write ( getSum ( x , y , z ) % mod ) ;";"Sum of all numbers formed having 4 atmost X times , 5 atmost Y times and 6 atmost Z times | Javascript program to find sum of all numbers formed having 4 atmost X times , 5 atmost Y times and 6 atmost Z times ; exactsum [ i ] [ j ] [ k ] stores the sum of all the numbers having exact i 4 ' s , ▁ j ▁ 5' s and k 6 's ; exactnum [ i ] [ j ] [ k ] stores numbers of numbers having exact i 4 ' s , ▁ j ▁ 5' s and k 6 's ; Utility function to calculate the sum for x 4 ' s , ▁ y ▁ 5' s and z 6 's ; Computing exactsum [ i ] [ j ] [ k ] as explained above ; Driver code"
Javascript;"function findMax ( a , n ) { var dp = Array ( n ) . fill ( ) . map ( ( ) => Array ( 2 ) . fill ( 0 ) ) ; var i , j ; for ( i = 0 ; i < n ; i ++ ) for ( j = 0 ; j < 2 ; j ++ ) dp [ i ] [ j ] = 0 ; dp [ 0 ] [ 0 ] = a [ 0 ] + a [ 1 ] ; dp [ 0 ] [ 1 ] = a [ 0 ] * a [ 1 ] ; for ( i = 1 ; i <= n - 2 ; i ++ ) { dp [ i ] [ 0 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] ) + a [ i + 1 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] - a [ i ] + a [ i ] * a [ i + 1 ] ; } document . write ( Math . max ( dp [ n - 2 ] [ 0 ] , dp [ n - 2 ] [ 1 ] ) ) ; } var arr = [ 5 , - 1 , - 5 , - 3 , 2 , 9 , - 4 ] ; findMax ( arr , 7 ) ;";"Maximum value obtained by performing given operations in an Array | A function to calculate the maximum value ; basecases ; Loop to iterate and add the max value in the dp array ; Driver Code"
Javascript;"function sum ( arr , l , r ) { let s = 0 ; for ( let i = l ; i <= r ; i ++ ) { s += arr [ i ] ; } return s ; } let dp = new Array ( 101 ) ; for ( let i = 0 ; i < 101 ; i ++ ) { dp [ i ] = new Array ( 101 ) ; for ( let j = 0 ; j < 101 ; j ++ ) { dp [ i ] [ j ] = new Array ( 101 ) ; for ( let k = 0 ; k < 101 ; k ++ ) { dp [ i ] [ j ] [ k ] = 0 ; } } } function solve ( arr , l , r , k ) { if ( r - l + 1 <= k ) return sum ( arr , l , r ) ; if ( dp [ l ] [ r ] [ k ] != 0 ) return dp [ l ] [ r ] [ k ] ; let sum_ = sum ( arr , l , r ) ; let len_r = ( r - l + 1 ) - k ; let len = ( r - l + 1 ) ; let ans = 0 ; for ( let i = 0 ; i < len - len_r + 1 ; i ++ ) { let sum_sub = sum ( arr , i + l , i + l + len_r - 1 ) ; ans = Math . max ( ans , ( sum_ - sum_sub ) + ( sum_sub - solve ( arr , i + l , i + l + len_r - 1 , k ) ) ) ; } dp [ l ] [ r ] [ k ] = ans ; return ans ; } let arr = [ 10 , 15 , 20 , 9 , 2 , 5 ] , k = 2 ; let n = arr . length ; document . write ( solve ( arr , 0 , n - 1 , k ) ) ;";"Optimal strategy for a Game with modifications | Function to return sum of subarray from l to r ; calculate sum by a loop from l to r ; dp to store the values of sub problems ; if length of the array is less than k return the sum ; if the value is previously calculated ; else calculate the value ; select all the sub array of length len_r ; get the sum of that sub array ; check if it is the maximum or not ; store it in the table ; Driver code"
Javascript;"let MAXI = 50 ; let dp = new Array ( MAXI ) ; let n , m ; let INT_MAX = Number . MAX_VALUE ; function minDifference ( x , y , k , b , c ) { if ( x >= n y >= m ) return INT_MAX ; if ( x == n - 1 && y == m - 1 ) { let diff = b [ x ] [ y ] - c [ x ] [ y ] ; return Math . min ( Math . abs ( k - diff ) , Math . abs ( k + diff ) ) ; } let ans = dp [ x ] [ y ] [ k ] ; if ( ans != - 1 ) return ans ; ans = INT_MAX ; let diff = b [ x ] [ y ] - c [ x ] [ y ] ; ans = Math . min ( ans , minDifference ( x + 1 , y , Math . abs ( k + diff ) , b , c ) ) ; ans = Math . min ( ans , minDifference ( x , y + 1 , Math . abs ( k + diff ) , b , c ) ) ; ans = Math . min ( ans , minDifference ( x + 1 , y , Math . abs ( k - diff ) , b , c ) ) ; ans = Math . min ( ans , minDifference ( x , y + 1 , Math . abs ( k - diff ) , b , c ) ) ; return ans ; } n = 2 ; m = 2 ; let b = [ [ 1 , 4 ] , [ 2 , 4 ] ] ; let c = [ [ 3 , 2 ] , [ 3 , 1 ] ] ; for ( let i = 0 ; i < MAXI ; i ++ ) { dp [ i ] = new Array ( MAXI ) ; for ( let j = 0 ; j < MAXI ; j ++ ) { dp [ i ] [ j ] = new Array ( MAXI * MAXI ) ; for ( let k = 0 ; k < MAXI * MAXI ; k ++ ) { dp [ i ] [ j ] [ k ] = - 1 ; } } } document . write ( minDifference ( 0 , 0 , 0 , b , c ) ) ;";"Find the minimum difference path from ( 0 , 0 ) to ( N | JavaScript implementation of the approach ; Function to return the minimum difference path from ( 0 , 0 ) to ( N - 1 , M - 1 ) ; Terminating case ; Base case ; If it is already visited ; Recursive calls ; Return the value ; Driver code ; Function call"
Javascript;"function longest_subseq ( n , k , s ) { let dp = new Array ( n ) ; let max_length = new Array ( 26 ) ; for ( let i = 0 ; i < 26 ; i ++ ) { max_length [ i ] = 0 ; dp [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { let curr = s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; let lower = Math . max ( 0 , curr - k ) ; let upper = Math . min ( 25 , curr + k ) ; for ( let j = lower ; j < upper + 1 ; j ++ ) { dp [ i ] = Math . max ( dp [ i ] , max_length [ j ] + 1 ) ; } max_length [ curr ] = Math . max ( dp [ i ] , max_length [ curr ] ) ; } let ans = 0 ; ans = Math . max ( ... dp ) return ans ; } let s = "" "" ; let n = s . length ; let k = 3 ; document . write ( longest_subseq ( n , k , s ) ) ;";"Longest subsequence having difference atmost K | Function to find the longest Special Sequence ; Creating a list with all 0 's of size  equal to the length of String ; Supporting list with all 0 's of size 26 since  the given String consists  of only lower case alphabets ; Converting the ascii value to list indices ; Determining the lower bound ; Determining the upper bound ; Filling the dp array with values ; Filling the max_length array with max length of subsequence till now ; return the max length of subsequence ; Driver Code"
Javascript;"function areAllNegative ( arr ) { let n = arr . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) return false ; } return true ; } function getRightToLeftKadane ( arr ) { let max_so_far = 0 , max_ending_here = 0 ; let size = arr . length ; let new_arr = new Array ( size ) ; for ( let i = 0 ; i < size ; i ++ ) new_arr [ i ] = arr [ i ] ; for ( let i = size - 1 ; i >= 0 ; i -- ) { max_ending_here = max_ending_here + new_arr [ i ] ; if ( max_ending_here < 0 ) max_ending_here = 0 ; else if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; new_arr [ i ] = max_so_far ; } return new_arr ; } function getPrefixSum ( arr ) { let n = arr . length ; let new_arr = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) new_arr [ i ] = arr [ i ] ; for ( let i = 1 ; i < n ; i ++ ) new_arr [ i ] = new_arr [ i - 1 ] + new_arr [ i ] ; return new_arr ; } function maxSumSubArr ( a ) { let max_so_far = 0 , max_ending_here = 0 ; let n = a . length ; for ( let i = 0 ; i < n ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_ending_here < 0 ) max_ending_here = 0 ; else if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; } return max_so_far ; } function maxSumSubWithOp ( arr ) { let kadane_r_to_l = getRightToLeftKadane ( arr ) ; let size = arr . length ; let prefixSum = getPrefixSum ( arr ) ; for ( let i = 1 ; i < size ; i ++ ) { prefixSum [ i ] = Math . max ( prefixSum [ i - 1 ] , prefixSum [ i ] ) ; } let max_subarray_sum = 0 ; for ( let i = 0 ; i < size - 1 ; i ++ ) { max_subarray_sum = Math . max ( max_subarray_sum , prefixSum [ i ] + kadane_r_to_l [ i + 1 ] ) ; } return max_subarray_sum ; } function maxSum ( arr , size ) { if ( areAllNegative ( arr ) ) { let mx = - 1000000000 ; for ( let i = 0 ; i < size ; i ++ ) { if ( arr [ i ] > mx ) mx = arr [ i ] ; } return mx ; } let resSum = maxSumSubArr ( arr ) ; resSum = Math . max ( resSum , maxSumSubWithOp ( arr ) ) ; let reverse_arr = new Array ( size ) ; for ( let i = 0 ; i < size ; i ++ ) reverse_arr [ size - 1 - i ] = arr [ i ] ; resSum = Math . max ( resSum , maxSumSubWithOp ( reverse_arr ) ) ; return resSum ; } let arr = [ - 9 , 21 , 24 , 24 , - 51 , - 6 , 17 , - 42 , - 39 , 33 ] ; let size = arr . length ; document . write ( maxSum ( arr , size ) ) ;";"Maximum sum subarray after altering the array | Function that returns true if all the array element are <= 0 ; If any element is non - negative ; Function to return the vector representing the right to left Kadane array as described in the approach ; Function to return the prefix_sum vector ; Function to return the maximum sum subarray ; Function to get the maximum sum subarray in the modified array ; kadane_r_to_l [ i ] will store the maximum subarray sum for thre subarray arr [ i ... N - 1 ] ; Get the prefix sum array ; To get max_prefix_sum_at_any_index ; Summation of both gives the maximum subarray sum after applying the operation ; Function to return the maximum subarray sum after performing the given operation at most once ; If all element are negative then return the maximum element ; Maximum subarray sum without performing any operation ; Maximum subarray sum after performing the operations of first type ; Reversing the array to use the same existing function for operations of the second type ; Driver code"
Javascript;"function max_sum ( a , n ) { var dp = Array ( n + 1 ) . fill ( ) . map ( ( ) => Array ( 2 ) . fill ( 0 ) ) ; dp [ 0 ] [ 0 ] = 0 ; dp [ 0 ] [ 1 ] = - 999999 ; for ( i = 0 ; i <= n - 1 ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] + a [ i ] , dp [ i ] [ 1 ] - a [ i ] ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] - a [ i ] , dp [ i ] [ 1 ] + a [ i ] ) ; } return dp [ n ] [ 0 ] ; } var a = [ - 10 , 5 , - 4 ] ; var n = a . length ; document . write ( max_sum ( a , n ) ) ;";"Maximum possible array sum after performing the given operation | Function to return the maximum possible sum after performing the given operation ; Dp vector to store the answer ; Base value ; Return the maximum sum ; Driver code"
Javascript;"let MOD = 1000000007 ; function number_of_ways ( arr , n , k ) { if ( k == 1 ) return 1 ; let dp = new Array ( k + 1 ) ; let i ; for ( i = 0 ; i < k + 1 ; i ++ ) dp [ i ] = - 1 ; for ( i = 0 ; i < n ; i ++ ) dp [ arr [ i ] ] = 0 ; dp [ 0 ] = 1 ; dp [ 1 ] = ( dp [ 1 ] == - 1 ) ? 1 : dp [ 1 ] ; for ( i = 2 ; i <= k ; ++ i ) { if ( dp [ i ] == 0 ) continue ; dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] ; dp [ i ] %= MOD ; } return dp [ k ] ; } let arr = [ 3 ] ; let n = arr . length ; let k = 6 ; document . write ( number_of_ways ( arr , n , k ) ) ;";"Find the number of ways to reach Kth step in stair case | JavaScript implementation of the approach ; Function to return the number of ways to reach the kth step ; Create the dp array ; Broken steps ; Calculate the number of ways for the rest of the positions ; If it is a blocked position ; Number of ways to get to the ith step ; Return the required answer ; Driver code"
Javascript;"function findCount ( n ) { return parseInt ( Math . log ( n ) / Math . log ( 2 ) , 10 ) + 1 ; } let N = 10 ; document . write ( findCount ( N ) ) ;";"Minimum number of coins that can generate all the values in the given range | Function to find minimum number of coins ; Driver code"
Javascript;"function count ( n ) { let count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; } function findSetBits ( n ) { for ( let i = 0 ; i <= n ; i ++ ) document . write ( count ( i ) + "" "" ) ; } let n = 5 ; findSetBits ( n ) ;";"Calculate the number of set bits for every number from 0 to N | Javascript implementation of the approach ; Function to find the count of set bits in all the integers from 0 to n ; Driver code"
Javascript;"function countWays ( n ) { let a = [ ] ; let i = 1 ; while ( i <= n ) a . push ( i ++ ) ; let ways = 0 ; do { let flag = ( a [ 0 ] == 1 ) ; for ( let j = 1 ; j < n ; j ++ ) { if ( Math . abs ( a [ j ] - a [ j - 1 ] ) > 2 ) flag = false ; } if ( flag ) ways ++ ; } while ( next_permutation ( a ) ) ; return ways ; } function next_permutation ( p ) { for ( let a = p . length - 2 ; a >= 0 ; -- a ) { if ( p [ a ] < p [ a + 1 ] ) { for ( let b = p . length - 1 ; ; -- b ) { if ( p [ b ] > p [ a ] ) { let t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; for ( ++ a , b = p . length - 1 ; a < b ; ++ a , -- b ) { t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; } return true ; } } } } return false ; } let n = 6 ; document . write ( countWays ( n ) ) ;";"Count number of ways to arrange first N numbers | Function to return the count of required arrangements ; Create a vector ; Store numbers from 1 to n ; To store the count of ways ; Generate all the permutations using next_permutation in STL ; Initialize flag to true if first element is 1 else false ; Checking if the current permutation satisfies the given conditions ; If the current permutation is invalid then set the flag to false ; If valid arrangement ; Generate the next permutation ;  ; Driver code"
Javascript;"function countWays ( n ) { let dp = new Array ( n + 1 ) ; dp [ 0 ] = 0 ; dp [ 1 ] = 1 ; dp [ 2 ] = 1 ; for ( let i = 3 ; i <= n ; i ++ ) { dp [ i ] = dp [ i - 1 ] + dp [ i - 3 ] + 1 ; } return dp [ n ] ; } let n = 6 ; document . write ( countWays ( n ) ) ;";"Count number of ways to arrange first N numbers | Function to return the count of required arrangements ; Create the dp array ; Initialize the base cases as explained above ; ( 12 ) as the only possibility ; Generate answer for greater values ; dp [ n ] contains the desired answer ; Driver code"
Javascript;"function NumberOfShortestPaths ( n , m ) { var a = Array ( n ) . fill ( ) . map ( ( ) => Array ( m ) . fill ( 0 ) ) ; for ( var i = n - 1 ; i >= 0 ; i -- ) { for ( j = 0 ; j < m ; j ++ ) { if ( j == 0 i == n - 1 ) a [ i ] [ j ] = 1 ; else a [ i ] [ j ] = a [ i ] [ j - 1 ] + a [ i + 1 ] [ j ] ; } } for ( var i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { document . write ( a [ i ] [ j ] + "" "" ) ; } document . write ( "" "" ) ; } } var n = 5 , m = 2 ; NumberOfShortestPaths ( n , m ) ;";"Number of shortest paths to reach every cell from bottom | Function to find number of shortest paths ; Compute the grid starting from the bottom - left corner ; Prvar the grid ; Driver code ; Function call"
Javascript;"function Max_Sum ( arr1 , arr2 , n ) { let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n ; i ++ ) { if ( i == 0 ) { dp [ i ] [ 0 ] = arr1 [ i ] ; dp [ i ] [ 1 ] = arr2 [ i ] ; continue ; } dp [ i ] [ 0 ] = Math . max ( dp [ i - 1 ] [ 0 ] , dp [ i - 1 ] [ 1 ] + arr1 [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( dp [ i - 1 ] [ 1 ] , dp [ i - 1 ] [ 0 ] + arr2 [ i ] ) ; } return Math . max ( dp [ n - 1 ] [ 0 ] , dp [ n - 1 ] [ 1 ] ) ; } let arr1 = [ 9 , 3 , 5 , 7 , 3 ] ; let arr2 = [ 5 , 8 , 1 , 4 , 5 ] ; let n = arr1 . length ; document . write ( Max_Sum ( arr1 , arr2 , n ) ) ;";"Maximum sum combination from two arrays | Function to maximum sum combination from two arrays ; To store dp value ; For loop to calculate the value of dp ; Return the required answer ; Driver code ; Function call"
Javascript;"function checkpossible ( mask , arr , prefix , n , k ) { let i , j ; let dp = new Array ( n + 1 ) ; for ( i = 0 ; i < n + 1 ; i ++ ) { dp [ i ] = new Array ( k + 1 ) ; for ( j = 0 ; j < k + 1 ; j ++ ) { dp [ i ] [ j ] = false ; } } dp [ 0 ] [ 0 ] = true ; for ( i = 1 ; i <= n ; i ++ ) { for ( j = 1 ; j <= k ; j ++ ) { for ( let l = i - 1 ; l >= 0 ; -- l ) { if ( dp [ l ] [ j - 1 ] && ( ( ( prefix [ i ] - prefix [ l ] ) & mask ) == mask ) ) { dp [ i ] [ j ] = true ; break ; } } } } return dp [ n ] [ k ] ; } function Partition ( arr , n , k ) { let prefix = new Array ( n + 1 ) ; prefix . fill ( 0 ) ; for ( let i = 1 ; i <= n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + arr [ i ] ; } let LOGS = 20 ; let ans = 0 ; for ( let i = LOGS ; i >= 0 ; -- i ) { if ( checkpossible ( ans | ( 1 << i ) , arr , prefix , n , k ) ) { ans = ans | ( 1 << i ) ; } } return ans ; } let arr = [ 0 , 1 , 2 , 7 , 10 , 23 , 21 , 6 , 8 , 7 , 3 ] , k = 2 ; let n = arr . length - 1 ; document . write ( Partition ( arr , n , k ) ) ;";"Partition the array in K segments such that bitwise AND of individual segment sum is maximized | Function to check whether a k segment partition is possible such that bitwise AND is ' mask ' ; dp [ i ] [ j ] stores whether it is possible to partition first i elements into j segments such that all j segments are ' good ' ; Initialising dp ; Filling dp in bottom - up manner ; Finding a cut such that first l elements can be partitioned into j - 1 ' good ' segments and arr [ l + 1 ] + ... + arr [ i ] is a ' good ' segment ; Function to find maximum possible AND ; Array to store prefix sums ; Maximum no of bits in the possible answer ; This will store the final answer ; Constructing answer greedily selecting from the higher most bit ; Checking if array can be partitioned such that the bitwise AND is ans | ( 1 << i ) ; if possible , update the answer ; Return the final answer ; Driver code ; n = 11 , first element is zero to make array 1 based indexing . So , number of elements are 10 ; Function call"
Javascript;"let RODS = 3 ; let N = 3 ; let dp = new Array ( N + 1 ) ; function initialize ( ) { for ( let i = 0 ; i <= N ; i += 1 ) { dp [ i ] = new Array ( RODS + 1 ) ; for ( let j = 1 ; j <= RODS ; j ++ ) { dp [ i ] [ j ] = new Array ( RODS + 1 ) ; for ( let k = 1 ; k <= RODS ; k += 1 ) { dp [ i ] [ j ] [ k ] = Number . MAX_VALUE ; } } } } function mincost ( idx , src , dest , costs ) { if ( idx > N ) return 0 ; if ( dp [ idx ] [ src ] [ dest ] != Number . MAX_VALUE ) return dp [ idx ] [ src ] [ dest ] ; let rem = 6 - ( src + dest ) ; let ans = Number . MAX_VALUE ; let case1 = costs [ src - 1 ] [ dest - 1 ] + mincost ( idx + 1 , src , rem , costs ) + mincost ( idx + 1 , rem , dest , costs ) ; let case2 = costs [ src - 1 ] [ rem - 1 ] + mincost ( idx + 1 , src , dest , costs ) + mincost ( idx + 1 , dest , src , costs ) + costs [ rem - 1 ] [ dest - 1 ] + mincost ( idx + 1 , src , dest , costs ) ; ans = Math . min ( case1 , case2 ) ; dp [ idx ] [ src ] [ dest ] = ans ; return ans ; } let costs = [ [ 0 , 1 , 2 ] , [ 2 , 0 , 1 ] , [ 3 , 2 , 0 ] ] ; initialize ( ) ; document . write ( mincost ( 1 , 1 , 3 , costs ) ) ;";"Cost Based Tower of Hanoi | Javascript implementation of the approach ; Function to initialize the dp table ; Initialize with maximum value ; Function to return the minimum cost ; Base case ; If problem is already solved , return the pre - calculated answer ; Number of the auxiliary disk ; Initialize the minimum cost as Infinity ; Calculationg the cost for first case ; Calculating the cost for second case ; Minimum of both the above cases ; Store it in the dp table ; Return the minimum cost ; Driver code"
Javascript;"let C = 5 ; let R = 3 ; let INT_MAX = 10000000 ; let table = new Array ( R ) ; let visited = new Array ( R ) ; for ( let i = 0 ; i < R ; i ++ ) { table [ i ] = new Array ( C ) ; visited [ i ] = new Array ( C ) ; } function min ( p , q , r , s ) { let temp1 = p < q ? p : q ; let temp2 = r < s ? r : s ; if ( temp1 < temp2 ) return temp1 ; return temp2 ; } function Distance ( arr , i , j ) { if ( i >= R j >= C i < 0 j < 0 ) return INT_MAX ; else if ( arr [ i ] [ j ] == 0 ) { table [ i ] [ j ] = INT_MAX ; return INT_MAX ; } else if ( arr [ i ] [ j ] == 2 ) { table [ i ] [ j ] = 0 ; return 0 ; } else if ( visited [ i ] [ j ] == 1 ) { return INT_MAX ; } else { visited [ i ] [ j ] = 1 ; let temp1 = Distance ( arr , i + 1 , j ) ; let temp2 = Distance ( arr , i - 1 , j ) ; let temp3 = Distance ( arr , i , j + 1 ) ; let temp4 = Distance ( arr , i , j - 1 ) ; let min_value = 1 + min ( temp1 , temp2 , temp3 , temp4 ) ; if ( table [ i ] [ j ] > 0 && table [ i ] [ j ] < INT_MAX ) { if ( min_value < table [ i ] [ j ] ) table [ i ] [ j ] = min_value ; } else table [ i ] [ j ] = min_value ; visited [ i ] [ j ] = 0 ; } return table [ i ] [ j ] ; } function minTime ( arr ) { let max = 0 ; for ( let i = 0 ; i < R ; i ++ ) { for ( let j = 0 ; j < C ; j ++ ) { if ( arr [ i ] [ j ] == 1 ) Distance ( arr , i , j ) ; } } for ( let i = 0 ; i < R ; i ++ ) { for ( let j = 0 ; j < C ; j ++ ) { if ( arr [ i ] [ j ] == 1 && table [ i ] [ j ] > max ) max = table [ i ] [ j ] ; } } if ( max < INT_MAX ) return max ; return - 1 ; } let arr = [ [ 2 , 1 , 0 , 2 , 1 ] , [ 0 , 0 , 1 , 2 , 1 ] , [ 1 , 0 , 0 , 2 , 1 ] ] document . write ( minTime ( arr ) ) ;";"Minimum time required to rot all oranges | Dynamic Programming | Javascript implementation of the approach ; DP table to memoize the values ; Visited array to keep track of visited nodes in order to avoid infinite loops ; Function to return the minimum of four numbers ; Function to return the minimum distance to any rotten orange from [ i , j ] ; If i , j lie outside the array ; If 0 then it can 't lead to  any path so return INT_MAX ; If 2 then we have reached our rotten oranges so return from here ; If this node is already visited then return to avoid infinite loops ; Mark the current node as visited ; Check in all four possible directions ; Take the minimum of all ; If result already exists in the table check if min_value is less than existing value ; Function to return the minimum time required to rot all the oranges ; Calculate the minimum distances to any rotten orange from all the fresh oranges ; Pick the maximum distance of fresh orange to some rotten orange ; If all oranges can be rotten ; Driver Code"
Javascript;"let maxLen = 10 ; let dp = new Array ( maxLen ) ; let visit = new Array ( maxLen ) ; function maxSum ( arr , i , n , k ) { if ( i >= n ) return 0 ; if ( visit [ i ] ) return dp [ i ] ; visit [ i ] = true ; let tot = 0 ; dp [ i ] = maxSum ( arr , i + 1 , n , k ) ; for ( let j = i ; j < ( i + k ) && ( j < n ) ; j ++ ) { tot += arr [ j ] ; dp [ i ] = Math . max ( dp [ i ] , tot + maxSum ( arr , j + 2 , n , k ) ) ; } return dp [ i ] ; } let arr = [ - 1 , 2 , - 3 , 4 , 5 ] ; let k = 2 ; let n = arr . length ; document . write ( maxSum ( arr , 0 , n , k ) ) ;";"Maximum sum of non | Javascript program to implement above approach ; Variable to store states of dp ; Variable to check if a given state has been solved ; Function to find the maximum sum subsequence such that no two elements are adjacent ; Base case ; To check if a state has been solved ; Variable to store prefix sum for sub - array { i , j } ; Required recurrence relation ; Returning the value ; Input array"
Javascript;"let dp = new Array ( 1024 ) ; dp . fill ( - 1 ) ; function get_binary ( u ) { let ans = 0 ; while ( u > 0 ) { let rem = u % 10 ; ans |= ( 1 << rem ) ; u = parseInt ( u / 10 , 10 ) ; } return ans ; } function recur ( u , array , n ) { if ( u == 0 ) return 0 ; if ( dp [ u ] != - 1 ) return dp [ u ] ; for ( let i = 0 ; i < n ; i ++ ) { let mask = get_binary ( array [ i ] ) ; if ( ( mask u ) == u ) { dp [ u ] = Math . max ( Math . max ( 0 , dp [ u ^ mask ] ) + array [ i ] , dp [ u ] ) ; } } return dp [ u ] ; } function solve ( array , n ) { for ( let i = 0 ; i < ( 1 << 10 ) ; i ++ ) { dp [ i ] = - 1 ; } let ans = 0 ; for ( let i = 0 ; i < ( 1 << 10 ) ; i ++ ) { ans = Math . max ( ans , recur ( i , array , n ) ) ; } return ans ; } let array = [ 22 , 132 , 4 , 45 , 12 , 223 ] ; let n = array . length ; document . write ( solve ( array , n ) ) ;";"Maximum subset sum such that no two elements in set have same digit in them | Javascript implementation of above approach ; Function to create mask for every number ; Recursion for Filling DP array ; Base Condition ; Recurrence Relation ; Function to find Maximum Subset Sum ; Initialize DP array ; Iterate over all possible masks of 10 bit number ; Driver Code"
Javascript;"let SIZE = 3 ; let N = 3 ; function minSum ( A , B , C , i , n , curr , dp ) { if ( n <= 0 ) return 0 ; if ( dp [ n ] [ curr ] != - 1 ) return dp [ n ] [ curr ] ; if ( curr == 0 ) { return dp [ n ] [ curr ] = Math . min ( B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; } if ( curr == 1 ) return dp [ n ] [ curr ] = Math . min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , C [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 2 , dp ) ) ; return dp [ n ] [ curr ] = Math . min ( A [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 0 , dp ) , B [ i ] + minSum ( A , B , C , i + 1 , n - 1 , 1 , dp ) ) ; } let A = [ 1 , 50 , 1 ] ; let B = [ 50 , 50 , 50 ] ; let C = [ 50 , 50 , 50 ] ; let dp = new Array ( SIZE ) ; for ( let i = 0 ; i < SIZE ; i ++ ) { dp [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } document . write ( Math . min ( A [ 0 ] + minSum ( A , B , C , 1 , SIZE - 1 , 0 , dp ) , Math . min ( B [ 0 ] + minSum ( A , B , C , 1 , SIZE - 1 , 1 , dp ) , C [ 0 ] + minSum ( A , B , C , 1 , SIZE - 1 , 2 , dp ) ) ) ) ;";"Minimize the sum after choosing elements from the given three arrays | Javascript implementation of the above approach ; Function to return the minimized sum ; If all the indices have been used ; If this value is pre - calculated then return its value from dp array instead of re - computing it ; If A [ i - 1 ] was chosen previously then only B [ i ] or C [ i ] can chosen now choose the one which leads to the minimum sum ; If B [ i - 1 ] was chosen previously then only A [ i ] or C [ i ] can chosen now choose the one which leads to the minimum sum ; If C [ i - 1 ] was chosen previously then only A [ i ] or B [ i ] can chosen now choose the one which leads to the minimum sum ; Driver code ; Initialize the dp [ ] [ ] array ; min ( start with A [ 0 ] , start with B [ 0 ] , start with C [ 0 ] )"
Javascript;"let n = 3 ; let dp = new Array ( n ) ; let v = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; v [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = new Array ( 2 ) ; v [ i ] [ j ] = new Array ( 2 ) ; for ( let k = 0 ; k < 2 ; k ++ ) { dp [ i ] [ j ] [ k ] = 0 ; v [ i ] [ j ] [ k ] = 0 ; } } } function max ( a , b , c ) { let m = a ; if ( m < b ) { m = b ; } if ( m < c ) { m = c ; } return m ; } function maxScore ( arr , i , j , s ) { if ( i > n - 1 i < 0 j > n - 1 ) { return 0 ; } if ( i == 0 && j == n - 1 ) { return arr [ i ] [ j ] ; } if ( v [ i ] [ j ] [ s ] ) { return dp [ i ] [ j ] [ s ] ; } v [ i ] [ j ] [ s ] = true ; if ( s != 1 ) { dp [ i ] [ j ] [ s ] = arr [ i ] [ j ] + Math . max ( maxScore ( arr , i + 1 , j , s ) , Math . max ( maxScore ( arr , i , j + 1 , s ) , maxScore ( arr , i - 1 , j , ( s == 1 ) ? 0 : 1 ) ) ) ; else { dp [ i ] [ j ] [ s ] = arr [ i ] [ j ] + Math . max ( maxScore ( arr , i - 1 , j , s ) , maxScore ( arr , i , j + 1 , s ) ) ; } return dp [ i ] [ j ] [ s ] ; } let arr = [ [ 1 , 1 , 1 ] , [ 1 , 5 , 1 ] , [ 1 , 1 , 1 ] ] ; document . write ( maxScore ( arr , 0 , 0 , 0 ) ) ;";"Maximise matrix sum by following the given Path | Javascript implementation of the approach ; To store the states of the DP ; Function to return the maximum of the three integers ; Function to return the maximum score ; Base cases ; If the state has already been solved then return it ; Marking the state as solved ; Growing phase ; } Shrinking phase ; Returning the solved state ; Driver code"
Javascript;"function MaximumMarks ( marksarr , timearr , h , n , p ) { let no_of_topics = n + 1 ; let total_time = h + 1 ; let T = new Array ( no_of_topics ) ; for ( let i = 0 ; i < no_of_topics ; i ++ ) { T [ i ] = new Array ( total_time ) ; for ( let j = 0 ; j < total_time ; j ++ ) { T [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < no_of_topics ; i ++ ) { T [ i ] [ 0 ] = 0 ; } for ( let j = 0 ; j < total_time ; j ++ ) { T [ 0 ] [ j ] = 0 ; } for ( let i = 1 ; i < no_of_topics ; i ++ ) { for ( let j = 1 ; j < total_time ; j ++ ) { if ( j < timearr [ i ] ) { T [ i ] [ j ] = T [ i - 1 ] [ j ] ; } else { T [ i ] [ j ] = Math . max ( marksarr [ i ] + T [ i - 1 ] [ j - timearr [ i ] ] , T [ i - 1 ] [ j ] ) ; } } } let i = no_of_topics - 1 , j = total_time - 1 ; let sum = 0 ; while ( i > 0 && j > 0 ) { if ( T [ i ] [ j ] == T [ i - 1 ] [ j ] ) { i -- ; } else { sum += timearr [ i ] ; j -= timearr [ i ] ; i -- ; } } let marks = T [ no_of_topics - 1 ] [ total_time - 1 ] ; if ( marks < p ) return - 1 ; return sum ; } let n = 4 , h = 10 , p = 10 ; let marksarr = [ 0 , 6 , 4 , 2 , 8 ] ; let timearr = [ 0 , 4 , 6 , 2 , 7 ] ; document . write ( MaximumMarks ( marksarr , timearr , h , n , p ) ) ;";"Find maximum topics to prepare in order to pass the exam | Function to return the maximum marks by considering topics which can be completed in the given time duration ; If we are given 0 time then nothing can be done So all values are 0 ; If we are given 0 topics then the time required will be 0 for sure ; Calculating the maximum marks that can be achieved under the given time constraints ; If time taken to read that topic is more than the time left now at position j then do no read that topic ; Two cases arise : 1 ) Considering current topic 2 ) Ignoring current topic We are finding maximum of ( current topic weightage + topics which can be done in leftover time - current topic time ) and ignoring current topic weightage sum ; Moving upwards in table from bottom right to calculate the total time taken to read the topics which can be done in given time and have highest weightage sum ; It means we have not considered reading this topic for max weightage sum ; Adding the topic time ; Evaluating the left over time after considering this current topic ; One topic completed ; It contains the maximum weightage sum formed by considering the topics ; Condition when exam cannot be passed ; Return the marks that can be obtained after passing the exam ; Number of topics , hours left and the passing marks ; n + 1 is taken for simplicity in loops Array will be indexed starting from 1"
Javascript;"let maxLen = 10 ; let maskLen = 130 ; let dp = new Array ( maxLen ) ; for ( let i = 0 ; i < maxLen ; i ++ ) { dp [ i ] = new Array ( maskLen ) ; } let v = new Array ( maxLen ) ; for ( let i = 0 ; i < maxLen ; i ++ ) { v [ i ] = new Array ( maskLen ) ; } function minSteps ( arr , i , mask , n ) { if ( i == n - 1 ) { return 0 ; } if ( i > n - 1 i < 0 ) { return 9999999 ; } if ( ( mask >> i ) % 2 == 1 ) { return 9999999 ; } if ( v [ i ] [ mask ] ) { return dp [ i ] [ mask ] ; } v [ i ] [ mask ] = true ; dp [ i ] [ mask ] = 1 + Math . min ( minSteps ( arr , i - arr [ i ] , ( mask | ( 1 << i ) ) , n ) , minSteps ( arr , i + arr [ i ] , ( mask | ( 1 << i ) ) , n ) ) ; return dp [ i ] [ mask ] ; } let arr = [ 1 , 2 , 2 , 2 , 1 , 1 ] ; let n = arr . length ; let ans = minSteps ( arr , 0 , 0 , n ) ; if ( ans >= 9999999 ) { document . write ( - 1 ) ; } else { document . write ( ans ) ; }";"Minimize the number of steps required to reach the end of the array | Javascript implementation of the above approach ; variable to store states of dp ; variable to check if a given state has been solved ; Function to find the minimum number of steps required to reach the end of the array ; base case ; to check if a state has been solved ; required recurrence relation ; returning the value ; Driver code"
Javascript;"function oSRec ( arr , i , j , sum ) { if ( j == i + 1 ) return Math . max ( arr [ i ] , arr [ j ] ) ; return Math . max ( ( sum - oSRec ( arr , i + 1 , j , sum - arr [ i ] ) ) , ( sum - oSRec ( arr , i , j - 1 , sum - arr [ j ] ) ) ) ; } function optimalStrategyOfGame ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; } return oSRec ( arr , 0 , n - 1 , sum ) ; } let arr1 = [ 8 , 15 , 3 , 7 ] ; let n = arr1 . length ; document . write ( optimalStrategyOfGame ( arr1 , n ) + "" "" ) ; let arr2 = [ 2 , 2 , 2 , 2 ] ; n = arr2 . length ; document . write ( optimalStrategyOfGame ( arr2 , n ) + "" "" ) ; let arr3 = [ 20 , 30 , 2 , 2 , 2 , 10 ] ; n = arr3 . length ; document . write ( optimalStrategyOfGame ( arr3 , n ) + "" "" ) ;";"Optimal Strategy for a Game | Set 2 | Javascript program to find out maximum value from a given sequence of coins ; For both of your choices , the opponent gives you total sum minus maximum of his value ; Returns optimal value possible that a player can collect from an array of coins of size n . Note than n must be even ; Driver code"
Javascript;"function ispower ( n ) { if ( n < 125 ) return ( n == 1 n == 5 n == 25 ) ; if ( n % 125 != 0 ) return false ; else return ispower ( parseInt ( n / 125 ) ) ; } function number ( s , i , j ) { var ans = 0 ; for ( var x = i ; x < j ; x ++ ) { ans = ans * 2 + ( s [ x ] - ' ' ) ; } return ans ; } function minCuts ( s , n ) { var dp = Array ( n + 1 ) . fill ( n + 1 ) ; dp [ 0 ] = 0 ; for ( var i = 1 ; i <= n ; i ++ ) { if ( s [ i - 1 ] == ' ' ) continue ; for ( var j = 0 ; j < i ; j ++ ) { if ( s [ j ] == ' ' ) continue ; var num = number ( s , j , i ) ; if ( ! ispower ( num ) ) continue ; dp [ i ] = Math . min ( dp [ i ] , dp [ j ] + 1 ) ; } } return ( ( dp [ n ] < n + 1 ) ? dp [ n ] : - 1 ) ; } var s = "" "" ; var n = s . length ; document . write ( minCuts ( s , n ) ) ;";"Minimum number of sub | Function that returns true if n is a power of 5 ; Function to return the decimal value of binary equivalent ; Function to return the minimum cuts required ; Allocating memory for dp [ ] array ; From length 1 to n ; If previous character is '0' then ignore to avoid number with leading 0 s . ; Ignore s [ j ] = '0' starting numbers ; Number formed from s [ j ... . i ] ; Check for power of 5 ; Assigning min value to get min cut possible ; ( n + 1 ) to check if all the strings are traversed and no divisible by 5 is obtained like 000000 ; Driver code"
Javascript;"function MinOfCubed ( k ) { if ( k < 8 ) return k ; let res = k ; for ( let i = 1 ; i <= k ; i ++ ) { if ( ( i * i * i ) > k ) return res ; res = Math . min ( res , MinOfCubed ( k - ( i * i * i ) ) + 1 ) ; } return res ; } let num = 15 ; document . write ( MinOfCubed ( num ) ) ;";"Minimum number of cubes whose sum equals to given number N | Function to return the minimum number of cubes whose sum is k ; If k is less than the 2 ^ 3 ; Initialize with the maximum number of cubes required ; Driver code"
Javascript;"function MinOfCubedDP ( k ) { let DP = new Array ( k + 1 ) ; DP . fill ( 0 ) ; let j = 1 , t = 1 ; DP [ 0 ] = 0 ; for ( let i = 1 ; i <= k ; i ++ ) { DP [ i ] = Number . MAX_VALUE ; while ( j <= i ) { if ( j == i ) DP [ i ] = 1 ; else if ( DP [ i ] > DP [ i - j ] ) DP [ i ] = DP [ i - j ] + 1 ; t ++ ; j = t * t * t ; } t = j = 1 ; } return DP [ k ] ; } let num = 15 ; document . write ( MinOfCubedDP ( num ) ) ;";"Minimum number of cubes whose sum equals to given number N | Function to return the minimum number of cubes whose sum is k ; While current perfect cube is less than current element ; If i is a perfect cube ; i = ( i - 1 ) + 1 ^ 3 ; Next perfect cube ; Re - initialization for next element ; Driver code"
Javascript;"function maxSum ( a , n ) { let ans = 0 ; let arr = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) arr [ i ] = a [ i - 1 ] ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; ++ i ) { dp [ i ] = new Array ( 3 ) ; for ( let j = 0 ; j < 3 ; ++ j ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= n ; ++ i ) { dp [ i ] [ 0 ] = Math . max ( arr [ i ] , dp [ i - 1 ] [ 0 ] + arr [ i ] ) ; dp [ i ] [ 1 ] = Math . max ( 0 , dp [ i - 1 ] [ 0 ] ) - arr [ i ] ; if ( i >= 2 ) dp [ i ] [ 1 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i - 1 ] [ 1 ] + arr [ i ] ) ; if ( i >= 2 ) dp [ i ] [ 2 ] = dp [ i - 1 ] [ 1 ] - arr [ i ] ; if ( i >= 3 ) dp [ i ] [ 2 ] = Math . max ( dp [ i ] [ 2 ] , dp [ i - 1 ] [ 2 ] + arr [ i ] ) ; ans = Math . max ( ans , dp [ i ] [ 0 ] ) ; ans = Math . max ( ans , dp [ i ] [ 1 ] ) ; ans = Math . max ( ans , dp [ i ] [ 2 ] ) ; } return ans ; } let arr = [ - 5 , 3 , 2 , 7 , - 8 , 3 , 7 , - 9 , 10 , 12 , - 6 ] ; let n = arr . length ; document . write ( maxSum ( arr , n ) ) ;";"Maximum Subarray Sum after inverting at most two elements | Function to return the maximum required sub - array sum ; Creating one based indexing ; 2d array to contain solution for each step ; Case 1 : Choosing current or ( current + previous ) whichever is smaller ; Case 2 : ( a ) Altering sign and add to previous case 1 or value 0 ; Case 2 : ( b ) Adding current element with previous case 2 and updating the maximum ; Case 3 : ( a ) Altering sign and add to previous case 2 ; Case 3 : ( b ) Adding current element with previous case 3 ; Updating the maximum value of variable ans ; Return the final solution ; Driver code"
Javascript;"function maxSum ( arr , k , n ) { if ( n == 0 ) return 0 ; if ( n == 1 ) return arr [ 0 ] ; if ( n == 2 ) return Math . max ( arr [ 0 ] , arr [ 1 ] ) ; let dp = new Array ( n ) ; dp [ 0 ] = arr [ 0 ] ; for ( let i = 1 ; i <= k ; i ++ ) dp [ i ] = Math . max ( arr [ i ] , dp [ i - 1 ] ) ; for ( let i = k + 1 ; i < n ; i ++ ) dp [ i ] = Math . max ( arr [ i ] , dp [ i - ( k + 1 ) ] + arr [ i ] ) ; let max = Number . MIN_VALUE ; for ( let i = 0 ; i < dp . length ; i ++ ) { max = Math . max ( max , dp [ i ] ) ; } return max ; } let arr = [ 6 , 7 , 1 , 3 , 8 , 2 , 4 ] ; let n = arr . length ; let k = 2 ; document . write ( maxSum ( arr , k , n ) ) ;";"Maximum sum possible for a sub | Function to return the maximum sum possible ; dp [ i ] represent the maximum sum so far after reaching current position i ; Initialize dp [ 0 ] ; Initialize the dp values till k since any two elements included in the sub - sequence must be atleast k indices apart , and thus first element and second element will be k indices apart ; Fill remaining positions ; Return the maximum sum ; Driver code"
Javascript;"function MinimumCost ( a , n , x ) { for ( i = 1 ; i < n ; i ++ ) { a [ i ] = Math . min ( a [ i ] , 2 * a [ i - 1 ] ) ; } var ind = 0 ; var sum = 0 ; while ( x > 0 ) { if ( x != 0 ) sum += a [ ind ] ; ind ++ ; x = x >> 1 ; } return sum ; } var a = [ 20 , 50 , 60 , 90 ] ; var x = 7 ; var n = a . length ; document . write ( MinimumCost ( a , n , x ) ) ;";"Minimum cost to form a number X by adding up powers of 2 | Function to return the minimum cost ; Re - compute the array ; Add answers for set bits ; If bit is set ; Increase the counter ; Right shift the number ; Driver code"
Javascript;"function countWays ( n , l , r ) { let tL = l , tR = r ; let L = new Array ( 3 ) ; let R = new Array ( 3 ) ; L [ l % 2 ] = l ; R [ r % 2 ] = r ; l ++ ; r -- ; if ( l <= tR && r >= tL ) { L [ l % 2 ] = l ; R [ r % 2 ] = r ; } let cnt0 = 0 , cnt1 = 0 ; if ( R [ 0 ] > 0 && L [ 0 ] > 0 ) cnt0 = ( R [ 0 ] - L [ 0 ] ) / 2 + 1 ; if ( R [ 1 ] > 0 && L [ 1 ] > 0 ) cnt1 = ( R [ 1 ] - L [ 1 ] ) / 2 + 1 ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( 3 ) ; for ( let j = 0 ; j < 3 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 1 ] [ 0 ] = cnt0 ; dp [ 1 ] [ 1 ] = cnt1 ; for ( let i = 2 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = ( cnt0 * dp [ i - 1 ] [ 0 ] + cnt1 * dp [ i - 1 ] [ 1 ] ) ; dp [ i ] [ 1 ] = ( cnt0 * dp [ i - 1 ] [ 1 ] + cnt1 * dp [ i - 1 ] [ 0 ] ) ; } return dp [ n ] [ 0 ] ; } let n = 2 , l = 1 , r = 3 ; document . write ( countWays ( n , l , r ) ) ;";"Ways to form an array having integers in given range such that total sum is divisible by 2 | Function to return the number of ways to form an array of size n such that sum of all elements is divisible by 2 ; Represents first and last numbers of each type ( modulo 0 and 1 ) ; Count of numbers of each type between range ; Base Cases ; Ways to form array whose sum upto i numbers modulo 2 is 0 ; Ways to form array whose sum upto i numbers modulo 2 is 1 ; Return the required count of ways ; Driver Code"
Javascript;"let m = 1001 ; let MOD = 998244353 ; let dp = new Array ( m ) ; for ( let i = 0 ; i < m ; i ++ ) { dp [ i ] = new Array ( m ) ; for ( let j = 0 ; j < m ; j ++ ) { dp [ i ] [ j ] = 0 ; } } function solve ( idx , diff , N , M , K ) { if ( idx > N ) { if ( diff == K ) return 1 ; return 0 ; } if ( dp [ idx ] [ diff ] != - 1 ) return dp [ idx ] [ diff ] ; let ans = solve ( idx + 1 , diff , N , M , K ) ; ans += ( M - 1 ) * solve ( idx + 1 , diff + 1 , N , M , K ) ; dp [ idx ] [ diff ] = ans % MOD ; return dp [ idx ] [ diff ] ; } let N = 3 , M = 3 , K = 0 ; for ( let i = 0 ; i <= M ; i ++ ) for ( let j = 0 ; j <= M ; j ++ ) dp [ i ] [ j ] = - 1 ; document . write ( ( M * solve ( 2 , 0 , N , M , K ) ) ) ;";"Color N boxes using M colors such that K boxes have different color from the box on its left | JavaScript Program to Paint N boxes using M colors such that K boxes have color different from color of box on its left ; This function returns the required number of ways where idx is the current index and diff is number of boxes having different color from box on its left ; Base Case ; If already computed ; Either paint with same color as previous one ; Or paint with remaining ( M - 1 ) colors ; Driver code ; Multiply M since first box can be painted with any of the M colors and start solving from 2 nd box"
Javascript;"N = 3 ; function maxPathSum ( tri ) { var ans = 0 ; for ( var i = N - 2 ; i >= 0 ; i -- ) { for ( var j = 0 ; j < N - i ; j ++ ) { if ( j - 1 >= 0 ) tri [ i ] [ j ] += Math . max ( tri [ i + 1 ] [ j ] , tri [ i + 1 ] [ j - 1 ] ) ; else tri [ i ] [ j ] += tri [ i + 1 ] [ j ] ; ans = Math . max ( ans , tri [ i ] [ j ] ) ; } } return ans ; } var tri = [ [ 1 , 5 , 3 ] , [ 4 , 8 , 0 ] , [ 1 , 0 , 0 ] ] ; document . write ( maxPathSum ( tri ) ) ;";"Maximum path sum in an Inverted triangle | SET 2 | Javascript program implementation of Max sum problem in a triangle ; Function for finding maximum sum ; Loop for bottom - up calculation ; For each element , check both elements just below the number and below left to the number add the maximum of them to it ; Return the maximum sum ; Driver Code"
Javascript;"function subsetXOR ( arr , n , K ) { let max_ele = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; let m = ( 1 << parseInt ( Math . log ( max_ele ) / Math . log ( 2 ) + 1 , 10 ) ) - 1 ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( m + 1 ) ; for ( let j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = new Array ( n + 1 ) ; for ( let k = 0 ; k <= n ; k ++ ) { dp [ i ] [ j ] [ k ] = 0 ; } } } for ( let i = 0 ; i <= n ; i ++ ) dp [ i ] [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 0 ; j <= m ; j ++ ) { for ( let k = 0 ; k <= n ; k ++ ) { dp [ i ] [ j ] [ k ] = dp [ i - 1 ] [ j ] [ k ] ; if ( k != 0 ) { dp [ i ] [ j ] [ k ] += k * dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] [ k - 1 ] ; } } } } let ans = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { ans += dp [ n ] [ K ] [ i ] ; } return ans ; } let arr = [ 1 , 2 , 3 ] ; let k = 1 ; let n = arr . length ; document . write ( subsetXOR ( arr , n , k ) ) ;";"Count no . of ordered subsets having a particular XOR value | Returns count of ordered subsets of arr [ ] with XOR value = K ; Find maximum element in arr [ ] ; Maximum possible XOR value ; The value of dp [ i ] [ j ] [ k ] is the number of subsets of length k having XOR of their elements as j from the set arr [ 0. . . i - 1 ] ; Initializing all the values of dp [ i ] [ j ] [ k ] as 0 ; The xor of empty subset is 0 ; Fill the dp table ; The answer is the number of subsets of all lengths from set arr [ 0. . n - 1 ] having XOR of elements as k ; Driver Code"
Javascript;"function get_max_splits ( num_String ) { let count = 0 , current_num ; let running_sum = 0 ; for ( let i = 0 ; i < num_String . length ; i ++ ) { current_num = num_String [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ; running_sum += current_num ; if ( current_num % 3 == 0 || ( running_sum != 0 && running_sum % 3 == 0 ) ) { count += 1 ; running_sum = 0 ; } } return count ; } document . write ( get_max_splits ( "" "" ) + "" "" ) ;";"Possible cuts of a number such that maximum parts are divisible by 3 | JavaScript program to find the maximum number of numbers divisible by 3 in large number ; This will contain the count of the splits ; This will keep sum of all successive integers , when they are indivisible by 3 ; This is the condition of finding a split ; Driver code"
Javascript;"var M = 20 ; var dp = Array . from ( Array ( M ) , ( ) => Array ( M ) ) ; var d , K ; function count ( pos , cnt , tight , nonz , num ) { if ( pos == num . length ) { if ( cnt == K ) return 1 ; return 0 ; } if ( dp [ pos ] [ cnt ] [ tight ] [ nonz ] != - 1 ) return dp [ pos ] [ cnt ] [ tight ] [ nonz ] ; var ans = 0 ; var limit = ( tight ? 9 : num [ pos ] ) ; for ( var dig = 0 ; dig <= limit ; dig ++ ) { var currCnt = cnt ; if ( dig == d ) { if ( d != 0 || ( ! d && nonz ) ) currCnt ++ ; } var currTight = tight ; if ( dig < num [ pos ] ) currTight = 1 ; ans += count ( pos + 1 , currCnt , currTight , nonz || ( dig != 0 ? 1 : 0 ) , num ) ; } return dp [ pos ] [ cnt ] [ tight ] [ nonz ] = ans ; } function solve ( x ) { var num = [ ] ; while ( x ) { num . push ( x % 10 ) ; x = parseInt ( x / 10 ) ; } num . reverse ( ) ; for ( var i = 0 ; i < M ; i ++ ) for ( var j = 0 ; j < M ; j ++ ) dp [ i ] [ j ] = Array . from ( Array ( 2 ) , ( ) => Array ( 2 ) . fill ( - 1 ) ) return count ( 0 , 0 , 0 , 0 , num ) ; } var L = 11 , R = 100 ; d = 2 , K = 1 ; document . write ( solve ( R ) - solve ( L - 1 ) ) ;";"Count of Numbers in a Range where digit d occurs exactly K times | JavaScript Program to find the count of numbers in a range where digit d occurs exactly K times ; states - position , count , tight , nonz ; d is required digit and K is occurrence ; This function returns the count of required numbers from 0 to num ; Last position ; If this result is already computed simply return it ; Maximum limit upto which we can place digit . If tight is 1 , means number has already become smaller so we can place any digit , otherwise num [ pos ] ; Nonz is true if we placed a non zero digit at the starting of the number ; At this position , number becomes smaller ; Next recursive call , also set nonz to 1 if current digit is non zero ; Function to convert x into its digit vector and uses count ( ) function to return the required count ; Initialize dp ; Driver Code to test above functions"
Javascript;"function solve ( x ) { let ans = 0 , first , last , temp = x ; if ( x < 10 ) return x ; last = x % 10 ; while ( x > 0 ) { first = x % 10 ; x /= 10 ; } if ( first <= last ) ans = 9 + temp / 10 ; else ans = 8 + temp / 10 ; return ans ; } let L = 2 , R = 60 ; document . write ( ( solve ( R ) - solve ( L - 1 ) ) + "" "" ) ; L = 1 , R = 1000 ; document . write ( solve ( R ) - solve ( L - 1 ) ) ;";"Count of Numbers in Range where first digit is equal to last digit of the number | Javascript program to implement the above approach ; Base Case ; Calculating the last digit ; Calculating the first digit ; Driver code"
Javascript;"function findMinimumCost ( n , x , y ) { let dp = new Array ( n + 1 ) ; dp [ 1 ] = x ; for ( let i = 2 ; i <= n ; i ++ ) { if ( ( i & 1 ) != 0 ) { dp [ i ] = Math . min ( dp [ i - 1 ] + x , dp [ parseInt ( ( i + 1 ) / 2 , 10 ) ] + y + x ) ; } else { dp [ i ] = Math . min ( dp [ i - 1 ] + x , dp [ parseInt ( i / 2 , 10 ) ] + y ) ; } } return dp [ n ] ; } let n = 4 , x = 2 , y = 1 ; document . write ( findMinimumCost ( n , x , y ) ) ;";"Form N | Returns the minimum cost to form a n - copy string Here , x -> Cost to add / remove a single character ' G ' and y -> cost to append the string to itself ; Base Case : to form a 1 - copy string we need to perform an operation of type 1 ( i . e Add ) ; Case1 . Perform a Add operation on ( i - 1 ) - copy string , Case2 . Perform a type 2 operation on ( ( i + 1 ) / 2 ) - copy string ; Case1 . Perform a Add operation on ( i - 1 ) - copy string , Case2 . Perform a type 3 operation on ( i / 2 ) - copy string ; Driver Code"
Javascript;"let r = 4 , c = 5 ; function findMinSteps ( mat , n , m , dp , vis ) { if ( n == 0 || m == 0 || n == ( r - 1 ) || m == ( c - 1 ) ) { return 0 ; } if ( dp [ n ] [ m ] != - 1 ) return dp [ n ] [ m ] ; vis [ n ] [ m ] = true ; let ans1 , ans2 , ans3 , ans4 ; ans1 = ans2 = ans3 = ans4 = 1e9 ; if ( mat [ n - 1 ] [ m ] == 0 ) { if ( ! vis [ n - 1 ] [ m ] ) ans1 = 1 + findMinSteps ( mat , n - 1 , m , dp , vis ) ; } if ( mat [ n ] [ m + 1 ] == 0 ) { if ( ! vis [ n ] [ m + 1 ] ) ans2 = 1 + findMinSteps ( mat , n , m + 1 , dp , vis ) ; } if ( mat [ n ] [ m - 1 ] == 0 ) { if ( ! vis [ n ] [ m - 1 ] ) ans3 = 1 + findMinSteps ( mat , n , m - 1 , dp , vis ) ; } if ( mat [ n + 1 ] [ m ] == 0 ) { if ( ! vis [ n + 1 ] [ m ] ) ans4 = 1 + findMinSteps ( mat , n + 1 , m , dp , vis ) ; } dp [ n ] [ m ] = Math . min ( ans1 , Math . min ( ans2 , Math . min ( ans3 , ans4 ) ) ) ; return dp [ n ] [ m ] ; } function minimumSteps ( mat , n , m ) { let twox = - 1 ; let twoy = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { if ( mat [ i ] [ j ] == 2 ) { twox = i ; twoy = j ; break ; } } if ( twox != - 1 ) break ; } let dp = new Array ( r ) ; for ( let j = 0 ; j < r ; j ++ ) { dp [ j ] = new Array ( r ) ; for ( let i = 0 ; i < r ; i ++ ) { dp [ j ] [ i ] = - 1 ; } } let vis = new Array ( r ) ; for ( let j = 0 ; j < r ; j ++ ) { vis [ j ] = new Array ( r ) ; for ( let i = 0 ; i < r ; i ++ ) { vis [ j ] [ i ] = false ; } } let res = findMinSteps ( mat , twox , twoy , dp , vis ) ; if ( res >= 1e9 ) return - 1 ; else return res ; } let mat = [ [ 1 , 1 , 1 , 0 , 1 ] , [ 1 , 0 , 2 , 0 , 1 ] , [ 0 , 0 , 1 , 0 , 1 ] , [ 1 , 0 , 1 , 1 , 0 ] ] ; document . write ( minimumSteps ( mat , r , c ) ) ;";"Minimum steps to reach any of the boundary edges of a matrix | Set 1 | Javascript program to find Minimum steps to reach any of the boundary edges of a matrix ; Function to find out minimum steps ; boundary edges reached ; already had a route through this point , hence no need to re - visit ; visiting a position ; vertically up ; horizontally right ; horizontally left ; vertically down ; minimum of every path ; Function that returns the minimum steps ; index to store the location at which you are standing ; find '2' in the matrix ; Initialize dp matrix with - 1 ; Initialize vis matrix with false ; Call function to find out minimum steps using memoization and recursion ; if not possible ; Driver Code"
Javascript;"function nCr ( n , r ) { var ans = 1 ; if ( r > n - r ) r = n - r ; for ( var i = 0 ; i < r ; i ++ ) { ans *= n - i ; ans /= i + 1 ; } return ans ; } function countDerangements ( n ) { var der = [ ... Array ( n + 1 ) ] ; der [ 0 ] = 1 ; der [ 1 ] = 0 ; der [ 2 ] = 1 ; for ( var i = 3 ; i <= n ; i ++ ) der [ i ] = ( i - 1 ) * ( der [ i - 1 ] + der [ i - 2 ] ) ; return der [ n ] ; } function countPermutations ( n , k ) { var ans = 0 ; for ( var i = n - k ; i <= n ; i ++ ) { var ways = nCr ( n , i ) ; ans += ways * countDerangements ( n - i ) ; } return ans ; } var n = 5 , k = 3 ; document . write ( countPermutations ( n , k ) ) ;";"Count the number of special permutations | Function to return the number of ways to choose r objects out of n objects ; Function to return the number of derangements of n ; Function to return the required number of permutations ; Ways to choose i indices from n indices ; Dearangements of ( n - i ) indices ; Driver Code to test above functions"
Javascript;"class pair { constructor ( first , second ) { this . first = first ; this . second = second ; } } let n = 3 ; let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } function answerQueries ( queries , q ) { for ( let i = 0 ; i < q ; i ++ ) { let x = queries [ i ] . first ; x -- ; let y = queries [ i ] . second ; y -- ; document . write ( dp [ x ] [ y ] + "" "" ) ; } } function pre_compute ( a ) { if ( a [ 0 ] [ 0 ] == ' ' ) dp [ 0 ] [ 0 ] = 0 ; else dp [ 0 ] [ 0 ] = 1 ; for ( let row = 0 ; row < n ; row ++ ) { for ( let col = 0 ; col < n ; col ++ ) { if ( row != 0 col != 0 ) dp [ row ] [ col ] = Number . MAX_VALUE ; if ( row != 0 ) { dp [ row ] [ col ] = Math . min ( dp [ row ] [ col ] , dp [ row - 1 ] [ col ] ) ; } if ( col != 0 ) { dp [ row ] [ col ] = Math . min ( dp [ row ] [ col ] , dp [ row ] [ col - 1 ] ) ; } if ( a [ row ] [ col ] != ' ' && ( row != 0 col != 0 ) ) dp [ row ] [ col ] += 1 ; } } } let a = [ [ ' ' , ' ' , ' ' ] , [ ' ' , ' ' , ' ' ] , [ ' ' , ' ' , ' ' ] ] ; let queries = [ new pair ( 1 , 3 ) , new pair ( 3 , 3 ) ] ; let q = 2 ; pre_compute ( a ) ; answerQueries ( queries , q ) ;";"Paths with maximum number of ' a ' from ( 1 , 1 ) to ( X , Y ) vertically or horizontally | Javascript program to find paths with maximum number of ' a ' from ( 1 , 1 ) to ( X , Y ) vertically or horizontally ; Function to answer queries ; Iterate till query ; Decrease to get 0 - based indexing ; Print answer ; Function that pre - computes the dp array ; Check fo the first character ; Iterate in row and columns ; If not first row or not first column ; Not first row ; Not first column ; If it is not ' a ' then increase by 1 ; character N X N array ; queries ; number of queries ; function call to pre - compute ; function call to answer every query"
Javascript;"function squares ( i ) { if ( ( i & 1 ) == 1 ) return parseInt ( i / 4 , 10 ) * 2 + 1 ; else return parseInt ( ( i - 1 ) / 4 , 10 ) * 2 + 2 ; } function bishop_placements ( n , k ) { if ( k > 2 * n - 1 ) return 0 ; let dp = new Array ( n * 2 ) ; for ( let i = 0 ; i < n * 2 ; i ++ ) { dp [ i ] = new Array ( k + 1 ) ; for ( let j = 0 ; j < k + 1 ; j ++ ) { dp [ i ] [ j ] = 0 ; } dp [ i ] [ 0 ] = 1 ; } dp [ 1 ] [ 1 ] = 1 ; for ( let i = 2 ; i < n * 2 ; i ++ ) { for ( let j = 1 ; j <= k ; j ++ ) dp [ i ] [ j ] = dp [ i - 2 ] [ j ] + dp [ i - 2 ] [ j - 1 ] * ( squares ( i ) - j + 1 ) ; } let ans = 0 ; for ( let i = 0 ; i <= k ; i ++ ) { ans += dp [ n * 2 - 1 ] [ i ] * dp [ n * 2 - 2 ] [ k - i ] ; } return ans ; } let n = 2 ; let k = 2 ; let ans = bishop_placements ( n , k ) ; document . write ( ans ) ;";"Ways to place K bishops on an NÃ — N chessboard so that no two attack | returns the number of squares in diagonal i ; returns the number of ways to fill a n * n chessboard with k bishops so that no two bishops attack each other . ; return 0 if the number of valid places to be filled is less than the number of bishops ; dp table to store the values ; Setting the base conditions ; calculate the required number of ways ; stores the answer ; Driver code"
Javascript;"var MAX = 10 ; var F = Array . from ( Array ( MAX ) , ( ) => Array ( MAX ) . fill ( 0 ) ) ; var C = Array ( MAX ) . fill ( 0 ) ; function noOfAssignments ( S , n , i , c_x ) { if ( F [ i ] [ c_x ] != - 1 ) { return F [ i ] [ c_x ] ; } if ( i == n ) { if ( c_x == 1 ) { F [ i ] [ c_x ] = 0 ; } else { F [ i ] [ c_x ] = 1 ; } return F [ i ] [ c_x ] ; } var c_y = C [ i ] - c_x ; if ( S [ i ] == ' ' ) { F [ i ] [ c_x ] = noOfAssignments ( S , n , i + 1 , c_x + 1 ) + noOfAssignments ( S , n , i + 1 , c_x ) ; return F [ i ] [ c_x ] ; } F [ i ] [ c_x ] = 0 ; if ( c_x == 1 ) { F [ i ] [ c_x ] += noOfAssignments ( S , n , i + 1 , c_x - 1 ) ; } if ( c_y == 1 ) { F [ i ] [ c_x ] += noOfAssignments ( S , n , i + 1 , c_x ) ; } return F [ i ] [ c_x ] ; } var S = "" "" ; var n = S . length ; for ( var i = 0 ; i < MAX ; i ++ ) { for ( var j = 0 ; j < MAX ; j ++ ) { F [ i ] [ j ] = - 1 ; } } C [ 0 ] = 0 ; for ( var i = 0 ; i < n ; ++ i ) { if ( S [ i ] == ' ' ) { C [ i + 1 ] = C [ i ] + 1 ; } else { C [ i + 1 ] = C [ i ] - 1 ; } } document . write ( noOfAssignments ( S , n , 0 , 0 ) + "" "" ) ;";"Number of ways to partition a string into two balanced subsequences | For maximum length of input string ; Declaring the DP table ; Declaring the prefix array ; Function to calculate the number of valid assignments ; Return 1 if X is balanced . ; Increment the count if it an opening bracket ; Decrement the count if it a closing bracket ; Driver code ; Initializing the DP table ; Creating the prefix array ; Initial value for c_x and c_y is zero"
Javascript;"let n = 3 ; function minFallingPathSum ( A ) { for ( let R = n - 2 ; R >= 0 ; -- R ) { for ( let C = 0 ; C < n ; ++ C ) { let best = A [ R + 1 ] [ C ] ; if ( C > 0 ) best = Math . min ( best , A [ R + 1 ] [ C - 1 ] ) ; if ( C + 1 < n ) best = Math . min ( best , A [ R + 1 ] [ C + 1 ] ) ; A [ R ] [ C ] = A [ R ] [ C ] + best ; } } let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < n ; ++ i ) ans = Math . min ( ans , A [ 0 ] [ i ] ) ; return ans ; } let A = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ; document . write ( minFallingPathSum ( A ) ) ;";"Minimum sum falling path in a NxN grid | Javascript Program to minimum required sum ; Function to return minimum path falling sum ; R = Row and C = Column We begin from second last row and keep adding maximum sum . ; best = min ( A [ R + 1 ] [ C - 1 ] , A [ R + 1 ] [ C ] , A [ R + 1 ] [ C + 1 ] ) ; Driver program ; function to print required answer"
Javascript;"let N = 100 ; let n = 3 , m = 4 ; function maxPlus ( arr ) { let ans = 0 ; let left = new Array ( N ) ; let right = new Array ( N ) ; let up = new Array ( N ) ; let down = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { left [ i ] = new Array ( N ) ; right [ i ] = new Array ( N ) ; up [ i ] = new Array ( N ) ; down [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { left [ i ] [ j ] = 0 ; right [ i ] [ j ] = 0 ; up [ i ] [ j ] = 0 ; down [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { left [ i ] [ j ] = Math . max ( 0 , ( ( j != 0 ) ? left [ i ] [ j - 1 ] : 0 ) ) + arr [ i ] [ j ] ; up [ i ] [ j ] = Math . max ( 0 , ( ( i != 0 ) ? up [ i - 1 ] [ j ] : 0 ) ) + arr [ i ] [ j ] ; } } for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 0 ; j < m ; j ++ ) { right [ i ] [ j ] = Math . max ( 0 , ( j + 1 == m ? 0 : right [ i ] [ j + 1 ] ) ) + arr [ i ] [ j ] ; down [ i ] [ j ] = Math . max ( 0 , ( i + 1 == n ? 0 : down [ i + 1 ] [ j ] ) ) + arr [ i ] [ j ] ; } } for ( let i = 1 ; i < n - 1 ; ++ i ) for ( let j = 1 ; j < m - 1 ; ++ j ) { ans = Math . max ( ans , up [ i - 1 ] [ j ] + down [ i + 1 ] [ j ] + left [ i ] [ j - 1 ] + right [ i ] [ j + 1 ] + arr [ i ] [ j ] ) ; } return ans ; } let arr = [ [ 1 , 1 , 1 , 1 ] , [ - 6 , 1 , 1 , - 4 ] , [ 1 , 1 , 1 , 1 ] ] ; document . write ( maxPlus ( arr ) ) ;";"Find the maximum sum of Plus shape pattern in a 2 | JavaScript program to find the maximum value of a + shaped pattern in 2 - D array ; Function to return maximum Plus value ; Initializing answer with the minimum value ; Initializing all four arrays ; Initializing left and up array . ; Initializing right and down array . ; calculating value of maximum Plus ( + ) sign ; Driver code ; Function call to find maximum value"
Javascript;"function countStaircases ( N ) { let memo = new Array ( N + 5 ) ; for ( let i = 0 ; i < N + 5 ; i ++ ) { memo [ i ] = new Array ( N + 5 ) ; for ( let j = 0 ; j < N + 5 ; j ++ ) { memo [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i <= N ; i ++ ) { for ( let j = 0 ; j <= N ; j ++ ) { memo [ i ] [ j ] = 0 ; } } memo [ 3 ] [ 2 ] = memo [ 4 ] [ 2 ] = 1 ; for ( let i = 5 ; i <= N ; i ++ ) { for ( let j = 2 ; j <= i ; j ++ ) { if ( j == 2 ) { memo [ i ] [ j ] = memo [ i - j ] [ j ] + 1 ; } else { memo [ i ] [ j ] = memo [ i - j ] [ j ] + memo [ i - j ] [ j - 1 ] ; } } } let answer = 0 ; for ( let i = 1 ; i <= N ; i ++ ) answer = answer + memo [ N ] [ i ] ; return answer ; } let N = 7 ; document . write ( countStaircases ( N ) ) ;";"Total number of different staircase that can made from N boxes | Function to find the total number of different staircase that can made from N boxes ; DP table , there are two states . First describes the number of boxes and second describes the step ; Initialize all the elements of the table to zero ; Base case ; When step is equal to 2 ; When step is greater than 2 ; Count the total staircase from all the steps ; Driver Code"
Javascript;"function maxCost ( a , n , l , r ) { var mx = 0 , k ; for ( var i = 0 ; i < n ; ++ i ) mx = Math . max ( mx , a [ i ] ) ; var count = new Array ( mx + 1 ) ; count . fill ( 0 ) ; for ( var i = 0 ; i < n ; i ++ ) count [ a [ i ] ] ++ ; var res = new Array ( mx + 1 ) ; res [ 0 ] = 0 ; l = Math . min ( l , r ) ; for ( var num = 1 ; num <= mx ; num ++ ) { k = Math . max ( num - l - 1 , 0 ) ; res [ num ] = Math . max ( res [ num - 1 ] , num * count [ num ] + res [ k ] ) ; } return res [ mx ] ; } var a = [ 2 , 1 , 2 , 3 , 2 , 2 , 1 ] ; var l = 1 , r = 1 ; var n = a . length ; document . write ( maxCost ( a , n , l , r ) ) ;";"Find maximum points which can be obtained by deleting elements from array | function to return maximum cost obtained ; find maximum element of the array . ; initialize count of all elements to zero . ; calculate frequency of all elements of array . ; stores cost of deleted elements . ; selecting minimum range from L and R . ; finds upto which elements are to be deleted when element num is selected . ; get maximum when selecting element num or not . ; Driver Code ; size of array ; function call to find maximum cost"
Javascript;"function countPaths ( m , n ) { if ( m == 1 n == 1 ) return 1 ; return countPaths ( m - 1 , n ) + countPaths ( m , n - 1 ) ; } let n = 5 , m = 5 ; document . write ( countPaths ( n , m ) ) ;";"Count the number of ways to traverse a Matrix | Returns The number of way from top - left to mat [ m - 1 ] [ n - 1 ] ; Return 1 if it is the first row or first column ; Recursively find the no of way to reach the last cell . ; Driver Code"
Javascript;"function countPaths ( m , n ) { let dp = new Array ( m + 1 ) ; for ( let i = 0 ; i <= m ; i ++ ) { dp [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j <= n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 1 ; i <= m ; i ++ ) { for ( let j = 1 ; j <= n ; j ++ ) { if ( i == 1 j == 1 ) dp [ i ] [ j ] = 1 ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i ] [ j - 1 ] ; } } return dp [ m ] [ n ] ; } let n = 5 ; let m = 5 ; document . write ( countPaths ( n , m ) ) ;";"Count the number of ways to traverse a Matrix | Returns The number of way from top - left to mat [ m - 1 ] [ n - 1 ] ; Driver code"
Javascript;"function binomialCoeff ( n , k ) { var res = 1 ; if ( k > n - k ) k = n - k ; for ( i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } function catalan ( n ) { var c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } var n = 3 ; document . write ( catalan ( n ) ) ;";"Number of ways a convex polygon of n + 2 sides can split into triangles by connecting vertices | Returns value of Binomial Coefficient C ( n , k ) ; Since C ( n , k ) = C ( n , n - k ) ; Calculate value of [ n * ( n - 1 ) * -- - * ( n - k + 1 ) ] / [ k * ( k - 1 ) * -- - * 1 ] ; A Binomial coefficient based function to find nth catalan number in O ( n ) time ; Calculate value of 2 nCn ; return 2 nCn / ( n + 1 ) ; Driver code"
Javascript;"function alternateFib ( n ) { if ( n < 0 ) return ; var f1 = 0 ; var f2 = 1 ; document . write ( f1 + "" "" ) ; for ( i = 2 ; i <= n ; i ++ ) { var f3 = f2 + f1 ; if ( i % 2 == 0 ) document . write ( f3 + "" "" ) ; f1 = f2 ; f2 = f3 ; } } var N = 15 ; alternateFib ( N ) ;";"Alternate Fibonacci Numbers | Alternate Fibonacci Series using Dynamic Programming ; 0 th and 1 st number of the series are 0 and 1 ; Driver Code"
Javascript;"function totalWays ( N , M , X ) { let dp = new Array ( N + 1 ) ; for ( let i = 0 ; i < N + 1 ; i ++ ) { dp [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } if ( X == 1 ) { dp [ 0 ] [ 0 ] = 1 ; } else { dp [ 0 ] [ 1 ] = 0 ; } if ( X == 1 ) { dp [ 1 ] [ 0 ] = 0 ; dp [ 1 ] [ 1 ] = M - 1 ; } else { dp [ 1 ] [ 0 ] = 1 ; dp [ 1 ] [ 1 ] = ( M - 2 ) ; } for ( let i = 2 ; i < N ; i ++ ) { dp [ i ] [ 0 ] = dp [ i - 1 ] [ 1 ] ; dp [ i ] [ 1 ] = dp [ i - 1 ] [ 0 ] * ( M - 1 ) + dp [ i - 1 ] [ 1 ] * ( M - 2 ) ; } return dp [ N - 1 ] [ 0 ] ; } let N = 4 , M = 3 , X = 2 ; document . write ( totalWays ( N , M , X ) ) ;";"Number of ways to form an array with distinct adjacent elements | Returns the total ways to form arrays such that every consecutive element is different and each element except the first and last can take values from 1 to M ; define the dp [ ] [ ] array ; if the first element is 1 ; there is only one way to place a 1 at the first index ; the value at first index needs to be 1 , thus there is no way to place a non - one integer ; if the first element was 1 then at index 1 , only non one integer can be placed thus there are M - 1 ways to place a non one integer at index 2 and 0 ways to place a 1 at the 2 nd index ; Else there is one way to place a one at index 2 and if a non one needs to be placed here , there are ( M - 2 ) options , i . e neither the element at this index should be 1 , neither should it be equal to the previous element ; Build the dp array in bottom up manner ; f ( i , one ) = f ( i - 1 , non - one ) ; f ( i , non - one ) = f ( i - 1 , one ) * ( M - 1 ) + f ( i - 1 , non - one ) * ( M - 2 ) ; last element needs to be one , so return dp [ n - 1 ] [ 0 ] ; Driver Code"
Javascript;"function fib ( n ) { if ( n <= 1 ) return n ; return fib ( n - 1 ) + fib ( n - 2 ) ; } let n = 6 ; document . write ( fib ( n ) ) ;";"Memoization ( 1D , 2D and 3D ) | Fibonacci Series using Recursion ; Base case ; recursive calls ; Driver Code"
Javascript;"function fib ( n ) { let term = new Array ( 1000 ) ; term . fill ( 0 ) ; if ( n <= 1 ) return n ; if ( term [ n ] != 0 ) return term [ n ] ; else { term [ n ] = fib ( n - 1 ) + fib ( n - 2 ) ; return term [ n ] ; } } let n = 6 ; document . write ( fib ( n ) ) ;";"Memoization ( 1D , 2D and 3D ) | Fibonacci Series using memoized Recursion ; base case ; if fib ( n ) has already been computed we do not do further recursive calls and hence reduce the number of repeated work ; store the computed value of fib ( n ) in an array term at index n to so that it does not needs to be precomputed again ; Driver Code"
Javascript;"function max ( a , b ) { return ( a > b ) ? a : b ; } function lcs ( X , Y , m , n ) { if ( m == 0 n == 0 ) return 0 ; if ( X [ m - 1 ] == Y [ n - 1 ] ) return 1 + lcs ( X , Y , m - 1 , n - 1 ) ; else return max ( lcs ( X , Y , m , n - 1 ) , lcs ( X , Y , m - 1 , n ) ) ; } let X = "" "" ; let Y = "" "" ; let m = X . length ; let n = Y . length ; document . write ( "" "" + lcs ( X , Y , m , n ) ) ;";"Memoization ( 1D , 2D and 3D ) | Utility function to get max of 2 integers ; Returns length of LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ] ; Driver Code"
Javascript;"function minimumNumberOfDigits ( a , b ) { if ( a > b a < 0 b < 0 a > 900 b > 8100 ) return - 1 ; if ( a == 0 && b == 0 ) return 0 ; if ( dp [ a ] [ b ] != - 1 ) return dp [ a ] [ b ] ; var ans = 101 ; for ( var i = 9 ; i >= 1 ; i -- ) { var k = minimumNumberOfDigits ( a - i , b - ( i * i ) ) ; if ( k != - 1 ) ans = Math . min ( ans , k + 1 ) ; } return dp [ a ] [ b ] = ans ; } function printSmallestNumber ( a , b ) { dp = new Array ( 901 ) . fill ( - 1 ) . map ( ( ) => new Array ( 8101 ) . fill ( - 1 ) ) ; ; dp [ 0 ] [ 0 ] = 0 ; var k = minimumNumberOfDigits ( a , b ) ; if ( k == - 1 k > 100 ) document . write ( "" "" ) ; else { while ( a > 0 && b > 0 ) { for ( var i = 1 ; i <= 9 ; i ++ ) { if ( a >= i && b >= i * i && 1 + dp [ a - i ] [ b - i * i ] == dp [ a ] [ b ] ) { document . write ( i ) ; a -= i ; b -= i * i ; break ; } } } } } var a = 18 , b = 162 ; printSmallestNumber ( a , b ) ;";"Smallest number with given sum of digits and sum of square of digits | Top down dp to find minimum number of digits with given sum of dits a and sum of square of digits as b ; Invalid condition ; Number of digits satisfied ; Memoization ; Initialize ans as maximum as we have to find the minimum number of digits ; Check for all possible combinations of digits ; recurrence call ; If the combination of digits cannot give sum as a and sum of square of digits as b ; Returns the minimum number of digits ; Function to print the digits that gives sum as a and sum of square of digits as b ; initialize the dp array as - 1 ; base condition ; function call to get the minimum number of digits ; When there does not exists any number ; Printing the digits from the most significant digit ; Trying all combinations ; checking conditions for minimum digits ; Driver Code ; Function call to print the smallest number"
Javascript;"let MAX = 100 ; function binomialCoeff ( n , k ) { let C = new Array ( k + 1 ) ; C . fill ( 0 ) ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } function sumOfproduct ( n ) { return binomialCoeff ( 2 * n , n - 1 ) ; } let n = 3 ; document . write ( sumOfproduct ( n ) ) ;";"Sum of product of consecutive Binomial Coefficients | Javascript Program to find sum of product of consecutive Binomial Coefficient . ; Find the binomial coefficient up to nth term ; memset ( C , 0 , sizeof ( C ) ) ; C [ 0 ] = 1 ; nC0 is 1 ; Compute next row of pascal triangle using the previous row ; Return the sum of the product of consecutive binomial coefficient . ; Driver Code"
Javascript;"var MAX = 100 ; function check ( i , sum , n , k , a , dp ) { if ( sum <= 0 ) return false ; if ( i >= n ) { if ( sum == k ) return true ; return false ; } if ( dp [ i ] [ sum ] != - 1 ) return dp [ i ] [ sum ] ; dp [ i ] [ sum ] = check ( i + 1 , sum - 2 * a [ i ] , n , k , a , dp ) || check ( i + 1 , sum , n , k , a , dp ) ; dp [ i ] [ sum ] = check ( i + 1 , sum - ( i + 1 ) , n , k , a , dp ) || dp [ i ] [ sum ] ; dp [ i ] [ sum ] = check ( i + 1 , sum + i + 1 , n , k , a , dp ) || dp [ i ] [ sum ] ; return dp [ i ] [ sum ] ; } function wrapper ( n , k , a ) { var sum = 0 ; for ( var i = 0 ; i < n ; i ++ ) sum += a [ i ] ; var dp = Array . from ( Array ( MAX ) , ( ) => Array ( MAX ) . fill ( - 1 ) ) ; return check ( 0 , sum , n , k , a , dp ) ; } var a = [ 1 , 2 , 3 , 4 ] ; var n = 4 , k = 5 ; ( wrapper ( n , k , a ) ? ( document . write ( "" "" ) ) : ( document . write ( "" "" ) ) ) ;";"Check if array sum can be made K by three operations on it | Javascript Program to find if Array can have a sum of K by applying three types of possible operations on it ; Check if it is possible to achieve a sum with three operation allowed . ; If sum is negative . ; If going out of bound . ; If sum is achieved . ; If the current state is not evaluated yet . ; Replacing element with negative value of the element . ; Substracting index number from the element . ; Adding index number to the element . ; Wrapper Function ; Driver Code"
Javascript;"function fib ( n ) { let a = 0 , b = 1 , c ; if ( n >= 0 ) document . write ( a + "" "" ) ; if ( n >= 1 ) document . write ( b + "" "" ) ; for ( let i = 2 ; i <= n ; i ++ ) { c = a + b ; document . write ( c + "" "" ) ; a = b ; b = c ; } } fib ( 9 ) ;";"Print Fibonacci sequence using 2 variables | Simple Javascript Program to print Fibonacci sequence ; Driver code"
Javascript;"function pre_compute ( a , n , index , k ) { let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] > a [ 0 ] ) dp [ 0 ] [ i ] = a [ i ] + a [ 0 ] ; else dp [ 0 ] [ i ] = a [ i ] ; } for ( let i = 1 ; i < n ; i ++ ) { for ( let j = 0 ; j < n ; j ++ ) { if ( a [ j ] > a [ i ] && j > i ) { if ( dp [ i - 1 ] [ i ] + a [ j ] > dp [ i - 1 ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ i ] + a [ j ] ; else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } else dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } return dp [ index ] [ k ] ; } let a = [ 1 , 101 , 2 , 3 , 100 , 4 , 5 ] ; let n = a . length ; let index = 4 , k = 6 ; document . write ( pre_compute ( a , n , index , k ) ) ;";"Maximum sum increasing subsequence from a prefix and a given element after prefix is must | Javascript program to find maximum sum increasing subsequence tiint i - th index and including k - th index . ; Initializing the first row of the dp [ ] [ ] . ; Creating the dp [ ] [ ] matrix . ; To calculate for i = 4 and k = 6. ; Driver code"
Javascript;"function gen ( n ) { let S = new Array ( n + 1 ) ; S . fill ( 0 ) ; S [ 0 ] = 0 ; if ( n != 0 ) S [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) { if ( i % 2 == 0 ) S [ i ] = 4 * S [ parseInt ( i / 2 , 10 ) ] ; else S [ i ] = 4 * S [ parseInt ( i / 2 , 10 ) ] + 1 ; } return S [ n ] ; } function moserDeBruijn ( n ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( gen ( i ) + "" "" ) ; } let n = 15 ; document . write ( "" "" + n + "" "" + "" "" + "" "" ) ; moserDeBruijn ( n ) ;";"Moser | Function to generate nth term of Moser - de Bruijn Sequence ; S ( 2 * n ) = 4 * S ( n ) ; S ( 2 * n + 1 ) = 4 * S ( n ) + 1 ; Generating the first ' n ' terms of Moser - de Bruijn Sequence ; Driver Code"
Javascript;"function LCSubStr ( X , Y ) { var m = X . length ; var n = Y . length ; var result = 0 ; var len = Array . from ( Array ( 2 ) , ( ) => Array ( n ) ) ; var currRow = 0 ; for ( var i = 0 ; i <= m ; i ++ ) { for ( var j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) { len [ currRow ] [ j ] = 0 ; } else if ( X [ i - 1 ] == Y [ j - 1 ] ) { len [ currRow ] [ j ] = len [ 1 - currRow ] [ j - 1 ] + 1 ; result = Math . max ( result , len [ currRow ] [ j ] ) ; } else { len [ currRow ] [ j ] = 0 ; } } currRow = 1 - currRow ; } return result ; } var X = "" "" ; var Y = "" "" ; document . write ( LCSubStr ( X , Y ) ) ;";"Longest Common Substring ( Space optimized DP solution ) | Function to find longest common substring . ; Find length of both the strings . ; Variable to store length of longest common substring . ; Matrix to store result of two consecutive rows at a time . ; Variable to represent which row of matrix is current row . ; For a particular value of i and j , len [ currRow ] [ j ] stores length of longest common substring in string X [ 0. . i ] and Y [ 0. . j ] . ; Make current row as previous row and previous row as new current row . ; Driver code"
Javascript;"function func ( n , m , A ) { let ModArray = [ ] ; for ( let i = 0 ; i < n ; i ++ ) ModArray . push ( 0 ) ; let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { ModArray [ i ] = A [ i ] % m ; sum += ModArray [ i ] ; } sum = sum % m ; if ( sum % m == 0 ) { document . write ( "" "" ) ; return ; } if ( sum % 2 != 0 ) { document . write ( "" "" ) ; } else { ModArray . shift ( ) ; let i = 0 ; let j = ModArray . length - 1 ; ModArray . sort ( function ( a , b ) { return a - b } ) ; sum = parseInt ( sum / 2 , 10 ) ; let i1 , i2 ; while ( i <= j ) { let s = ModArray [ i ] + ModArray [ j ] ; if ( s == sum ) { i1 = i ; i2 = j ; document . write ( "" "" ) ; break ; } else if ( s > sum ) j -- ; else i ++ ; } } } let m = 2 ; let a = [ 1 , 3 , 9 ] ; let n = a . length ; func ( n , m , a ) ;";"Check if any valid sequence is divisible by M | Function to check if any valid sequence is divisible by M ; Declare mod array ; Calculate the mod array ; Check if sum is divisible by M ; Check if sum is not divisible by 2 ; Remove the first element from the ModArray since it is not possible to place minus on the first element ; Decrease the size of array ; Sort the array ; Loop until the pointer cross each other ; Check if sum becomes equal ; Increase and decrease the pointer accordingly ; Driver code ; Function call"
Javascript;"function printGolomb ( n ) { let dp = Array ( n + 1 ) . fill ( 0 ) ; dp [ 1 ] = 1 ; document . write ( dp [ 1 ] + "" "" ) ; for ( i = 2 ; i <= n ; i ++ ) { dp [ i ] = 1 + dp [ i - dp [ dp [ i - 1 ] ] ] ; document . write ( dp [ i ] + "" "" ) ; } } let n = 9 ; printGolomb ( n ) ;";"Golomb sequence | Print the first n term of Golomb Sequence ; base cases ; Finding and printing first n terms of Golomb Sequence . ; Driver code"
Javascript;"let N = 1000 ; function arrangeBraces ( n , pos , k ) { let h = new Array ( N ) ; h . fill ( false ) ; let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < k ; i ++ ) { h [ pos [ i ] ] = true ; } dp [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= 2 * n ; i ++ ) { for ( let j = 0 ; j <= 2 * n ; j ++ ) { if ( h [ i ] ) { if ( j != 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] ; } else { dp [ i ] [ j ] = 0 ; } } else if ( j != 0 ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j - 1 ] + dp [ i - 1 ] [ j + 1 ] ; } else { dp [ i ] [ j ] = dp [ i - 1 ] [ j + 1 ] ; } } } return dp [ 2 * n ] [ 0 ] ; } let n = 3 ; let pos = [ 2 ] ; let k = pos . length ; document . write ( arrangeBraces ( n , pos , k ) ) ;";"Balanced expressions such that given positions have opening brackets | Javascript code to find number of ways of arranging bracket with proper expressions ; function to calculate the number of proper bracket sequence ; hash array to mark the positions of opening brackets ; dp 2d array ; mark positions in hash array ; first position marked as 1 ; iterate and formulate the recurrences ; if position has a opening bracket ; return answer ; driver code ; positions where opening braces will be placed"
Javascript;"function findLength ( str , n ) { let current_sum = 0 ; let max_sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) { current_sum += ( str [ i ] == ' ' ? 1 : - 1 ) ; if ( current_sum < 0 ) { current_sum = 0 ; } max_sum = Math . max ( current_sum , max_sum ) ; } return max_sum == 0 ? - 1 : max_sum ; } let str = "" "" ; let n = str . length ; document . write ( findLength ( str , n ) ) ;";"Maximum difference of zeros and ones in binary string | Set 2 ( O ( n ) time ) | Find the length of substring with maximum difference of zeros and ones in binary string ; traverse a binary string from left to right ; add current value to the current_sum according to the Character if it ' s ▁ ' 0 ' add 1 else -1 ; update maximum sum ; return - 1 if string does not contain any zero that means string contains all ones otherwise max_sum ; Driver Code"
Javascript;"function chordCnt ( A ) { var n = 2 * A ; var dpArray = Array ( n + 1 ) . fill ( 0 ) ; dpArray [ 0 ] = 1 ; dpArray [ 2 ] = 1 ; for ( var i = 4 ; i <= n ; i += 2 ) { for ( var j = 0 ; j < i - 1 ; j += 2 ) { dpArray [ i ] += ( dpArray [ j ] * dpArray [ i - 2 - j ] ) ; } } return dpArray [ n ] ; } var N ; N = 2 ; document . write ( chordCnt ( N ) + ' ' ) ; N = 1 ; document . write ( chordCnt ( N ) + ' ' ) ; N = 4 ; document . write ( chordCnt ( N ) + ' ' ) ;";"Count ways to divide circle using N non | JavaScript code to count ways to divide circle using N non - intersecting chords . ; n = no of points required ; dp array containing the sum ; returning the required number ; Driver function"
Javascript;"var arr = [ [ 5 ] , [ 5 ] ] function isPath ( arr ) { arr [ 0 ] [ 0 ] = 1 ; for ( var i = 1 ; i < 5 ; i ++ ) if ( arr [ i ] [ 0 ] != - 1 ) arr [ i ] [ 0 ] = arr [ i - 1 ] [ 0 ] ; for ( var j = 1 ; j < 5 ; j ++ ) if ( arr [ 0 ] [ j ] != - 1 ) arr [ 0 ] [ j ] = arr [ 0 ] [ j - 1 ] ; for ( var i = 1 ; i < 5 ; i ++ ) for ( var j = 1 ; j < 5 ; j ++ ) if ( arr [ i ] [ j ] != - 1 ) arr [ i ] [ j ] = Math . max ( arr [ i ] [ j - 1 ] , arr [ i - 1 ] [ j ] ) ; return ( arr [ 5 - 1 ] [ 5 - 1 ] == 1 ) ; } var arr = [ [ 0 , 0 , 0 , - 1 , 0 ] , [ - 1 , 0 , 0 , - 1 , - 1 ] , [ 0 , 0 , 0 , - 1 , 0 ] , [ - 1 , 0 , - 1 , 0 , - 1 ] , [ 0 , 0 , - 1 , 0 , 0 ] ] ; if ( isPath ( arr ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check for possible path in 2D matrix | JavaScript program to find if there is path from top left to right bottom ; to find the path from top left to bottom right ; set arr [ 0 ] [ 0 ] = 1 ; Mark reachable ( from top left ) nodes in first row and first column . ; Mark reachable nodes in remaining matrix . ; return yes if right bottom index is 1 ; Given array ; path from arr [ 0 ] [ 0 ] to arr [ row ] [ col ]"
Javascript;"function nswp ( n ) { if ( n == 0 n == 1 ) return 1 ; return 2 * nswp ( n - 1 ) + nswp ( n - 2 ) ; } let n = 3 ; document . write ( nswp ( n ) ) ;";"Newmanâ €“ Shanksâ €“ Williams prime | return nth Newman - Shanks - Williams prime ; Base case ; Recursive step ; Driver code"
Javascript;"function nswp ( n ) { let dp = new Array ( n + 1 ) ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( let i = 2 ; i <= n ; i ++ ) dp [ i ] = 2 * dp [ i - 1 ] + dp [ i - 2 ] ; return dp [ n ] ; } let n = 3 ; document . write ( nswp ( n ) ) ;";"Newman Shanks Williams prime | return nth Newman Shanks Williams prime ; Base case ; Finding nth Newman Shanks Williams prime ; Driver Code"
Javascript;"let MAX = 256 ; function numberofways ( A , B , N , M ) { let pos = new Array ( MAX ) ; for ( let i = 0 ; i < MAX ; i ++ ) pos [ i ] = [ ] ; for ( let i = 0 ; i < M ; i ++ ) pos [ B [ i ] . charCodeAt ( 0 ) ] . push ( i + 1 ) ; let dpl = new Array ( N + 2 ) ; for ( let i = 0 ; i < N + 2 ; i ++ ) { dpl [ i ] = new Array ( M + 2 ) ; for ( let j = 0 ; j < M + 2 ; j ++ ) dpl [ i ] [ j ] = 0 ; } for ( let i = 1 ; i <= N ; i ++ ) { for ( let j = 1 ; j <= M ; j ++ ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpl [ i ] [ j ] = dpl [ i - 1 ] [ j - 1 ] + 1 ; else dpl [ i ] [ j ] = Math . max ( dpl [ i - 1 ] [ j ] , dpl [ i ] [ j - 1 ] ) ; } } let LCS = dpl [ N ] [ M ] ; let dpr = new Array ( N + 2 ) ; for ( let i = 0 ; i < N + 2 ; i ++ ) { dpr [ i ] = new Array ( M + 2 ) ; for ( let j = 0 ; j < M + 2 ; j ++ ) dpr [ i ] [ j ] = 0 ; } for ( let i = N ; i >= 1 ; i -- ) { for ( let j = M ; j >= 1 ; j -- ) { if ( A [ i - 1 ] == B [ j - 1 ] ) dpr [ i ] [ j ] = dpr [ i + 1 ] [ j + 1 ] + 1 ; else dpr [ i ] [ j ] = Math . max ( dpr [ i + 1 ] [ j ] , dpr [ i ] [ j + 1 ] ) ; } } let ans = 0 ; for ( let i = 0 ; i <= N ; i ++ ) { for ( let j = 0 ; j < MAX ; j ++ ) { for ( let x = 0 ; x < pos [ j ] . length ; x ++ ) { if ( dpl [ i ] [ pos [ j ] [ x ] - 1 ] + dpr [ i + 1 ] [ pos [ j ] [ x ] + 1 ] == LCS ) { ans ++ ; break ; } } } } return ans ; } let A = "" "" , B = "" "" ; let N = A . length , M = B . length ; document . write ( numberofways ( A , B , N , M ) ) ;";"Number of ways to insert a character to increase the LCS by one | JavaScript Program for Number of ways to insert a character to increase LCS by one ; Return the Number of ways to insert a character to increase the Longest Common Subsequence by one ; Insert all positions of all characters in string B . ; Longest Common Subsequence ; Longest Common Subsequence from reverse ; inserting character between position i and i + 1 ; Driver Code"
Javascript;"function lcs ( X , Y , m , n ) { let L = new Array ( m + 1 ) ; for ( let i = 0 ; i <= m ; ++ i ) { L [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j <= n ; j ++ ) { L [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i <= m ; ++ i ) { for ( let j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 2 * ( X [ i - 1 ] - ' ' ) ; else L [ i ] [ j ] = L [ i - 1 ] [ j ] > L [ i ] [ j - 1 ] ? L [ i - 1 ] [ j ] : L [ i ] [ j - 1 ] ; } } return L [ m ] [ n ] ; } function findMinCost ( X , Y ) { let m = X . length , n = Y . length ; let cost = 0 ; for ( let i = 0 ; i < m ; ++ i ) cost += X [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ; for ( let i = 0 ; i < n ; ++ i ) cost += Y [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ; return cost - lcs ( X , Y , m , n ) ; } let X = ( "" "" ) . split ( ' ' ) ; let Y = ( "" "" ) . split ( ' ' ) ; document . write ( "" "" + "" "" + findMinCost ( X , Y ) ) ;";"Minimum cost to make two strings identical by deleting the digits | Function to returns cost of removing the identical characters in LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ] ; Following steps build L [ m + 1 ] [ n + 1 ] in bottom up fashion . Note that L [ i ] [ j ] contains cost of removing identical characters in LCS of X [ 0. . i - 1 ] and Y [ 0. . j - 1 ] ; If both characters are same , add both of them ; Otherwise find the maximum cost among them ; Returns cost of making X [ ] and Y [ ] identical ; Find LCS of X [ ] and Y [ ] ; Initialize the cost variable ; Find cost of all characters in both strings ; Driver function"
Javascript;"function isSubSeqDivisible ( str ) { let i , j , k , l = str . length ; let arr = [ ] ; for ( i = 0 ; i < l ; i ++ ) arr [ i ] = str [ i ] - ' ' ; for ( i = 0 ; i < l ; i ++ ) { for ( j = i ; j < l ; j ++ ) { for ( k = j ; k < l ; k ++ ) { if ( arr [ i ] % 8 == 0 ) return true ; else if ( ( arr [ i ] * 10 + arr [ j ] ) % 8 == 0 && i != j ) return true ; else if ( ( arr [ i ] * 100 + arr [ j ] * 10 + arr [ k ] ) % 8 == 0 && i != j && j != k && i != k ) return true ; } } } return false ; } let str = "" "" ; if ( isSubSeqDivisible ( str ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Given a large number , check if a subsequence of digits is divisible by 8 | Function to calculate any permutation divisible by 8. If such permutation exists , the function will return that permutation else it will return - 1 ; Converting string to integer array for ease of computations ( Indexing in arr [ ] is considered to be starting from 1 ) ; Generating all possible permutations and checking if any such permutation is divisible by 8 ; Driver Code"
Javascript;"function isSubSeqDivisible ( str ) { let n = str . length ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i < 10 ; i ++ ) { dp [ i ] = new Array ( 10 ) ; for ( let j = 0 ; j < 10 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } let arr = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) arr [ i ] = ( str [ i - 1 ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; for ( let i = 1 ; i <= n ; i ++ ) { dp [ i ] [ arr [ i ] % 8 ] = 1 ; for ( let j = 0 ; j < 8 ; j ++ ) { if ( dp [ i - 1 ] [ j ] > dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] ) dp [ i ] [ ( j * 10 + arr [ i ] ) % 8 ] = dp [ i - 1 ] [ j ] ; if ( dp [ i - 1 ] [ j ] > dp [ i ] [ j ] ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; } } for ( let i = 1 ; i <= n ; i ++ ) { if ( dp [ i ] [ 0 ] == 1 ) return true ; } return false ; } let str = "" "" ; if ( isSubSeqDivisible ( str ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Given a large number , check if a subsequence of digits is divisible by 8 | Function takes in an array of numbers , dynamically goes on the location and makes combination of numbers . ; Converting string to integer array for ease of computations ( Indexing in arr [ ] is considered to be starting from 1 ) ; If we consider the number in our combination , we add it to the previous combination ; If we exclude the number from our combination ; If at dp [ i ] [ 0 ] , we find value 1 / true , it shows that the number exists at the value of ' i ' ; Driver function"
Javascript;"let str = "" "" ; let mp = new Map ( ) ; let no = 8 ; while ( no < 100 ) { no = no + 8 ; mp . set ( ( Math . floor ( no / 10 ) ) % 10 , no % 10 ) ; } let visited = new Array ( 10 ) ; for ( let i = 0 ; i < visited . length ; i ++ ) { visited [ i ] = false ; } let i ; for ( i = str . length - 1 ; i >= 0 ; i -- ) { if ( str [ i ] == ' ' ) { document . write ( "" "" ) ; break ; } if ( visited [ mp . get ( str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ] ) { document . write ( "" "" ) ; break ; } visited [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] = true ; } if ( i == - 1 ) document . write ( "" "" ) ;";"Given a large number , check if a subsequence of digits is divisible by 8 | Driver code ; map key will be tens place digit of number that is divisible by 8 and value will be units place digit ; For filling the map let start with initial value 8 ; key is digit at tens place and value is digit at units place mp . add ( { key , value } ) if ( mp . containsKey ( ( no / 10 ) % 10 ) ) ; Create a hash to check if we visited a number ; Iterate from last index to 0 th index ; If 8 is present in String then 8 divided 8 hence print yes ; considering present character as the second digit of two digits no we check if the value of this key is marked in hash or not If marked then we a have a number divisible by 8 ; If no subsequence divisible by 8"
Javascript;"function maxLength ( s , n ) { let dp = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { dp [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n - 1 ; i ++ ) if ( s [ i ] == ' ' && s [ i + 1 ] == ' ' ) dp [ i ] [ i + 1 ] = 2 ; for ( let l = 2 ; l < n ; l ++ ) { for ( let i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s [ i ] == ' ' && s [ j ] == ' ' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; for ( let k = i ; k < j ; k ++ ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } return dp [ 0 ] [ n - 1 ] ; } let s = "" "" ; let n = s . length ; document . write ( maxLength ( s , n ) ) ;";"Length of Longest Balanced Subsequence | Javascript program to find length of the longest balanced subsequence . ; Considering all balanced substrings of length 2 ; Considering all other substrings ; Driver Code"
Javascript;"function find_partial_sum ( arr , start , end ) { let sum = 0 ; for ( let i = start ; i < end ; i ++ ) sum += arr [ i ] ; return sum ; } function maxSumBitonicSubArr ( arr , n ) { let max_sum = - 1000000 ; let i = 0 ; while ( i < n ) { let j = i ; while ( j + 1 < n && arr [ j ] < arr [ j + 1 ] ) j ++ ; while ( i < j && arr [ i ] <= 0 ) i ++ ; let k = j ; while ( k + 1 < n && arr [ k ] > arr [ k + 1 ] ) k ++ ; let last = k ; while ( k > j && arr [ k ] <= 0 ) k -- ; let sum_inc = find_partial_sum ( arr , i , j + 1 ) ; let sum_dec = find_partial_sum ( arr , j , k + 1 ) ; let sum_all = sum_inc + sum_dec - arr [ j ] ; max_sum = Math . max ( Math . max ( max_sum , sum_inc ) , Math . max ( sum_dec , sum_all ) ) ; i = Math . max ( last , i + 1 ) ; } return max_sum ; } let arr = [ 5 , 3 , 9 , 2 , 7 , 6 , 4 ] ; let n = arr . length ; document . write ( "" "" + maxSumBitonicSubArr ( arr , n ) + "" "" ) ; let arr2 = [ 1 , 2 , 3 , 4 , 5 ] ; let n2 = arr2 . length ; document . write ( "" "" + maxSumBitonicSubArr ( arr2 , n2 ) + "" "" ) ; let arr3 = [ 5 , 4 , 3 , 2 , 1 ] ; let n3 = arr3 . length ; document . write ( "" "" + maxSumBitonicSubArr ( arr3 , n3 ) + "" "" ) ; let arr4 = [ 5 , 5 , 5 , 5 ] ; let n4 = arr4 . length ; document . write ( "" "" + maxSumBitonicSubArr ( arr4 , n4 ) + "" "" ) ; let arr5 = [ - 1 , 0 , 1 , 2 , 3 , 1 , 0 , - 1 , - 10 ] ; let n5 = arr5 . length ; document . write ( "" "" + maxSumBitonicSubArr ( arr5 , n5 ) + "" "" ) ; let arr6 = [ - 1 , 0 , 1 , 2 , 0 , - 1 , - 2 , 0 , 1 , 3 ] ; let n6 = arr6 . length ; document . write ( "" "" + maxSumBitonicSubArr ( arr6 , n6 ) + "" "" ) ;";"Maximum sum bitonic subarray | Javascript implementation to find the maximum sum bitonic subarray ; Function to find the maximum sum bitonic subarray . ; To store the maximum sum bitonic subarray ; Find the longest increasing subarray starting at i . ; Now we know that a [ i . . j ] is an increasing subarray . Remove non - positive elements from the left side as much as possible . ; Find the longest decreasing subarray starting at j . ; Now we know that a [ j . . k ] is a decreasing subarray . Remove non - positive elements from the right side as much as possible . last is needed to keep the last seen element . ; Compute the max sum of the increasing part . ; Compute the max sum of the decreasing part . ; The overall max sum is the sum of both parts minus the peak element , because it was counted twice . ; If the next element is equal to the current , i . e . arr [ i + 1 ] == arr [ i ] , last == i . To ensure the algorithm has progress , get the max of last and i + 1. ; Required maximum sum ; The example from the article , the answer is 19. ; Always increasing , the answer is 15. ; Always decreasing , the answer is 15. ; All are equal , the answer is 5. ; The whole array is bitonic , but the answer is 7. ; The answer is 4 ( the tail ) ."
Javascript;"function smallestSumSubarr ( arr , n ) { let min_ending_here = 2147483647 ; let min_so_far = 2147483647 ; for ( let i = 0 ; i < n ; i ++ ) { if ( min_ending_here > 0 ) min_ending_here = arr [ i ] ; else min_ending_here += arr [ i ] ; min_so_far = Math . min ( min_so_far , min_ending_here ) ; } return min_so_far ; } let arr = [ 3 , - 4 , 2 , - 3 , - 1 , 7 , - 5 ] ; let n = arr . length ; document . write ( "" "" + smallestSumSubarr ( arr , n ) ) ;";"Smallest sum contiguous subarray | function to find the smallest sum contiguous subarray ; to store the minimum value that is ending up to the current index ; to store the minimum value encountered so far ; traverse the array elements ; if min_ending_here > 0 , then it could not possibly contribute to the minimum sum further ; else add the value arr [ i ] to min_ending_here ; update min_so_far ; required smallest sum contiguous subarray value ; Driver method"
Javascript;"function ans ( n ) { if ( n < 6 ) { return n ; } return n % 6 + 10 * ( ans ( parseInt ( n / 6 ) ) ) ; } function getSpecialNumber ( N ) { return ans ( -- N ) ; } var N = 17 ; var answer = getSpecialNumber ( N ) ; document . write ( answer ) ;";"n | javascript code to find nth number with digits 0 , 1 , 2 , 3 , 4 , 5 ; If the Number is less than 6 return the number as it is . ; Call the function again and again the get the desired result . And convert the number to base 6. ; Decrease the Number by 1 and Call ans function to convert N to base 6 ; Driver code"
Javascript;"let dp = new Array ( 300 ) ; for ( let i = 0 ; i < 300 ; i ++ ) { dp [ i ] = new Array ( 300 ) ; for ( let j = 0 ; j < 300 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } function minimumSquare ( m , n ) { let vertical_min = Number . MAX_VALUE ; let horizontal_min = Number . MAX_VALUE ; if ( n == 13 && m == 11 ) return 6 ; if ( m == 13 && n == 11 ) return 6 ; if ( m == n ) return 1 ; if ( dp [ m ] [ n ] != 0 ) return dp [ m ] [ n ] ; for ( let i = 1 ; i <= parseInt ( m / 2 , 10 ) ; i ++ ) { horizontal_min = Math . min ( minimumSquare ( i , n ) + minimumSquare ( m - i , n ) , horizontal_min ) ; } for ( let j = 1 ; j <= parseInt ( n / 2 , 10 ) ; j ++ ) { vertical_min = Math . min ( minimumSquare ( m , j ) + minimumSquare ( m , n - j ) , vertical_min ) ; } dp [ m ] [ n ] = Math . min ( vertical_min , horizontal_min ) ; return dp [ m ] [ n ] ; } let m = 30 , n = 35 ; document . write ( minimumSquare ( m , n ) ) ;";"Paper Cut into Minimum Number of Squares | Set 2 | Javascript program to find minimum number of squares to cut a paper using Dynamic Programming ; Returns min number of squares needed ; Initializing max values to vertical_min and horizontal_min ; N = 11 & M = 13 is a special case ; If the given rectangle is already a square ; If the answer for the given rectangle is previously calculated return that answer ; The rectangle is cut horizontally and vertically into two parts and the cut with minimum value is found for every recursive call . ; Calculating the minimum answer for the rectangles with width equal to n and length less than m for finding the cut point for the minimum answer ; Calculating the minimum answer for the rectangles with width less than n and length equal to m for finding the cut point for the minimum answer ; Minimum of the vertical cut or horizontal cut to form a square is the answer ; Driver code ; Function call"
Javascript;"function fact ( n ) { var res = 1 ; for ( var i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } function nCr ( n , r ) { return fact ( n ) / ( fact ( r ) * fact ( n - r ) ) ; } var n = 2 ; document . write ( "" "" + nCr ( n + 9 , 9 ) ) ;";"Number of n | Returns factorial of n ; returns nCr ; Driver code"
Javascript;"function countWays ( n , k ) { let total = k ; let mod = 1000000007 ; let same = 0 , diff = k ; for ( let i = 2 ; i <= n ; i ++ ) { same = diff ; diff = total * ( k - 1 ) ; diff = diff % mod ; total = ( same + diff ) % mod ; } return total ; } let n = 3 , k = 2 ; document . write ( countWays ( n , k ) ) ;";"Painting Fence Algorithm | Returns count of ways to color k posts using k colors ; There are k ways to color first post ; There are 0 ways for single post to violate ( same color_ and k ways to not violate ( different color ) ; Fill for 2 posts onwards ; Current same is same as previous diff ; We always have k - 1 choices for next post ; Total choices till i . ; Driver code"
Javascript;"function sumOfSubstrings ( num ) { let sum = 0 ; let mf = 1 ; for ( let i = num . length - 1 ; i >= 0 ; i -- ) { sum += ( num [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) * ( i + 1 ) * mf ; mf = mf * 10 + 1 ; } return sum ; } let num = "" "" ; document . write ( sumOfSubstrings ( num ) ) ;";"Sum of all substrings of a string representing a number | Set 2 ( Constant Extra Space ) | Returns sum of all substring of num ; Initialize result ; Here traversing the array in reverse order . Initializing loop from last element . mf is multiplying factor . ; Each time sum is added to its previous sum . Multiplying the three factors as explained above . s [ i ] - '0' is done to convert char to int . ; Making new multiplying factor as explained above . ; Driver Code"
Javascript;"function maxSumWithK ( a , n , k ) { let maxSum = new Array ( n ) ; maxSum [ 0 ] = a [ 0 ] ; let curr_max = a [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { curr_max = Math . max ( a [ i ] , curr_max + a [ i ] ) ; maxSum [ i ] = curr_max ; } let sum = 0 ; for ( let i = 0 ; i < k ; i ++ ) sum += a [ i ] ; let result = sum ; for ( let i = k ; i < n ; i ++ ) { sum = sum + a [ i ] - a [ i - k ] ; result = Math . max ( result , sum ) ; result = Math . max ( result , sum + maxSum [ i - k ] ) ; } return result ; } let arr = [ 1 , 2 , 3 , - 10 , - 3 ] ; let k = 4 ; document . write ( maxSumWithK ( arr , arr . length , k ) ) ;";"Largest sum subarray with at | Returns maximum sum of a subarray with at - least k elements . ; maxSum [ i ] is going to store maximum sum till index i such that a [ i ] is part of the sum . ; We use Kadane 's algorithm to fill maxSum[]  Below code is taken from method 3 of  https:www.geeksforgeeks.org/largest-sum-contiguous-subarray/ ; Sum of first k elements ; Use the concept of sliding window ; Compute sum of k elements ending with a [ i ] . ; Update result if required ; Include maximum sum till [ i - k ] also if it increases overall max . ; Driver code"
Javascript;"let arr = [ 1 , 5 , 6 ] ; function countWays ( N ) { let count = new Array ( N + 1 ) ; count . fill ( 0 ) ; count [ 0 ] = 1 ; for ( let i = 1 ; i <= N ; i ++ ) for ( let j = 0 ; j < arr . length ; j ++ ) if ( i >= arr [ j ] ) count [ i ] += count [ i - arr [ j ] ] ; return count [ N ] ; } let N = 7 ; document . write ( "" "" + countWays ( N ) ) ;";"Ways to sum to N using array elements with repetition allowed | JavaScript implementation to count ways to sum up to a given value N ; method to count the total number of ways to sum up to ' N ' ; base case ; count ways for all values up to ' N ' and store the result ; if i >= arr [ j ] then accumulate count for value ' i ' as ways to form value ' i - arr [ j ] ' ; required number of ways ; Driver code"
Javascript;"function getTotalNumberOfSequences ( m , n ) { if ( m < n ) return 0 ; if ( n == 0 ) return 1 ; return getTotalNumberOfSequences ( m - 1 , n ) + getTotalNumberOfSequences ( m / 2 , n - 1 ) ; } let m = 10 ; let n = 4 ; document . write ( "" "" , getTotalNumberOfSequences ( m , n ) ) ;";"Sequences of given length where every element is more than or equal to twice of previous | Recursive function to find the number of special sequences ; A special sequence cannot exist if length n is more than the maximum value m . ; If n is 0 , found an empty special sequence ; There can be two possibilities : ( 1 ) Reduce last element value ( 2 ) Consider last element as m and reduce number of terms ; Driver Code"
Javascript;"function getTotalNumberOfSequences ( m , n ) { let T = new Array ( m + 1 ) ; for ( let i = 0 ; i < m + 1 ; i ++ ) { T [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 j == 0 ) T [ i ] [ j ] = 0 ; else if ( i < j ) T [ i ] [ j ] = 0 ; else if ( j == 1 ) T [ i ] [ j ] = i ; else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ parseInt ( i / 2 , 10 ) ] [ j - 1 ] ; } } return T [ m ] [ n ] ; } let m = 10 ; let n = 4 ; document . write ( "" "" + getTotalNumberOfSequences ( m , n ) ) ;";"Sequences of given length where every element is more than or equal to twice of previous | DP based function to find the number of special sequences ; define T and build in bottom manner to store number of special sequences of length n and maximum value m ; Base case : If length of sequence is 0 or maximum value is 0 , there cannot exist any special sequence ; if length of sequence is more than the maximum value , special sequence cannot exist ; If length of sequence is 1 then the number of special sequences is equal to the maximum value For example with maximum value 2 and length 1 , there can be 2 special sequences { 1 } , { 2 } ; otherwise calculate ; Driver Code"
Javascript;"function lcs ( str1 , str2 , m , n ) { let L = new Array ( m + 1 ) ; let i , j ; for ( i = 0 ; i <= m ; i ++ ) { L [ i ] = new Array ( n + 1 ) ; for ( j = 0 ; j <= n ; j ++ ) { L [ i ] [ j ] = 0 ; } } for ( i = 0 ; i <= m ; i ++ ) { for ( j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ i ] [ j ] = 0 ; else if ( str1 [ i - 1 ] == str2 [ j - 1 ] ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ m ] [ n ] ; } function printMinDelAndInsert ( str1 , str2 ) { let m = str1 . length ; let n = str2 . length ; let len = lcs ( str1 , str2 , m , n ) ; document . write ( "" "" + "" "" ) ; document . write ( ( m - len ) + "" "" ) ; document . write ( "" "" + "" "" ) ; document . write ( ( n - len ) + "" "" ) ; } let str1 = "" "" ; let str2 = "" "" ; printMinDelAndInsert ( str1 , str2 ) ;";"Minimum number of deletions and insertions to transform one string into another | Returns length of length common subsequence for str1 [ 0. . m - 1 ] , str2 [ 0. . n - 1 ] ; Following steps build L [ m + 1 ] [ n + 1 ] in bottom up fashion . Note that L [ i ] [ j ] contains length of LCS of str1 [ 0. . i - 1 ] and str2 [ 0. . j - 1 ] ; L [ m ] [ n ] contains length of LCS for X [ 0. . n - 1 ] and Y [ 0. . m - 1 ] ; function to find minimum number of deletions and insertions ; Driver code ; Function Call"
Javascript;"function lis ( arr , n ) { let result = 0 ; let lis = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) lis [ i ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) for ( let j = 0 ; j < i ; j ++ ) if ( arr [ i ] > arr [ j ] && lis [ i ] < lis [ j ] + 1 ) lis [ i ] = lis [ j ] + 1 ; for ( let i = 0 ; i < n ; i ++ ) if ( result < lis [ i ] ) result = lis [ i ] ; return result ; } function minimumNumberOfDeletions ( arr , n ) { let len = lis ( arr , n ) ; return ( n - len ) ; } let arr = [ 30 , 40 , 2 , 5 , 1 , 7 , 45 , 50 , 8 ] ; let n = arr . length ; document . write ( "" "" + minimumNumberOfDeletions ( arr , n ) ) ;";"Minimum number of deletions to make a sorted sequence | lis ( ) returns the length of the longest increasing subsequence in arr [ ] of size n ; Initialize LIS values for all indexes ; Compute optimized LIS values in bottom up manner ; Pick resultimum of all LIS values ; function to calculate minimum number of deletions ; Find longest increasing subsequence ; After removing elements other than the lis , we get sorted sequence . ; Driver Code"
Javascript;"let inf = 1000000000 ; function minCost ( a , n , k ) { let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( k + 1 ) ; for ( let j = 0 ; j <= k ; j ++ ) dp [ i ] [ j ] = inf ; } dp [ 0 ] [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 1 ; j <= k ; j ++ ) for ( let m = i - 1 ; m >= 0 ; m -- ) dp [ i ] [ j ] = Math . min ( dp [ i ] [ j ] , dp [ m ] [ j - 1 ] + ( a [ i - 1 ] - a [ m ] ) * ( a [ i - 1 ] - a [ m ] ) ) ; return dp [ n ] [ k ] ; } let k = 2 ; let a = [ 1 , 5 , 8 , 10 ] ; let n = a . length ; document . write ( minCost ( a , n , k ) ) ;";"Clustering / Partitioning an array such that sum of square differences is minimum | Javascript program to find minimum cost k partitions of array . ; Returns minimum cost of partitioning a [ ] in k clusters . ; Create a dp [ ] [ ] table and initialize all values as infinite . dp [ i ] [ j ] is going to store optimal partition cost for arr [ 0. . i - 1 ] and j partitions ; Fill dp [ ] [ ] in bottom up manner ; Current ending position ( After i - th iteration result for a [ 0. . i - 1 ] is computed . ; j is number of partitions ; Picking previous partition for current i . ; Driver code"
Javascript;"function lps ( str ) { let n = str . length ; let L = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { L [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; j ++ ) { L [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 1 ; for ( let cl = 2 ; cl <= n ; cl ++ ) { for ( let i = 0 ; i < n - cl + 1 ; i ++ ) { let j = i + cl - 1 ; if ( str [ i ] == str [ j ] && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( str [ i ] == str [ j ] ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = Math . max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } return L [ 0 ] [ n - 1 ] ; } function minimumNumberOfDeletions ( str ) { let n = str . length ; let len = lps ( str ) ; return ( n - len ) ; } let str = "" "" ; document . write ( "" "" + "" "" + minimumNumberOfDeletions ( str ) ) ;";"Minimum number of deletions to make a string palindrome | Returns the length of the longest palindromic subsequence in ' str ' ; Create a table to store results of subproblems ; Strings of length 1 are palindrome of length 1 ; Build the table . Note that the lower diagonal values of table are useless and not filled in the process . c1 is length of substring ; length of longest palindromic subsequence ; function to calculate minimum number of deletions ; Find longest palindromic subsequence ; After removing characters other than the lps , we get palindrome . ; Driver Code"
Javascript;"function offeringNumber ( n , templeHeight ) { for ( let i = 0 ; i < n ; ++ i ) { let left = 0 , right = 0 ; for ( let j = i - 1 ; j >= 0 ; -- j ) { if ( templeHeight [ j ] < templeHeight [ j + 1 ] ) ++ left ; else break ; } for ( let j = i + 1 ; j < n ; ++ j ) { if ( templeHeight [ j ] < templeHeight [ j - 1 ] ) ++ right ; else break ; } sum += Math . max ( right , left ) + 1 ; } return sum ; } let arr1 = [ 1 , 2 , 2 ] ; document . write ( offeringNumber ( 3 , arr1 ) + "" "" ) ; let arr2 = [ 1 , 4 , 3 , 6 , 2 , 1 ] ; document . write ( offeringNumber ( 6 , arr2 ) ) ;";"Temple Offerings | Returns minimum offerings required ; Go through all temples one by one ; Go to left while height keeps increasing ; Go to right while height keeps increasing ; This temple should offer maximum of two values to follow the rule . ; Driver code"
Javascript;"function modularSum ( arr , n , m ) { if ( n > m ) return true ; let DP = new Array ( m ) ; for ( let l = 0 ; l < m ; l ++ ) DP [ l ] = false ; for ( let i = 0 ; i < n ; i ++ ) { if ( DP [ 0 ] ) return true ; let temp = new Array ( m ) ; for ( let l = 0 ; l < m ; l ++ ) temp [ l ] = false ; for ( let j = 0 ; j < m ; j ++ ) { if ( DP [ j ] == true ) { if ( DP [ ( j + arr [ i ] ) % m ] == false ) temp [ ( j + arr [ i ] ) % m ] = true ; } } for ( let j = 0 ; j < m ; j ++ ) if ( temp [ j ] ) DP [ j ] = true ; DP [ arr [ i ] % m ] = true ; } return DP [ 0 ] ; } let arr = [ 1 , 7 ] ; let n = arr . length ; let m = 5 ; if ( modularSum ( arr , n , m ) ) document . write ( "" "" + "" "" ) ; else document . write ( "" "" + "" "" ) ;";"Subset with sum divisible by m | Returns true if there is a subset of arr [ ] with sum divisible by m ; This array will keep track of all the possible sum ( after modulo m ) which can be made using subsets of arr [ ] initialising boolean array with all false ; we 'll loop through all the elements of arr[] ; anytime we encounter a sum divisible by m , we are done ; To store all the new encountered sum ( after modulo ) . It is used to make sure that arr [ i ] is added only to those entries for which DP [ j ] was true before current iteration . ; For each element of arr [ ] , we loop through all elements of DP table from 1 to m and we add current element i . e . , arr [ i ] to all those elements which are true in DP table ; if an element is true in DP table ; We update it in temp and update to DP once loop of j is over ; Updating all the elements of temp to DP table since iteration over j is over ; Also since arr [ i ] is a single element subset , arr [ i ] % m is one of the possible sum ; Driver Code"
Javascript;"function maxSum ( tri , n ) { if ( n > 1 ) tri [ 1 ] [ 1 ] = tri [ 1 ] [ 1 ] + tri [ 0 ] [ 0 ] ; tri [ 1 ] [ 0 ] = tri [ 1 ] [ 0 ] + tri [ 0 ] [ 0 ] ; for ( let i = 2 ; i < n ; i ++ ) { tri [ i ] [ 0 ] = tri [ i ] [ 0 ] + tri [ i - 1 ] [ 0 ] ; tri [ i ] [ i ] = tri [ i ] [ i ] + tri [ i - 1 ] [ i - 1 ] ; for ( let j = 1 ; j < i ; j ++ ) { if ( tri [ i ] [ j ] + tri [ i - 1 ] [ j - 1 ] >= tri [ i ] [ j ] + tri [ i - 1 ] [ j ] ) tri [ i ] [ j ] = tri [ i ] [ j ] + tri [ i - 1 ] [ j - 1 ] ; else tri [ i ] [ j ] = tri [ i ] [ j ] + tri [ i - 1 ] [ j ] ; } } let max = tri [ n - 1 ] [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) { if ( max < tri [ n - 1 ] [ i ] ) max = tri [ n - 1 ] [ i ] ; } return max ; } let tri = [ [ 1 ] , [ 2 , 1 ] , [ 3 , 3 , 2 ] ] ; document . write ( maxSum ( tri , 3 ) ) ;";"Maximum sum of a path in a Right Number Triangle | function to find maximum sum path ; Adding the element of row 1 to both the elements of row 2 to reduce a step from the loop ; Traverse remaining rows ; Loop to traverse columns ; tri [ i ] would store the possible combinations of sum of the paths ; array at n - 1 index ( tri [ i ] ) stores all possible adding combination , finding the maximum one out of them ; Driver Code"
Javascript;"function maximumDifferenceSum ( arr , N ) { let dp = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp [ i ] = new Array ( 2 ) ; for ( let j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < N ; i ++ ) dp [ i ] [ 0 ] = dp [ i ] [ 1 ] = 0 ; for ( let i = 0 ; i < ( N - 1 ) ; i ++ ) { dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 1 ] + Math . abs ( 1 - arr [ i ] ) ) ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] + Math . abs ( arr [ i + 1 ] - 1 ) , dp [ i ] [ 1 ] + Math . abs ( arr [ i + 1 ] - arr [ i ] ) ) ; } return Math . max ( dp [ N - 1 ] [ 0 ] , dp [ N - 1 ] [ 1 ] ) ; } let arr = [ 3 , 2 , 1 , 4 , 5 ] ; let N = arr . length ; document . write ( maximumDifferenceSum ( arr , N ) ) ;";"Modify array to maximize sum of adjacent differences | Returns maximum - difference - sum with array modifications allowed . ; Initialize dp [ ] [ ] with 0 values . ; for [ i + 1 ] [ 0 ] ( i . e . current modified value is 1 ) , choose maximum from dp [ i ] [ 0 ] + abs ( 1 - 1 ) = dp [ i ] [ 0 ] and dp [ i ] [ 1 ] + abs ( 1 - arr [ i ] ) ; for [ i + 1 ] [ 1 ] ( i . e . current modified value is arr [ i + 1 ] ) , choose maximum from dp [ i ] [ 0 ] + abs ( arr [ i + 1 ] - 1 ) and dp [ i ] [ 1 ] + abs ( arr [ i + 1 ] - arr [ i ] ) ; Driver code"
Javascript;"function countStrUtil ( dp , n , bCount , cCount ) { if ( bCount < 0 cCount < 0 ) { return 0 ; } if ( n == 0 ) { return 1 ; } if ( bCount == 0 && cCount == 0 ) { return 1 ; } if ( dp [ n ] [ bCount ] [ cCount ] != - 1 ) { return dp [ n ] [ bCount ] [ cCount ] ; } var res = countStrUtil ( dp , n - 1 , bCount , cCount ) ; res += countStrUtil ( dp , n - 1 , bCount - 1 , cCount ) ; res += countStrUtil ( dp , n - 1 , bCount , cCount - 1 ) ; return ( dp [ n ] [ bCount ] [ cCount ] = res ) ; } function countStr ( n , bCount , cCount ) { dp = Array ( n + 1 ) . fill ( 0 ) . map ( x => Array ( 2 ) . fill ( 0 ) . map ( x => Array ( 3 ) . fill ( 0 ) ) ) ; for ( i = 0 ; i < n + 1 ; i ++ ) { for ( j = 0 ; j < 2 ; j ++ ) { for ( k = 0 ; k < 3 ; k ++ ) { dp [ i ] [ j ] [ k ] = - 1 ; } } } return countStrUtil ( dp , n , bCount , cCount ) ; } var n = 3 ; var bCount = 1 , cCount = 2 ; document . write ( countStr ( n , bCount , cCount ) ) ;";"Count of strings that can be formed using a , b and c under given constraints | n is total number of characters . bCount and cCount are counts of ' b ' and ' c ' respectively . ; Base cases ; if we had saw this combination previously ; Three cases , we choose , a or b or c In all three cases n decreases by 1. ; A wrapper over countStrUtil ( ) ; Total number of characters"
Javascript;"let N = 8 ; let dx = [ 1 , 2 , 2 , 1 , - 1 , - 2 , - 2 , - 1 ] ; let dy = [ 2 , 1 , - 1 , - 2 , - 2 , - 1 , 1 , 2 ] ; function inside ( x , y ) { return ( x >= 0 && x < N && y >= 0 && y < N ) ; } function findProb ( start_x , start_y , steps ) { let dp1 = new Array ( N ) ; for ( let i = 0 ; i < N ; i ++ ) { dp1 [ i ] = new Array ( N ) ; for ( let j = 0 ; j < N ; j ++ ) { dp1 [ i ] [ j ] = new Array ( steps + 1 ) ; for ( let k = 0 ; k < steps + 1 ; k ++ ) { dp1 [ i ] [ j ] [ k ] = 0 ; } } } for ( let i = 0 ; i < N ; ++ i ) for ( let j = 0 ; j < N ; ++ j ) dp1 [ i ] [ j ] [ 0 ] = 1 ; for ( let s = 1 ; s <= steps ; ++ s ) { for ( let x = 0 ; x < N ; ++ x ) { for ( let y = 0 ; y < N ; ++ y ) { let prob = 0.0 ; for ( let i = 0 ; i < 8 ; ++ i ) { let nx = x + dx [ i ] ; let ny = y + dy [ i ] ; if ( inside ( nx , ny ) ) prob += dp1 [ nx ] [ ny ] [ s - 1 ] / 8.0 ; } dp1 [ x ] [ y ] [ s ] = prob ; } } } return dp1 [ start_x ] [ start_y ] [ steps ] ; } let K = 3 ; document . write ( findProb ( 0 , 0 , K ) ) ;";"Probability of Knight to remain in the chessboard | size of the chessboard ; direction vector for the Knight ; returns true if the knight is inside the chessboard ; Bottom up approach for finding the probability to go out of chessboard . ; dp array ; for 0 number of steps , each position will have probability 1 ; for every number of steps s ; for every position ( x , y ) after s number of steps ; for every position reachable from ( x , y ) ; if this position lie inside the board ; store the result ; return the result ; number of steps ; Function Call"
Javascript;"function countSubarray ( arr , n , k ) { let s = 0 ; let i = 0 ; while ( i < n ) { if ( arr [ i ] > k ) { i ++ ; continue ; } let count = 0 ; while ( i < n && arr [ i ] <= k ) { i ++ ; count ++ ; } s += parseInt ( ( count * ( count + 1 ) ) / 2 , 10 ) ; } return ( n * parseInt ( ( n + 1 ) / 2 , 10 ) - s ) ; } let arr = [ 1 , 2 , 3 ] ; let k = 2 ; let n = arr . length ; document . write ( countSubarray ( arr , n , k ) ) ;";"Count of subarrays whose maximum element is greater than k | Return number of subarrays whose maximum element is less than or equal to K . ; To store count of subarrays with all elements less than or equal to k . ; Traversing the array . ; If element is greater than k , ignore . ; Counting the subarray length whose each element is less than equal to k . ; Suming number of subarray whose maximum element is less than equal to k . ; Driver code"
Javascript;"function nCr ( n , k ) { let C = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { C [ i ] = new Array ( k + 1 ) ; for ( let j = 0 ; j <= k ; j ++ ) { C [ i ] [ j ] = 0 ; } } let i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; } function resultOfAllSubsets ( arr , N ) { let result = 0.0 ; let sum = 0 ; for ( let i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; for ( let n = 1 ; n <= N ; n ++ ) result += ( sum * ( nCr ( N - 1 , n - 1 ) ) ) / n ; return result ; } let arr = [ 2 , 3 , 5 , 7 ] ; let N = arr . length ; document . write ( resultOfAllSubsets ( arr , N ) ) ;";"Sum of average of all subsets | Returns value of Binomial Coefficient C ( n , k ) ; Calculate value of Binomial Coefficient in bottom up manner ; Base Cases ; Calculate value using previously stored values ; method returns sum of average of all subsets ; Initialize result ; Find sum of elements ; looping once for all subset of same size ; each element occurs nCr ( N - 1 , n - 1 ) times while considering subset of size n ; Driver code to test above methods"
Javascript;"let arr = [ 100 , 1000 , 100 , 1000 , 1 ] ; let sum = new Array ( 10000 ) ; for ( let i = 0 ; i < 10000 ; i ++ ) { sum [ i ] = - 1 ; } function maxSumWO3Consec ( n ) { if ( sum [ n ] != - 1 ) { return sum [ n ] ; } if ( n == 0 ) { return sum [ n ] = 0 ; } if ( n == 1 ) { return sum [ n ] = arr [ 0 ] ; } if ( n == 2 ) { return sum [ n ] = arr [ 1 ] + arr [ 0 ] ; } return sum [ n ] = 500 + Math . max ( Math . max ( maxSumWO3Consec ( n - 1 ) , maxSumWO3Consec ( n - 2 ) + arr [ n ] ) , arr [ n ] + arr [ n - 1 ] + maxSumWO3Consec ( n - 3 ) ) ; } let n = arr . length - 1 ; document . write ( maxSumWO3Consec ( n ) + 1 ) ;";"Maximum subsequence sum such that no three are consecutive | JavaScript program to find the maximum sum such that no three are consecutive using recursion . ; Returns maximum subsequence sum such that no three elements are consecutive ; Base cases ( process first three elements ) ; Process rest of the elements We have three cases ; Driver code"
Javascript;"function maxSumPairWithDifferenceLessThanK ( arr , N , k ) { var maxSum = 0 ; arr . sort ( ( a , b ) => a - b ) ; for ( i = N - 1 ; i > 0 ; -- i ) { if ( arr [ i ] - arr [ i - 1 ] < k ) { maxSum += arr [ i ] ; maxSum += arr [ i - 1 ] ; -- i ; } } return maxSum ; } var arr = [ 3 , 5 , 10 , 15 , 17 , 12 , 9 ] ; var N = arr . length ; var K = 4 ; document . write ( maxSumPairWithDifferenceLessThanK ( arr , N , K ) ) ;";"Maximum sum of pairs with specific difference | Method to return maximum sum we can get by finding less than K difference pairs ; Sort elements to ensure every i and i - 1 is closest possible pair ; To get maximum possible sum , iterate from largest to smallest , giving larger numbers priority over smaller numbers . ; Case I : Diff of arr [ i ] and arr [ i - 1 ] is less then K , add to maxSum Case II : Diff between arr [ i ] and arr [ i - 1 ] is not less then K , move to next i since with sorting we know , arr [ i ] - arr [ i - 1 ] < arr [ i ] - arr [ i - 2 ] and so on . ; Assuming only positive numbers . ; When a match is found skip this pair ; Driver code"
Javascript;"function countGroups ( position , previous_sum , length , num ) { if ( position == length ) return 1 ; let res = 0 ; let sum = 0 ; for ( let i = position ; i < length ; i ++ ) { sum += ( num [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } return res ; } let num = "" "" ; let len = num . length ; document . write ( countGroups ( 0 , 0 , len , num ) ) ;";"Count digit groupings of a number with given constraints | Function to find the subgroups ; Terminating Condition ; sum of digits ; Traverse all digits from current position to rest of the length of string ; If forward_sum is greater than the previous sum , then call the method again ; Note : We pass current sum as previous sum ; Total number of subgroups till current position ; Driver Code"
Javascript;"let MAX = 40 ; let dp = new Array ( MAX ) ; function countGroups ( position , previous_sum , length , num ) { if ( position == length ) return 1 ; if ( dp [ position ] [ previous_sum ] != - 1 ) return dp [ position ] [ previous_sum ] ; dp [ position ] [ previous_sum ] = 0 ; let res = 0 ; let sum = 0 ; for ( let i = position ; i < length ; i ++ ) { sum += ( num [ i ] - ' ' ) ; if ( sum >= previous_sum ) res += countGroups ( i + 1 , sum , length , num ) ; } dp [ position ] [ previous_sum ] = res ; return res ; } let num = "" "" . split ( "" "" ) ; let len = num . length ; for ( let i = 0 ; i < dp . length ; i ++ ) { dp [ i ] = new Array ( 9 * MAX + 1 ) for ( let j = 0 ; j < 9 * MAX + 1 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } document . write ( countGroups ( 0 , 0 , len , num ) ) ;";"Count digit groupings of a number with given constraints | Maximum length of input number string ; A memoization table to store results of subproblems length of string is 40 and maximum sum will be 9 * 40 = 360. ; Function to find the count of splits with given condition ; Terminating Condition ; If already evaluated for a given sub problem then return the value ; countGroups for current sub - group is 0 ; sum of digits ; Traverse all digits from current position to rest of the length of string ; If forward_sum is greater than the previous sum , then call the method again ; Note : We pass current sum as previous sum ; total number of subgroups till current position ; Driver Code ; Initialize dp table"
Javascript;"function KnapSack ( val , wt , n , W ) { let dp = new Array ( W + 1 ) ; for ( let i = 0 ; i < W + 1 ; i ++ ) { dp [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) for ( let j = W ; j >= wt [ i ] ; j -- ) dp [ j ] = Math . max ( dp [ j ] , val [ i ] + dp [ j - wt [ i ] ] ) ; return dp [ W ] ; } let val = [ 7 , 8 , 4 ] ; let wt = [ 3 , 8 , 6 ] ; let W = 10 , n = 3 ; document . write ( KnapSack ( val , wt , n , W ) ) ;";"A Space Optimized DP solution for 0 | val [ ] is for storing maximum profit for each weight wt [ ] is for storing weights n number of item W maximum capacity of bag dp [ W + 1 ] to store final result ; array to store final result dp [ i ] stores the profit with KnapSack capacity "" i "" ; initially profit with 0 to W KnapSack capacity is 0 ; iterate through all items ; traverse dp array from right to left ; above line finds out maximum of dp [ j ] ( excluding ith element value ) and val [ i ] + dp [ j - wt [ i ] ] ( including ith element value and the profit with "" KnapSack ▁ capacity ▁ - ▁ ith ▁ element ▁ weight "" ) ; Driver code"
Javascript;"function count ( a , b ) { var m = a . length ; var n = b . length ; var lookup = Array ( m + 1 ) ; for ( var i = 0 ; i < m + 1 ; i ++ ) lookup [ i ] = Array ( n + 1 ) . fill ( 0 ) ; for ( i = 0 ; i <= n ; ++ i ) lookup [ 0 ] [ i ] = 0 ; for ( i = 0 ; i <= m ; ++ i ) lookup [ i ] [ 0 ] = 1 ; for ( i = 1 ; i <= m ; i ++ ) { for ( j = 1 ; j <= n ; j ++ ) { if ( a . charAt ( i - 1 ) == b . charAt ( j - 1 ) ) lookup [ i ] [ j ] = lookup [ i - 1 ] [ j - 1 ] + lookup [ i - 1 ] [ j ] ; else lookup [ i ] [ j ] = lookup [ i - 1 ] [ j ] ; } } return lookup [ m ] [ n ] ; } var a = "" "" ; var b = "" "" ; document . write ( count ( a , b ) ) ;";"Find number of times a string occurs as a subsequence in given string | Iterative DP function to find the number of times the second string occurs in the first string , whether continuous or discontinuous ; Create a table to store results of sub - problems ; If first string is empty ; If second string is empty ; Fill lookup in bottom up manner ; If last characters are same , we have two options - 1. consider last characters of both strings in solution 2. ignore last character of first string ; If last character are different , ignore last character of first string ; Driver Code"
Javascript;"function lenOfLongestGP ( set , n ) { if ( n < 2 ) { return n ; } if ( n == 2 ) { return ( set [ 1 ] % set [ 0 ] == 0 ? 2 : 1 ) ; } set . sort ( function ( a , b ) { return a - b } ) ; let L = new Array ( n ) ; for ( let i = 0 ; i < n ; ++ i ) { L [ i ] = new Array ( n ) ; for ( let j = 0 ; j < n ; ++ j ) { L [ i ] [ j ] = 0 ; } } let llgp = 1 ; for ( let i = 0 ; i < n - 1 ; ++ i ) { if ( set [ n - 1 ] % set [ i ] == 0 ) { L [ i ] [ n - 1 ] = 2 ; if ( 2 > llgp ) llgp = 2 ; } else { L [ i ] [ n - 1 ] = 1 ; } } L [ n - 1 ] [ n - 1 ] = 1 ; for ( let j = n - 2 ; j >= 1 ; -- j ) { let i = j - 1 , k = j + 1 ; while ( i >= 0 && k <= n - 1 ) { if ( set [ i ] * set [ k ] < set [ j ] * set [ j ] ) { ++ k ; } else if ( set [ i ] * set [ k ] > set [ j ] * set [ j ] ) { if ( set [ j ] % set [ i ] == 0 ) { L [ i ] [ j ] = 2 ; if ( 2 > llgp ) llgp = 2 ; } else { L [ i ] [ j ] = 1 ; } -- i ; } else { if ( set [ j ] % set [ i ] == 0 ) { L [ i ] [ j ] = L [ j ] [ k ] + 1 ; if ( L [ i ] [ j ] > llgp ) { llgp = L [ i ] [ j ] ; } } else { L [ i ] [ j ] = 1 ; } -- i ; ++ k ; } } while ( i >= 0 ) { if ( set [ j ] % set [ i ] == 0 ) { L [ i ] [ j ] = 2 ; if ( 2 > llgp ) llgp = 2 ; } else { L [ i ] [ j ] = 1 ; } -- i ; } } return llgp ; } let set1 = [ 1 , 3 , 9 , 27 , 81 , 243 ] ; let n1 = set1 . length ; document . write ( lenOfLongestGP ( set1 , n1 ) + "" "" ) ; let set2 = [ 1 , 3 , 4 , 9 , 7 , 27 ] ; let n2 = set2 . length ; document . write ( lenOfLongestGP ( set2 , n2 ) + "" "" ) ; let set3 = [ 2 , 3 , 5 , 7 , 11 , 13 ] ; let n3 = set3 . length ; document . write ( lenOfLongestGP ( set3 , n3 ) + "" "" ) ;";"Longest Geometric Progression | Returns length of the longest GP subset of set [ ] ; Base cases ; Let us sort the set first ; An entry L [ i ] [ j ] in this table stores LLGP with set [ i ] and set [ j ] as first two elements of GP and j > i . ; Initialize result ( A single element is always a GP ) ; Initialize values of last column ; Consider every element as second element of GP ; Search for i and k for j ; Two cases when i , j and k don 't form a GP. ; i , j and k form GP , LLGP with i and j as first two elements is equal to LLGP with j and k as first two elements plus 1. L [ j ] [ k ] must have been filled before as we run the loop from right side ; Update overall LLGP ; Change i and k to fill more L [ i ] [ j ] values for current j ; If the loop was stopped due to k becoming more than n - 1 , set the remaining entries in column j as 1 or 2 based on divisibility of set [ j ] by set [ i ] ; Return result ; Driver code"
Javascript;"function lcs ( X , Y ) { let m = X . length , n = Y . length ; let L = new Array ( 2 ) ; for ( let i = 0 ; i < 2 ; i ++ ) { L [ i ] = new Array ( n + 1 ) ; for ( let j = 0 ; j < n + 1 ; j ++ ) { L [ i ] [ j ] = 0 ; } } let bi = 0 ; for ( let i = 0 ; i <= m ; i ++ ) { bi = i & 1 ; for ( let j = 0 ; j <= n ; j ++ ) { if ( i == 0 j == 0 ) L [ bi ] [ j ] = 0 ; else if ( X [ i - 1 ] == Y [ j - 1 ] ) L [ bi ] [ j ] = L [ 1 - bi ] [ j - 1 ] + 1 ; else L [ bi ] [ j ] = Math . max ( L [ 1 - bi ] [ j ] , L [ bi ] [ j - 1 ] ) ; } } return L [ bi ] [ n ] ; } let X = "" "" ; let Y = "" "" ; document . write ( "" "" + lcs ( X , Y ) ) ;";"A Space Optimized Solution of LCS | Returns length of LCS for X [ 0. . m - 1 ] , Y [ 0. . n - 1 ] ; Find lengths of two strings ; Binary index , used to index current row and previous row . ; Compute current binary index ; Last filled entry contains length of LCS for X [ 0. . n - 1 ] and Y [ 0. . m - 1 ] ; Driver code"
Javascript;"function subsetXOR ( arr , n , k ) { let max_ele = arr [ 0 ] ; for ( let i = 1 ; i < n ; i ++ ) if ( arr [ i ] > max_ele ) max_ele = arr [ i ] ; let m = ( 1 << parseInt ( Math . log ( max_ele ) / Math . log ( 2 ) + 1 , 10 ) ) - 1 ; if ( k > m ) { return 0 ; } let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( m + 1 ) ; for ( let j = 0 ; j <= m ; j ++ ) { dp [ i ] [ j ] = 0 ; } } dp [ 0 ] [ 0 ] = 1 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = 0 ; j <= m ; j ++ ) dp [ i ] [ j ] = dp [ i - 1 ] [ j ] + dp [ i - 1 ] [ j ^ arr [ i - 1 ] ] ; return dp [ n ] [ k ] ; } let arr = [ 1 , 2 , 3 , 4 , 5 ] ; let k = 4 ; let n = arr . length ; document . write ( "" "" + subsetXOR ( arr , n , k ) ) ;";"Count number of subsets having a particular XOR value | Returns count of subsets of arr [ ] with XOR value equals to k . ; Find maximum element in arr [ ] ; Maximum possible XOR value ; The value of dp [ i ] [ j ] is the number of subsets having XOR of their elements as j from the set arr [ 0. . . i - 1 ] ; Initializing all the values of dp [ i ] [ j ] as 0 ; The xor of empty subset is 0 ; Fill the dp table ; The answer is the number of subset from set arr [ 0. . n - 1 ] having XOR of elements as k ; Driver Code"
Javascript;"function findMin ( arr , n ) { let sum = 0 ; for ( let i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; let dp = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { dp [ i ] = new Array ( sum + 1 ) ; for ( let j = 0 ; j <= sum ; j ++ ) { if ( j == 0 ) dp [ i ] [ j ] = true ; } } for ( let i = 1 ; i <= sum ; i ++ ) dp [ 0 ] [ i ] = false ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = 1 ; j <= sum ; j ++ ) { dp [ i ] [ j ] = dp [ i - 1 ] [ j ] ; if ( arr [ i - 1 ] <= j ) dp [ i ] [ j ] |= dp [ i - 1 ] [ j - arr [ i - 1 ] ] ; } } let diff = Number . MAX_VALUE ; for ( let j = Math . floor ( sum / 2 ) ; j >= 0 ; j -- ) { if ( dp [ n ] [ j ] == true ) { diff = sum - 2 * j ; break ; } } return diff ; } let arr = [ 3 , 1 , 4 , 2 , 2 , 1 ] ; let n = arr . length ; document . write ( "" "" + findMin ( arr , n ) ) ;";"Partition a set into two subsets such that the difference of subset sums is minimum | Returns the minimum value of the difference of the two sets . ; Calculate sum of all elements ; Create an array to store results of subproblems ; Initialize first column as true . 0 sum is possible with all elements . ; Initialize top row , except dp [ 0 ] [ 0 ] , as false . With 0 elements , no other sum except 0 is possible ; Fill the partition table in bottom up manner ; If i 'th element is excluded ; If i 'th element is included ; Initialize difference of two sums . ; Find the largest j such that dp [ n ] [ j ] is true where j loops from sum / 2 t0 0 ; Driver program to test above function"
Javascript;"let MAX = 1000 ; let dp = new Array ( MAX ) ; for ( let i = 0 ; i < MAX ; i ++ ) { dp [ i ] = new Array ( MAX ) ; for ( let j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = 0 ; } } function minSizeRec ( arr , low , high , k ) { if ( dp [ low ] [ high ] != - 1 ) { return dp [ low ] [ high ] ; } if ( ( high - low + 1 ) < 3 ) { return high - low + 1 ; } let res = 1 + minSizeRec ( arr , low + 1 , high , k ) ; for ( let i = low + 1 ; i <= high - 1 ; i ++ ) { for ( let j = i + 1 ; j <= high ; j ++ ) { if ( arr [ i ] == ( arr [ low ] + k ) && arr [ j ] == ( arr [ low ] + 2 * k ) && minSizeRec ( arr , low + 1 , i - 1 , k ) == 0 && minSizeRec ( arr , i + 1 , j - 1 , k ) == 0 ) { res = Math . min ( res , minSizeRec ( arr , j + 1 , high , k ) ) ; } } } return ( dp [ low ] [ high ] = res ) ; } function minSize ( arr , n , k ) { for ( let i = 0 ; i < MAX ; i ++ ) { for ( let j = 0 ; j < MAX ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } return minSizeRec ( arr , 0 , n - 1 , k ) ; } let arr = [ 2 , 3 , 4 , 5 , 6 , 4 ] ; let n = arr . length ; let k = 1 ; document . write ( minSize ( arr , n , k ) ) ;";"Find minimum possible size of array with given rules for removing elements | Javascript program to find size of minimum possible array after removing elements according to given rules ; dp [ i ] [ j ] denotes the minimum number of elements left in the subarray arr [ i . . j ] . ; If already evaluated ; If size of array is less than 3 ; Initialize result as the case when first element is separated ( not removed using given rules ) ; Now consider all cases when first element forms a triplet and removed . Check for all possible triplets ( low , i , j ) ; Check if this triplet follows the given rules of removal . And elements between ' low ' and ' i ' , and between ' i ' and ' j ' can be recursively removed . ; Insert value in table and return result ; This function mainly initializes dp table and calls recursive function minSizeRec ; Driver code"
Javascript;"function countSol ( coeff , start , end , rhs ) { if ( rhs == 0 ) return 1 ; let result = 0 ; for ( let i = start ; i <= end ; i ++ ) if ( coeff [ i ] <= rhs ) result += countSol ( coeff , i , end , rhs - coeff [ i ] ) ; return result ; } let coeff = [ 2 , 2 , 5 ] ; let rhs = 4 ; let n = coeff . length ; document . write ( countSol ( coeff , 0 , n - 1 , rhs ) ) ;";"Find number of solutions of a linear equation of n variables | Recursive function that returns count of solutions for given RHS value and coefficients coeff [ start . . end ] ; Base case ; Initialize count of solutions ; One by subtract all smaller or equal coefficiants and recur ; Driver Code"
Javascript;"function getMaxRec ( str , i , n , lookup ) { if ( i >= n ) { return 0 ; } if ( lookup [ i ] != - 1 ) { return lookup [ i ] ; } let ans = 1 + getMaxRec ( str , i + 1 , n , lookup ) ; if ( i + 1 < n ) { if ( str [ i ] != str [ i + 1 ] ) { ans = Math . max ( 4 + getMaxRec ( str , i + 2 , n , lookup ) , ans ) ; } else { ans = Math . max ( 3 + getMaxRec ( str , i + 2 , n , lookup ) , ans ) ; } } return lookup [ i ] = ans ; } function getMaxWeight ( str ) { let n = str . length ; let lookup = new Array ( n ) ; lookup . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { lookup [ i ] = - 1 ; } return getMaxRec ( str , 0 , str . length , lookup ) ; } let str = "" "" ; document . write ( "" "" + "" "" + str + "" "" + getMaxWeight ( str ) ) ;";"Maximum weight transformation of a given string | Returns weight of the maximum weight transformation ; Base case ; If this subproblem is already solved ; Don 't make pair, so  weight gained is 1 ; If we can make pair ; If elements are dissimilar , weight gained is 4 ; if elements are similar so for making a pair we toggle any of them . Since toggle cost is 1 so overall weight gain becomes 3 ; save and return maximum of above cases ; Initializes lookup table and calls getMaxRec ( ) ; Create and initialize lookup table ; Call recursive function ; Driver Code"
Javascript;"function steps ( source , step , dest ) { if ( Math . abs ( source ) > ( dest ) ) return Number . MAX_SAFE_INTEGER ; if ( source == dest ) return step ; let pos = steps ( source + step + 1 , step + 1 , dest ) ; let neg = steps ( source - step - 1 , step + 1 , dest ) ; return Math . min ( pos , neg ) ; } let dest = 11 ; document . write ( "" "" + dest + "" "" + steps ( 0 , 0 , dest ) ) ;";"Minimum steps to reach a destination | source -> source vertex step -> value of last step taken dest -> destination vertex ; base cases ; if we go on positive side ; if we go on negative side ; minimum of both cases ; Driver code"
Javascript;"function LCSubStr ( s , t , n , m ) { var dp = Array ( 2 ) . fill ( ) . map ( ( ) => Array ( m + 1 ) . fill ( 0 ) ) ; var res = 0 ; for ( var i = 1 ; i <= n ; i ++ ) { for ( var j = 1 ; j <= m ; j ++ ) { if ( s . charAt ( i - 1 ) == t . charAt ( j - 1 ) ) { dp [ i % 2 ] [ j ] = dp [ ( i - 1 ) % 2 ] [ j - 1 ] + 1 ; if ( dp [ i % 2 ] [ j ] > res ) res = dp [ i % 2 ] [ j ] ; } else dp [ i % 2 ] [ j ] = 0 ; } } return res ; } var X = "" "" ; var Y = "" "" ; var m = X . length ; var n = Y . length ; document . write ( LCSubStr ( X , Y , m , n ) ) ;";"Longest Common Substring | DP | Function to find the length of the longest LCS ; Create DP table ; Driver Code ; Function call"
Javascript;"let X , Y ; function lcs ( i , j , count ) { if ( i == 0 j == 0 ) return count ; if ( X [ i - 1 ] == Y [ j - 1 ] ) { count = lcs ( i - 1 , j - 1 , count + 1 ) ; } count = Math . max ( count , Math . max ( lcs ( i , j - 1 , 0 ) , lcs ( i - 1 , j , 0 ) ) ) ; return count ; } let n , m ; X = "" "" ; Y = "" "" ; n = X . length ; m = Y . length ; document . write ( lcs ( n , m , 0 ) ) ;";"Longest Common Substring | DP | Javascript program using to find length of the longest common substring recursion ; Returns length of function f or longest common substring of X [ 0. . m - 1 ] and Y [ 0. . n - 1 ] ; Driver code"
Javascript;"function possibleEqualArray ( A , N ) { var tot_XOR = 0 ; for ( var i = 0 ; i < N ; i ++ ) { tot_XOR ^= A [ i ] ; } if ( tot_XOR == 0 ) { document . write ( "" "" ) ; return ; } var cur_XOR = 0 ; var cnt = 0 ; for ( var i = 0 ; i < N ; i ++ ) { cur_XOR ^= A [ i ] ; if ( cur_XOR == tot_XOR ) { cnt ++ ; cur_XOR = 0 ; } } if ( cnt > 2 ) { document . write ( "" "" ) ; } else { document . write ( "" "" ) ; } } var A = [ 0 , 2 , 2 ] ; var N = ( A . length ) ; possibleEqualArray ( A , N ) ;";"Make Array elements equal by replacing adjacent elements with their XOR | Function to check if it is possible to make all the array elements equal using the given operation ; Stores the XOR of all elements of array A [ ] ; Case 1 , check if the XOR of the array A [ ] is 0 ; Maintains the XOR till the current element ; Iterate over the array ; If the current XOR is equal to the total XOR increment the count and initialize current XOR as 0 ; Print Answer ; Driver Code ; Function Call"
Javascript;"function countPalindromes ( S ) { var N = S . length ; var Z = Array ( N ) . fill ( 0 ) ; var l = 0 , r = 0 ; for ( var i = 1 ; i < N ; i ++ ) { if ( i <= r ) Z [ i ] = Math . min ( r - i + 1 , Z [ i - l ] ) ; while ( i + Z [ i ] < N && S [ Z [ i ] ] == S [ i + Z [ i ] ] ) { Z [ i ] ++ ; } if ( i + Z [ i ] - 1 > r ) { l = i ; r = i + Z [ i ] - 1 ; } } var sum = 0 ; for ( var i = 0 ; i < Z . length ; i ++ ) { sum += Z [ i ] + 1 ; } return sum ; } var S = "" "" ; document . write ( countPalindromes ( S ) ) ;";"Count of palindromes that can be obtained by concatenating equal length prefix and substrings | Function to calculate the number of palindromes ; Calculation of Z - array ; Calculation of sigma ( Z [ i ] + 1 ) ; Return the count ; Given String"
Javascript;"function printSubsInDelimeters ( str ) { let dels = [ ] ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] == ' ' ) { dels . push ( i ) ; } else if ( ( str [ i ] == ' ' ) && ( dels . length > 0 ) ) { let pos = dels [ dels . length - 1 ] ; dels . pop ( ) ; let len = i - 1 - pos ; let ans ; if ( pos < len ) { ans = str . substring ( pos + 1 , len + 1 ) ; } else { ans = str . substring ( pos + 1 , len + pos + 1 ) ; } document . write ( ans + "" "" ) ; } } } let str = "" "" ; printSubsInDelimeters ( str ) ;";"Extract substrings between any pair of delimiters | Function to print strings present between any pair of delimeters ; Stores the indices of ; If opening delimeter is encountered ; If closing delimeter is encountered ; Extract the position of opening delimeter ; Length of substring ; Extract the substring ; Driver Code"
Javascript;"class pair { constructor ( first , second ) { this . first = first ; this . second = second ; } } function printDiagonalTraversal ( nums ) { let m = nums . length ; let q = [ ] ; q . push ( new pair ( 0 , 0 ) ) ; while ( q . length != 0 ) { let p = q [ 0 ] ; q . shift ( ) ; document . write ( nums [ p . first ] [ p . second ] + "" "" ) ; if ( p . second == 0 && p . first + 1 < m ) { q . push ( new pair ( p . first + 1 , p . second ) ) ; } if ( p . second + 1 < nums [ p . first ] . length ) q . push ( new pair ( p . first , p . second + 1 ) ) ; } } let arr = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ; printDiagonalTraversal ( arr ) ;";"Print matrix elements from top | Javascript program for the above approach ; Function to traverse the matrix diagonally upwards ; Store the number of rows ; Initialize queue ; Push the index of first element i . e . , ( 0 , 0 ) ; Get the front element ; Pop the element at the front ; Insert the element below if the current element is in first column ; Insert the right neighbour if it exists ; Given vector of vectors arr ; Function call"
Javascript;"function restore ( arr , N ) { var result = [ ] ; var mp = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { if ( ! mp . has ( arr [ i ] ) ) { result . push ( arr [ i ] ) ; mp . set ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } } return result ; } function print_result ( result ) { for ( var i = 0 ; i < result . length ; i ++ ) { document . write ( result [ i ] + "" "" ) ; } } var arr = [ 1 , 13 , 1 , 24 , 13 , 24 , 2 , 2 ] ; var N = arr . length ; print_result ( restore ( arr , N ) ) ;";"Find original sequence from Array containing the sequence merged many times in order | Function that returns the restored permutation ; Vector to store the result ; Map to mark the elements which are taken in result ; Check if the element is coming first time ; Push in result vector ; Mark it in the map ; Return the answer ; Function to print the result ; Given Array ; Function Call"
Javascript;"function restore ( arr , N ) { let result = [ ] ; let count1 = 1 ; let s = new Set ( ) ; for ( let i = 0 ; i < N ; i ++ ) { s . add ( arr [ i ] ) ; if ( s . size == count1 ) { result . push ( arr [ i ] ) ; count1 ++ ; } } return result ; } function print_result ( result ) { for ( let i = 0 ; i < result . length ; i ++ ) document . write ( result [ i ] + "" "" ) ; } let arr = [ 1 , 13 , 1 , 24 , 13 , 24 , 2 , 2 ] ; let N = arr . length ; print_result ( restore ( arr , N ) ) ;";"Find original sequence from Array containing the sequence merged many times in order | Function that returns the restored permutation ; Vector to store the result ; Set to insert unique elements ; Check if the element is coming first time ; Push in result vector ; Function to print the result ; Given Array ; Function call"
Javascript;"function sum ( n ) { return n * parseInt ( ( n - 1 ) / 2 ) ; } function BSpattern ( N ) { var Val = 0 , Pthree = 0 , cnt = 0 , initial ; var s = "" "" ; for ( var i = 0 ; i < N ; i ++ ) { cnt = 0 ; if ( i > 0 ) { document . write ( s ) ; s += "" "" ; } for ( var j = i ; j < N ; j ++ ) { if ( i > 0 ) { cnt ++ ; } document . write ( ++ Val ) ; document . write ( 0 ) ; } if ( i == 0 ) { var Sumbeforelast = sum ( Val ) * 2 ; Pthree = Val + Sumbeforelast + 1 ; initial = Pthree ; } initial = initial - cnt ; Pthree = initial ; for ( var k = i ; k < N ; k ++ ) { document . write ( Pthree ++ ) ; if ( k != N - 1 ) { document . write ( 0 ) ; } } document . write ( "" "" ) ; } } var N = 5 ; BSpattern ( N ) ;";"Program to print the pattern 1020304017018019020 * * 50607014015016 * * * * 809012013 * * * * * * 10011. . . | Function to find the sum of N integers from 1 to N ; Function to print the given pattern ; Iterate over [ 0 , N - 1 ] ; Sub - Pattern - 1 ; Sub - Pattern - 2 ; Count the number of element in rows and sub - pattern 2 and 3 will have same rows ; Increment Val to print the series 1 , 2 , 3 , 4 , 5 ... ; Finally , add the ( N - 1 ) th element i . e . , 5 and increment it by 1 ; Initial is used to give the initial value of the row in Sub - Pattern 3 ; Sub - Pattern 3 ; Skip printing zero at the last ; Given N ; Function Call"
Javascript;"function checkprefix ( A , B ) { var s1 = A . toString ( ) ; var s2 = B . toString ( ) ; var n1 = s1 . length ; var n2 = s2 . length ; if ( n1 < n2 ) { return false ; } for ( var i = 0 ; i < n2 ; i ++ ) { if ( s1 [ i ] != s2 [ i ] ) { return false ; } } return true ; } var A = 12345 , B = 12 ; var result = checkprefix ( A , B ) ; if ( result ) { document . write ( "" "" ) ; } else { document . write ( "" "" ) ; }";"Check if a number starts with another number or not | Function to check if B is a prefix of A or not ; Convert numbers into Strings ; Find the lengths of Strings s1 and s2 ; Base Case ; Traverse the Strings s1 & s2 ; If at any index characters are unequals then return false ; Return true ; Given numbers ; Function call ; If B is a prefix of A , then print "" Yes """
Javascript;"function possibleToReach ( x , y , z ) { if ( z < Math . abs ( x ) + Math . abs ( y ) || ( z - Math . abs ( x ) - Math . abs ( y ) ) % 2 == 1 ) { document . write ( "" "" + "" "" ) ; } else document . write ( "" "" + "" "" ) ; } var x = 5 , y = 5 ; var z = 11 ; possibleToReach ( x , y , z ) ;";"Check if it is possible to reach ( x , y ) from origin in exactly Z steps using only plus movements | Function to check if it is possible to reach ( x , y ) from origin in exactly z steps ; Condition if we can 't reach in Z steps ; Destination povar coordinate ; Number of steps allowed ; Function Call"
Javascript;"function nCycle ( N ) { return ( N ) * ( N - 1 ) + 1 ; } let N = 4 ; document . write ( nCycle ( N ) ) ;";"Number of cycles in a Polygon with lines from Centroid to Vertices | Function to find the Number of Cycles ; Driver code"
Javascript;"let a = new Array ( 65 ) ; a . fill ( 0 ) ; function Count ( i ) { if ( i == 0 ) return 1 ; else if ( i < 0 ) return 0 ; if ( a [ i ] == 0 ) { a [ i ] = ( i + 1 ) + 2 * Count ( i - 1 ) ; return a [ i ] ; } else return a [ i ] ; } function solve ( n ) { let i , sum = 0 ; while ( n > 0 ) { i = parseInt ( Math . log ( n ) / Math . log ( 2 ) , 10 ) ; n = n - parseInt ( Math . pow ( 2 , i ) , 10 ) ; sum = sum + ( i + 1 ) + Count ( i - 1 ) ; } return sum ; } let n = 7 ; document . write ( solve ( n ) ) ;";"Sum of consecutive bit differences of first N non | Javascript program for the above problem ; Recursive function to count the sum of bit differences of numbers from 1 to pow ( 2 , ( i + 1 ) ) - 1 ; base cases ; Recursion call if the sum of bit difference of numbers around i are not calculated ; return the sum of bit differences if already calculated ; Function to calculate the sum of bit differences up to N ; nearest smaller power of 2 ; remaining numbers ; calculate the count of bit diff ; Driver code"
Javascript;"function count_ht ( s , N ) { var p = [ 0 , 0 ] ; if ( s == ' ' ) { p [ 0 ] = Math . floor ( N / 2.0 ) ; p [ 1 ] = Math . ceil ( N / 2.0 ) ; } else if ( s == ' ' ) { p [ 0 ] = Math . ceil ( N / 2.0 ) ; p [ 1 ] = Math . floor ( N / 2.0 ) ; } return p ; } var C = ' ' ; var N = 5 ; var p = count_ht ( C , N ) ; document . write ( "" "" + ( p [ 0 ] ) + "" "" ) ; document . write ( "" "" + ( p [ 1 ] ) + "" "" ) ;";"Count of total Heads and Tails after N flips in a coin | Function to find count of head and tail ; Check if initially all the coins are facing towards head ; Check if initially all the coins are facing towards tail ; Driver code"
Javascript;"function findPalindrome ( C ) { var S = C ; S = reverse ( S ) ; C = C + "" "" + S ; var n = C . length ; var longestPalindrome = new Array ( n ) . fill ( 0 ) ; longestPalindrome [ 0 ] = 0 ; var len = 0 ; var i = 1 ; while ( i < n ) { if ( C [ i ] === C [ len ] ) { len ++ ; longestPalindrome [ i ] = len ; i ++ ; } else { if ( len !== 0 ) { len = longestPalindrome [ len - 1 ] ; } else { longestPalindrome [ i ] = 0 ; i ++ ; } } } var ans = C . substring ( 0 , longestPalindrome [ n - 1 ] ) ; return ans ; } function findAns ( s ) { var A = "" "" ; var B = "" "" ; var F = "" "" ; var i = 0 ; var j = s . length - 1 ; var len = s . length ; while ( i < j && s [ i ] === s [ j ] ) { i = i + 1 ; j = j - 1 ; } if ( i > 0 ) { A = s . substring ( 0 , i ) ; B = s . substring ( len - i , len ) ; } if ( len > 2 * i ) { var C = s . substring ( i , i + ( s . length - 2 * i ) ) ; var D = findPalindrome ( C ) ; C = reverse ( C ) ; var E = findPalindrome ( C ) ; if ( D . length > E . length ) { F = D ; } else { F = E ; } } var answer = A + F + B ; return answer ; } function reverse ( input ) { var a = input . split ( "" "" ) ; var r = a . length - 1 ; for ( var l = 0 ; l < r ; l ++ , r -- ) { var temp = a [ l ] ; a [ l ] = a [ r ] ; a [ r ] = temp ; } return a . join ( "" "" ) ; } var str = "" "" ; document . write ( findAns ( str ) ) ;";"Longest palindromic string possible after removal of a substring | Function to find the longest palindrome from the start of the String using KMP match ; Append S ( reverse of C ) to C ; Use KMP algorithm ; Function to return longest palindromic String possible from the given String after removal of any subString ; Initialize three Strings A , B AND F ; Loop to find longest subStrings from both ends which are reverse of each other ; Proceed to third step of our approach ; Remove the subStrings A and B ; Find the longest palindromic subString from beginning of C ; Find the longest palindromic subString from end of C ; Store the maximum of D and E in F ; Find the readonly answer ; Driver Code"
Javascript;"function nthTerm ( N ) { let nth = 0 ; if ( N % 2 == 1 ) nth = ( N * N ) + 1 ; else nth = ( N * N ) - 1 ; return nth ; } let N = 5 ; document . write ( nthTerm ( N ) ) ;";"Find Nth term of the series 2 , 3 , 10 , 15 , 26. ... | Function to find Nth term ; Nth term ; Driver code"
Javascript;"function nthTerm ( N ) { let nth = 0 , first_term = 12 ; nth = ( first_term * ( Math . pow ( 2 , N - 1 ) ) ) + 11 * ( ( Math . pow ( 2 , N - 1 ) ) - 1 ) ; return nth ; } let N = 5 ; document . write ( nthTerm ( N ) ) ;";"Find the Nth term in series 12 , 35 , 81 , 173 , 357 , ... | Function to find Nth term ; Nth term ; Driver code"
Javascript;"function nthTerm ( N ) { let nth = 0 , first_term = 4 ; let pi = 1 , po = 1 ; let n = N ; while ( n > 1 ) { pi *= n - 1 ; n -- ; po *= 2 ; } nth = ( first_term * pi ) / po ; return nth ; } let N = 5 ; document . write ( nthTerm ( N ) ) ;";"Find Nth term of the series 4 , 2 , 2 , 3 , 6 , ... | Function to find Nth term ; Nth term ; Driver code"
Javascript;"function finalNum ( arr , n ) { var result = 0 ; for ( i = 0 ; i < n ; i ++ ) { result = __gcd ( result , arr [ i ] ) ; } return result ; } function __gcd ( a , b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } var arr = [ 3 , 9 , 6 , 36 ] ; var n = arr . length ; document . write ( finalNum ( arr , n ) ) ;";"Find the final number obtained after performing the given operation | Function to return the final number obtained after performing the given operation ; Find the gcd of the array elements ; Driver code"
Javascript;"function isVowel ( ch ) { switch ( ch ) { case "" "" : case "" "" : case "" "" : case "" "" : case "" "" : return true ; } return false ; } function isSatisfied ( str , n ) { for ( var i = 1 ; i < n ; i ++ ) { if ( ! isVowel ( str [ i ] ) && ! isVowel ( str [ i - 1 ] ) ) { return false ; } } for ( var i = 1 ; i < n - 1 ; i ++ ) { if ( isVowel ( str [ i ] ) && ! isVowel ( str [ i - 1 ] ) && ! isVowel ( str [ i + 1 ] ) ) { return false ; } } return true ; } var str = "" "" ; var n = str . length ; if ( isSatisfied ( str . split ( "" "" ) , n ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check whether all the substrings have number of vowels atleast as that of consonants | Function that returns true if character ch is a vowel ; Compares two integers according to their digit sum ; Check if there are two consecutive consonants ; Check if there is any vowel surrounded by two consonants ; Driver code"
Javascript;"function LengthlongestPrefixSuffix ( s ) { var n = s . length ; var lps = Array . from ( { length : n } , ( _ , i ) => 0 ) ; lps [ 0 ] = 0 ; var len = 0 ; var i = 1 ; while ( i < n ) { if ( s . charAt ( i ) == s . charAt ( len ) ) { len ++ ; lps [ i ] = len ; i ++ ; } else { if ( len != 0 ) { len = lps [ len - 1 ] ; } else { lps [ i ] = 0 ; i ++ ; } } } var res = lps [ n - 1 ] ; return ( res > n / 2 ) ? n / 2 : res ; } function longestPrefixSuffix ( s ) { var len = LengthlongestPrefixSuffix ( s ) ; var prefix = "" "" ; for ( var i = 0 ; i < len ; i ++ ) prefix += s . charAt ( i ) ; return prefix ; } var s = "" "" ; var ans = longestPrefixSuffix ( s ) ; if ( ans == "" "" ) document . write ( "" "" ) ; else document . write ( ans ) ;";"Print the longest prefix of the given string which is also the suffix of the same string | Returns length of the longest prefix which is also suffix and the two do not overlap . This function mainly is copy of computeLPSArray ( ) in KMP Algorithm ; lps [ 0 ] is always 0 ; Length of the previous longest prefix suffix ; Loop to calculate lps [ i ] for i = 1 to n - 1 ; This is tricky . Consider the example . AAACAAAA and i = 7. The idea is similar to search step . ; Also , note that we do not increment i here ; If len = 0 ; Since we are looking for non overlapping parts ; Function that returns the prefix ; Get the length of the longest prefix ; Stores the prefix ; Traverse and add characters ; Returns the prefix ; Driver code"
Javascript;"function no_of_characters ( M ) { let k = 1 ; while ( true ) { if ( Math . pow ( 2 , k + 1 ) - 2 < M ) k ++ ; else break ; } return k ; } function print_string ( M ) { let k , num , N ; k = no_of_characters ( M ) ; N = M - ( Math . pow ( 2 , k ) - 2 ) ; while ( k > 0 ) { num = Math . pow ( 2 , k - 1 ) ; if ( num >= N ) document . write ( "" "" ) ; else { document . write ( "" "" ) ; N -= num ; } k -- ; } document . write ( "" "" ) ; } let M ; M = 30 ; print_string ( M ) ; M = 55 ; print_string ( M ) ; M = 100 ; print_string ( M ) ;";"Print a number as string of ' A ' and ' B ' in lexicographic order | Function to calculate number of characters in corresponding string of ' A ' and ' B ' ; Since the minimum number of characters will be 1 ; Calculating number of characters ; Since k length string can represent at most pow ( 2 , k + 1 ) - 2 that is if k = 4 , it can represent at most pow ( 2 , 4 + 1 ) - 2 = 30 so we have to calculate the length of the corresponding string ; return the length of the corresponding string ; Function to print corresponding string of ' A ' and ' B ' ; Find length of string ; Since the first number that can be represented by k length string will be ( pow ( 2 , k ) - 2 ) + 1 and it will be AAA ... A , k times , therefore , N will store that how much we have to print ; At a particular time , we have to decide whether we have to print ' A ' or ' B ' , this can be check by calculating the value of pow ( 2 , k - 1 ) ; Print new line ; Driver code"
Javascript;"function updateString ( S , A , B ) { let l = A . length ; for ( let i = 0 ; i + l <= S . length ; i ++ ) { let curr = S . substring ( i , i + l ) ; if ( curr == A ) { let new_string = S . substring ( 0 , i ) + B + S . substring ( i + l ) ; S = new_string ; i += l - 1 ; } else { let new_string = S . substring ( 0 , i ) + A + S . substring ( i + l ) ; S = new_string ; i += l - 1 ; } } return S ; } let S = "" "" ; let A = "" "" ; let B = "" "" ; document . write ( updateString ( S , A , B ) ) ;";"Replace two substrings ( of a string ) with each other | Function to return the resultant string ; Iterate through all positions i ; Current sub - string of length = len ( A ) = len ( B ) ; If current sub - string gets equal to A or B ; Update S after replacing A ; Update S after replacing B ; Return the updated string ; Driver code"
Javascript;"function printPattern ( n , m ) { if ( m > 2 * ( n + 1 ) m < n - 1 ) { document . write ( "" "" ) ; } else if ( Math . abs ( n - m ) <= 1 ) { while ( n > 0 && m > 0 ) { document . write ( "" "" ) ; n -- ; m -- ; } if ( n != 0 ) { document . write ( "" "" ) ; } if ( m != 0 ) { document . write ( "" "" ) ; } } else { while ( m - n > 1 && n > 0 ) { document . write ( "" "" ) ; m = m - 2 ; n = n - 1 ; } while ( n > 0 ) { document . write ( "" "" ) ; n -- ; m -- ; } while ( m > 0 ) { document . write ( "" "" ) ; m -- ; } } } var n = 4 , m = 8 ; printPattern ( n , m ) ;";"Print n 0 s and m 1 s such that no two 0 s and no three 1 s are together | Function to print the required pattern ; When condition fails ; When m = n - 1 ; Driver code"
Javascript;"function countDecreasing ( A , n ) { var len = 1 ; for ( var i = 0 ; i < n - 1 ; ++ i ) { if ( A [ i + 1 ] < A [ i ] ) len ++ ; else { cnt += parseInt ( ( ( len - 1 ) * len ) / 2 ) ; len = 1 ; } } if ( len > 1 ) cnt += parseInt ( ( ( len - 1 ) * len ) / 2 ) ; return cnt ; } var A = [ 100 , 3 , 1 , 13 ] ; var n = A . length ; document . write ( countDecreasing ( A , n ) ) ;";"Find the count of Strictly decreasing Subarrays | Function to count the number of strictly decreasing subarrays ; Initialize length of current decreasing subarray ; Traverse through the array ; If arr [ i + 1 ] is less than arr [ i ] , then increment length ; Else Update count and reset length ; If last length is more than 1 ; Driver code"
Javascript;"function minimumChar ( S1 , S2 ) { let n = S1 . length ; let m = S2 . length ; let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < m - n + 1 ; i ++ ) { let minRemovedChar = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( S1 [ j ] != S2 [ i + j ] ) { minRemovedChar ++ ; } } ans = Math . min ( minRemovedChar , ans ) ; } return ans ; } let S1 = "" "" ; let S2 = "" "" ; document . write ( minimumChar ( S1 , S2 ) ) ;";"Minimum changes required to make first string substring of second string | Function to find the minimum number of characters to be replaced in string S2 , such that S1 is a substring of S2 ; Get the sizes of both strings ; Traverse the string S2 ; From every index in S2 , check the number of mis - matching characters in substring of length of S1 ; Take minimum of prev and current mis - match ; return answer ; Driver Code"
Javascript;"let mod = 100000007 ; function countFreq ( pat , txt ) { let M = pat . length ; let N = txt . length ; let res = 0 ; for ( let i = 0 ; i <= N - M ; i ++ ) { let j ; for ( j = 0 ; j < M ; j ++ ) { if ( txt [ i + j ] != pat [ j ] ) { break ; } } if ( j == M ) { res ++ ; j = 0 ; } } return res ; } let txt = "" "" ; let pat = "" "" ; document . write ( countFreq ( pat , txt ) ) ;";"Frequency of a substring in a string | JavaScript program to count occurrences of pat in txt . ; A loop to slide pat [ ] one by one ; For current index i , check for pattern match ; If pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; Driver Code"
Javascript;"function search ( pat , txt ) { let M = pat . length ; let N = txt . length ; let i = 0 ; while ( i <= N - M ) { let j ; for ( j = 0 ; j < M ; j ++ ) if ( txt [ i + j ] != pat [ j ] ) break ; if ( j == M ) { document . write ( "" "" + i + "" "" ) ; i = i + M ; } else if ( j == 0 ) i = i + 1 ; else i = i + j ; } } let txt = "" "" ; let pat = "" "" ; search ( pat , txt ) ;";"Optimized Naive Algorithm for Pattern Searching | A modified Naive Pattern Searching algorithm that is optimized for the cases when all characters of pattern are different ; For current index i , check for pattern match ; If pat [ 0. . . M - 1 ] = txt [ i , i + 1 , ... i + M - 1 ] ; Slide the pattern by j ; Driver code"
Javascript;"function findMissingDigit ( a , b , c ) { let w = 1 ; let a_mod_11 = 0 ; for ( let i = a . length - 1 ; i >= 0 ; i -- ) { a_mod_11 = ( a_mod_11 + w * ( a [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ) % 11 ; w = w * - 1 ; } let b_mod_11 = 0 ; w = 1 ; for ( let i = b . length - 1 ; i >= 0 ; i -- ) { b_mod_11 = ( b_mod_11 + w * ( b [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ) % 11 ; w = w * - 1 ; } let c_mod_11 = 0 ; let xSignIsPositive = true ; w = 1 ; for ( let i = c . length - 1 ; i >= 0 ; i -- ) { if ( c [ i ] == ' ' ) { xSignIsPositive = ( w == 1 ) ; } else { c_mod_11 = ( c_mod_11 + w * ( c [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ) % 11 ; } w = w * - 1 ; } let x = ( ( a_mod_11 * b_mod_11 ) - c_mod_11 ) % 11 ; if ( ! xSignIsPositive ) { x = - x ; } return ( x % 11 + 11 ) % 11 ; } let A = "" "" ; let B = "" "" ; let C = "" "" ; document . write ( findMissingDigit ( A , B , C ) ) ;";"Find the missing digit in given product of large positive integers | Function to find the replaced digit in the product of a * b ; Keeps track of the sign of the current digit ; Stores the value of a % 11 ; Find the value of a mod 11 for large value of a as per the derived formula ; Stores the value of b % 11 ; Find the value of b mod 11 for large value of a as per the derived formula ; Stores the value of c % 11 ; Keeps track of the sign of x ; If the current digit is the missing digit , then keep the track of its sign ; Find the value of x using the derived equation ; Check if x has a negative sign ; Return positive equivaluent of x mod 11 ; Driver Code"
Javascript;"function findIfPossible ( N , str ) { let countG = 0 , countF = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' ' ) countG ++ ; else countF ++ ; } if ( 2 * countF != countG ) { document . write ( "" "" ) ; } else { let id = 0 ; let flag = true ; for ( let i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' ' ) { countG -- ; id ++ ; } else { countF -- ; id -- ; } if ( id < 0 ) { flag = false ; break ; } if ( countG < countF ) { flag = false ; break ; } } if ( flag ) { document . write ( "" "" ) ; } else { document . write ( "" "" ) ; } } } let n = 6 ; let str = "" "" ; findIfPossible ( n , str ) ;";"Check if a string can be made empty by repeatedly removing given subsequence | Function to check if a string can be made empty by removing all subsequences of the form "" GFG "" or not ; Driver Code"
Javascript;"function isPossible ( str1 , str2 ) { let arr = new Array ( 256 ) . fill ( 0 ) ; let l1 = str1 . length ; let l2 = str2 . length ; let i , j ; let possible = true ; for ( i = 0 ; i < l1 ; i ++ ) { arr [ str1 [ i ] ] = 1 ; } for ( i = 0 ; i < l2 ; i ++ ) { if ( str2 [ i ] != "" "" ) { if ( arr [ str2 [ i ] ] == 1 ) continue ; else { possible = false ; break ; } } } if ( possible ) { document . write ( "" "" ) ; } else { document . write ( "" "" ) ; } } let str1 = "" "" ; let str2 = "" "" ; isPossible ( str1 , str2 ) ;";"Check whether second string can be formed from characters of first string used any number of times | Function to check if str2 can be made by characters of str1 or not ; To store the occurrence of every character ; Length of the two strings ; Assume that it is possible to compose the string str2 from str1 ; Iterate over str1 ; Store the presence of every character ; Iterate over str2 ; Ignore the spaces ; Check for the presence of character in str1 ; If it is possible to make str2 from str1 ; Given strings ; Function Call"
Javascript;"function find_Min_Inversion ( n , s1 , s2 ) { let count = 0 ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( s1 [ i ] != s2 [ i ] ) { if ( s1 [ i ] = ' ' ) { s1 [ i ] = ' ' ; } else { s1 [ i ] = ' ' ; } if ( s1 [ i + 1 ] = ' ' ) { s1 [ i + 1 ] = ' ' ; } else { s1 [ i + 1 ] = ' ' ; } count ++ ; } } if ( s1 != s2 ) { return count ; } return - 1 ; } let n = 4 ; let s1 = "" "" ; let s2 = "" "" ; document . write ( find_Min_Inversion ( n , s1 , s2 ) ) ;";"Minimum number of flipping adjacent bits required to make given Binary Strings equal | Function to find the minimum number of inversions required . ; Initializing the answer ; Iterate over the range ; If s1 [ i ] != s2 [ i ] , then inverse the characters at i snd ( i + 1 ) positions in s1 . ; Adding 1 to counter if characters are not same ; Driver Code"
Javascript;"function findSubsequence ( S , ch ) { let N = S . length ; let ans = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( S [ i ] == ch ) { ans ++ ; ch = String . fromCharCode ( ch . charCodeAt ( 0 ) + 1 ) ; } } return ans ; } function findMaxSubsequence ( S ) { let ans = 0 ; for ( let ch = ' ' . charCodeAt ( 0 ) ; ch <= ' ' . charCodeAt ( 0 ) ; ch ++ ) { ans = Math . max ( ans , findSubsequence ( S , String . fromCharCode ( ch ) ) ) ; } return ans ; } let S = "" "" ; document . write ( findMaxSubsequence ( S ) ) ;";"Longest subsequence with consecutive English alphabets | Function to find the length of subsequence starting with character ch ; Length of the string ; Stores the maximum length ; Traverse the given string ; If s [ i ] is required character ch ; Increment ans by 1 ; Increment character ch ; Return the current maximum length with character ch ; Function to find the maximum length of subsequence of consecutive characters ; Stores the maximum length of consecutive characters ; Update ans ; Return the maximum length of subsequence ; Input ; Function Call"
Javascript;"function minOpsToEmptyString ( s ) { var ans = Number . MIN_VALUE ; var cn0 = 0 ; var cn1 = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s . charAt ( i ) == ' ' ) { if ( cn1 > 0 ) cn1 -- ; cn0 ++ ; } else { if ( cn0 > 0 ) cn0 -- ; cn1 ++ ; } ans = Math . max ( ans , Math . max ( cn0 , cn1 ) ) ; } document . write ( ans ) ; } var S = "" "" ; minOpsToEmptyString ( S ) ;";"Minimum number of alternate subsequences required to be removed to empty a Binary String | Function to find the minimum number of operations to empty a binary string ; Stores the resultant number of operations ; Stores the number of 0 s ; Stores the number of 1 s ; Traverse the given string ; To balance 0 with 1 if possible ; Increment the value of cn0 by 1 ; To balance 1 with 0 if possible ; Increment the value of cn1 ; Update the maximum number of unused 0 s and 1 s ; Print the resultant count ; Driver Code"
Javascript;"function shortestString ( S , N ) { let st = 0 ; for ( let i = 0 ; i < N ; i ++ ) { if ( st > 0 && S [ i ] == ' ' ) { st -- ; } else { st ++ ; } } return st ; } let S = "" "" ; let N = S . length ; document . write ( shortestString ( S , N ) ) ;";"Smallest string obtained by removing all occurrences of 01 and 11 from Binary String | Set 2 | Function to find the length of the smallest string possible by removing substrings ""01"" and ""11"" ; Stores the length of the smallest string ; Traverse the string S ; If st is greater than 0 and S [ i ] is '1' ; Delete the last character and decrement st by 1 ; Otherwise ; Increment st by 1 ; Return the answer in st ; Input ; Function call"
Javascript;"function findLength ( str , n ) { let pre = Array . from ( { length : n } , ( _ , i ) => 0 ) ; let post = Array . from ( { length : n } , ( _ , i ) => 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { pre [ i ] = 0 ; post [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { if ( i != 0 ) { pre [ i ] += pre [ i - 1 ] ; } if ( str [ i ] == ' ' ) { pre [ i ] += 1 ; } } for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( i != n - 1 ) post [ i ] += post [ i + 1 ] ; if ( str [ i ] == ' ' ) post [ i ] += 1 ; } let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { ans = Math . max ( ans , pre [ i ] + post [ i ] ) ; } return ans ; } let S = "" "" ; document . write ( findLength ( S , S . length ) ) ;";"Longest Non | Function to find the length of the longest non - increasing subsequence ; Stores the prefix and suffix count of 1 s and 0 s respectively ; Initialize the array ; Store the number of '1' s up to current index i in pre ; Find the prefix sum ; If the current element is '1' , update the pre [ i ] ; Store the number of '0' s over the range [ i , N - 1 ] ; Find the suffix sum ; If the current element is '0' , update post [ i ] ; Stores the maximum length ; Find the maximum value of pre [ i ] + post [ i ] ; Return the answer ; Driver Code"
Javascript;"function countSubstring ( S , N ) { var prevSum = new Map ( ) ; var res = 0 ; var currentSum = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( S [ i ] >= ' ' && S [ i ] <= ' ' ) { currentSum ++ ; } else currentSum -- ; if ( currentSum == 0 ) res ++ ; if ( prevSum . has ( currentSum ) ) { res += ( prevSum . get ( currentSum ) ) ; } if ( prevSum . has ( currentSum ) ) prevSum . set ( currentSum , prevSum . get ( currentSum ) + 1 ) else prevSum . set ( currentSum , 1 ) } return res ; } var S = "" "" ; document . write ( countSubstring ( S , S . length ) ) ;";"Number of substrings having an equal number of lowercase and uppercase letters | Function to find the count of substrings having an equal number of uppercase and lowercase characters ; Stores the count of prefixes having sum S considering uppercase and lowercase characters as 1 and - 1 ; Stores the count of substrings having equal number of lowercase and uppercase characters ; Stores the sum obtained so far ; If the character is uppercase ; Otherwise ; If currsum is o ; If the current sum exists in the HashMap prevSum ; Increment the resultant count by 1 ; Update the frequency of the current sum by 1 ; Return the resultant count of the subarrays ; Driver Code"
Javascript;"function subString ( s , n ) { var count = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var len = i + 1 ; len <= n ; len ++ ) { var test_str = s . substring ( i , len ) ; var res = { } ; var temp = test_str . split ( "" "" ) ; for ( const keys of temp ) { res [ keys ] = ( res [ keys ] ? res [ keys ] : 0 ) + 1 ; } var flag = 0 ; for ( const [ key , value ] of Object . entries ( res ) ) { if ( res [ key ] % 2 != 0 ) { flag = 1 ; break ; } } if ( flag == 0 ) count += 1 ; } } return count ; } var S = "" "" ; var N = S . length ; document . write ( subString ( S , N ) ) ;";"Number of substrings with each character occurring even times | Function to count substrings having even frequency of each character ; Stores the total count of substrings ; Traverse the range [ 0 , N ] : ; Traverse the range [ i + 1 , N ] ; Stores the substring over the range of indices [ i , len ] ; Stores the frequency of characters ; Count frequency of each character ; Traverse the dictionary ; If any of the keys have odd count ; Otherwise ; Return count ; Driver Code"
Javascript;"function countStringPairs ( a , n ) { var ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { var p = a [ i ] ; var q = a [ j ] ; if ( p [ 0 ] !== q [ 0 ] ) { p = p . split ( "" "" ) ; q = q . split ( "" "" ) ; var temp = p [ 0 ] ; p [ 0 ] = q [ 0 ] ; q [ 0 ] = temp ; p = p . join ( "" "" ) ; q = q . join ( "" "" ) ; var flag1 = 0 ; var flag2 = 0 ; for ( let k = 0 ; k < n ; k ++ ) { if ( a [ k ] === p ) flag1 = 1 ; if ( a [ k ] === q ) flag2 = 1 ; } if ( flag1 === 0 && flag2 === 0 ) { ans = ans + 1 ; } } } } document . write ( ans ) ; } var arr = [ "" "" , "" "" , "" "" ] ; var N = arr . length ; countStringPairs ( arr , N ) ;";"Count new pairs of strings that can be obtained by swapping first characters of pairs of strings from given array | Function to count new pairs of strings that can be obtained by swapping first characters of any pair of strings ; Stores the count of pairs ; Generate all possible pairs of strings from the array arr [ ] ; Stores the current pair of strings ; Swap the first characters ; Check if they are already present in the array or not ; If both the strings are not present ; Increment the ans by 1 ; Print the resultant count ; Driver Code"
Javascript;"function addFrequencyToCharacter ( s ) { var frequency = new Array ( 26 ) . fill ( 0 ) ; var n = s . length ; for ( var i = 0 ; i < n ; i ++ ) { frequency [ s [ i ] . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) ] += 1 ; } for ( var i = 0 ; i < n ; i ++ ) { var add = frequency [ s [ i ] . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) ] % 26 ; if ( s [ i ] . charCodeAt ( 0 ) + add <= "" "" . charCodeAt ( 0 ) ) s [ i ] = String . fromCharCode ( s [ i ] . charCodeAt ( 0 ) + add ) ; else { add = s [ i ] . charCodeAt ( 0 ) + add - "" "" . charCodeAt ( 0 ) ; s [ i ] = String . fromCharCode ( "" "" . charCodeAt ( 0 ) + add - 1 ) ; } } document . write ( s . join ( "" "" ) + "" "" ) ; } var str = "" "" ; addFrequencyToCharacter ( str . split ( "" "" ) ) ;";"Modify string by replacing characters by alphabets whose distance from that character is equal to its frequency | Function to modify string by replacing characters by the alphabet present at distance equal to frequency of the string ; Stores frequency of characters ; Stores length of the string ; Traverse the given string S ; Increment frequency of current character by 1 ; Traverse the string ; Store the value to be added to the current character ; Check if after adding the frequency , the character is less than ' z ' or not ; Otherwise , update the value of add so that s [ i ] doesn ' t ▁ exceed ▁ ' z ' ; Print the modified string ; Driver Code"
Javascript;"function isPossible ( S , R , N ) { var cntl = 0 , cntr = 0 ; var cntu = 0 , cntd = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( S [ i ] == ' ' ) cntl ++ ; else if ( S [ i ] == ' ' ) cntr ++ ; else if ( S [ i ] == ' ' ) cntu ++ ; else cntd ++ ; } if ( Math . max ( Math . max ( cntl , cntr ) , Math . max ( cntu , cntd ) ) >= R ) return "" "" ; var mp = new Map ( ) ; var r_square = R * R ; for ( var i = 1 ; i * i <= r_square ; i ++ ) { mp . set ( i * i , i ) ; if ( mp . has ( r_square - i * i ) ) { if ( Math . max ( cntl , cntr ) >= mp . get ( r_square - i * i ) && Math . max ( cntu , cntd ) >= i ) return "" "" ; if ( Math . max ( cntl , cntr ) >= i && Math . max ( cntu , cntd ) >= mp . get ( r_square - i * i ) ) return "" "" ; } } return "" "" ; } var S = "" "" ; var R = 5 ; var N = S . length ; document . write ( isPossible ( S , R , N ) ) ;";"Check if it is possible to reach any point on the circumference of a given circle from origin | Function to check if it is possible to reach any point on circumference of the given circle from ( 0 , 0 ) ; Stores the count of ' L ' , ' R ' ; Stores the count of ' U ' , ' D ' ; Traverse the string S ; Update the count of L ; Update the count of R ; Update the count of U ; Update the count of D ; Condition 1 for reaching the circumference ; Store the the value of ( i * i ) in the Map ; Check if ( r_square - i * i ) already present in HashMap ; If it is possible to reach the point ( mp [ r_square - i * i ] , i ) ; If it is possible to reach the point ( i , mp [ r_square - i * i ] ) ; If it is impossible to reach ; Driver Code"
Javascript;"function addASCII ( S , N ) { var newStr = new Array ( S . length ) ; for ( var i = 0 ; i < S . length ; i ++ ) { var a = N [ i ] . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) ; var b = S [ i ] . charCodeAt ( 0 ) + a ; if ( b > 122 ) b -= 26 ; newStr [ i ] = String . fromCharCode ( b ) ; } document . write ( newStr . join ( "" "" ) ) ; } var S = "" "" , N = "" "" ; addASCII ( S , N ) ;";"Modify characters of a string by adding integer values of same | Function to modify a given string by adding ASCII value of characters from a string S to integer values of same indexed characters in string N ; Traverse the string ; Stores integer value of character in string N ; Stores ASCII value of character in string S ; If b exceeds 122 ; Replace the character ; Print resultant string ; Given strings ; Function call to modify string S by given operations"
Javascript;"function findMinimumChairs ( s ) { var count = 0 ; var i = 0 ; var mini = - 2147483647 ; while ( i < s . length ) { if ( s [ i ] == ' ' ) count ++ ; else count -- ; mini = Math . max ( count , mini ) ; i ++ ; } return mini ; } var s = "" "" ; document . write ( findMinimumChairs ( s ) ) ;";"Minimum number of chairs required to ensure that every worker is seated at any instant | Function to find the minimum number of chairs required to ensure that every worker is seated at any time ; Stores the number of chairs required ; Pointer to iterate ; Stores minimum number of chairs required ; Iterate over every character ; If character is ' E ' ; Increase the count ; Otherwise ; Update maximum value of count obtained at any given time ; Return mini ; Given String ; Function call to find the minimum number of chairs"
Javascript;"function fillString ( str , k ) { var s = str . split ( "" "" ) ; var mp = { } ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] !== "" "" ) { mp [ i % k ] = s [ i ] ; } } for ( var i = 0 ; i < s . length ; i ++ ) { if ( ! mp . hasOwnProperty ( i % k ) ) { document . write ( - 1 ) ; return ; } s [ i ] = mp [ i % k ] ; } document . write ( s . join ( "" "" ) + "" "" ) ; } var S = "" "" ; var K = 4 ; fillString ( S , K ) ;";"Modify string by inserting characters such that every K | Function to replace all ' ? ' characters in a string such that the given conditions are satisfied ; Traverse the string to Map the characters with respective positions ; Traverse the string again and replace all unknown characters ; If i % k is not found in the Map M , then return - 1 ; Update S [ i ] ; Print the string S ; Driver code"
Javascript;"function rearrangeString ( s1 , s2 ) { let cnt = new Array ( 26 ) ; cnt . fill ( 0 ) ; for ( let i = 0 ; i < s2 . length ; i ++ ) cnt [ s2 [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ++ ; let unique = 0 ; for ( let i = 0 ; i < 26 ; i ++ ) if ( cnt [ i ] != 0 ) unique ++ ; if ( unique == 1 ) { let count_in_s2 = s2 . length ; let count_in_s1 = 0 ; for ( let i = 0 ; i < s1 . length ; i ++ ) if ( s1 [ i ] == s2 [ 0 ] ) count_in_s1 ++ ; if ( count_in_s1 < count_in_s2 ) { document . write ( s1 . join ( "" "" ) ) ; return ; } document . write ( - 1 ) ; } else { let inc = 1 ; for ( let i = 0 ; i < s2 . length - 1 ; i ++ ) if ( s2 [ i ] . charCodeAt ( ) > s2 [ i + 1 ] . charCodeAt ( ) ) inc = 0 ; if ( inc == 1 ) { s1 . sort ( ) ; s1 . reverse ( ) ; document . write ( s1 . join ( "" "" ) ) ; } else { s1 . sort ( ) ; document . write ( s1 . join ( "" "" ) ) ; } } } let s1 = "" "" . split ( ' ' ) ; let s2 = "" "" . split ( ' ' ) ; rearrangeString ( s1 , s2 ) ;";"Rearrange a string S1 such that another given string S2 is not its subsequence | Function to rearrange characters in string S1 such that S2 is not a subsequence of it ; Store the frequencies of characters of string s2 ; Traverse the string s2 ; Update the frequency ; Find the number of unique characters in s2 ; Increment unique by 1 if the condition satisfies ; Check if the number of unique characters in string s2 is 1 ; Store the unique character frequency ; Store occurence of it in s1 ; Find count of that character in the string s1 ; Increment count by 1 if that unique character is same as current character ; If count count_in_s1 is less than count_in_s2 , then print s1 and return ; Otherwise , there is no possible arrangement ; Checks if any character in s2 is less than its next character ; Iterate the string , s2 ; If s [ i ] is greater than the s [ i + 1 ] ; Set inc to 0 ; If inc = 1 , print s1 in decreasing order ; Otherwise , print s1 in increasing order ; Driver code"
Javascript;"function isReducible ( str ) { let N = str . length ; let s = [ ] ; for ( let i = 0 ; i < N ; i ++ ) { if ( str [ i ] == ' ' ) s . push ( str [ i ] ) ; else if ( s . length > 0 ) s . pop ( ) ; else return false ; } if ( s . length == 0 ) { return true ; } else { return false ; } } let str = "" "" ; if ( isReducible ( str ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check if a string can be emptied by removing all subsequences of the form ""10"" | Function to find if string is reducible to NULL ; Length of string ; Stack to store all 1 s ; Iterate over the characters of the string ; If current character is 1 ; Push it into the stack ; Pop from the stack ; If the stack is empty ; Driver code"
Javascript;"function cntMinOperation ( S , N ) { let cntOp = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { if ( S [ i ] == ' ' && S [ i + 1 ] == ' ' ) { S [ i + 1 ] = ' ' ; cntOp += 1 ; } } return cntOp ; } let S = "" "" ; let N = S . length ; document . write ( cntMinOperation ( S . split ( ' ' ) , N ) ) ;";"Minimize flips required such that string does not any pair of consecutive 0 s | Function to find minimum flips required such that a String does not contain any pair of consecutive 0 s ; Stores minimum count of flips ; Iterate over the characters of the String ; If two consecutive characters are equal to '0' ; Update S [ i + 1 ] ; Update cntOp ; Driver Code"
Javascript;"function solution ( s ) { var vowel = [ ] , consonant = [ ] ; s . split ( ' ' ) . forEach ( i => { if ( i == ' ' i == ' ' i == ' ' i == ' ' i == ' ' ) { vowel . push ( i ) ; } else { consonant . push ( i ) ; } } ) ; var Nc , Nv ; Nv = vowel . length ; Nc = consonant . length ; var M = parseInt ( Nc / ( Nv - 1 ) ) ; var ans = "" "" ; var consotnant_till = 0 ; vowel . forEach ( i => { ans += i ; var temp = 0 ; for ( var j = consotnant_till ; j < Math . min ( Nc , consotnant_till + M ) ; j ++ ) { ans += consonant [ j ] ; temp ++ ; } consotnant_till += temp ; } ) ; return ans ; } var str = "" "" ; document . write ( solution ( str ) ) ;";"Rearrange a string to maximize the minimum distance between any pair of vowels | Function to rearrange the string such that the minimum distance between any of vowels is maximum . ; Store vowels and consonants ; Iterate over the characters of string ; If current character is a vowel ; If current character is a consonant ; Stores count of vowels and consonants respectively ; Stores the resultant string ; Stores count of consonants appended into ans ; Append vowel to ans ; Append consonants ; Append consonant to ans ; Update temp ; Remove the taken elements of consonant ; Return final ans ; Driver Code ; Function Call"
Javascript;"function smallestlexicographicstring ( s , k ) { let n = s . length ; if ( k >= n ) { for ( let i = 0 ; i < n ; i ++ ) { s [ i ] = ' ' ; } document . write ( s ) ; return ; } for ( let i = 0 ; i < n ; i ++ ) { if ( k == 0 ) { break ; } if ( s [ i ] == ' ' ) continue ; for ( let j = i + 1 ; j < n ; j ++ ) { if ( s [ j ] . charCodeAt ( ) > s [ i ] . charCodeAt ( ) ) { s [ j ] = s [ i ] ; break ; } else if ( j == n - 1 ) s [ j ] = s [ i ] ; } s [ i ] = ' ' ; k -- ; } document . write ( s . join ( "" "" ) ) ; } let s = ( "" "" ) . split ( ' ' ) ; let k = 6 ; smallestlexicographicstring ( s , k ) ;";"Lexicographically smallest string possible by performing K operations on a given string | Function to find the lexicographically smallest possible string by performing K operations on string S ; Store the size of string , s ; Check if k >= n , if true , convert every character to ' a ' ; Iterate in range [ 0 , n - 1 ] using i ; When k reaches 0 , break the loop ; If current character is ' a ' , continue ; Otherwise , iterate in the range [ i + 1 , n - 1 ] using j ; Check if s [ j ] > s [ i ] ; If true , set s [ j ] = s [ i ] and break out of the loop ; Check if j reaches the last index ; Update S [ i ] ; Decrement k by 1 ; Print string ; Given String , s ; Given k ; Function Call"
Javascript;"function canReduceString ( S , N ) { var count_1 = 0 ; var count_2 = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( S [ i ] === "" "" ) { count_1 ++ ; } else { count_2 ++ ; } } if ( count_1 === 0 count_2 === 0 ) { document . write ( "" "" + "" "" ) ; } else if ( count_1 === count_2 ) { document . write ( "" "" + "" "" ) ; } else if ( N % 2 !== 0 ) { document . write ( "" "" ) ; } else { document . write ( Math . abs ( count_1 - count_2 ) / 2 ) ; } } var S = "" "" ; var N = S . length ; canReduceString ( S , N ) ;";"Minimize removal of non | Function to find minimum count of steps required ot make string S an empty string ; Stores count of occurences ' ( ' ; Stores count of occurences ' ) ' ; Traverse the string , str ; If current character is ' ( ' ; Update count_1 ; Update count_2 ; If all the characters are same , then print - 1 ; If the count of occurence of ' ) ' and ' ( ' are same then print 0 ; If length of string is Odd ; Given string ; Size of the string ; Function Call"
Javascript;"function isAcceptedDFA ( s , N ) { var count = 0 ; for ( var i = 0 ; i < N ; i ++ ) { if ( s [ i ] === "" "" ) count ++ ; } if ( count === N && count !== 0 ) { document . write ( "" "" ) ; } else { document . write ( "" "" ) ; } } var S = "" "" ; isAcceptedDFA ( S , S . length ) ;";"Program to construct a DFA which accepts the language L = { aN | N â ‰¥ 1 } | Function to check whether the String S satisfy the given DFA or not ; Stores the count of characters ; Iterate over the range [ 0 , N ] ; Count and check every element for ' a ' ; If String matches with DFA ; If not matches ; Driver Code ; Function Call"
Javascript;"function maximum_pallindromic ( arr ) { var res = 0 ; var c1 = 0 , c2 = 0 ; for ( var i = 0 ; i < 26 ; i ++ ) { res += parseInt ( arr [ i ] / 3 ) ; arr [ i ] = ( arr [ i ] % 3 ) ; if ( arr [ i ] == 1 ) c1 ++ ; else if ( arr [ i ] == 2 ) c2 ++ ; } res += Math . min ( c1 , c2 ) ; var t = Math . min ( c1 , c2 ) ; c1 -= t ; c2 -= t ; res += 2 * parseInt ( c2 / 3 ) ; c2 %= 3 ; res += parseInt ( c2 / 2 ) ; document . write ( res ) ; } var arr = [ 4 , 5 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ] ; maximum_pallindromic ( arr ) ;";"Maximize palindromic strings of length 3 possible from given count of alphabets | Function to count maximum number of palindromic string of length 3 ; Stores the final count of palindromic strings ; Traverse the array ; Increment res by arr [ i ] / 3 , i . e forming string of only i + ' a ' character ; Store remainder ; Increment c1 by one , if current frequency is 1 ; Increment c2 by one , if current frequency is 2 ; Count palindromic strings of length 3 having the character at the ends different from that present in the middle ; Update c1 and c2 ; Increment res by 2 * c2 / 3 ; Finally print the result ; Given array ; Function Call"
Javascript;"function find_Winner ( arr , N ) { var Q = Array . from ( Array ( N ) , ( ) => Array ( ) ) var M = arr . length ; for ( var i = 0 ; i < M ; i ++ ) { var len = arr [ i ] . length ; for ( var j = 0 ; j < len ; j ++ ) { Q [ i ] . push ( arr [ i ] [ j ] - 1 ) ; } } var player = 0 ; while ( Q [ player ] . length > 0 ) { var nextPlayer = Q [ player ] [ 0 ] - ' ' ; Q [ player ] . shift ( ) ; player = nextPlayer ; } document . write ( "" "" + ( player + 1 ) ) ; } var N = 3 ; var arr = [ "" "" , "" "" , "" "" ] ; find_Winner ( arr , N ) ;";"Find the winner of game of repeatedly removing the first character to empty given string | Function to find the winner of a game of repeatedly removing the first character to empty a string ; Store characters of each string of the array arr [ ] ; Stores count of strings in arr [ ] ; Traverse the array arr [ ] ; Stores length of current string ; Traverse the string ; Insert arr [ i ] [ j ] ; 1 st Player starts the game ; Stores the player number for the next turn ; Remove 1 st character of current string ; Update player number for the next turn ; Driver Code"
Javascript;"function longestSubstring ( s ) { let dp = new Array ( 1024 ) . fill ( 1 ) ; let res = 0 , mask = 0 ; dp [ 0 ] = - 1 ; for ( let i = 0 ; i < s . length ; ++ i ) { mask ^= 1 << ( s [ i ] - ' ' ) ; res = Math . max ( res , i - dp [ mask ] ) ; for ( let j = 0 ; j <= 9 ; ++ j ) res = Math . max ( res , i - dp [ mask ^ ( 1 << j ) ] ) ; dp [ mask ] = Math . min ( dp [ mask ] , i ) ; } return res ; } let s = "" "" ; document . write ( longestSubstring ( s ) ) ;";"Longest Substring that can be made a palindrome by swapping of characters | Function to find the Longest substring that can be made a palindrome by swapping of characters ; Initialize dp array of size 1024 ; Initializing mask and res ; Traverse the string ; Find the mask of the current character ; Finding the length of the longest substring in s which is a palindrome for even count ; Finding the length of the longest substring in s which is a palindrome for one odd count ; Finding maximum length of substring having one odd count ; dp [ mask ] is minimum of current i and dp [ mask ] ; Return longest length of the substring which forms a palindrome with swaps ; Input String ; Function Call"
Javascript;"function Validate ( M ) { let len = M . length ; let temp = "" "" ; for ( let i = 0 ; i < len ; i ++ ) { if ( ! isNaN ( parseInt ( M [ i ] ) ) ) temp += M [ i ] ; } let nwlen = temp . length ; if ( nwlen != 10 ) { document . write ( "" "" ) ; return ; } let res = "" "" ; let x = temp . substring ( 0 , 3 ) ; res += "" "" + x + "" "" ; x = temp . substring ( 3 , 6 ) ; res += "" "" + x + "" "" ; x = temp . substring ( 6 , 9 ) ; res += "" "" + x + "" "" ; x = temp . substring ( 9 , 10 ) ; res += "" "" + x + "" "" ; document . write ( res + "" "" ) ; } let M = "" "" ; Validate ( M ) ;";"Convert given string to a valid mobile number | Function to print the valid and formatted phone number ; Length of given String ; Store digits in temp ; Iterate given M ; If any digit , append it to temp ; Find new length of String ; If length is not equal to 10 ; Store final result ; Make groups of 3 digits and enclose them within ( ) and separate them with "" - "" 0 to 2 index 1 st group ; 3 to 5 index 2 nd group ; 6 to 8 index 3 rd group ; 9 to 9 index last group ; Print final result ; Given String ; Function Call"
Javascript;"function hexaModK ( s , k ) { var mp = new Map ( ) ; for ( var i = 1 ; i <= 9 ; i ++ ) { mp . set ( String . fromCharCode ( i + ' ' . charCodeAt ( 0 ) ) , i ) ; } mp . set ( ' ' , 10 ) ; mp . set ( ' ' , 11 ) ; mp . set ( ' ' , 12 ) ; mp . set ( ' ' , 13 ) ; mp . set ( ' ' , 14 ) ; mp . set ( ' ' , 15 ) ; var m = parseInt ( k , 16 ) ; var base = 1 ; var ans = 0 ; for ( var i = s . length - 1 ; i >= 0 ; i -- ) { var n = mp . get ( s [ i ] ) % m ; ans = ( ans + ( base % m * n % m ) % m ) % m ; base = ( base % m * 16 % m ) % m ; } document . write ( ans . toString ( 16 ) . toUpperCase ( ) ) ; } var n = "" "" ; var k = "" "" ; hexaModK ( n , k ) ;";"Modulus of two Hexadecimal Numbers | Function to calculate modulus of two Hexadecimal numbers ; Store all possible hexadecimal digits ; Iterate over the range [ '0' , '9' ] ; Convert given string to long ; Base to get 16 power ; Store N % K ; Iterate over the digits of N ; Stores i - th digit of N ; Update ans ; Update base ; Print the answer converting into hexadecimal ; Given string N and K ; Function Call"
Javascript;"var combination = "" "" ; var combinations = [ ] ; function printSequences ( combinations ) { for ( var s of combinations ) { document . write ( s + "" "" ) ; } } function generateCombinations ( s , n ) { for ( var i = 0 ; i < s . length ; i ++ ) { combination += s [ i ] ; var x = parseInt ( combination ) ; if ( x <= n ) { combinations . push ( combination ) ; generateCombinations ( s , n ) ; } combination = combination . substring ( 0 , combination . length - 1 ) ; } } var S = "" "" ; var N = 100 ; generateCombinations ( S , N ) ; printSequences ( combinations ) ;";"Print all combinations generated by characters of a numeric string which does not exceed N | Store the current sequence of s ; Store the all the required sequences ; Function to print all sequences of S satisfying the required condition ; Print all Strings in the set ; Function to generate all sequences of String S that are at most N ; Iterate over String s ; Push ith character to combination ; Convert the String to number ; Check if the condition is true ; Push the current String to the readonly set of sequences ; Recursively call function ; Backtrack to its previous state ; Driver Code ; Function Call ; Print required sequences"
Javascript;"function compute_hash ( str ) { let p = 31 ; let MOD = 1e9 + 7 ; let hash_val = 0 ; let mul = 1 ; for ( let i = 0 ; i < str . length ; i ++ ) { let ch = str [ i ] ; hash_val = ( hash_val + ( ch . charCodeAt ( ) - ' ' . charCodeAt ( ) + 1 ) * mul ) % MOD ; mul = ( mul * p ) % MOD ; } return hash_val ; } function distinct_str ( arr , n ) { let hash = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { hash [ i ] = compute_hash ( arr [ i ] ) ; } hash . sort ( function ( a , b ) { return a - b } ) ; let cntElem = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( hash [ i ] != hash [ i - 1 ] ) { cntElem ++ ; } } return cntElem ; } let arr = [ "" "" , "" "" , "" "" , "" "" ] ; let N = arr . length ; document . write ( distinct_str ( arr , N ) ) ;";"Count Distinct Strings present in an array using Polynomial rolling hash function | Function to find the hash value of a string ; Traverse the string ; Update hash_val ; Update mul ; Return hash_val of str ; Function to find the count of distinct strings present in the given array ; Store the hash values of the strings ; Traverse the array ; Stores hash value of arr [ i ] ; Sort hash [ ] array ; Stores count of distinct strings in the array ; Traverse hash [ ] array ; Update cntElem ; Driver Code"
Javascript;"function SieveOfEratosthenes ( prime , n ) { for ( let i = 0 ; i <= n ; i ++ ) { prime [ i ] = true ; } prime [ 0 ] = prime [ 1 ] = false ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( prime [ i ] == true ) { for ( let j = 2 ; i * j <= n ; j ++ ) { prime [ i * j ] = false ; } } } } function removePrimeFrequencies ( s ) { var n = s . length ; var prime = new Array ( n + 1 ) ; SieveOfEratosthenes ( prime , n ) ; var m = { } ; for ( let i = 0 ; i < s . length ; i ++ ) m [ s [ i ] ] = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { m [ s [ i ] ] ++ ; } var new_string = "" "" ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( prime [ m [ s [ i ] ] ] ) continue ; new_string += s [ i ] ; } console . log ( new_string ) ; } str = "" "" ; removePrimeFrequencies ( str ) ;";"Remove characters from given string whose frequencies are a Prime Number | Function to perform the seive of eratosthenes algorithm ; Initialize all entries in prime [ ] as true ; Initialize 0 and 1 as non prime ; Traversing the prime array ; If i is prime ; All multiples of i must be marked false as they are non prime ; Function to remove characters which have prime frequency in the string ; Length of the string ; Create a boolean array prime ; Sieve of Eratosthenes ; Stores the frequency of character ; Storing the frequencies ; New string that will be formed ; Removing the characters which have prime frequencies ; If the character has prime frequency then skip ; Else concatenate the character to the new string ; Print the modified string ; Driver Code ; Function Call"
Javascript;"function rearrange ( s ) { let s1 = "" "" , s2 = "" "" , ans = "" "" ; let s3 = s . split ( "" "" ) ; for ( let x = 0 ; x < s3 . length ; x ++ ) { if ( s3 [ x ] >= ' ' && s3 [ x ] <= ' ' ) s1 += s3 [ x ] ; else s2 += s3 [ x ] ; } let n = s1 . length ; let m = s2 . length ; if ( Math . abs ( n - m ) > 1 ) return "" "" ; let i = 0 , j = 0 , k = 0 ; let flag = ( n >= m ) ? 1 : 0 ; while ( i < n && j < m ) { if ( flag != 0 ) ans += s1 [ i ++ ] ; else ans += s2 [ j ++ ] ; if ( flag == 1 ) flag = 0 ; else flag = 1 ; } return ans ; } let str = "" "" ; document . write ( rearrange ( str ) + "" "" ) ;";"Rearrange string such that no pair of adjacent characters are of the same type | Function to rearrange given alphanumeric String such that no two adjacent characters are of the same type ; Stores alphabets and digits ; Store the alphabets and digits separately in the Strings ; Stores the count of alphabets and digits ; If respective counts differ by 1 ; Desired arrangement not possible ; Stores the indexes ; Check if first character should be alphabet or digit ; Place alphabets and digits alternatively ; If current character needs to be alphabet ; If current character needs to be a digit ; Flip flag for alternate arrangement ; Return resultant String ; Given String ; Function Call"
Javascript;"function charactersCount ( str , n ) { let count = 0 ; while ( n > 0 ) { let cur = str [ 0 ] . charCodeAt ( ) ; let ind = 0 ; for ( let j = 1 ; j < n ; j ++ ) { if ( str [ j ] . charCodeAt ( ) < cur ) { cur = str [ j ] . charCodeAt ( ) ; ind = j ; } } str = str . substring ( 0 , ind ) + str . substring ( ind + 1 ) ; n -- ; count += ind + 1 ; } document . write ( count + "" "" ) ; } let str = "" "" ; let n = 5 ; charactersCount ( str , n ) ;";"Find value after N operations to remove N characters of string S with given constraints | Function to find the value after N operations to remove all the N characters of String S ; Iterate till N ; Remove character at ind and decrease n ( size of String ) ; Increase count by ind + 1 ; Given String str ; Function call"
Javascript;"function printMiddleCharacter ( str ) { let len = str . length ; let middle = parseInt ( len / 2 , 10 ) ; document . write ( str [ middle ] ) ; } let str = "" "" ; printMiddleCharacter ( str ) ;";"Print the middle character of a string | Function that prints the middle character of a string ; Finding string length ; Finding middle index of string ; Print the middle character of the string ; Given string str ; Function Call"
Javascript;"function check ( s ) { let a = new Set ( ) ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( a . has ( s [ i ] ) ) { return false ; } a . add ( s [ i ] ) ; } return true ; } function helper ( arr , ind ) { let fin = [ ] ; fin . push ( "" "" ) ; if ( ind == arr . length ) return fin ; let tmp = helper ( arr , ind + 1 ) ; let ret = tmp ; for ( let i = 0 ; i < tmp . length ; i ++ ) { let test = tmp [ i ] + arr [ ind ] ; if ( check ( test ) ) ret . push ( test ) ; } return ret ; } function maxLength ( arr ) { let tmp = helper ( arr , 0 ) ; let len = 0 ; for ( let i = 0 ; i < tmp . length ; i ++ ) { len = len > tmp [ i ] . length ? len : tmp [ i ] . length ; } return len ; } let s = [ ] ; s . push ( "" "" ) ; document . write ( maxLength ( s ) ) ;";"Maximize length of the String by concatenating characters from an Array of Strings | Function to check if all the string characters are unique ; Check for repetition in characters ; Function to generate all possible strings from the given array ; Base case ; Consider every string as a starting substring and store the generated string ; Add current string to result of other strings and check if characters are unique or not ; Function to find the maximum possible length of a string ; Return max length possible ; Return the answer ; Driver Code"
Javascript;"function Range_sum_query ( S , Query ) { var N = S . length ; var A = Array ( N ) ; A [ 0 ] = S [ 0 ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) + 1 ; for ( var i = 1 ; i < N ; i ++ ) { A [ i ] = S [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) + 1 ; A [ i ] = A [ i ] + A [ i - 1 ] ; } for ( var i = 0 ; i < Query . length ; i ++ ) { if ( Query [ i ] [ 0 ] == 1 ) { document . write ( A [ ( Query [ i ] [ 1 ] ) - 1 ] + "" "" ) ; } else { document . write ( A [ ( Query [ i ] [ 1 ] ) - 1 ] - A [ ( Query [ i ] [ 0 ] ) - 2 ] + "" "" ) ; } } } var S = "" "" ; var Query = [ ] ; Query . push ( [ 2 , 4 ] ) ; Query . push ( [ 1 , 3 ] ) ; Range_sum_query ( S , Query ) ;";"Perform range sum queries on string as per given condition | Function to perform range sum queries on string as per the given condition ; Initialize N by string size ; Create array A [ ] for prefix sum ; Iterate till N ; Traverse the queries ; Check if if L == 1 range sum will be A [ R - 1 ] ; Condition if L > 1 range sum will be A [ R - 1 ] - A [ L - 2 ] ; Given string ; Given Queries ; Function call"
Javascript;"function swap_ ( a , l , i ) { let temp ; temp = a [ l ] ; a [ l ] = a [ i ] ; a [ i ] = temp ; } function permute ( str , l , r , n ) { let i ; if ( l == r ) { let j = parseInt ( ( str ) . join ( "" "" ) ) ; if ( j % n == 0 ) document . write ( ( str ) . join ( "" "" ) + "" "" ) ; return ; } for ( i = l ; i < r ; i ++ ) { swap_ ( str , l , i ) ; permute ( str , l + 1 , r , n ) ; swap_ ( str , l , i ) ; } } let str = "" "" ; let n = 5 ; let len = str . length ; if ( len > 0 ) permute ( str . split ( "" "" ) , 0 , len , n ) ;";"Generate all possible permutations of a Number divisible by N | Function to Swap two characters ; Function to generate all permutations and print the ones that are divisible by the N ; Convert String to integer ; Check for divisibility and print it ; Print all the permutations ; Swap characters ; Permute remaining characters ; Revoke the swaps ; Driver Code"
Javascript;"function decimalToBinary ( N ) { var ans = "" "" ; while ( N > 0 ) { if ( N % 2 == 1 ) { ans = ' ' + ans ; } else { ans = ' ' + ans ; } N = parseInt ( N / 2 ) ; } return ans ; } function checkBinaryString ( str , N ) { var map = Array ( N + 10 ) . fill ( 0 ) , cnt = 0 ; for ( var i = N ; i > 0 ; i -- ) { if ( ! map [ i ] ) { var t = i ; var s = decimalToBinary ( t ) ; if ( str . includes ( s ) ) { while ( t > 0 && map [ t ] == 0 ) { map [ t ] = 1 ; cnt ++ ; t >>= 1 ; } } } } for ( var i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] == ' ' ) { cnt ++ ; break ; } } if ( cnt == N + 1 ) return "" "" ; else return "" "" ; } var str = "" "" ; var N = 3 ; document . write ( checkBinaryString ( str , N ) ) ;";"Check if binary representations of 0 to N are present as substrings in given binary string | Function to convert decimal to binary representation ; Iterate over all bits of N ; If bit is 1 ; Return binary representation ; Function to check if binary conversion of numbers from N to 1 exists in the string as a substring or not ; To store the count of number exists as a substring ; Traverse from N to 1 ; If current number is not present in map ; Store current number ; Find binary of t ; If the string s is a substring of str ; Mark t as true ; Increment the count ; Update for t / 2 ; Special judgment '0' ; If the count is N + 1 , return "" yes "" ; Given String ; Given Number ; Function Call"
Javascript;"function largestAnagramGrp ( arr ) { var prime = [ 2 , 3 , 5 , 7 , 11 , 13 , 17 , 19 , 23 , 29 , 31 , 37 , 41 , 43 , 47 , 53 , 59 , 61 , 67 , 71 , 73 , 79 , 83 , 89 , 97 , 101 , ] ; var max = - 1 ; var maxpdt = - 1 ; var W = { } ; var P = { } ; for ( const temp of arr ) { var c = temp . split ( "" "" ) ; var pdt = 1 ; for ( const t of c ) { pdt *= prime [ t . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) ] ; } if ( P . hasOwnProperty ( pdt ) ) { P [ pdt ] = P [ pdt ] + 1 ; } else { W [ pdt ] = temp ; P [ pdt ] = 1 ; } } for ( const [ key , value ] of Object . entries ( P ) ) { if ( max < value ) { max = value ; maxpdt = key ; } } return W [ maxpdt ] ; } var S = "" "" + "" "" ; var arr = S . split ( "" "" ) ; document . write ( largestAnagramGrp ( arr ) ) ;";"Find the word with most anagrams in a given sentence | Function to find the word with maximum number of anagrams ; Primes assigned to 26 alphabets ; Stores the product and word mappings ; Stores the frequencies of products ; Calculate the product of primes assigned ; If product already exists ; Otherwise ; Fetch the most frequent product ; Return a string with that product ; Driver Code"
Javascript;"function print_next_vovel_string ( st ) { var m = { } ; m [ "" "" ] = 0 ; m [ "" "" ] = 1 ; m [ "" "" ] = 2 ; m [ "" "" ] = 3 ; m [ "" "" ] = 4 ; var arr = [ "" "" , "" "" , "" "" , "" "" , "" "" ] ; var N = st . length ; for ( let i = 0 ; i < N ; i ++ ) { var c = st [ i ] ; if ( c === "" "" c === "" "" c === "" "" c === "" "" c === "" "" ) { index = m [ st [ i ] ] + 1 ; newindex = index % 5 ; st = st . replace ( st [ i ] , arr [ newindex ] ) ; } } return st ; } var st = "" "" ; document . write ( print_next_vovel_string ( st ) ) ;";"Replace every vowels with lexicographically next vowel in a String | Function to replace every vowel with next vowel lexicographically ; Storing the vowels in the map with custom numbers showing their index ; Iterate over the string ; If the current character is a vowel Find the index in Hash and Replace it with next vowel from Hash ; Driver function"
Javascript;"function isPalindrome ( str ) { let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( str [ i ] != str [ len - i - 1 ] ) return false ; } return true ; } function isCompressablePalindrome ( str ) { let len = str . length ; let compressed = "" "" ; compressed = str [ 0 ] ; for ( let i = 1 ; i < len ; i ++ ) { if ( str [ i ] != str [ i - 1 ] ) compressed += str [ i ] ; } return isPalindrome ( compressed ) ; } let str = "" "" ; if ( isCompressablePalindrome ( str ) ) document . write ( "" "" + "" "" ) ; else document . write ( "" "" ) ;";"Check if string is palindrome after removing all consecutive duplicates | Function to check if a String is palindrome or not ; Length of the String ; Check if its a palindrome ; If the palindromic condition is not met ; Return true as str is palindromic ; Function to check if String str is palindromic after removing every consecutive characters from the str ; Length of the String str ; Create an empty compressed String ; The first character will always be included in the readonly String ; Check all the characters of the String ; If the current character is not same as its previous one , then insert it in the readonly String ; Check if the compressed String is a palindrome ; Given String ; Function call"
Javascript;"function isvowel ( x ) { return ( x == ' ' x == ' ' x == ' ' x == ' ' x == ' ' ) ; } function CountTotal ( str ) { let ans = 0 ; let n = str . length ; let s = str . split ( ' ' ) ; let cnt = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( isvowel ( s [ i ] ) ) cnt += 1 ; else { ans += ( cnt * ( cnt + 1 ) / 2 ) ; cnt = 0 ; } } if ( cnt != 0 ) ans += ( cnt * ( cnt + 1 ) / 2 ) ; return ans ; } let s = "" "" ; document . write ( CountTotal ( s ) ) ;";"Count of substrings consisting only of vowels | Function to check vowel or not ; Function to find largest string which satisfy condition ; Check if current character is vowel ; Increment count ; Count all possible substrings of calculated length ; Reset the length ; Add remaining possible substrings consisting of vowels occupying last indices of the string ; Driver code"
Javascript;"let totCount ; let firstCount ; function getTotCount ( num ) { totCount = 1 ; firstCount = 1 ; let temp = 1 ; while ( ( num & temp ) == 0 ) { temp = temp << 1 ; totCount += 1 ; } firstCount = totCount ; temp = num >> totCount ; while ( temp != 0 ) { totCount += 1 ; temp = temp >> 1 ; } } function flipBitsFromRightMostSetBit ( num ) { getTotCount ( num ) ; let num1 = num ^ ( ( 1 << totCount ) - 1 ) ; num1 = num1 ^ ( ( 1 << firstCount ) - 1 ) ; return num1 ; } let n = 120 ; document . write ( flipBitsFromRightMostSetBit ( n ) ) ;";"Number formed by flipping all bits to the left of rightmost set bit | JavaScript program to find the integer formed after flipping all bits to the left of the rightmost set bit ; Function to get the total count ; Moving until we get the rightmost set bit ; To get total number of bits in a number ; Function to find the integer formed after flipping all bits to the left of the rightmost set bit ; Find the total count of bits and the rightmost set bit ; XOR given number with the number which has is made up of only totbits set ; To avoid flipping the bits to the right of the set bit , take XOR with the number made up of only set firstbits ; Driver Code"
Javascript;"function isVowel ( x ) { return x === "" "" || x === "" "" || x === "" "" || x === "" "" || x === "" "" ; } function findMaxLen ( s ) { var maxLen = 0 ; var cur ; if ( isVowel ( s [ 0 ] ) ) maxLen = 1 ; cur = maxLen ; for ( var i = 1 ; i < s . length ; i ++ ) { if ( isVowel ( s [ i ] ) ) { if ( s [ i ] !== s [ i - 1 ] ) cur += 1 ; else cur = 1 ; } else { cur = 0 ; } maxLen = Math . max ( cur , maxLen ) ; } return maxLen ; } var Str = "" "" ; document . write ( findMaxLen ( Str ) ) ;";"Longest substring of vowels with no two adjacent alphabets same | Function to check a character is vowel or not ; Function to find length of longest substring consisting only of vowels and no similar adjacent alphabets ; Stores max length of valid subString ; Stores length of current valid subString ; If curr and prev character are not same , include it ; If same as prev one , start new subString from here ; Store max in maxLen ; Driver code"
Javascript;"function power ( base , pow ) { let res = 1 ; while ( pow > 0 ) { if ( ( pow & 1 ) == 1 ) res = ( res * base ) ; base = ( base * base ) ; pow >>= 1 ; } return res ; } function countNonPalindromicString ( n , m ) { let total = power ( n , m ) ; let palindrome = power ( n , m / 2 + m % 2 ) ; let count = total - palindrome ; return count ; } let n = 3 , m = 5 ; document . write ( countNonPalindromicString ( n , m ) ) ;";"Count of non | Iterative Function to calculate base ^ pow in O ( log y ) ; Function to return the count of non palindromic strings ; Count of strings using n characters with repetitions allowed ; Count of palindromic strings ; Count of non - palindromic strings ; Driver Code"
Javascript;"var freq = Array ( 26 ) . fill ( 0 ) ; function checkPalindrome ( ) { var oddCnt = 0 ; freq . forEach ( x => { if ( x % 2 == 1 ) oddCnt ++ ; } ) ; return oddCnt <= 1 ; } function countPalindromePermutation ( s , k ) { for ( var i = 0 ; i < k ; i ++ ) { freq [ s [ i ] . charCodeAt ( 0 ) - 97 ] ++ ; } var ans = 0 ; if ( checkPalindrome ( ) ) { ans ++ ; } var i = 0 , j = k ; while ( j < s . length ) { freq [ s [ i ++ ] . charCodeAt ( 0 ) - 97 ] -- ; freq [ s [ j ++ ] . charCodeAt ( 0 ) - 97 ] ++ ; if ( checkPalindrome ( ) ) { ans ++ ; } } return ans ; } var str = "" "" ; var K = 3 ; document . write ( countPalindromePermutation ( str , K ) ) ;";"Count of K | To store the frequency array ; Function to check palindromic of of any substring using frequency array ; Initialise the odd count ; Traversing frequency array to compute the count of characters having odd frequency ; Returns true if odd count is atmost 1 ; Function to count the total number substring whose any permutations are palindromic ; Computing the frequency of first K character of the string ; To store the count of palindromic permutations ; Checking for the current window if it has any palindromic permutation ; Start and end point of window ; Decrementing count of first element of the window ; Incrementing count of next element of the window ; Checking current window character frequency count ; Return the final count ; Given string str ; Window of size K ; Function Call"
Javascript;"function minFlips ( target ) { let curr = ' ' ; let count = 0 ; for ( let i = 0 ; i < target . length ; i ++ ) { if ( target [ i ] == curr ) { count ++ ; curr = String . fromCharCode ( 48 + ( curr . charCodeAt ( ) + 1 ) % 2 ) ; } } return count ; } let S = "" "" ; document . write ( minFlips ( S ) ) ;";"Minimum flips required to form given binary string where every flip changes all bits to its right as well | Function to return the count of minimum flips required ; If curr occurs in the final string ; Switch curr to '0' if '1' or vice - versa ; Driver code"
Javascript;"function checkSuffix ( A , B ) { let digit_B = parseInt ( Math . log10 ( B ) + 1 , 10 ) ; A -= B ; return ( A % ( Math . pow ( 10 , digit_B ) ) > 0 ) ; } let A = 12345 , B = 45 ; let result = checkSuffix ( A , B ) ; if ( ! result ) { document . write ( "" "" ) ; } else { document . write ( "" "" ) ; }";"Check if a number ends with another number or not | Function to check if B is a suffix of A or not ; Find the number of digit in B ; Subtract B from A ; Returns true , if B is a suffix of A ; Given numbers ; Function call ; If B is a suffix of A , then print "" Yes """
Javascript;"function count_min_length ( s ) { var hash = new Array ( 26 ) . fill ( 0 ) ; var ans = 2147483648 ; for ( var i = 0 ; i < 26 ; i ++ ) hash [ i ] = - 1 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( hash [ s [ i ] . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) ] == - 1 ) hash [ s [ i ] . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) ] = i ; else { if ( hash [ s [ i ] . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) ] == i - 1 || hash [ s [ i ] . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) ] == i - 2 ) return 0 ; ans = Math . min ( ans , i - hash [ s [ i ] . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) ] - 1 ) ; hash [ s [ i ] . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) ] = i ; } } if ( ans === 2147483648 ) return - 1 ; return ans ; } var str = "" "" ; document . write ( count_min_length ( str ) ) ;";"Minimum length of substring whose rotation generates a palindromic substring | Function to return the minimum length of substring ; Store the index of previous occurrence of the character ; Variable to store the maximum length of substring ; If the current character hasn 't appeared yet ; If the character has occured within one or two previous index , a palindromic substring already exists ; Update the maximum ; Replace the previous index of the character by the current index ; If character appeared at least twice ; Driver code"
Javascript;"function RemoveHTMLTags ( s ) { const pattern = new RegExp ( "" \\ \\ "" ) ; s = new String ( s ) . replace ( pattern , "" "" ) ; document . write ( s ) ; return ; } let str = "" "" ; RemoveHTMLTags ( str ) ;";"Program to remove HTML tags from a given String | Function to remove the HTML tags from the given string ; Use regex_replace function in regex to erase every tags enclosed in < > ; Print string after removing tags ; Given String ; Function call to print the HTML string after removing tags"
Javascript;"function rec ( a , i ) { if ( i == 0 ) { document . write ( a . join ( "" "" ) ) ; return ; } if ( a [ i ] == ' ' ) { let j = i ; while ( a [ j ] != ' \0 ' && a [ j + 1 ] != ' \0 ' ) { let temp = a [ j ] ; a [ j ] = a [ j + 1 ] ; a [ j + 1 ] = temp ; j ++ ; } } rec ( a , i - 1 ) ; } let a = [ ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' ' , ' \0 ' ] ; let n = 10 ; rec ( a , n - 1 ) ;";"Move all occurrence of letter ' x ' from the string s to the end using Recursion | Recursive program to bring ' x ' to the end ; When the string is completed from reverse direction end of recursion ; If the character x is found ; Transverse the whole string ; Swap the x so that it moves to the last ; call to the smaller problem now ; Driver code ; Size of a ; Call to rec"
Javascript;"function largestCharacter ( str ) { let uppercase = new Array ( 26 ) ; uppercase . fill ( false ) ; let lowercase = new Array ( 26 ) ; lowercase . fill ( false ) ; let arr = str . split ( ' ' ) ; for ( let c = 0 ; c < arr . length ; c ++ ) { if ( arr == arr . toLowerCase ( ) ) lowercase [ arr . charCodeAt ( ) - 97 ] = true ; if ( arr == arr . toUpperCase ( ) ) uppercase [ arr . charCodeAt ( ) - 65 ] = true ; } for ( let i = 25 ; i >= 0 ; i -- ) { if ( uppercase [ i ] && lowercase [ i ] ) return String . fromCharCode ( i + ' ' . charCodeAt ( ) ) + "" "" ; } return "" "" ; } let str = "" "" ; document . write ( largestCharacter ( str ) ) ;";"Find the largest Alphabetic character present in the string | Function to find the Largest Alphabetic Character ; Array for keeping track of both uppercase and lowercase english alphabets ; Iterate from right side of array to get the largest index character ; Check for the character if both its uppercase and lowercase exist or not ; Return - 1 if no such character whose uppercase and lowercase present in string str ; Driver code"
Javascript;"function generateString ( N , M , K ) { let s = "" "" ; let cnt1 = 0 ; let cnt2 = 0 ; for ( let i = 0 ; i < N ; i ++ ) { cnt1 ++ ; cnt2 ++ ; if ( cnt1 <= M ) { if ( cnt2 <= K ) { s = s + String . fromCharCode ( 96 + cnt1 ) ; } else { s = s + ' ' ; } } else { cnt1 = 1 ; cnt2 = 1 ; s = s + ' ' ; } } return s ; } let N = 7 , M = 5 , K = 3 ; document . write ( generateString ( N , M , K ) )";"Generate a string of size N whose each substring of size M has exactly K distinct characters | Function to generate the String ; Declare empty string ; counter for M ; counter for K ; Loop to generate string size of N ; Generating K distinct letters one by one ; After generating b distinct letters , append rest a - b letters as ' a ' ; Reset the counter value and repeat the process ; return final result string ; Driver code"
Javascript;"function finalString ( str ) { let x = 0 , y = 0 ; let left ; let n = str . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) x ++ ; else y ++ ; } if ( x > y ) left = 1 ; else left = 0 ; let length = n - 2 * Math . min ( x , y ) ; for ( let i = 0 ; i < length ; i ++ ) { document . write ( left ) ; } } let str = "" "" ; finalString ( str ) ;";"Print string after removing all ( “ 10 ” or “ 01 ” ) from the binary string | Function to print the final String after removing all the occurrences of ""10"" and ""01"" from the given binary String ; Variables to store the count of 1 ' s ▁ and ▁ 0' s ; Variable left will store whether 0 ' s ▁ or ▁ 1' s is left in the final String ; Length of the String ; For loop to count the occurrences of 1 ' s ▁ and ▁ 0' s in the String ; To check if the count of 1 ' s ▁ is ▁ ▁ greater ▁ than ▁ the ▁ count ▁ of ▁ 0' s or not . If x is greater , then those many 1 's  are prleted. ; Length of the final remaining String after removing all the occurrences ; Printing the final String ; Driver Code"
Javascript;"function swap ( str , i , j ) { let tempArr = str . split ( "" "" ) ; let temp = tempArr [ i ] ; tempArr [ i ] = tempArr [ j ] ; tempArr [ j ] = temp ; return ( tempArr ) . join ( "" "" ) ; } function IsLexicographicallySmaller ( A , B ) { if ( A < ( B ) ) { return true ; } let temp = A ; let p = temp . split ( "" "" ) ; p . sort ( ) ; temp = ( p ) . join ( "" "" ) ; let index = - 1 ; for ( let i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] != temp [ i ] ) { index = i ; break ; } } if ( index == - 1 ) { return false ; } let j = 0 ; for ( let i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] == temp [ index ] ) j = i ; } A = swap ( A , index , j ) ; if ( A < ( B ) ) { return true ; } else { return false ; } } let A = "" "" ; let B = "" "" ; if ( IsLexicographicallySmaller ( A , B ) ) { document . write ( "" "" ) ; } else { document . write ( "" "" ) ; }";"Lexicographically smaller string by swapping at most one character pair | Swap function ; Function that finds whether is it possible to make String A lexicographically smaller than String B ; Condition if String A is already smaller than B ; Sorting temp String ; Condition for first changed character of String A and temp ; Condition if String A is already sorted ; Finding first changed character from last of String A ; Swap the two characters ; Condition if String A is smaller than B ; Driver Code"
Javascript;"function max ( x , y ) { return ( x > y ) ? x : y ; } function longestPalindromic ( str , i , j , count ) { if ( i > j ) return count ; if ( i == j ) return ( count + 1 ) ; if ( str [ i ] == str [ j ] ) { count = longestPalindromic ( str , i + 1 , j - 1 , count + 2 ) ; return max ( count , max ( longestPalindromic ( str , i + 1 , j , 0 ) , longestPalindromic ( str , i , j - 1 , 0 ) ) ) ; } return Math . max ( longestPalindromic ( str , i + 1 , j , 0 ) , longestPalindromic ( str , i , j - 1 , 0 ) ) ; } function longest_palindromic_substr ( str ) { return longestPalindromic ( str , 0 , str . length - 1 , 0 ) ; } let str = "" "" ; document . write ( longest_palindromic_substr ( str ) ) ;";"Length of longest palindromic sub | Function to find maximum of the two variables ; Function to find the longest palindromic subString : Recursion ; Base condition when the start index is greater than end index ; Base condition when both the start and end index are equal ; Condition when corner characters are equal in the String ; Recursive call to find the longest Palindromic String by excluding the corner characters ; Recursive call to find the longest Palindromic String by including one corner character at a time ; Function to find the longest palindromic sub - String ; Utility function call ; Driver Code ; Function Call"
Javascript;"function MaxPrefix ( s ) { var Dict = { } ; for ( const i of s ) { if ( Dict . hasOwnProperty ( i ) ) { Dict [ i ] ++ ; } else { Dict [ i ] = 1 ; } } var minfrequency = 2147483647 ; for ( const [ key , value ] of Object . entries ( Dict ) ) { minfrequency = Math . min ( minfrequency , value ) ; } var countminFrequency = 0 ; for ( const [ key , value ] of Object . entries ( Dict ) ) { if ( Dict [ key ] === minfrequency ) countminFrequency += 1 ; } var mapper = { } ; var indi = 0 ; for ( const i of s ) { if ( mapper . hasOwnProperty ( i ) ) { mapper [ i ] ++ ; } else { mapper [ i ] = 1 ; } if ( mapper [ i ] > countminFrequency ) break ; indi += 1 ; } document . write ( s . substring ( 0 , indi ) ) ; } var str = "" "" ; MaxPrefix ( str ) ;";"Maximum length prefix such that frequency of each character is atmost number of characters with minimum frequency | Function to find the maximum possible prefix of the s ; Hash map to store the frequency of the characters in the s ; Iterate over the s to find the occurence of each Character ; Minimum frequency of the Characters ; Loop to find the count of minimum frequency in the hash - map ; Loop to find the maximum possible length of the prefix in the s ; Condition to check if the frequency is greater than minimum possible freq ; maxprefix s and its length . ; Driver Code s is initialize . ; str is passed in MaxPrefix function ."
Javascript;"function countSubString ( S , L , n ) { var freq = new Array ( 26 ) . fill ( 0 ) ; var ans = 0 ; for ( var i = 0 ; i < n ; i ++ ) { freq [ L [ i ] . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) ] = 1 ; } var count = 0 ; for ( const x of S ) { if ( freq [ x . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) ] > 0 ) { ans = ans + parseInt ( ( count * count + count ) / 2 ) ; count = 0 ; } else count ++ ; } ans += parseInt ( ( count * count + count ) / 2 ) ; return ans ; } var S = "" "" ; var L = [ "" "" , "" "" , "" "" ] ; var n = L . length ; document . write ( countSubString ( S . split ( "" "" ) , L , n ) ) ;";"Count of Substrings that can be formed without using the given list of Characters | Function to find the Number of sub - Strings without using given character ; Mark the given characters in the freq array ; Count variable to store the count of the characters until a character from given L is encountered ; If a character from L is encountered , then the answer variable is incremented by the value obtained by using the mentioned formula and count is set to 0 ; For last remaining characters ; Driver code"
Javascript;"function checkIfStartsWithVowels ( str ) { if ( ! ( str [ 0 ] == ' ' str [ 0 ] == ' ' str [ 0 ] == ' ' str [ 0 ] == ' ' str [ 0 ] == ' ' str [ 0 ] == ' ' str [ 0 ] == ' ' str [ 0 ] == ' ' str [ 0 ] == ' ' str [ 0 ] == ' ' ) ) return 1 ; else return 0 ; } function check ( str ) { if ( checkIfStartsWithVowels ( str ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ; } var str = "" "" ; check ( str ) ; str = "" "" ; check ( str ) ;";"Program to accept Strings starting with a Vowel | Function to check if first character is vowel ; Function to check ; Driver code"
Javascript;"function findNthOccur ( str , ch , N ) { var occur = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] == ch ) { occur += 1 ; } if ( occur == N ) return i ; } return - 1 ; } var str = "" "" ; var ch = ' ' ; var N = 2 ; document . write ( findNthOccur ( str , ch , N ) ) ;";"Find the Nth occurrence of a character in the given String | Function to find the Nth occurrence of a character ; Loop to find the Nth occurrence of the character ; Driver Code"
Javascript;"function solve ( X , Y , N , K ) { let count = new Array ( N + 1 ) ; count . fill ( 0 ) ; let sol = 0 ; count [ 0 ] = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { count [ i ] = count [ i - 1 ] + Math . abs ( X [ i - 1 ] . charCodeAt ( ) - Y [ i - 1 ] . charCodeAt ( ) ) ; } let j = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { while ( ( count [ i ] - count [ j ] ) > K ) { j ++ ; } sol = Math . max ( sol , i - j ) ; } return sol ; } let N = 4 ; let X = "" "" , Y = "" "" ; let K = 3 ; document . write ( solve ( X , Y , N , K ) ) ;";"Longest equal substring with cost less than K | Function to find the maximum length ; Fill the prefix array with the difference of letters ; Update the maximum length ; Driver code"
Javascript;"function jaro_distance ( s1 , s2 ) { if ( s1 == s2 ) return 1.0 ; let len1 = s1 . length , len2 = s2 . length ; if ( len1 == 0 len2 == 0 ) return 0.0 ; let max_dist = Math . floor ( Math . max ( len1 , len2 ) / 2 ) - 1 ; let match = 0 ; let hash_s1 = new Array ( s1 . length ) ; hash_s1 . fill ( 0 ) ; let hash_s2 = new Array ( s2 . length ) ; hash_s2 . fill ( 0 ) ; for ( let i = 0 ; i < len1 ; i ++ ) { for ( let j = Math . max ( 0 , i - max_dist ) ; j < Math . min ( len2 , i + max_dist + 1 ) ; j ++ ) if ( s1 [ i ] == s2 [ j ] && hash_s2 [ j ] == 0 ) { hash_s1 [ i ] = 1 ; hash_s2 [ j ] = 1 ; match ++ ; break ; } } if ( match == 0 ) return 0.0 ; let t = 0 ; let point = 0 ; for ( let i = 0 ; i < len1 ; i ++ ) if ( hash_s1 [ i ] == 1 ) { while ( hash_s2 [ point ] == 0 ) point ++ ; if ( s1 [ i ] != s2 [ point ++ ] ) t ++ ; } t /= 2 ; return ( ( match ) / ( len1 ) + ( match ) / ( len2 ) + ( match - t ) / ( match ) ) / 3.0 ; } function jaro_Winkler ( s1 , s2 ) { let jaro_dist = jaro_distance ( s1 , s2 ) ; if ( jaro_dist > 0.7 ) { let prefix = 0 ; for ( let i = 0 ; i < Math . min ( s1 . length , s2 . length ) ; i ++ ) { if ( s1 [ i ] == s2 [ i ] ) prefix ++ ; else break ; } prefix = Math . min ( 4 , prefix ) ; jaro_dist += 0.1 * prefix * ( 1 - jaro_dist ) ; } return jaro_dist . toFixed ( 6 ) ; } let s1 = "" "" , s2 = "" "" ; document . write ( "" "" + jaro_Winkler ( s1 , s2 ) ) ;";"Jaro and Jaro | Function to calculate the Jaro Similarity of two strings ; If the strings are equal ; Length of two strings ; Maximum distance upto which matching is allowed ; Count of matches ; Hash for matches ; Traverse through the first string ; Check if there is any matches ; If there is a match ; If there is no match ; Number of transpositions ; Count number of occurrences where two characters match but there is a third matched character in between the indices ; Find the next matched character in second string ; Return the Jaro Similarity ; Jaro Winkler Similarity ; If the jaro Similarity is above a threshold ; Find the length of common prefix ; If the characters match ; Else break ; Maximum of 4 characters are allowed in prefix ; Calculate jaro winkler Similarity ; Driver code ; Print Jaro - Winkler Similarity of two strings"
Javascript;"function isWordPresent ( sentence , word ) { let s = sentence . split ( "" "" ) ; for ( let temp = 0 ; temp < s . length ; temp ++ ) { if ( s [ temp ] == ( word ) ) { return true ; } } return false ; } let s = "" "" ; let word = "" "" ; if ( isWordPresent ( s , word ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check if a word is present in a sentence | Function that returns true if the word is found ; To break the sentence in words ; To temporarily store each individual word ; Comparing the current word with the word to be searched ; Driver code"
Javascript;"function isWordPresent ( sentence , word ) { word = transform ( word ) ; sentence = transform ( sentence ) ; let s = sentence . split ( "" "" ) ; for ( let temp = 0 ; temp < s . length ; temp ++ ) { if ( s [ temp ] == ( word ) ) { return true ; } } return false ; } function transform ( word ) { return word . toUpperCase ( ) ; } let s = "" "" ; let word = "" "" ; if ( isWordPresent ( s , word ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check if a word is present in a sentence | Function that returns true if the word is found ; To convert the word in uppercase ; To convert the complete sentence in uppercase ; To break the sentence in words ; To store the individual words of the sentence ; Comparing the current word with the word to be searched ; Driver code"
Javascript;"function countChars ( str , n ) { let i = 0 , cnt = 0 ; while ( i < n ) { if ( str [ i ] == ' ' ) i += 1 ; else i += 2 ; cnt += 1 ; } return cnt ; } let str = "" "" ; let n = str . length ; document . write ( countChars ( str , n ) ) ;";"Count of 1 | Function to return the count of required characters ; While there are characters left ; Single bit character ; Two - bit character ; Update the count ; Driver code"
Javascript;"let MAX = 26 ; function compressString ( s , n ) { let freq = new Array ( MAX ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { freq [ s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ++ ; } for ( let i = 0 ; i < MAX ; i ++ ) { if ( freq [ i ] == 0 ) continue ; document . write ( String . fromCharCode ( i + ' ' . charCodeAt ( ) ) + "" "" + freq [ i ] ) ; } } let s = "" "" ; let n = s . length ; compressString ( s , n ) ;";"Print the frequency of each character in Alphabetical order | Javascript implementation of the approach ; Function to print the frequency of each of the characters of s in alphabetical order ; To store the frequency of the characters ; Update the frequency array ; Print the frequency in alphatecial order ; If the current alphabet doesn 't  appear in the string ; Driver code"
Javascript;"function decBinary ( arr , n ) { let k = parseInt ( Math . log ( n ) / Math . log ( 2 ) , 10 ) ; while ( n > 0 ) { arr [ k -- ] = n % 2 ; n = parseInt ( n / 2 , 10 ) ; } } function binaryDec ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) ans += arr [ i ] << ( n - i - 1 ) ; return ans ; } function concat ( m , n ) { let k = parseInt ( Math . log ( m ) / Math . log ( 2 ) , 10 ) + 1 ; let l = parseInt ( Math . log ( n ) / Math . log ( 2 ) , 10 ) + 1 ; let a = new Array ( k ) ; let b = new Array ( l ) ; let c = new Array ( k + l ) ; decBinary ( a , m ) ; decBinary ( b , n ) ; let iN = 0 ; for ( let i = 0 ; i < k ; i ++ ) c [ iN ++ ] = a [ i ] ; for ( let i = 0 ; i < l ; i ++ ) c [ iN ++ ] = b [ i ] ; return ( binaryDec ( c , k + l ) ) ; } let m = 4 , n = 5 ; document . write ( concat ( m , n ) ) ;";"Find the number obtained after concatenation of binary representation of M and N | Function to convert decimal number n to its binary representation stored as an array [ ] arr ; Funtion to convert the number represented as a binary array [ ] arr into its decimal equivalent ; Function to concatenate the binary numbers and return the decimal result ; Number of bits in both the numbers ; Convert the bits in both the integers to the arrays [ ] a and [ ] b ; c [ ] will be the binary array for the result ; Update the c [ ] array ; Return the decimal equivalent of the result ; Driver code"
Javascript;"function getBinaryLength ( n ) { let length = 0 ; while ( n > 0 ) { length += 1 ; n = parseInt ( n / 2 , 10 ) ; } return length ; } function concat ( m , n ) { let length = getBinaryLength ( n ) ; return ( m << length ) + n ; } let m = 4 , n = 5 ; document . write ( concat ( m , n ) ) ;";"Find the number obtained after concatenation of binary representation of M and N | Utility function to calculate binary length of a number . ; Function to concatenate the binary numbers and return the decimal result ; Find binary length of n ; left binary shift m and then add n ; Driver code"
Javascript;"function addZeros ( str , n ) { for ( let i = 0 ; i < n ; i ++ ) { str = "" "" + str ; } return str ; } function getXOR ( a , b ) { let aLen = a . length ; let bLen = b . length ; if ( aLen > bLen ) { a = addZeros ( b , aLen - bLen ) ; } else if ( bLen > aLen ) { a = addZeros ( a , bLen - aLen ) ; } let len = Math . max ( aLen , bLen ) ; let res = "" "" ; for ( let i = 0 ; i < len ; i ++ ) { if ( a [ i ] == b [ i ] ) res += "" "" ; else res += "" "" ; } return res ; } let a = "" "" , b = "" "" ; document . write ( getXOR ( a , b ) ) ;";"XOR two binary strings of unequal lengths | Function to insert n 0 s in the beginning of the given string ; Function to return the XOR of the given strings ; Lengths of the given strings ; Make both the strings of equal lengths by inserting 0 s in the beginning ; Updated length ; To store the resultant XOR ; Driver code"
Javascript;"var MAX = 26 ; function minOperation ( str , len ) { var first = Array ( MAX ) . fill ( - 1 ) ; var last = Array ( MAX ) . fill ( - 1 ) ; for ( var i = 0 ; i < len ; i ++ ) { var index = ( str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ) ; if ( first [ index ] == - 1 ) first [ index ] = i ; last [ index ] = i ; } var minOp = - 1 ; for ( var i = 0 ; i < MAX ; i ++ ) { if ( first [ i ] == - 1 first [ i ] == last [ i ] ) continue ; var cnt = len - ( last [ i ] - first [ i ] + 1 ) ; if ( minOp == - 1 cnt < minOp ) minOp = cnt ; } return minOp ; } var str = "" "" ; var len = str . length ; document . write ( minOperation ( str , len ) ) ;";"Minimum operations required to make the string satisfy the given condition | Javascript implementation of the approach ; Function to return the minimum operations required ; To store the first and the last occurrence of all the characters ; Update the occurrences of the characters ; Only set the first occurrence if it hasn 't already been set ; To store the minimum operations ; If the frequency of the current character in the string is less than 2 ; Count of characters to be removed so that the string starts and ends at the current character ; Driver code"
Javascript;"let N = 2 ; function isVowel ( ch ) { return ( ch == ' ' ch == ' ' ch == ' ' ch == ' ' ch == ' ' ) ; } function countVowels ( str , l , r ) { let cnt = 0 ; for ( let i = l ; i <= r ; i ++ ) { if ( isVowel ( str [ i ] ) ) cnt ++ ; } return cnt ; } function performQueries ( str , queries , q ) { for ( let i = 0 ; i < q ; i ++ ) { document . write ( countVowels ( str , queries [ i ] [ 0 ] , queries [ i ] [ 1 ] ) + "" "" ) ; } } let str = "" "" ; let queries = [ [ 1 , 3 ] , [ 2 , 4 ] , [ 1 , 9 ] ] ; let q = queries . length ; performQueries ( str , queries , q ) ;";"Queries to find the count of vowels in the substrings of the given string | Javascript implementation of the approach ; Function that returns true if ch is a vowel ; Function to return the count of vowels in the substring str [ l ... r ] ; To store the count of vowels ; For every character in the index range [ l , r ] ; If the current character is a vowel ; For every query ; Find the count of vowels for the current query ; Driver code"
Javascript;"class node { constructor ( ) { this . data = ' ' ; this . next = null ; } } function add ( data ) { let newnode = new node ( ) ; newnode . data = data ; newnode . next = null ; return newnode ; } function string_to_SLL ( text , head ) { head = add ( text [ 0 ] ) ; let curr = head ; for ( let i = 1 ; i < text . length ; i ++ ) { curr . next = add ( text [ i ] ) ; curr = curr . next ; } return head ; } function print ( head ) { let curr = head ; while ( curr != null ) { document . write ( curr . data + "" "" ) ; curr = curr . next ; } } let text = "" "" ; let head = null ; head = string_to_SLL ( text , head ) ; print ( head ) ;";"Convert a String to a Singly Linked List | Structure for a Singly Linked List ; Function to add a new node to the Linked List ; Function to convert the string to Linked List . ; curr pointer points to the current node where the insertion should take place ; Function to print the data present in all the nodes ; Driver code"
Javascript;"function minLength ( str , len ) { let s = [ ] ; for ( let i = 0 ; i < len ; i ++ ) { if ( s . length == 0 ) { s . push ( str [ i ] ) ; } else { let c = s [ s . length - 1 ] ; if ( c != str [ i ] && c . toUpperCase ( ) == str [ i ] . toUpperCase ( ) ) { s . pop ( ) ; } else { s . push ( str [ i ] ) ; } } } return s . length ; } ' ' ' ' ' ' let str = "" "" ; let len = str . length ; document . write ( minLength ( str , len ) ) ;";"Reduce the string to minimum length with the given operation | Function to return the minimum possible length str can be reduced to with the given operation ; Stack to store the characters of the given string ; For every character of the string ; If the stack is empty then push the current character in the stack ; Get the top character ; If the top element is not equal to the current element and it only differs in the case ; Pop the top element from stack ; Else push the current element ;"
Javascript;"let MAX = 26 ; function canBeMadeEqual ( str1 , str2 ) { let len1 = str1 . length ; let len2 = str2 . length ; if ( len1 == len2 ) { let freq = new Array ( MAX ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < len1 ; i ++ ) { freq [ str1 [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ++ ; } for ( let i = 0 ; i < len2 ; i ++ ) { if ( freq [ str2 [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] > 0 ) return true ; } } return false ; } let str1 = "" "" , str2 = "" "" ; if ( canBeMadeEqual ( str1 , str2 ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check whether two strings can be made equal by copying their characters with the adjacent ones | JavaScript implementation of the above approach ; Function that returns true if both the strings can be made equal with the given operation ; Lengths of both the strings have to be equal ; To store the frequency of the characters of str1 ; For every character of str2 ; If current character of str2 also appears in str1 ; Driver code"
Javascript;"function getCount ( str , n ) { var cnt = 0 ; var i = 0 ; while ( i < n - 2 ) { if ( str [ i ] === str [ i + 1 ] && str [ i ] === str [ i + 2 ] ) { cnt ++ ; i = i + 2 ; } else { i ++ ; } } return cnt ; } var str = "" "" ; var n = str . length ; document . write ( getCount ( str , n ) ) ;";"Minimum characters that are to be inserted such that no three consecutive characters are same | Function to return the count of characters that are to be inserted in str such that no three consecutive characters are same ; To store the count of operations required ; A character needs to be inserted after str [ i + 1 ] ; Current three consecutive characters are not same ; Driver code"
Javascript;"function fact ( n ) { let fact = 1 ; for ( let i = 1 ; i <= n ; i ++ ) fact *= i ; return fact ; } function countStrings ( str , n ) { let distinct_char = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) { distinct_char . add ( str [ i ] ) ; } return fact ( distinct_char . size ) ; } let str = "" "" ; let n = str . length ; document . write ( countStrings ( str , n ) ) ;";"Find the number of strings formed using distinct characters of a given string | Function to return the factorial of n ; Function to return the count of all possible strings that can be formed with the characters of the given string without repeating characters ; To store the distinct characters of the string str ; Driver code"
Javascript;"function getChar ( str ) { let sum = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { sum += ( str [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) + 1 ) ; } if ( sum % 26 == 0 ) return ' ' ; else { sum = sum % 26 ; return String . fromCharCode ( ' ' . charCodeAt ( ) + sum - 1 ) ; } } let str = "" "" ; document . write ( getChar ( str ) ) ;";"Find the character made by adding all the characters of the given string | Function to return the required character ; To store the sum of the characters of the given string ; Add the current character to the sum ; Return the required character ; Driver code"
Javascript;"function reverse ( str , len , l , r ) { if ( l < 0 r >= len l > r ) return "" "" ; while ( l < r ) { let c = str [ l ] ; str [ l ] = str [ r ] ; str [ r ] = c ; l ++ ; r -- ; } return str . join ( "" "" ) ; } let str = "" "" ; let len = str . length ; let l = 5 , r = 7 ; document . write ( reverse ( str . split ( ' ' ) , len , l , r ) ) ;";"Reverse the given string in the range [ L , R ] | Function to return the string after reversing characters in the range [ L , R ] ; Invalid range ; While there are characters to swap ; Swap ( str [ l ] , str [ r ] ) ; Driver code"
Javascript;"function encrypt ( input ) { let evenPos = ' ' , oddPos = ' ' ; let repeat , ascii ; for ( let i = 0 ; i < input . length ; i ++ ) { ascii = input [ i ] . charCodeAt ( ) ; repeat = ascii >= 97 ? ascii - 96 : ascii - 64 ; for ( let j = 0 ; j < repeat ; j ++ ) { if ( i % 2 == 0 ) document . write ( oddPos ) ; else document . write ( evenPos ) ; } } } let input = [ ' ' , ' ' , ' ' , ' ' ] ; encrypt ( input ) ;";"Program to Encrypt a String using ! and @ | Function to encrypt the string ; evenPos is for storing encrypting char at evenPosition oddPos is for storing encrypting char at oddPosition ; Get the number of times the character is to be repeated ; if i is odd , print ' ! ' else print ' @ ' ; Driver code ; Encrypt the String"
Javascript;"function IsRedundantBraces ( A ) { let a = 0 , b = 0 ; for ( let i = 0 ; i < A . length ; i ++ ) { if ( A [ i ] == ' ' && A [ i + 2 ] == ' ' ) return true ; if ( A [ i ] == ' ' A [ i ] == ' ' A [ i ] == ' ' A [ i ] == ' ' ) a ++ ; if ( A [ i ] == ' ' ) b ++ ; } if ( b > a ) return true ; return false ; } let A = "" "" ; if ( IsRedundantBraces ( A ) ) { document . write ( "" "" ) ; } else { document . write ( "" "" ) ; }";"Check if expression contains redundant bracket or not | Set 2 | Function to check for redundant braces ; count of no of signs ; Driver Code"
Javascript;"function balancedBrackets ( str ) { var dep = 0 ; var minDep = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] === "" "" ) dep ++ ; else dep -- ; if ( minDep > dep ) minDep = dep ; } if ( minDep < 0 ) { for ( var i = 0 ; i < Math . abs ( minDep ) ; i ++ ) str = "" "" + str ; } dep = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] === "" "" ) dep ++ ; else dep -- ; } if ( dep !== 0 ) { for ( var i = 0 ; i < dep ; i ++ ) str = str + "" "" ; } return str ; } var str = "" "" ; document . write ( balancedBrackets ( str ) ) ;";"Convert an unbalanced bracket sequence to a balanced sequence | Function to return balancedBrackets string ; Initializing dep to 0 ; Stores maximum negative depth ; if dep is less than minDep ; if minDep is less than 0 then there is need to add ' ( ' at the front ; Reinitializing to check the updated string ; if dep is not 0 then there is need to add ' ) ' at the back ; Driver code"
Javascript;"function minOperations ( str , n ) { var count = 0 ; for ( var i = 0 ; i < n - 1 ; i ++ ) { if ( str [ i ] != str [ i + 1 ] ) count ++ ; } return ( count + 1 ) / 2 ; } var str = "" "" ; var n = str . length ; document . write ( minOperations ( str , n ) ) ;";"Minimum operations required to convert a binary string to all 0 s or all 1 s | Function to return the count of minimum operations required ; Increment count when consecutive characters are different ; Answer is rounding off the ( count / 2 ) to lower ; Driver code"
Javascript;"function find_digit ( s , n ) { var first_digit = - 1 ; for ( var i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] < ' ' s [ i ] > ' ' ) { first_digit = i ; break ; } } first_digit ++ ; var s_len = first_digit ; var num = 0 , pw = 1 ; var i = n - 1 ; while ( i >= 0 ) { if ( s [ i ] >= ' ' && s [ i ] <= ' ' ) { var digit = s [ i ] - ' ' ; num = num + ( pw * digit ) ; if ( num >= s_len ) return - 1 ; pw = pw * 10 ; } i -- ; } num = num * 10 ; var req = s_len - num ; if ( req > 9 req < 0 ) return - 1 ; return req ; } var s = "" "" ; var n = s . length ; document . write ( find_digit ( s , n ) ) ;";"Append a digit in the end to make the number equal to the length of the remaining string | Function to return the required digit ; To store the position of the first numeric digit in the string ; To store the length of the string without the numeric digits in the end ; pw stores the current power of 10 and num is to store the number which is appended in the end ; If current character is a numeric digit ; Get the current digit ; Build the number ; If number exceeds the length ; Next power of 10 ; Append 0 in the end ; Required number that must be added ; If number is not a single digit ; Driver code"
Javascript;"function canConvert ( str1 , str2 ) { var i = 0 , j = 0 ; while ( i < str1 . length && j < str2 . length ) { if ( str1 [ i ] !== str2 [ j ] ) { if ( str1 [ i ] === "" "" && str2 [ j ] === "" "" && i + 1 < str1 . length && str1 [ i + 1 ] === "" "" ) { i += 2 ; j ++ ; } else { return false ; } } else { i ++ ; j ++ ; } } if ( i === str1 . length && j === str2 . length ) return true ; return false ; } var str1 = "" "" , str2 = "" "" ; if ( canConvert ( str1 , str2 ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check whether str1 can be converted to str2 with the given operations | Function that returns true if str1 can be converted to str2 with the given operations ; Traverse from left to right ; If the two characters do not match ; If possible to combine ; If not possible to combine ; If the two characters match ; If possible to convert one string to another ; Driver code"
Javascript;"function reverse ( s ) { let stc = [ ] ; let temp = "" "" ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ' ' ) { stc . push ( temp ) ; temp = "" "" ; } else { temp = temp + s [ i ] ; } } stc . push ( temp ) ; while ( stc . length != 0 ) { temp = stc [ stc . length - 1 ] ; document . write ( temp + "" "" ) ; stc . pop ( ) ; } } let s = "" "" ; reverse ( s ) ;";"Reverse the Words of a String using Stack | Function to reverse the words of the given String without using strtok ( ) . ; Create an empty String stack ; Create an empty temporary String ; Traversing the entire String ; Push the temporary variable into the stack ; Assigning temporary variable as empty ; For the last word of the String ; Get the words in reverse order ; Driver code"
Javascript;"function printMatrix ( n , m ) { if ( n < 5 m < 5 ) { document . write ( - 1 ) ; return ; } var s = "" "" ; for ( var i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < m ; j ++ ) { document . write ( s [ j % 5 ] + "" "" ) ; } document . write ( "" "" ) ; var c = s [ 0 ] ; s = s . substring ( 1 , s . length ) + s . substring ( 0 , 1 ) ; s [ 4 ] = c ; } } var n = 5 , m = 5 ; printMatrix ( n , m ) ;";"Print an N x M matrix such that each row and column has all the vowels in it | Function to print the required matrix ; Impossible to generate the required matrix ; Store all the vowels ; Print the matrix ; Print vowels for every index ; Shift the vowels by one ; Driver code"
Javascript;"function isTwoAlter ( s ) { for ( let i = 0 ; i < s . length - 2 ; i ++ ) { if ( s [ i ] != s [ i + 2 ] ) { return false ; } } if ( s [ 0 ] == s [ 1 ] ) return false ; return true ; } let str = "" "" ; if ( isTwoAlter ( str ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check if a given string is made up of two alternating characters | Function that returns true if the string is made up of two alternating characters ; Check if ith character matches with the character at index ( i + 2 ) ; If string consists of a single character repeating itself ; Driver code"
Javascript;"function minOperations ( n , a , b , c ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let x = a [ i ] ; let y = b [ i ] ; let z = c [ i ] ; if ( x == y && y == z ) { ; } else if ( x == y y == z x == z ) { ans ++ ; } else { ans += 2 ; } } return ans ; } let a = "" "" ; let b = "" "" ; let c = "" "" ; let n = a . length ; document . write ( minOperations ( n , a , b , c ) ) ;";"Number of character corrections in the given strings to make them equal | Function to return the count of operations required ; To store the count of operations ; No operation required ; One operation is required when any two characters are equal ; Two operations are required when none of the characters are equal ; Return the minimum count of operations required ; Driver code"
Javascript;"function check ( s ) { let n = s . length ; for ( let i = 0 ; i < n - 1 ; i ++ ) { if ( s [ i ] > s [ i + 1 ] ) return true ; } return false ; } let s = "" "" ; if ( check ( s ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check if string can be made lexicographically smaller by reversing any substring | Function that returns true if s can be made lexicographically smaller by reversing a sub - string in s ; Traverse in the string ; Check if s [ i + 1 ] < s [ i ] ; Not possible ; Driver code"
Javascript;"function countSubStr ( str , n , x ) { let res = 0 , count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == x ) { res += ( ( count + 1 ) * ( n - i ) ) ; count = 0 ; } else count ++ ; } return res ; } let str = "" "" ; let n = str . length ; let x = ' ' ; document . write ( countSubStr ( str , n , x ) ) ;";"Count of sub | Function to return the count of required sub - strings ; Number of sub - strings from position of current x to the end of str ; To store the number of characters before x ; Driver code"
Javascript;"function countSubStr ( str , n ) { var len = str . length ; return len - n + 1 ; } var str = "" "" ; var n = 5 ; document . write ( countSubStr ( str , n ) ) ;";"Count of sub | Function to return the count of possible sub - strings of length n ; Driver code"
Javascript;"function countSubstrings ( s , c ) { var n = s . length ; var cnt = 0 ; var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) != c ) cnt ++ ; else { sum += ( cnt * ( cnt + 1 ) ) / 2 ; cnt = 0 ; } } sum += ( cnt * ( cnt + 1 ) ) / 2 ; return sum ; } var s = "" "" ; var c = ' ' ; document . write ( countSubstrings ( s , c ) ) ;";"Count of sub | Function to return the number of sub - strings that do not contain the given character c ; Length of the string ; Traverse in the string ; If current character is different from the given character ; Update the number of sub - strings ; Reset count to 0 ; For the characters appearing after the last occurrence of c ; Driver code"
Javascript;"function getMinimizedSum ( str , len ) { var i , maxVal = - 2147483648 , sum = 0 ; var occurrences = new Array ( 26 ) . fill ( 0 ) ; for ( i = 0 ; i < len ; i ++ ) { occurrences [ str [ i ] . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) ] ++ ; sum += str [ i ] . charCodeAt ( 0 ) ; } for ( i = 0 ; i < 26 ; i ++ ) { maxVal = Math . max ( maxVal , occurrences [ i ] * ( i + "" "" . charCodeAt ( 0 ) ) ) ; } return sum - maxVal ; } var str = "" "" ; var len = str . length ; document . write ( getMinimizedSum ( str , len ) ) ;";"Minimize ASCII values sum after removing all occurrences of one character | Function to return the minimized sum ; To store the occurrences of each character of the string ; Update the occurrence ; Calculate the sum ; Get the character which is contributing the maximum value to the sum ; Count of occurrence of the character multiplied by its ASCII value ; Return the minimized sum ; Driver code"
Javascript;"function isPalindrome ( s ) { let i = 0 ; let j = s . length - 1 ; while ( i < j ) { if ( s [ i ] != s [ j ] ) return false ; i ++ ; j -- ; } return true ; } function getIndex ( S1 , S2 , n ) { let S = "" "" ; for ( let i = 0 ; i < n ; i ++ ) { S = S + S1 [ i ] ; let Temp = "" "" ; for ( let j = i + 1 ; j < n ; j ++ ) Temp += S2 [ j ] ; if ( isPalindrome ( S + Temp ) ) { return i ; } } return - 1 ; } let S1 = "" "" , S2 = "" "" ; let n = S1 . length ; document . write ( getIndex ( S1 , S2 , n ) ) ;";"Find index i such that prefix of S1 and suffix of S2 till i form a palindrome when concatenated | Function that returns true if s is palindrome ; Function to return the required index ; Copy the ith character in S ; Copy all the character of string s2 in Temp ; Check whether the string is palindrome ; Driver code"
Javascript;"function isPalindrome ( s , i , j ) { while ( i < j ) { if ( s [ i ] != s [ j ] ) return false ; i ++ ; j -- ; } return true ; } function getIndex ( s1 , s2 , len ) { let i = 0 , j = len - 1 ; while ( i < j ) { if ( s1 [ i ] != s2 [ j ] ) { break ; } i ++ ; j -- ; } if ( i == j ) { return i - 1 ; } else if ( isPalindrome ( s2 , i , j ) ) return i - 1 ; else if ( isPalindrome ( s1 , i , j ) ) return j ; return - 1 ; } let s1 = "" "" , s2 = "" "" ; let len = s1 . length ; document . write ( getIndex ( s1 , s2 , len ) + "" "" ) ;";"Find index i such that prefix of S1 and suffix of S2 till i form a palindrome when concatenated | Function that returns true if the sub - String starting from index i and ending at index j is a palindrome ; Function to get the required index ; Start comparing the two Strings from both ends . ; Break from the loop at first mismatch ; If it is possible to concatenate the Strings to form palindrome , return index ; If remaining part for s2 is palindrome ; If remaining part for s1 is palindrome ; If not possible , return - 1 ; Driver Code"
Javascript;"function count_acronym ( n , arr ) { let freq = new Array ( 26 ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) freq [ arr [ i ] [ 0 ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ++ ; let cnt = 0 ; for ( let i = 0 ; i < n ; i ++ ) { let st = arr [ i ] ; let num = new Array ( 26 ) ; num . fill ( 0 ) ; for ( let j = 0 ; j < st . length ; j ++ ) num [ st [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ++ ; let flag = true ; for ( let j = 1 ; j < 26 ; j ++ ) { if ( num [ j ] > freq [ j ] ) { flag = false ; break ; } } let x = st [ 0 ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ; if ( freq [ x ] - 1 < num [ x ] ) flag = false ; if ( flag ) cnt ++ ; } return cnt ; } let arr = [ "" "" , "" "" , "" "" , "" "" , "" "" ] ; let n = arr . length ; document . write ( count_acronym ( n , arr ) ) ;";"Acronym words | Function to return the number of strings that can be an acronym for other strings ; Frequency array to store the frequency of the first character of every string in the array ; To store the count of required strings ; Current word ; Frequency array to store the frequency of each of the character of the current string ; Check if the frequency of every character in the current string is <= its value in freq [ ] ; First character of the current string ; Driver code"
Javascript;"function valid ( cnt ) { for ( var i = 0 ; i < 26 ; i ++ ) { if ( cnt [ i ] >= 2 ) return false ; } return true ; } function getGoodString ( ss , n ) { var s = ss . split ( "" "" ) ; if ( n < 26 ) return "" "" ; for ( var i = 25 ; i < n ; i ++ ) { var cnt = new Array ( 26 ) . fill ( 0 ) ; for ( var j = i ; j >= i - 25 ; j -- ) { cnt [ s [ j ] . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) ] ++ ; } if ( valid ( cnt ) ) { var cur = 0 ; while ( cnt [ cur ] > 0 ) cur ++ ; for ( var j = i - 25 ; j <= i ; j ++ ) { if ( s [ j ] === "" "" ) { s [ j ] = String . fromCharCode ( cur + "" "" . charCodeAt ( 0 ) ) ; cur ++ ; while ( cnt [ cur ] > 0 ) cur ++ ; } } return s . join ( "" "" ) ; } } return "" "" ; } var s = "" "" ; var n = s . length ; document . write ( getGoodString ( s , n ) ) ;";"Sub | Function that returns true if every lowercase character appears atmost once ; every character frequency must be not greater than one ; Function that returns the modified good string if possible ; If the length of the string is less than n ; Sub - strings of length 26 ; To store frequency of each character ; Get the frequency of each character in the current sub - string ; Check if we can get sub - string containing all the 26 characters ; Find which character is missing ; Fill with missing characters ; Find the next missing character ; Return the modified good string ; Driver code"
Javascript;"function isVowel ( c ) { c = c . toLowerCase ( ) ; if ( c === "" "" c === "" "" c === "" "" c === "" "" c === "" "" ) { return true ; } return false ; } function swapRepeated ( str ) { for ( var i = 0 ; i < str . length - 1 ; i ++ ) { if ( ( isVowel ( str [ i ] ) && isVowel ( str [ i + 1 ] ) ) || ( ! isVowel ( str [ i ] ) && ! isVowel ( str [ i + 1 ] ) ) ) { var c = str [ i ] ; str [ i ] = str [ i + 1 ] ; str [ i + 1 ] = c ; } } return str . join ( "" "" ) ; } var str = "" "" ; document . write ( swapRepeated ( str . split ( "" "" ) ) ) ;";"Modify the string by swapping continuous vowels or consonants | Function to check if a character is a vowel ; Function to swap two consecutively repeated vowels or consonants ; Traverse through the length of the string ; Check if the two consecutive characters are vowels or consonants ; swap the two characters ; Driver code"
Javascript;"function largestPalinSub ( s ) { let res = "" "" ; let mx = s [ 0 ] ; for ( let i = 1 ; i < s . length ; i ++ ) mx = String . fromCharCode ( Math . max ( mx . charCodeAt ( ) , s [ i ] . charCodeAt ( ) ) ) ; for ( let i = 0 ; i < s . length ; i ++ ) if ( s [ i ] == mx ) res += s [ i ] ; return res ; } let s = "" "" ; document . write ( largestPalinSub ( s ) ) ;";"Find the lexicographically largest palindromic Subsequence of a String | Function to find the largest palindromic subsequence ; Find the largest character ; Append all occurrences of largest character to the resultant string ; Driver Code"
Javascript;"function printString ( str , n ) { let ones = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( str [ i ] == ' ' ) ones ++ ; let used = false ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' && ! used ) { used = true ; for ( let j = 0 ; j < ones ; j ++ ) document . write ( "" "" ) ; } if ( str [ i ] != ' ' ) document . write ( str [ i ] ) ; } if ( ! used ) for ( let j = 0 ; j < ones ; j ++ ) document . write ( "" "" ) ; } let str = "" "" ; let n = str . length ; printString ( str . split ( ' ' ) , n ) ;";"Generate lexicographically smallest string of 0 , 1 and 2 with adjacent swaps allowed | Function to print the required string ; count number of 1 s ; To check if the all the 1 s have been used or not ; Print all the 1 s if any 2 is encountered ; If str [ i ] = 0 or str [ i ] = 2 ; If 1 s are not printed yet ; Driver code"
Javascript;"function findPermutation ( str , k ) { var has = new Array ( 26 ) ; for ( var i = 0 ; i < 26 ; i ++ ) has [ i ] = false ; var cnt = 0 ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( ! has [ str [ i ] . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) ] ) { cnt ++ ; has [ str [ i ] . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) ] = true ; } } var ans = 1 ; for ( var i = 2 ; i <= cnt ; i ++ ) ans *= i ; for ( var i = cnt - k ; i > 1 ; i -- ) ans /= i ; return ans ; } var str = "" "" ; var k = 4 ; document . write ( findPermutation ( str , k ) ) ;";"K length words that can be formed from given characters without repetition | Function to return the required count ; To store the count of distinct characters in str ; Traverse str character by character ; If current character is appearing for the first time in str ; Increment the distinct character count ; Update the appearance of the current character ; Since P ( n , r ) = n ! / ( n - r ) ! ; Return the answer ; Driver code"
Javascript;"function product ( x ) { let prod = 1 ; while ( x > 0 ) { prod *= ( x % 10 ) ; x = parseInt ( x / 10 , 10 ) ; } return prod ; } function findNumber ( l , r ) { let b = r . toString ( ) ; let ans = r ; for ( let i = 0 ; i < b . length ; i ++ ) { if ( b [ i ] == ' ' ) continue ; let curr = b . split ( ' ' ) ; curr [ i ] = String . fromCharCode ( ( ( curr [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) - 1 ) + ' ' . charCodeAt ( ) ) ; for ( let j = i + 1 ; j < curr . length ; j ++ ) curr [ j ] = ' ' ; let num = 0 ; for ( let j = 0 ; j < curr . length ; j ++ ) num = num * 10 + ( curr [ j ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; if ( num >= l && product ( ans ) < product ( num ) ) ans = num ; } return ans ; } let l = 1 , r = 10 ; document . write ( findNumber ( l , r ) + "" "" ) ; l = 51 ; r = 62 ; document . write ( findNumber ( l , r ) ) ;";"Find the number in a range having maximum product of the digits | Returns the product of digits of number x ; This function returns the number having maximum product of the digits ; Converting both integers to strings string a = l . ToString ( ) ; ; Let the current answer be r ; Stores the current number having current digit one less than current digit in b ; Replace all following digits with 9 to maximise the product ; Convert string to number ; Check if it lies in range and its product is greater than max product ; Driver Code"
Javascript;"function printExpansion ( str ) { var size = 0 ; for ( var i = str . length - 1 ; i >= 0 ; i -- ) { var subStr = str . substring ( i , i + ++ size ) ; document . write ( subStr ) ; } } var str = "" "" ; printExpansion ( str ) ;";"Concatenate suffixes of a String | Function to print the expansion of the string ; Take sub - string from i to n - 1 ; Print the sub - string ; Driver code"
Javascript;"function constructBinString ( a , b , x ) { let d , i ; d = parseInt ( x / 2 , 10 ) ; if ( x % 2 == 0 && parseInt ( x / 2 , 10 ) != a ) { d -- ; document . write ( "" "" ) ; a -- ; } for ( i = 0 ; i < d ; i ++ ) document . write ( "" "" ) ; a = a - d ; b = b - d ; for ( i = 0 ; i < b ; i ++ ) { document . write ( "" "" ) ; } for ( i = 0 ; i < a ; i ++ ) { document . write ( "" "" ) ; } } let a = 4 , b = 3 , x = 2 ; constructBinString ( a , b , x ) ;";"Construct a binary string following the given constraints | Function to print a binary string which has ' a ' number of 0 ' s , ▁ ' b ' ▁ number ▁ of ▁ 1' s and there are at least ' x ' indices such that s [ i ] != s [ i + 1 ] ; Divide index value by 2 and store it into d ; If index value x is even and x / 2 is not equal to a ; Loop for d for each d print 10 ; subtract d from a and b ; Loop for b to print remaining 1 's ; Loop for a to print remaining 0 's ; Driver code"
Javascript;"function matchPattern ( s ) { let count = 0 ; let n = s . length ; let i = 0 ; while ( i < n ) { while ( i < n && s [ i ] == ' ' ) { count ++ ; i ++ ; } while ( i < n && s [ i ] == ' ' ) { count -- ; i ++ ; } if ( count != 0 ) return false ; } return true ; } let s = "" "" ; if ( matchPattern ( s ) == true ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check If every group of a ' s ▁ is ▁ followed ▁ by ▁ a ▁ group ▁ of ▁ b ' s of same length | Function to match whether there are always n consecutive b ' s ▁ ▁ followed ▁ by ▁ n ▁ consecutive ▁ a ' s throughout the string ; Traverse through the string ; Count a 's in current segment ; Count b 's in current segment ; If both counts are not same . ; Driver code"
Javascript;"function maximum_one ( s , n ) { var cnt_one = 0 ; var max_cnt = 0 , temp = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' ) { cnt_one ++ ; temp ++ ; } else { max_cnt = Math . max ( temp , max_cnt ) ; temp = 0 ; } } max_cnt = Math . max ( max_cnt , temp ) ; var left = Array ( n ) ; var right = Array ( n ) ; if ( s [ 0 ] == ' ' ) left [ 0 ] = 1 ; else left [ 0 ] = 0 ; if ( s [ n - 1 ] == ' ' ) right [ n - 1 ] = 1 ; else right [ n - 1 ] = 0 ; for ( var i = 1 ; i < n ; i ++ ) { if ( s [ i ] == ' ' ) left [ i ] = left [ i - 1 ] + 1 ; else left [ i ] = 0 ; } for ( var i = n - 2 ; i >= 0 ; i -- ) { if ( s [ i ] == ' ' ) right [ i ] = right [ i + 1 ] + 1 ; else right [ i ] = 0 ; } for ( var i = 1 ; i < n - 1 ; i ++ ) { if ( s [ i ] == ' ' ) { var sum = left [ i - 1 ] + right [ i + 1 ] ; if ( sum < cnt_one ) max_cnt = Math . max ( max_cnt , sum + 1 ) ; else max_cnt = Math . max ( max_cnt , sum ) ; } } return max_cnt ; } var s = "" "" ; document . write ( maximum_one ( s , s . length ) ) ;";"Length of longest consecutive ones by at most one swap in a Binary String | Function to calculate the length of the longest consecutive 1 's ; To count all 1 's in the string ; To store cumulative 1 's ; Counting cumulative 1 's from left ; If 0 then start new cumulative one from that i ; perform step 3 of the approach ; step 3 ; string"
Javascript;"function MaxFreq ( str ) { let n = str . length ; let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { let s = "" "" ; for ( let j = i ; j < n ; j ++ ) { s += str [ j ] ; if ( mp . has ( s ) ) { mp . set ( s , mp . get ( s ) + 1 ) ; } else { mp . set ( s , 1 ) ; } } } let maxi = 0 ; let s = "" "" ; for ( let [ key , value ] of mp . entries ( ) ) { if ( value > maxi ) { maxi = value ; s = key ; } else if ( value == maxi ) { let ss = key ; if ( ss . length > s . length ) s = ss ; } } return s ; } let str = "" "" ; document . write ( MaxFreq ( str ) ) ;";"Maximum length substring with highest frequency in a string | Function to return maximum occurred subString of a String ; Size of the String ; To store maximum frequency ; To store String which has maximum frequency ; Return subString which has maximum frequency ; Driver code ; Function call"
Javascript;"function maxFreq ( s , a , b ) { var fre = new Array ( 10 ) . fill ( 0 ) ; var n = s . length ; if ( a > b ) { var temp = a ; a = b ; b = temp ; } for ( var i = 0 ; i < n ; i ++ ) fre [ s [ i ] . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) ] ++ ; if ( fre [ a ] === 0 && fre [ b ] === 0 ) return - 1 ; else if ( fre [ a ] >= fre [ b ] ) return a ; else return b ; } var a = 4 , b = 7 ; var s = "" "" ; document . write ( maxFreq ( s , a , b ) ) ;";"Lexicographically smallest substring with maximum occurrences containing a ' s ▁ and ▁ b ' s only | Function to Find the lexicographically smallest substring in a given string with maximum frequency and contains a ' s ▁ and ▁ b ' s only . ; To store frequency of digits ; size of string ; Take lexicographically larger digit in b ; get frequency of each character ; If no such string exits ; Maximum frequency ; Driver program"
Javascript;"function convert ( n , a , b ) { let l = new Array ( n ) ; let i ; for ( i = 0 ; i < n ; i ++ ) l [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] != b [ i ] ) l [ i ] = 1 ; } let cc = 0 ; let vl = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( l [ i ] == 0 ) { if ( vl != 0 ) cc += 1 ; vl = 0 ; } else vl += 1 ; } if ( vl != 0 ) cc += 1 ; document . write ( cc + "" "" ) ; } let a = "" "" ; let b = "" "" ; let n = a . length ; convert ( n , a , b ) ;";"Minimum steps to convert one binary string to other only using negation | Function to find the minimum steps to convert string a to string b ; array to mark the positions needed to be negated ; If two character are not same then they need to be negated ; To count the blocks of 1 ; To count the number of 1 ' s ▁ in ▁ ▁ each ▁ block ▁ of ▁ 1' s ; For the last block of 1 's ; Driver code"
Javascript;"function StringMatch ( s ) { var lo = 0 , hi = s . length , len = s . length ; var ans = [ ] ; for ( var x = 0 ; x < len ; x ++ ) { if ( s [ x ] == ' ' ) { ans . push ( lo ) ; lo += 1 ; } else { ans . push ( hi ) ; hi -= 1 ; } } ans . push ( lo ) ; document . write ( "" "" ) ; for ( var i = 0 ; i < ans . length ; i ++ ) { document . write ( ans [ i ] ) ; if ( i != ans . length - 1 ) document . write ( "" "" ) ; } document . write ( "" "" ) ; } var S = "" "" ; StringMatch ( S ) ;";"Generate a sequence with the given operations | function to find minimum required permutation ; Driver code"
Javascript;"function countWays ( s1 , s2 , n ) { var a , b , c , d ; a = b = c = d = 0 ; var result = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( s2 . charAt ( i ) == ' ' ) { if ( s1 . charAt ( i ) == ' ' ) { c ++ ; } else { d ++ ; } } else { if ( s1 . charAt ( i ) == ' ' ) { a ++ ; } else { b ++ ; } } } result = a * d + b * c + c * d ; return result ; } var n = 5 ; var s1 = "" "" ; var s2 = "" "" ; document . write ( countWays ( s1 , s2 , n ) ) ;";"Number of ways to swap two bit of s1 so that bitwise OR of s1 and s2 changes | Function to find number of ways ; initialise result that store No . of swaps required ; Traverse both strings and check the bits as explained ; calculate result ; Driver code"
Javascript;"function returnWinner ( s , l ) { let freq = new Array ( 26 ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < l ; i ++ ) { freq [ s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ++ ; } let cnt = 0 ; for ( let i = 0 ; i < 26 ; i ++ ) { if ( freq [ i ] % 2 != 0 ) cnt ++ ; } if ( ( cnt == 0 ) || ( cnt & 1 ) == 1 ) return 1 ; else return 2 ; } let s = "" "" ; let l = s . length ; let winner = returnWinner ( s , l ) ; document . write ( "" "" + winner ) ;";"Find the player who rearranges the characters to get a palindrome string first | Function that returns the winner of the game ; Initialize the freq array to 0 ; Iterate and count the frequencies of each character in the string ; Count the odd occurring character ; If odd occurrence ; Check condition for Player - 1 winning the game ; Driver code ; Function call that returns the winner"
Javascript;"function maxProductSum ( str , m ) { let n = str . length ; let maxProd = Number . MIN_VALUE , maxSum = Number . MIN_VALUE ; for ( let i = 0 ; i <= n - m ; i ++ ) { let product = 1 , sum = 0 ; for ( let j = i ; j < m + i ; j ++ ) { product = product * ( str [ j ] - ' ' ) ; sum = sum + ( str [ j ] - ' ' ) ; } maxProd = Math . max ( maxProd , product ) ; maxSum = Math . max ( maxSum , sum ) ; } document . write ( "" "" + maxProd + "" "" ) ; document . write ( "" "" + maxSum ) ; } let str = "" "" ; let m = 3 ; maxProductSum ( str , m ) ;";"Maximum sum and product of the M consecutive digits in a number | Function to find the maximum product ; Driver code"
Javascript;"function isVowel ( ch ) { if ( ch !== "" "" && ch !== "" "" && ch !== "" "" && ch !== "" "" && ch !== "" "" ) return false ; return true ; } function replacingConsonants ( s ) { for ( var i = 0 ; i < s . length ; i ++ ) { if ( isVowel ( s [ i ] ) ) continue ; else { if ( s [ i ] > "" "" && s [ i ] < "" "" ) { if ( Math . abs ( s [ i ] . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) ) > Math . abs ( s [ i ] . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) ) ) s = s . substring ( 0 , i ) + "" "" + s . substring ( i + 1 ) ; else s = s . substring ( 0 , i ) + "" "" + s . substring ( i + 1 ) ; } else if ( s [ i ] > "" "" && s [ i ] < "" "" ) { if ( Math . abs ( s [ i ] . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) ) > Math . abs ( s [ i ] . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) ) ) s = s . substring ( 0 , i ) + "" "" + s . substring ( i + 1 ) ; else s = s . substring ( 0 , i ) + "" "" + s . substring ( i + 1 ) ; } else if ( s [ i ] > "" "" && s [ i ] < "" "" ) { if ( Math . abs ( s [ i ] . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) ) > Math . abs ( s [ i ] . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) ) ) s = s . substring ( 0 , i ) + "" "" + s . substring ( i + 1 ) ; else s = s . substring ( 0 , i ) + "" "" + s . substring ( i + 1 ) ; } else if ( s [ i ] > "" "" && s [ i ] < "" "" ) { if ( Math . abs ( s [ i ] . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) ) > Math . abs ( s [ i ] . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) ) ) s = s . substring ( 0 , i ) + "" "" + s . substring ( i + 1 ) ; else s = s . substring ( 0 , i ) + "" "" + s . substring ( i + 1 ) ; } else if ( s [ i ] > "" "" ) s = s . substring ( 0 , i ) + "" "" + s . substring ( i + 1 ) ; } } return s ; } var s = "" "" ; document . write ( replacingConsonants ( s ) ) ;";"Replace all consonants with nearest vowels in a string | Function to check if a character is vowel or not ; Function to replace consonant with nearest vowels ; if , string element is vowel , jump to next element ; check if consonant lies between two vowels , if it lies , than replace it with nearest vowel ; here the bsolute difference of ascii value is considered ; when s [ i ] is equal to either ' v ' , ' w ' , ' x ' , ' y ' , ' z ' ; Driver code"
Javascript;"function maxLength ( s , n ) { var right = 0 , left = 0 ; var coun = 0 , max_length = Number . MIN_VALUE ; s = s + ' ' ; for ( var i = 0 ; i <= n ; i ++ ) { if ( s [ i ] == ' ' ) coun ++ ; else { if ( coun > max_length ) { right = 0 ; left = 0 ; if ( s [ i ] == ' ' ) right = 1 ; if ( ( ( i - coun ) > 0 ) && ( s [ i - coun - 1 ] == ' ' ) ) left = 1 ; coun = Math . ceil ( coun / ( right + left ) ) ; max_length = Math . max ( max_length , coun ) ; } coun = 0 ; } } return max_length ; } var s = "" "" ; var n = s . length ; document . write ( maxLength ( s , n ) ) ;";"Find time taken for signal to reach all positions in a string | Returns time needed for signal to traverse through complete string . ; for the calculation of last index ; for strings like oxoooo , xoxxoooo . . ; if coun is greater than max_length ; if ' x ' is present at the right side of max_length ; if ' x ' is present at left side of max_length ; We use ceiling function to handle odd number ' o ' s ; Driver code"
Javascript;"function printLargestString ( s , l , r ) { var freq = Array ( 26 ) . fill ( 0 ) ; l -- ; r -- ; for ( i = Math . min ( l , r ) ; i <= Math . max ( l , r ) ; i ++ ) { freq [ s . charCodeAt ( i ) - ' ' . charCodeAt ( 0 ) ] ++ ; } var ans = "" "" ; for ( var i = 25 ; i >= 0 ; i -- ) { while ( freq [ i ] > 0 ) { ans += String . fromCharCode ( ' ' . charCodeAt ( 0 ) + i ) ; freq [ i ] -- ; } } return ans ; } var s = "" "" ; var l = 3 , r = 5 ; document . write ( printLargestString ( s , l , r ) ) ;";"Lexicographically largest string formed from the characters in range L and R | Function to return the lexicographically largest String ; hash array ; make 0 - based indexing ; iterate and count frequencies of character ; ans String ; iterate in frequency array ; add til all characters are added ; Driver Code"
Javascript;"function arrange ( s ) { var cc = 0 ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ' ' ) cc ++ ; } var a = Array ( s . length + 1 ) . fill ( 0 ) ; var qq = [ [ 2 , 3 ] , [ 5 , 5 ] ] ; var n = qq . length ; for ( var i = 0 ; i < n ; i ++ ) { var l = qq [ i ] [ 0 ] , r = qq [ i ] [ 1 ] ; l -- , r -- ; a [ l ] ++ ; a [ r + 1 ] -- ; } var len_a = a . length ; for ( var i = 1 ; i < len_a ; i ++ ) { a [ i ] += a [ i - 1 ] ; } var zz = Array ( s . length ) . fill ( 0 ) ; for ( var i = 0 ; i < len_a - 1 ; i ++ ) { if ( a [ i ] > 0 ) { if ( cc > 0 ) { zz [ i ] = 1 ; cc -- ; } else break ; } if ( cc == 0 ) break ; } if ( cc > 0 ) { for ( var i = 0 ; i < s . length ; i ++ ) { if ( zz [ i ] == 0 ) { zz [ i ] = 1 ; cc -- ; } if ( cc == 0 ) break ; } } for ( var i = 0 ; i < s . length ; i ++ ) document . write ( zz [ i ] ) ; document . write ( "" "" ) ; } var str = "" "" ; arrange ( str ) ;";"Arrange a binary string to get maximum value within a range of indices | Javascript implementation of the approach ; Storing the count of 1 's in the string ; Query of l and r ; Applying range update technique . ; Taking prefix sum to get the range update values ; Final array which will store the arranged string ; if after maximizing the ranges any 1 is left then we maximize the string lexicographically . ; Driver Code"
Javascript;"function areVowelsInOrder ( s ) { var n = s . length ; var c = String . fromCharCode ( 64 ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' s [ i ] == ' ' ) { if ( s [ i ] < c ) return false ; else { c = s [ i ] ; } } } return true ; } var s = "" "" ; if ( areVowelsInOrder ( s ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check whether the vowels in a string are in alphabetical order or not | Function that checks whether the vowel characters in a string are in alphabetical order or not ; ASCII Value 64 is less than all the alphabets so using it as a default value ; check if the vowels in the string are sorted or not ; if the vowel is smaller than the previous vowel ; store the vowel ; Driver code ; check whether the vowel characters in a string are in alphabetical order or not"
Javascript;"function printHyphen ( string ) { var lis = string . split ( "" "" ) string = lis . join ( "" "" ) ; return string ; } var string = "" "" ; document . write ( printHyphen ( string ) ) ;";"Program to replace every space in a string with hyphen | JavaScript program for the above approach ; Split by space and converting String to list and ; joining the list and storing in string ; returning the string ; Driver code"
Javascript;"function newString ( s ) { let l = s . length ; let freq = new Array ( 26 ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < l ; i ++ ) { freq [ s [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] += 1 ; } let ans = "" "" ; for ( let i = 0 ; i < 26 ; i ++ ) { for ( let j = 0 ; j < freq [ i ] ; j ++ ) { ans += String . fromCharCode ( 97 + i ) ; } } return ans ; } let s = "" "" ; document . write ( newString ( s ) ) ;";"Rearrange the string to maximize the number of palindromic substrings | Function to return the newString ; length of string ; hashing array ; iterate and count ; resulting string ; form the resulting string ; number of times character appears ; append to resulting string ; Driver code"
Javascript;"function Remainder ( str , R ) { var len = str . length ; var Num , Rem = 0 ; for ( var i = 0 ; i < len ; i ++ ) { Num = Rem * 10 + ( str [ i ] - ' ' ) ; Rem = Num % R ; } return Rem ; } var str = "" "" ; var R = 13 ; document . write ( Remainder ( str , R ) ) ;";"Program to find remainder when large number is divided by r | Function to Return Remainder ; len is variable to store the length of Number string . ; loop that find Remainder ; Return the remainder ; Driver code Get the large number as string ; Get the divisor R ; Find and print the remainder"
Javascript;"function countWays ( a , n ) { let i , j ; let suff = new Array ( n ) ; if ( a [ n - 1 ] == 2 ) suff [ n - 1 ] = 1 ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( a [ i ] == 2 ) suff [ i ] = suff [ i + 1 ] + 1 ; else suff [ i ] = suff [ i + 1 ] ; } let ss = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( a [ i ] == 1 ) ss += suff [ i ] ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ i ] == 1 && a [ j ] == 1 && suff [ j ] >= 2 ) { ss += ( suff [ j ] ) * ( suff [ j ] - 1 ) / 2 ; } } } for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ i ] == 1 && a [ j ] == 1 && ( suff [ i ] - suff [ j ] ) >= 1 && suff [ j ] >= 1 ) { ss += ( suff [ i ] - suff [ j ] ) * suff [ j ] ; } } } document . write ( ss ) ; } let a = [ 1 , 2 , 1 , 1 , 2 , 2 ] ; let n = 6 ; countWays ( a , n ) ;";"Number of balanced bracket subsequence of length 2 and 4 | Javascript implementation of above approach ; Taking the frequency suffix sum of the number of 2 's present after every index ; Storing the count of subsequence ; Subsequence of length 2 ; Subsequence of length 4 of type 1 1 2 2 ; Subsequence of length 4 of type 1 2 1 2 ; Driver Code"
Javascript;"function count_carry ( a , b ) { let carry = 0 ; let count = 0 ; let len_a = a . length , len_b = b . length ; while ( len_a != 0 len_b != 0 ) { let x = 0 , y = 0 ; if ( len_a > 0 ) { x = a [ len_a - 1 ] - ' ' ; len_a -- ; } if ( len_b > 0 ) { y = b [ len_b - 1 ] - ' ' ; len_b -- ; } let sum = x + y + carry ; if ( sum >= 10 ) { carry = 1 ; count ++ ; } else carry = 0 ; } return count ; } let a = "" "" , b = "" "" ; let count = count_carry ( a , b ) ; if ( count == 0 ) document . write ( "" "" + "" "" ) ; else if ( count == 1 ) document . write ( "" "" + "" "" ) ; else document . write ( count ) ;";"Count the number of carry operations required to add two numbers | Function to count the number of carry operations ; Initialize the value of carry to 0 ; Counts the number of carry operations ; Initialize len_a and len_b with the sizes of strings ; Assigning the ascii value of the character ; Add both numbers / digits ; If sum > 0 , increment count and set carry to 1 ; Else , set carry to 0 ; Driver code"
Javascript;"function isInGivenBase ( str , bas ) { if ( bas > 16 ) return false ; else if ( bas <= 10 ) { for ( let i = 0 ; i < str . length ; i ++ ) if ( ! ( str [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str [ i ] . charCodeAt ( ) < ( ' ' . charCodeAt ( ) + bas ) ) ) return false ; } else { for ( let i = 0 ; i < str . length ; i ++ ) if ( ! ( ( str [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str [ i ] . charCodeAt ( ) < ( ' ' . charCodeAt ( ) + bas ) ) || ( str [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str [ i ] . charCodeAt ( ) < ( ' ' . charCodeAt ( ) + bas - 10 ) ) ) ) return false ; } return true ; } let str = "" "" ; if ( isInGivenBase ( str , 16 ) == true ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check if a number is in given base or not | Javascript program to check if given number is in given base or not . ; Allowed base are till 16 ( Hexadecimal ) ; If bas is below or equal to 10 , then all digits should be from 0 to 9. ; If base is below or equal to 16 , then all digits should be from 0 to 9 or from ' A ' ; Driver Code"
Javascript;"function printIndex ( str , s ) { var flag = false ; for ( var i = 0 ; i < str . length - s . length + 1 ; i ++ ) { if ( str . substring ( i , s . length + i ) == s ) { document . write ( i + "" "" ) ; flag = true ; } } if ( flag === false ) { document . write ( "" "" ) ; } } var str1 = "" "" ; var str2 = "" "" ; printIndex ( str1 , str2 ) ;";"Find indices of all occurrence of one string in other | JavaScript program to find indices of all occurrences of one String in other . ; Driver code"
Javascript;"function getMaxOccurringChar ( str ) { let freq = new Array ( 26 ) ; for ( let i = 0 ; i < freq . length ; i ++ ) { freq [ i ] = 0 ; } let max = - 1 ; let result = 0 ; let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { if ( str [ i ] != ' ' ) { freq [ str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; } } for ( let i = 0 ; i < 26 ; i ++ ) { if ( max < freq [ i ] ) { max = freq [ i ] ; result = String . fromCharCode ( i + ' ' . charCodeAt ( 0 ) ) ; } } return result ; } let str = "" "" . split ( "" "" ) ; document . write ( "" "" + getMaxOccurringChar ( str ) ) ;";"Maximum occurring character in an input string | Set | function to find the maximum occurring character in an input string which is lexicographically first ; freq [ ] used as hash table ; to store maximum frequency ; to store the maximum occurring character ; length of ' str ' ; get frequency of each character of ' str ' ; for each character , where character is obtained by ( i + ' a ' ) check whether it is the maximum character so far and accodingly update ' result ' ; maximum occurring character ; Driver Code"
Javascript;"function matchClosing ( X , start , end , open , close ) { let c = 1 ; let i = start + 1 ; while ( i <= end ) { if ( X [ i ] == open ) { c ++ ; } else if ( X [ i ] == close ) { c -- ; } if ( c == 0 ) { return i ; } i ++ ; } return i ; } function matchingOpening ( X , start , end , open , close ) { let c = - 1 ; let i = end - 1 ; while ( i >= start ) { if ( X [ i ] == open ) { c ++ ; } else if ( X [ i ] == close ) { c -- ; } if ( c == 0 ) { return i ; } i -- ; } return - 1 ; } function isBalanced ( X , n ) { let i , j = 0 , k , x , start , end ; for ( i = 0 ; i < n ; i ++ ) { if ( X [ i ] == ' ' ) { j = matchClosing ( X , i , n - 1 , ' ' , ' ' ) ; } else if ( X [ i ] == ' ' ) { j = matchClosing ( X , i , n - 1 , ' ' , ' ' ) ; } else if ( X [ i ] == ' ' ) { j = matchClosing ( X , i , n - 1 , ' ' , ' ' ) ; } else { if ( X [ i ] == ' ' ) { j = matchingOpening ( X , 0 , i , ' ' , ' ' ) ; } else if ( X [ i ] == ' ' ) { j = matchingOpening ( X , 0 , i , ' ' , ' ' ) ; } else if ( X [ i ] == ' ' ) { j = matchingOpening ( X , 0 , i , ' ' , ' ' ) ; } if ( j < 0 j >= i ) { return false ; } continue ; } if ( j >= n j < 0 ) { return false ; } start = i ; end = j ; for ( k = start + 1 ; k < end ; k ++ ) { if ( X [ k ] == ' ' ) { x = matchClosing ( X , k , end , ' ' , ' ' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ' ' ) { x = matchingOpening ( X , start , k , ' ' , ' ' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } if ( X [ k ] == ' ' ) { x = matchClosing ( X , k , end , ' ' , ' ' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ' ' ) { x = matchingOpening ( X , start , k , ' ' , ' ' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } if ( X [ k ] == ' ' ) { x = matchClosing ( X , k , end , ' ' , ' ' ) ; if ( ! ( k < x && x < end ) ) { return false ; } } else if ( X [ k ] == ' ' ) { x = matchingOpening ( X , start , k , ' ' , ' ' ) ; if ( ! ( start < x && x < k ) ) { return false ; } } } } return true ; } let X = "" "" . split ( "" "" ) ; let n = 6 ; if ( isBalanced ( X , n ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ; let Y = "" "" . split ( "" "" ) ; n = 7 ; if ( isBalanced ( Y , n ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check for balanced parentheses in an expression | O ( 1 ) space | Function1 to match closing bracket ; Function1 to match opening bracket ; Function to check balanced parentheses ; helper variables ; Handling case of opening parentheses ; Handling case of closing parentheses ; If corresponding matching opening parentheses doesn 't  lie in given interval return 0 ; else continue ; If corresponding closing parentheses doesn 't lie in given interval  return 0 ; if found , now check for each opening and closing parentheses in this interval ; Driver Code"
Javascript;"function possibleToSort ( arr , n , str ) { let max_element = - 1 ; for ( let i = 0 ; i < str . length ; i ++ ) { max_element = Math . max ( max_element , arr [ i ] ) ; if ( str [ i ] == ' ' ) { if ( max_element > i + 1 ) return "" "" ; } } return "" "" ; } let arr = [ 1 , 2 , 5 , 3 , 4 , 6 ] ; let n = arr . Length ; let str = "" "" ; document . write ( possibleToSort ( arr , n , str ) ) ;";"Sorting array with conditional swapping | Function to check if it is possible to sort the array ; Calculating max_element at each iteration . ; if we can not swap the i - th element . ; if it is impossible to swap the max_element then we can not sort the array . ; Otherwise , we can sort the array . ; Driver Code"
Javascript;"function findSubstring ( str , power ) { let map = new Map ( ) ; let curr_power = 0 ; let len = str . length ; for ( let i = 0 ; i < len ; i ++ ) { curr_power = curr_power + ( str [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) + 1 ) ; if ( curr_power == power ) { document . write ( "" "" + "" "" + i + "" "" + power + "" "" ) ; return ; } if ( map . has ( curr_power - power ) ) { document . write ( "" "" + ( map . get ( curr_power - power ) + 1 ) + "" "" + i + "" "" + power + "" "" ) ; return ; } map . set ( curr_power , i ) ; } document . write ( "" "" ) ; } let str = "" "" ; let power = 36 ; findSubstring ( str , power ) ;";"Find sub | Function to print indexes of substring with power as given power . ; Create an empty map ; Maintains sum of powers of characters so far . ; Add current character power to curr_power . ; If curr_power is equal to target power we found a substring starting from index 0 and ending at index i . ; If curr_power - power already exists in map then we have found a subarray with target power . ; If we reach here , then no substring exists . ; Driver Code"
Javascript;"function isPrimeString ( str ) { let len = str . length , n = 0 ; for ( let i = 0 ; i < len ; i ++ ) { n += str [ i ] . charCodeAt ( ) ; } if ( n <= 1 ) { return false ; } if ( n <= 3 ) { return true ; } if ( n % 2 == 0 n % 3 == 0 ) { return false ; } for ( let i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } let str = "" "" ; if ( isPrimeString ( str ) ) { document . write ( "" "" ) ; } else { document . write ( "" "" ) ; }";"Prime String | Function that checks if sum is prime or not ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Driver code"
Javascript;"function countWays ( s ) { let count = new Array ( 26 ) ; count . fill ( 0 ) ; for ( let i = 0 ; i < s . length ; i ++ ) count [ s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ++ ; count [ s [ 0 ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] = 1 ; let ans = 1 ; for ( let i = 0 ; i < 26 ; ++ i ) if ( count [ i ] != 0 ) ans *= count [ i ] ; return ans ; } let s = "" "" ; document . write ( countWays ( s ) ) ;";"Ways to split string such that each partition starts with distinct character | Returns the number of we can split the string ; Finding the frequency of each character . ; making frequency of first character of string equal to 1. ; Finding the product of frequency of occurrence of each character . ; Driver Code"
Javascript;"function lexoString ( s , k ) { var n = s . length ; var v = [ ] ; var mp = { } ; for ( var i = 0 ; i < s . length ; i ++ ) { if ( ! mp . hasOwnProperty ( s [ i ] ) ) { mp [ s [ i ] ] = 1 ; v . push ( s [ i ] ) ; } } v . sort ( ( a , b ) => a - b ) ; if ( k > n ) { document . write ( s . join ( "" "" ) ) ; for ( var i = n ; i < k ; i ++ ) { document . write ( v [ 0 ] ) ; } } for ( var i = k - 1 ; i >= 0 ; i -- ) { if ( s [ i ] !== v [ v . length - 1 ] ) { for ( var j = 0 ; j < i ; j ++ ) { document . write ( s [ j ] ) ; } for ( var j = 0 ; j < v . length ; j ++ ) { if ( v [ j ] > s [ i ] ) { document . write ( v [ j ] ) ; break ; } } for ( var j = i + 1 ; j < k ; j ++ ) { document . write ( v [ 0 ] ) ; } return ; } } document . write ( "" "" + "" "" + k + "" "" ) ; } var s = "" "" ; var k = 3 ; lexoString ( s . split ( "" "" ) , k ) ;";"Lexicographically next greater string using same character set | function to print output ; to store unique characters of the string ; to check uniqueness ; if mp [ s [ i ] ] = 0 then it is first time ; sort the unique characters ; simply add n - k smallest characters ; return ; end the program ; searching the first character left of index k and not equal to greatest character of the string ; finding the just next greater character than s [ i ] ; suffix with smallest character ; if we reach here then all indices to the left of k had the greatest character ; Driver code ; Function call"
Javascript;"let MAX = 256 ; function fact ( n ) { let res = 1 ; for ( let i = 2 ; i <= n ; i ++ ) res = res * i ; return res ; } function countPalinPermutations ( str ) { let n = str . length ; let freq = new Array ( MAX ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) freq [ str [ i ] . charCodeAt ( ) ] ++ ; let res = fact ( n / 2 ) ; let oddFreq = false ; for ( let i = 0 ; i < MAX ; i ++ ) { let half = freq [ i ] / 2 ; if ( freq [ i ] % 2 != 0 ) { if ( oddFreq == true ) return 0 ; oddFreq = true ; } res = res / fact ( half ) ; } return res ; } let str = "" "" ; document . write ( countPalinPermutations ( str ) ) ;";"Number of palindromic permutations | Set 1 | Javascript program to find number of palindromic permutations of a given string ; Returns factorial of n ; Returns count of palindromic permutations of str . ; Count frequencies of all characters ; Since half of the characters decide count of palindromic permutations , we take ( n / 2 ) ! ; To make sure that there is at most one odd occurring char ; Traverse through all counts ; To make sure that the string can permute to form a palindrome ; If there are more than one odd occurring chars ; Divide all permutations with repeated characters ; Driver code"
Javascript;"function isVowel ( ch ) { return ( ch === "" "" ch === "" "" ch === "" "" ch === "" "" ch === "" "" ) ; } function isCons ( ch ) { return ( ch !== "" "" && ch !== "" "" && ch !== "" "" && ch !== "" "" && ch !== "" "" ) ; } function countSpecial ( str ) { var len = str . length ; if ( len == 0 ) return 0 ; var co = new Array ( len + 1 ) . fill ( 0 ) ; var vo = new Array ( len + 1 ) . fill ( 0 ) ; if ( isCons ( str [ len - 1 ] ) === true ) co [ len - 1 ] = 1 ; else vo [ len - 1 ] = 1 ; for ( var i = len - 2 ; i >= 0 ; i -- ) { if ( isCons ( str [ i ] ) === true ) { co [ i ] = co [ i + 1 ] + 1 ; vo [ i ] = vo [ i + 1 ] ; } else { co [ i ] = co [ i + 1 ] ; vo [ i ] = vo [ i + 1 ] + 1 ; } } var ans = 0 ; for ( var i = 0 ; i < len ; i ++ ) { if ( isVowel ( str [ i ] ) ) ans = ans + co [ i + 1 ] ; else ans = ans + vo [ i + 1 ] ; } return parseInt ( ans ) ; } var str = "" "" ; document . write ( countSpecial ( str . split ( "" "" ) ) ) ;";"Substrings starting with vowel and ending with consonants and vice versa | Returns true if ch is vowel ; Function to check consonant ; in case of empty string , we can 't fullfill the  required condition, hence we return ans as 0. ; co [ i ] is going to store counts of consonants from str [ len - 1 ] to str [ i ] . vo [ i ] is going to store counts of vowels from str [ len - 1 ] to str [ i ] . ; Counting consonants and vowels from end of string . ; Now we traverse string from beginning ; If vowel , then count of substrings starting with str [ i ] is equal to count of consonants after it . ; If consonant , then count of substrings starting with str [ i ] is equal to count of vowels after it . ; Driver code"
Javascript;"function checkPalindrome ( str ) { let n = str . length ; let count = 0 ; for ( let i = 0 ; i < parseInt ( n / 2 , 10 ) ; ++ i ) if ( str [ i ] != str [ n - i - 1 ] ) ++ count ; return ( count <= 1 ) ; } let str = "" "" ; if ( checkPalindrome ( str ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Convert the string into palindrome string by changing only one character | Function to check if it is possible to convert the string into palindrome ; Counting number of characters that should be changed . ; If count of changes is less than or equal to 1 ; Driver Function"
Javascript;"function evenDecimalValue ( str , n ) { let result = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) { result += ( n - i ) ; } } return result ; } let str = "" "" ; let n = 5 ; document . write ( evenDecimalValue ( str , n ) ) ;";"Counting even decimal value substrings in a binary string | function return count of even decimal value substring ; store the count of even decimal value substring ; substring started with '0' ; increment result by ( n - i ) because all substring which are generate by this character produce even decimal value . ; Driver code"
Javascript;"function countSubstr ( s ) { let n = s . length ; let auxArr = new Array ( n ) ; if ( s [ 0 ] == ' ' ) auxArr [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( s [ i ] == ' ' ) auxArr [ i ] = auxArr [ i - 1 ] + 1 ; else auxArr [ i ] = auxArr [ i - 1 ] ; } let count = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) if ( s [ i ] == ' ' ) count += auxArr [ i ] ; return count ; } let s = "" "" ; document . write ( countSubstr ( s ) ) ;";"Number of substrings with odd decimal value in a binary string | Function to count number of substrings with odd decimal representation ; auxiliary array to store count of 1 's before ith index ; Store count of 1 's before  i-th index ; Variable to store answer ; Traverse the string reversely to calculate number of odd substrings before i - th index ; Driver code"
Javascript;"let MAX = 256 ; function canMakeStr2 ( str1 , str2 ) { let count = new Array ( MAX ) ; count . fill ( 0 ) ; for ( let i = 0 ; i < str1 . length ; i ++ ) count [ str1 [ i ] ] ++ ; for ( let i = 0 ; i < str2 . length ; i ++ ) { if ( count [ str2 [ i ] ] == 0 ) return false ; count [ str2 [ i ] ] -- ; } return true ; } let str1 = "" "" ; let str2 = "" "" ; if ( canMakeStr2 ( str1 , str2 ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check whether second string can be formed from characters of first string | Javascript program to check whether second string can be formed from first string ; Create a count array and count frequencies characters in str1 . ; Now traverse through str2 to check if every character has enough counts ; Driver Code"
Javascript;"function finalPosition ( move ) { let l = move . length ; let countUp = 0 , countDown = 0 ; let countLeft = 0 , countRight = 0 ; for ( let i = 0 ; i < l ; i ++ ) { if ( move [ i ] == ' ' ) countUp ++ ; else if ( move [ i ] == ' ' ) countDown ++ ; else if ( move [ i ] == ' ' ) countLeft ++ ; else if ( move [ i ] == ' ' ) countRight ++ ; } document . write ( "" "" + ( countRight - countLeft ) + "" "" + ( countUp - countDown ) + "" "" ) ; } let move = "" "" ; finalPosition ( move ) ;";"Position of robot after given movements | function to find final position of robot after the complete movement ; traverse the instruction string ' move ' ; for each movement increment its respective counter ; required final position of robot ; Driver code"
Javascript;"function maxbalancedprefix ( str , n ) { var sum = 0 ; var maxi = 0 ; for ( var i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ' ' ) sum += 1 ; else sum -= 1 ; if ( sum < 0 ) break ; if ( sum == 0 ) maxi = i + 1 ; } return maxi ; } var str = "" "" ; var n = str . length ; document . write ( maxbalancedprefix ( str , n ) ) ;";"Length of longest balanced parentheses prefix | Return the length of longest balanced parentheses prefix . ; Traversing the string . ; If open bracket add 1 to sum . ; If closed bracket subtract 1 from sum ; if first bracket is closing bracket then this condition would help ; If sum is 0 , store the index value . ; Driven Program"
Javascript;"function cost ( str ) { let len = str . length ; let res = 0 ; for ( let i = 0 , j = len - 1 ; i < j ; i ++ , j -- ) { if ( str [ i ] != str [ j ] ) { res += Math . min ( str [ i ] . charCodeAt ( ) , str [ j ] . charCodeAt ( ) ) - ' ' . charCodeAt ( ) + 1 ; } } return res ; } let str = "" "" ; document . write ( cost ( str ) ) ;";"Minimum cost to convert string into palindrome | Function to return cost ; length of string ; Iterate from both sides of string . If not equal , a cost will be there ; Driver code"
Javascript;"function isVowel ( c ) { return ( c == ' ' c == ' ' c == ' ' c == ' ' c == ' ' c == ' ' c == ' ' c == ' ' c == ' ' c == ' ' ) ; } function pigLatin ( s ) { let len = s . length ; let index = - 1 ; for ( let i = 0 ; i < len ; i ++ ) { if ( isVowel ( s [ i ] ) ) { index = i ; break ; } } if ( index == - 1 ) return "" "" ; return s . substring ( index ) + s . substring ( 0 , index ) + "" "" ; } str = pigLatin ( "" "" ) ; if ( str == "" "" ) document . write ( "" "" + "" "" + "" "" ) ; else document . write ( str ) ;";"Encoding a word into Pig Latin | js program to encode a word to a Pig Latin . ; the index of the first vowel is stored . ; Pig Latin is possible only if vowels is present ; Take all characters after index ( including index ) . Append all characters which are before index . Finally append "" ay "" ; Driver code"
Javascript;"let MAX_CHAR = 256 ; function isPresent ( s , q ) { let freq = new Array ( MAX_CHAR ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < s . length ; i ++ ) freq [ s [ i ] ] ++ ; for ( let i = 0 ; i < q . length ; i ++ ) { freq [ q [ i ] ] -- ; if ( freq [ q [ i ] ] < 0 ) return false ; } return true ; } let s = "" "" ; let q = "" "" ; if ( isPresent ( s , q ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Possibility of a word from a given set of characters | Javascript program to check if a query string is present is given set . ; Count occurrences of all characters in s . ; Check if number of occurrences of every character in q is less than or equal to that in s . ; driver program"
Javascript;"function countReduce ( str ) { let n = str . length ; let res = 0 ; for ( let i = 0 ; i < parseInt ( n / 2 , 10 ) ; i ++ ) res += Math . abs ( str [ i ] . charCodeAt ( ) - str [ n - i - 1 ] . charCodeAt ( ) ) ; return res ; } let str = "" "" ; document . write ( countReduce ( str ) ) ;";"Minimum reduce operations to convert a given string into a palindrome | Returns count of minimum character reduce operations to make palindrome . ; Compare every character of first half with the corresponding character of second half and add difference to result . ; Driver code"
Javascript;"function calculate ( s ) { let ans = 6 ; for ( let i = 0 ; i < 10 ; ++ i ) { for ( let j = 0 ; j < 10 ; ++ j ) { for ( let k = 0 ; k < 10 ; ++ k ) { for ( let l = 0 ; l < 10 ; ++ l ) { for ( let m = 0 ; m < 10 ; ++ m ) { for ( let n = 0 ; n < 10 ; ++ n ) { if ( i + j + k == l + m + n ) { let c = 0 ; if ( i != s [ 0 ] - ' ' ) c ++ ; if ( j != s [ 1 ] - ' ' ) c ++ ; if ( k != s [ 2 ] - ' ' ) c ++ ; if ( l != s [ 3 ] - ' ' ) c ++ ; if ( m != s [ 4 ] - ' ' ) c ++ ; if ( n != s [ 5 ] - ' ' ) c ++ ; if ( c < ans ) ans = c ; } } } } } } } return ans ; } let s = "" "" ; document . write ( calculate ( s ) ) ;";"Minimal operations to make a number magical | Function to calculate the minimal changes ; Maximum digits that can be changed ; Nested loops to generate all 6 digit numbers ; Counter to count the number of change required ; If first digit is equal ; If 2 nd digit is equal ; If 3 rd digit is equal ; If 4 th digit is equal ; If 5 th digit is equal ; If 6 th digit is equal ; Checks if less then the previous calculate changes ; Returns the answer ; Number stored in string ; Prints the minimum operations"
Javascript;"function makeAndCheckString ( words , str ) { let n = words . length ; let first = false , second = false ; for ( let i = 0 ; i < n ; i ++ ) { if ( words [ i ] == str ) return true ; if ( str [ 0 ] == words [ i ] [ 1 ] ) first = true ; if ( str [ 1 ] == words [ i ] [ 0 ] ) second = true ; if ( first && second ) return true ; } return false ; } let str = "" "" ; let words = [ "" "" , "" "" , "" "" , "" "" ] ; if ( makeAndCheckString ( words , str ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check if a two character string can be made using given words | Function to check if str can be made using given words ; If str itself is present ; Match first character of str with second of word and vice versa ; If both characters found . ; Driver Code"
Javascript;"function getBinaryRep ( N , num_of_bits ) { let r = "" "" ; num_of_bits -- ; while ( num_of_bits >= 0 ) { if ( ( N & ( 1 << num_of_bits ) ) != 0 ) r += "" "" ; else r += "" "" ; num_of_bits -- ; } return r ; } function NBitBinary ( N ) { let r = [ ] ; let first = 1 << ( N - 1 ) ; let last = first * 2 ; for ( let i = last - 1 ; i >= first ; -- i ) { let zero_cnt = 0 ; let one_cnt = 0 ; let t = i ; let num_of_bits = 0 ; while ( t > 0 ) { if ( ( t & 1 ) != 0 ) one_cnt ++ ; else zero_cnt ++ ; num_of_bits ++ ; t = t >> 1 ; } if ( one_cnt >= zero_cnt ) { let all_prefix_match = true ; let msk = ( 1 << num_of_bits ) - 2 ; let prefix_shift = 1 ; while ( msk > 0 ) { let prefix = ( msk & i ) >> prefix_shift ; let prefix_one_cnt = 0 ; let prefix_zero_cnt = 0 ; while ( prefix > 0 ) { if ( ( prefix & 1 ) != 0 ) prefix_one_cnt ++ ; else prefix_zero_cnt ++ ; prefix = prefix >> 1 ; } if ( prefix_zero_cnt > prefix_one_cnt ) { all_prefix_match = false ; break ; } prefix_shift ++ ; msk = msk & ( msk << 1 ) ; } if ( all_prefix_match ) { r . push ( getBinaryRep ( i , num_of_bits ) ) ; } } } return r ; } let n = 4 ; let results = NBitBinary ( n ) ; for ( let i = 0 ; i < results . length ; ++ i ) document . write ( results [ i ] + "" "" ) ; document . write ( "" "" ) ;";"Print N | Function to get the binary representation of the number N ; loop for each bit ; generate numbers in the range of ( 2 ^ N ) - 1 to 2 ^ ( N - 1 ) inclusive ; longest prefix check ; if counts of 1 is greater than counts of zero ; do sub - prefixes check ; Driver code ; Function call"
Javascript;"function findWinner ( votes ) { let map = new Map ( ) ; for ( let i = 0 ; i < votes . length ; i ++ ) { if ( map . has ( votes [ i ] ) ) { map . set ( votes [ i ] , map . get ( votes [ i ] ) + 1 ) ; } else map . set ( votes [ i ] , 1 ) ; } let maxValueInMap = 0 ; let winner = "" "" ; for ( let [ key , value ] of map . entries ( ) ) { let Key = key ; let val = value ; if ( val > maxValueInMap ) { maxValueInMap = val ; winner = key ; } else if ( val == maxValueInMap && winner > Key ) winner = Key ; } document . write ( winner ) ; } let votes = [ "" "" , "" "" , "" "" , "" "" , "" "" , "" "" , "" "" , "" "" , "" "" , "" "" , "" "" , "" "" , "" "" ] ; findWinner ( votes ) ;";"Find winner of an election where votes are represented as candidate names | We have four Candidates with name as ' John ' , ' Johnny ' , ' jamie ' , ' jackie ' . The votes in String array are as per the votes casted . Print the name of candidates received Max vote . ; Insert all votes in a hashmap ; Traverse through map to find the candidate with maximum votes . ; If there is a tie , pick lexicographically smaller . ; Driver code"
Javascript;"function checkLuhn ( cardNo ) { let nDigits = cardNo . length ; let nSum = 0 ; let isSecond = false ; for ( let i = nDigits - 1 ; i >= 0 ; i -- ) { let d = cardNo [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ; if ( isSecond == true ) d = d * 2 ; nSum += parseInt ( d / 10 , 10 ) ; nSum += d % 10 ; isSecond = ! isSecond ; } return ( nSum % 10 == 0 ) ; } let cardNo = "" "" ; if ( checkLuhn ( cardNo ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Luhn algorithm | Returns true if given card number is valid ; We add two digits to handle cases that make two digits after doubling ; Driver code"
Javascript;"let MAX_CHAR = 26 ; function distributingBalls ( k , n , str ) { let a = new Array ( MAX_CHAR ) ; a . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { a [ str [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ++ ; } for ( let i = 0 ; i < MAX_CHAR ; i ++ ) if ( a [ i ] > k ) return false ; return true ; } let n = 6 , k = 3 ; let str = "" "" ; if ( distributingBalls ( k , n , str ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Distributing all balls without repetition | Javascript program to find if its possible to distribute balls without repitiion ; function to find if its possible to distribute balls or not ; count array to count how many times each color has occurred ; increasing count of each color every time it appears ; to check if any color appears more than K times if it does we will print NO ; Driver code"
Javascript;"function isVowel ( x ) { return ( x == ' ' x == ' ' x == ' ' x == ' ' x == ' ' ) ; } function findSubstring ( str ) { let hash = new Set ( ) ; let n = str . length ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i ; j < n ; j ++ ) { if ( isVowel ( str [ j ] ) == false ) break ; hash . add ( str [ j ] ) ; if ( hash . size == 5 ) document . write ( str . substring ( i , j + 1 ) + "" "" ) ; } hash . clear ( ) ; } } let str = "" "" ; findSubstring ( str ) ;";"Find substrings that contain all vowels | Returns true if x is vowel . ; Function to check whether a character is vowel or not ; Outer loop picks starting character and inner loop picks ending character . ; If current character is not vowel , then no more result substrings possible starting from str [ i ] . ; If vowel , then we insert it in hash ; If all vowels are present in current substring ; Driver code"
Javascript;"function check ( list , s ) { let n = list . length ; if ( n == 0 ) { return false ; } for ( let i = 0 ; i < n ; i ++ ) { if ( list [ i ] . length != s . length ) { continue ; } let diff = false ; for ( let j = 0 ; j < list [ i ] . length ; j ++ ) { if ( list [ i ] [ j ] != s [ j ] ) { if ( ! diff ) { diff = true ; } else { diff = false ; break ; } } } if ( diff ) { return true ; } } return false ; } let s = [ ] ; s . push ( "" "" ) ; s . push ( "" "" ) ; s . push ( "" "" ) ; s . push ( "" "" ) ; s . push ( "" "" ) ; document . write ( check ( s , "" "" ) == true ? 1 : 0 ) ;";"Find if an array contains a string with one mismatch | Javascript program to find if given string is present with one mismatch . ; If the array is empty ; If sizes are same ; If first mismatch ; Second mismatch ; Driver code"
Javascript;"function sentencePalindrome ( str ) { let l = 0 ; let h = str . length - 1 ; str = str . toLowerCase ( ) ; while ( l <= h ) { let getAtl = str [ l ] ; let getAth = str [ h ] ; if ( ! ( getAtl >= ' ' && getAtl <= ' ' ) ) l ++ ; else if ( ! ( getAth >= ' ' && getAth <= ' ' ) ) h -- ; else if ( getAtl == getAth ) { l ++ ; h -- ; } else return false ; } return true ; } let str = "" "" ; if ( sentencePalindrome ( str ) ) document . write ( "" "" ) ; else document . write ( "" "" + "" "" + "" "" ) ;";"Sentence Palindrome ( Palindrome after removing spaces , dots , . . etc ) | To check sentence is palindrome or not ; Lowercase string ; Compares character until they are equal ; If there is another symbol in left of sentence ; If there is another symbol in right of sentence ; If characters are equal ; If characters are not equal then sentence is not palindrome ; Returns true if sentence is palindrome ; Driver program to test sentencePallindrome ( )"
Javascript;"function xorZero ( s ) { let one_count = 0 , zero_count = 0 ; let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) if ( s [ i ] == ' ' ) one_count ++ ; else zero_count ++ ; if ( one_count % 2 == 0 ) return zero_count ; return one_count ; } let s = "" "" ; document . write ( xorZero ( s ) ) ;";"Ways to remove one element from a binary string so that XOR becomes zero | Returns number of ways in which XOR become ZERO by remove 1 element ; Counting number of 0 and 1 ; If count of ones is even then return count of zero else count of one ; Driver Code"
Javascript;"function encoder ( key ) { let encoded = "" "" ; let arr = new Array ( 26 ) ; for ( let i = 0 ; i < 26 ; i ++ ) { arr [ i ] = false ; } for ( let i = 0 ; i < key . length ; i ++ ) { if ( key [ i ] . charCodeAt ( 0 ) >= ' ' . charCodeAt ( 0 ) && key [ i ] . charCodeAt ( 0 ) <= ' ' . charCodeAt ( 0 ) ) { if ( arr [ key [ i ] . charCodeAt ( 0 ) - 65 ] == false ) { encoded += ( key [ i ] ) ; arr [ key [ i ] . charCodeAt ( 0 ) - 65 ] = true ; } } else if ( key [ i ] . charCodeAt ( 0 ) >= ' ' . charCodeAt ( 0 ) && key [ i ] . charCodeAt ( 0 ) <= ' ' . charCodeAt ( 0 ) ) { if ( arr [ key [ i ] . charCodeAt ( 0 ) - 97 ] == false ) { encoded += String . fromCharCode ( key [ i ] . charCodeAt ( 0 ) - 32 ) ; arr [ key [ i ] . charCodeAt ( 0 ) - 97 ] = true ; } } } for ( let i = 0 ; i < 26 ; i ++ ) { if ( arr [ i ] == false ) { arr [ i ] = true ; encoded += String . fromCharCode ( i + 65 ) ; } } return encoded ; } function cipheredIt ( msg , encoded ) { let cipher = "" "" ; for ( let i = 0 ; i < msg . length ; i ++ ) { if ( msg [ i ] >= ' ' && msg [ i ] <= ' ' ) { let pos = msg [ i ] . charCodeAt ( 0 ) - 97 ; cipher += encoded [ pos ] ; } else if ( msg [ i ] >= ' ' && msg [ i ] <= ' ' ) { let pos = msg [ i ] . charCodeAt ( 0 ) - 65 ; cipher += encoded [ pos ] ; } else { cipher += msg [ i ] ; } } return cipher ; } let key ; key = "" "" ; document . write ( "" "" + key + "" "" ) ; let encoded = encoder ( key . split ( "" "" ) ) ; let message = "" "" ; document . write ( "" "" + message + "" "" ) ; document . write ( "" "" + cipheredIt ( message , encoded ) ) ;";"Keyword Cipher | Function generates the encoded text ; This array represents the 26 letters of alphabets ; This loop inserts the keyword at the start of the encoded string ; To check whether the character is inserted earlier in the encoded string or not ; This loop inserts the remaining characters in the encoded string . ; Function that generates encodes ( cipher ) the message ; This loop ciphered the message . Spaces , special characters and numbers remain same . ; Hold the Keyword ; Function call to generate encoded text ; Message that need to encode ; Function call to print ciphered text"
Javascript;"let MAX_CHAR = 26 ; function checkCorrectOrNot ( s ) { let count = new Array ( MAX_CHAR ) ; for ( let i = 0 ; i < count . length ; i ++ ) { count [ i ] = 0 ; } let n = s . length ; if ( n == 1 ) return true ; for ( let i = 0 , j = n - 1 ; i < j ; i ++ , j -- ) { count [ s [ i ] - ' ' ] ++ ; count [ s [ j ] - ' ' ] -- ; } for ( let i = 0 ; i < MAX_CHAR ; i ++ ) if ( count [ i ] != 0 ) return false ; return true ; } let s = "" "" ; if ( checkCorrectOrNot ( s ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check if both halves of the string have same set of characters | Javascript program to check if it two half of string contain same Character set or not ; Function to check both halves for equality ; Counter array initialized with 0 ; Length of the string ; Traverse till the middle element is reached ; First half ; Second half ; Checking if values are different set flag to 1 ; String to be checked"
Javascript;"function check_isogram ( str ) { let length = str . length ; let mapHash = new Array ( 26 ) ; mapHash . fill ( 0 ) ; for ( let i = 0 ; i < length ; i ++ ) { mapHash [ str [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ++ ; if ( mapHash [ str [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] > 1 ) { return false ; } } return true ; } let str = "" "" ; let str2 = "" "" ; if ( check_isogram ( str ) ) document . write ( "" "" + "" "" ) ; else document . write ( "" "" + "" "" ) ; if ( check_isogram ( str2 ) ) document . write ( "" "" + "" "" ) ; else document . write ( "" "" + "" "" ) ;";"Check if a string is Isogram or not | function to check isogram ; loop to store count of chars and check if it is greater than 1 ; if count > 1 , return false ; Driver code ; checking str as isogram ; checking str2 as isogram"
Javascript;"function checkString ( s ) { let len = s . length ; let first = 0 ; for ( let i = 0 ; i < len ; i ++ ) { if ( s [ i ] == ' ' ) { first = i ; break ; } } let last = 0 ; for ( let i = len - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' ' ) { last = i ; break ; } } for ( let i = first ; i <= last ; i ++ ) if ( s [ i ] == ' ' ) return false ; return true ; } let s = "" "" ; document . write ( checkString ( s ) ? "" "" : "" "" ) ;";"Check if a binary string has a 0 between 1 s or not | Set 1 ( General approach ) | Method returns 1 when string is valid else returns 0 ; Find first occurrence of 1 in s [ ] ; Find last occurrence of 1 in s [ ] ; Check if there is any 0 in range ; Driver method"
Javascript;"function printAllSubStrings ( s , n ) { for ( let i = 0 ; i < n ; i ++ ) { let temp = new Array ( n - i + 1 ) ; let tempindex = 0 ; for ( let j = i ; j < n ; j ++ ) { temp [ tempindex ++ ] = s [ j ] ; temp [ tempindex ] = ' \0 ' ; document . write ( temp . join ( "" "" ) + "" "" ) ; } } } let s = "" "" ; printAllSubStrings ( s , s . length ) ;";"Program to print all substrings of a given string | Function to print all ( n * ( n + 1 ) ) / 2 subStrings of a given String s of length n . ; Fix start index in outer loop . Reveal new character in inner loop till end of String . Print till - now - formed String . ; Driver code"
Javascript;"function preserveSpace ( str ) { let n = str . length ; let start = 0 ; let end = n - 1 ; let Str = str . split ( ' ' ) ; while ( start < end ) { if ( Str [ start ] == ' ' ) { start ++ ; continue ; } else if ( Str [ end ] == ' ' ) { end -- ; continue ; } else { let temp = Str [ start ] ; Str [ start ] = Str [ end ] ; Str [ end ] = temp ; start ++ ; end -- ; } } document . write ( Str . join ( "" "" ) ) ; } let str = "" "" ; preserveSpace ( str ) ;";"Reverse a string preserving space positions | Javascript program to implement the above approach ; Initialize two pointers as two corners ; Move both pointers toward each other ; If character at start or end is space , ignore it ; If both are not spaces , do swap ; Driver code"
Javascript;"function amendSentence ( sstr ) { let str = sstr . split ( ' ' ) ; for ( let i = 0 ; i < str . length ; i ++ ) { if ( str [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) && str [ i ] . charCodeAt ( ) <= ' ' . charCodeAt ( ) ) { str [ i ] = String . fromCharCode ( str [ i ] . charCodeAt ( ) + 32 ) ; if ( i != 0 ) document . write ( "" "" ) ; document . write ( str [ i ] ) ; } else document . write ( str [ i ] ) ; } } let str = "" "" ; amendSentence ( str ) ;";"Put spaces between words starting with capital letters | Function to amend the sentence ; Traverse the string ; Convert to lowercase if its an uppercase character ; Print space before it if its an uppercase character ; Print the character ; if lowercase character then just print ; Driver Code"
Javascript;"function repeat ( s , n ) { let s1 = s ; for ( let i = 1 ; i < n ; i ++ ) return s ; } let s = "" "" ; let n = 3 ; document . write ( repeat ( s , n ) ) ;";"C ++ program to concatenate a string given number of times | Function which return string by concatenating it . ; Copying given string to temporary string . ; s += s1 ; Concatenating strings ; Driver code"
Javascript;"let MAX_CHAR = 26 ; function factorial ( n ) { let fact = 1 ; for ( let i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; } function countDistinctPermutations ( str ) { let length = str . length ; let freq = new Array ( MAX_CHAR ) ; freq . fill ( 0 ) ; for ( let i = 0 ; i < length ; i ++ ) if ( str [ i ] . charCodeAt ( ) >= ' ' . charCodeAt ( ) ) freq [ str [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] ++ ; let fact = 1 ; for ( let i = 0 ; i < MAX_CHAR ; i ++ ) fact = fact * factorial ( freq [ i ] ) ; return parseInt ( factorial ( length ) / fact , 10 ) ; } let str = "" "" ; document . write ( countDistinctPermutations ( str ) ) ;";"Number of distinct permutation a String can have | Javascript program to find number of distinct permutations of a string . ; Utility function to find factorial of n . ; Returns count of distinct permutations of str . ; finding frequency of all the lower case alphabet and storing them in array of integer ; finding factorial of number of appearances and multiplying them since they are repeating alphabets ; finding factorial of size of string and dividing it by factorial found after multiplying ; Driver code"
Javascript;"function uniqueCharacters ( str ) { let checker = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { let bitAtIndex = str [ i ] - ' ' ; if ( ( checker & ( 1 << bitAtIndex ) ) > 0 ) { return false ; } checker = checker | ( 1 << bitAtIndex ) ; } return true ; } let input = "" "" ; if ( uniqueCharacters ( input ) ) { document . write ( "" "" + input + "" "" ) ; } else { document . write ( "" "" + input + "" "" ) ; }";"Determine if a string has all Unique Characters | Javascript program to illustrate String with unique characters without using any data structure ; Assuming string can have characters a - z this has 32 bits set to 0 ; if that bit is already set in checker , return false ; otherwise update and continue by setting that bit in the checker ; no duplicates encountered , return true ; Driver Code"
Javascript;"function isKthBitSet ( n , k ) { if ( ( n & ( 1 << ( k - 1 ) ) ) > 0 ) document . write ( "" "" ) ; else document . write ( "" "" ) ; } let n = 5 , k = 1 ; isKthBitSet ( n , k ) ;";"Check whether K | Javascript program to check if k - th bit of a given number is set or not . ; Driver code"
Javascript;"function reverseString ( str ) { return str . split ( "" "" ) . reverse ( ) . join ( "" "" ) ; } var str = ( "" "" ) ; document . write ( reverseString ( str ) ) ;";"Reverse string without using any temporary variable | Reversing a string using reverse ( ) ; Reverse str [ beign . . end ]"
Javascript;"function isPalRec ( str , s , e ) { if ( s == e ) return true ; if ( ( str . charAt ( s ) ) != ( str . charAt ( e ) ) ) return false ; if ( s < e + 1 ) return isPalRec ( str , s + 1 , e - 1 ) ; return true ; } function isPalindrome ( str ) { var n = str . length ; if ( n == 0 ) return true ; return isPalRec ( str , 0 , n - 1 ) ; } var str = "" "" ; if ( isPalindrome ( str ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Recursive function to check if a string is palindrome | A recursive function that check a str ( s . . e ) is palindrome or not . ; If there is only one character ; If first and last characters do not match ; If there are more than two characters , check if middle substring is also palindrome or not . ; An empty string is considered as palindrome ; Driver Code"
Javascript;"var MAX_CHAR = 26 ; function countSubstringWithEqualEnds ( s ) { var result = 0 ; var n = s . length ; var count = Array . from ( { length : MAX_CHAR } , ( _ , i ) => 0 ) ; for ( var i = 0 ; i < n ; i ++ ) count [ s . charAt ( i ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; for ( var i = 0 ; i < MAX_CHAR ; i ++ ) result += ( count [ i ] * ( count [ i ] + 1 ) / 2 ) ; return result ; } var s = "" "" ; document . write ( countSubstringWithEqualEnds ( s ) ) ;";"Count substrings with same first and last characters | assuming lower case only ; Calculating frequency of each character in the string . ; Computing result using counts ; Driver function"
Javascript;"function maxRepeating ( str ) { var n = str . length ; var count = 0 ; var res = str [ 0 ] ; var cur_count = 1 ; for ( var i = 0 ; i < n ; i ++ ) { if ( i < n - 1 && str [ i ] == str [ i + 1 ] ) cur_count ++ ; else { if ( cur_count > count ) { count = cur_count ; res = str [ i ] ; } cur_count = 1 ; } } return res ; } var str = "" "" ; document . write ( maxRepeating ( str ) ) ;";"Maximum consecutive repeating character in string | function to find out the maximum repeating character in given string ; Traverse string except last character ; If current character matches with next ; If doesn 't match, update result  (if required) and reset count ; Driver code"
Javascript;"let MAX = 10000 ; let CHAR_SIZE = 26 ; function precompute ( mat , str , len ) { for ( let i = 0 ; i < CHAR_SIZE ; ++ i ) mat [ len ] [ i ] = len ; for ( let i = len - 1 ; i >= 0 ; -- i ) { for ( let j = 0 ; j < CHAR_SIZE ; ++ j ) mat [ i ] [ j ] = mat [ i + 1 ] [ j ] ; mat [ i ] [ str [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] = i ; } } function query ( mat , str , len ) { let pos = 0 ; for ( let i = 0 ; i < str . length ; ++ i ) { if ( mat [ pos ] [ str [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] >= len ) return false ; else pos = mat [ pos ] [ str [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ] + 1 ; } return true ; } let S = "" "" ; let len = S . length ; let mat = new Array ( MAX ) ; for ( let i = 0 ; i < MAX ; i ++ ) { mat [ i ] = new Array ( CHAR_SIZE ) ; for ( let j = 0 ; j < CHAR_SIZE ; j ++ ) { mat [ i ] [ j ] = 0 ; } } precompute ( mat , S , len ) ; let get = query ( mat , "" "" , len ) ? "" "" : "" "" ; document . write ( get + "" "" ) ; get = query ( mat , "" "" , len ) ? "" "" : "" "" ; document . write ( get + "" "" ) ; get = query ( mat , "" "" , len ) ? "" "" : "" "" ; document . write ( get + "" "" ) ; get = query ( mat , "" "" , len ) ? "" "" : "" "" ; document . write ( get + "" "" ) ;";"Queries on subsequence of string | Javascript program to answer subsequence queries for a given string . ; Precompute the position of each character from each position of String S ; Computing position of each character from each position of String S ; Print "" Yes "" if T is subsequence of S , else "" No "" ; Traversing the string T ; If next position is greater than length of S set flag to false . ; Setting position of next character ; Driver Code"
Javascript;"function query ( s , i , j ) { let n = s . length ; i %= n ; j %= n ; if ( s [ i ] == s [ j ] ) document . write ( "" "" + "" "" ) ; else document . write ( "" "" + "" "" ) ; } let X = "" "" ; query ( X , 0 , 8 ) ; query ( X , 8 , 13 ) ; query ( X , 6 , 15 ) ;";"Queries for characters in a repeated string | Print whether index i and j have same element or not ; Finding relative position of index i , j . ; Checking is element are same at index i , j ; Driver Code"
Javascript;"function countPairs ( str ) { let result = 0 ; let n = str . length ; for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) if ( Math . abs ( str [ i ] . charCodeAt ( ) - str [ j ] . charCodeAt ( ) ) == Math . abs ( i - j ) ) result ++ ; return result ; } let str = "" "" ; document . write ( countPairs ( str ) ) ;";"Count of character pairs at same distance as in English alphabets | Method to count pairs ; Increment count if characters are at same distance ; Driver code"
Javascript;"function min ( a , b ) { if ( a < b ) return a ; else return b ; } function longestString ( str1 , str2 ) { var count1 = new Array ( 26 ) ; var count2 = new Array ( 26 ) ; count1 . fill ( 0 ) ; count2 . fill ( 0 ) ; for ( var i = 0 ; i < str1 . length ; i ++ ) { count1 [ str1 . charCodeAt ( i ) - 97 ] ++ ; } for ( var i = 0 ; i < str2 . length ; i ++ ) { count2 [ str2 . charCodeAt ( i ) - 97 ] ++ ; } var result = "" "" ; for ( var i = 0 ; i < 26 ; i ++ ) { for ( var j = 1 ; j <= min ( count1 [ i ] , count2 [ i ] ) ; j ++ ) { result += String . fromCharCode ( 97 + i ) ; } } document . write ( result ) ; } var str1 = "" "" ; var str2 = "" "" ; longestString ( str1 , str2 ) ;";"Longest common subsequence with permutations allowed | Javascript program to find LCS with permutations allowed ; Function to calculate longest String str1 -- > first String str2 -- > second String count1 [ ] -- > hash array to calculate frequency of characters in str1 count [ 2 ] -- > hash array to calculate frequency of characters in str2 result -- > resultant longest String whose permutations are sub - sequence of given two strings ; calculate frequency of characters ; Now traverse hash array ; append character ( ' a ' + i ) in resultant String ' result ' by min ( count1 [ i ] , count2i ] ) times ; Driver Code"
Javascript;"function checkPattern ( str , pattern ) { var len = pattern . length ; if ( str . length < len ) { return false ; } for ( var i = 0 ; i < len - 1 ; i ++ ) { var x = pattern [ i ] ; var y = pattern [ i + 1 ] ; var last = str . lastIndexOf ( x ) ; var first = str . indexOf ( y ) ; if ( last === - 1 first === - 1 last > first ) { return false ; } } return true ; } var str = "" "" ; var pattern = "" "" ; document . write ( checkPattern ( str , pattern ) ) ;";"Check if string follows order of characters defined by a pattern or not | Set 1 | Function to check if characters in the input string follows the same order as determined by characters present in the given pattern ; len stores length of the given pattern ; if length of pattern is more than length of input string , return false ; ; x , y are two adjacent characters in pattern ; find index of last occurrence of character x in the input string ; find index of first occurrence of character y in the input string ; return false if x or y are not present in the input string OR last occurrence of x is after the first occurrence of y in the input string ; return true if string matches the pattern ; Driver code"
Javascript;"function findSum ( str ) { let temp = "" "" ; let sum = 0 ; for ( let i = 0 ; i < str . length ; i ++ ) { let ch = str [ i ] ; if ( ! isNaN ( String ( ch ) * 1 ) ) temp += ch ; else { sum += parseInt ( temp ) ; temp = "" "" ; } } return sum + parseInt ( temp ) ; } let str = "" "" ; document . write ( findSum ( str ) ) ;";"Calculate sum of all numbers present in a string | Function to calculate sum of all numbers present in a string containing alphanumeric characters ; A temporary string ; holds sum of all numbers present in the string ; read each character in input string ; if current character is a digit ; if current character is an alphabet ; increment sum by number found earlier ( if any ) ; reset temporary string to empty ; atoi ( temp . c_str ( ) ) takes care of trailing numbers ; input alphanumeric string ; Function call"
Javascript;"function countkDist ( str , k ) { var res = 0 ; var n = str . length ; var cnt = Array . from ( { length : 26 } , ( _ , i ) => 0 ) ; for ( i = 0 ; i < n ; i ++ ) { var dist_count = 0 ; for ( j = i ; j < n ; j ++ ) { if ( cnt [ str . charAt ( j ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] == 0 ) dist_count ++ ; cnt [ str . charAt ( j ) . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; if ( dist_count == k ) res ++ ; } } return res ; } var ch = "" "" ; var k = 3 ; document . write ( "" "" + k + "" "" + countkDist ( ch , k ) ) ;";"Count number of substrings with exactly k distinct characters | Function to count number of substrings with exactly k unique characters ; Initialize result ; To store count of characters from ' a ' to ' z ' ; Consider all substrings beginning with str [ i ] ; Consider all substrings between str [ i . . j ] ; If this is a new character for this substring , increment dist_count . ; Increment count of current character ; If distinct character count becomes k , then increment result . ; Driver Program"
Javascript;"function to_upper ( input ) { var result = new Array ( input . length ) ; for ( var i = 0 ; i < input . length ; i ++ ) if ( "" "" . charCodeAt ( 0 ) <= input [ i ] . charCodeAt ( 0 ) <= "" "" . charCodeAt ( 0 ) ) result [ i ] = String . fromCharCode ( input [ i ] . charCodeAt ( 0 ) - "" "" . charCodeAt ( 0 ) + "" "" . charCodeAt ( 0 ) ) ; return result . join ( "" "" ) . toString ( ) ; } var str = "" "" ; document . write ( to_upper ( str ) ) ;";"Lower case to upper case | Converts a string to uppercase ; Driver code"
Javascript;"function findMinLength ( arr , n ) { let min = arr [ 0 ] . length ; for ( let i = 1 ; i < n ; i ++ ) { if ( arr [ i ] . length < min ) { min = arr [ i ] . length ; } } return ( min ) ; } function commonPrefix ( arr , n ) { let minlen = findMinLength ( arr , n ) ; let result = "" "" ; for ( let i = 0 ; i < minlen ; i ++ ) { current = arr [ 0 ] [ i ] ; for ( let j = 1 ; j < n ; j ++ ) { if ( arr [ j ] [ i ] != current ) { return result ; } } result += ( current ) ; } return ( result ) ; } let arr = [ "" "" , "" "" , "" "" , "" "" ] let n = arr . length ; let ans = commonPrefix ( arr , n ) ; if ( ans . length > 0 ) { document . write ( "" "" + ans ) ; } else { document . write ( "" "" ) ; }";"Longest Common Prefix using Character by Character Matching | A Function to find the string having the minimum length and returns that length ; A Function that returns the longest common prefix from the array of strings ; Our resultant string let current ; The current character ; Current character ( must be same in all strings to be a part of result ) ; Append to result ; Driver program to test above function"
Javascript;"function printZigZagConcat ( str , n ) { if ( n == 1 ) { document . write ( str ) ; return ; } let str1 = str . split ( "" "" ) ; let len = str . length ; let arr = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { arr [ i ] = "" "" ; } let row = 0 ; let down = true ; for ( let i = 0 ; i < len ; ++ i ) { arr [ row ] += ( str1 [ i ] ) ; if ( row == n - 1 ) { down = false ; } else if ( row == 0 ) { down = true ; } if ( down ) { row ++ ; } else { row -- ; } } for ( let i = 0 ; i < n ; ++ i ) { document . write ( arr [ i ] ) ; } } let str = "" "" ; let n = 3 ; printZigZagConcat ( str , n ) ;";"Print Concatenation of Zig | Prints concatenation of all rows of str 's  Zig-Zag fashion ; Corner Case ( Only one row ) ; Find length of string ; Create an array of strings for all n rows ; Initialize index for array of strings arr [ ] ; True if we are moving down in rows , else false ; Traverse through given string ; append current character to current row ; If last row is reached , change direction to ' up ' ; If 1 st row is reached , change direction to ' down ' ; If direction is down , increment , else decrement ; Print concatenation of all rows ; Driver Code"
Javascript;"let size = 256 ; function areIsomorphic ( str1 , str2 ) { let m = str1 . length ; let n = str2 . length ; if ( m != n ) return false ; let marked = new Array ( size ) ; for ( let i = 0 ; i < size ; i ++ ) marked [ i ] = false ; let map = new Array ( size ) ; map . fill ( 0 ) ; for ( let i = 0 ; i < size ; i ++ ) map [ i ] = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( map [ str1 [ i ] . charCodeAt ( ) ] == - 1 ) { if ( marked [ str2 [ i ] . charCodeAt ( ) ] == true ) return false ; marked [ str2 [ i ] . charCodeAt ( ) ] = true ; map [ str1 [ i ] . charCodeAt ( ) ] = str2 [ i ] . charCodeAt ( ) ; } else if ( map [ str1 [ i ] . charCodeAt ( ) ] != str2 [ i ] . charCodeAt ( ) ) return 0 ; } return 1 ; } let res = areIsomorphic ( "" "" , "" "" ) ; document . write ( res + "" "" ) ; res = areIsomorphic ( "" "" , "" "" ) ; document . write ( res ) ;";"Check if two given strings are isomorphic to each other | Javascript program to check if two strings are isomorphic ; Function returns true if str1 and str2 are isomorphic ; Length of both strings must be same for one to one corresponance ; To mark visited characters in str2 ; To store mapping of every character from str1 to that of str2 and Initialize all entries of map as - 1. ; Process all characters one by on ; If current character of str1 is seen first time in it . ; If current character of str2 is already seen , one to one mapping not possible ; Mark current character of str2 as visited ; Store mapping of current characters ; If this is not first appearance of current character in str1 , then check if previous appearance mapped to same character of str2 ; Driver code"
Javascript;"let CHAR = 26 ; function isoMorphic ( str1 , str2 ) { let n = str1 . length ; let m = str2 . length ; if ( n != m ) return false ; let countChars1 = new Array ( CHAR ) ; countChars1 . fill ( 0 ) ; let countChars2 = new Array ( CHAR ) ; countChars2 . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { countChars1 [ str1 [ i ] . charCodeAt ( ) - ' ' ] ++ ; countChars2 [ str2 [ i ] . charCodeAt ( ) - ' ' ] ++ ; if ( countChars1 [ str1 [ i ] . charCodeAt ( ) - ' ' ] != countChars2 [ str2 [ i ] . charCodeAt ( ) - ' ' ] ) { return false ; } } return true ; } document . write ( isoMorphic ( "" "" , "" "" ) ? 1 + "" "" : 0 + "" "" ) ; document . write ( isoMorphic ( "" "" , "" "" ) ? 1 : 0 ) ;";"Check if two given strings are isomorphic to each other | Javascript program for the above approach ; This function returns true if str1 and str2 are isomorphic ; Length of both strings must be same for one to one correspondence ; For counting the previous appearances of character in both the strings ; Process all characters one by one ; For string to be isomorphic the previous counts of appearances of current character in both string must be same if it is not same we return false . ; Driver Code"
Javascript;"function isPalin ( str , st , end ) { while ( st < end ) { if ( str [ st ] != str [ end ] ) return false ; st ++ ; end -- ; } return true ; } function findMinInsert ( str , n ) { for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( isPalin ( str , 0 , i ) ) return ( n - i - 1 ) ; } } let Input = "" "" ; document . write ( findMinInsert ( Input , Input . length ) ) ;";"Minimum insertions to form shortest palindrome | Returns true if a string str [ st . . end ] is palindrome ; Returns count of insertions on left side to make str [ ] a palindrome ; Find the largest prefix of given string that is palindrome . ; Characters after the palindromic prefix must be added at the beginning also to make the complete string palindrome ; Driver Code"
Javascript;"function removeRecur ( n ) { let prev_digit = n % 10 ; let pow = 10 ; let res = prev_digit ; while ( n > 0 ) { let curr_digit = n % 10 ; if ( curr_digit != prev_digit ) { res += curr_digit * pow ; prev_digit = curr_digit ; pow *= 10 ; } n = parseInt ( n / 10 , 10 ) ; } return res ; } let n = 12224 ; document . write ( removeRecur ( n ) ) ;";"Remove repeated digits in a given number | Javascript program to remove repeated digits ; Store first digits as previous digit ; Initialize power ; Iterate through all digits of n , note that the digits are processed from least significant digit to most significant digit . ; Store current digit ; Add the current digit to the beginning of result ; Update previous result and power ; Remove last digit from n ; Driver program"
Javascript;"function myAtoi ( str ) { var sign = 1 , base = 0 , i = 0 ; while ( str [ i ] == ' ' ) { i ++ ; } if ( str [ i ] == ' ' str [ i ] == ' ' ) { sign = 1 - 2 * ( str [ i ++ ] == ' ' ) ; } while ( str [ i ] >= ' ' && str [ i ] <= ' ' ) { if ( base > Number . MAX_VALUE / 10 || ( base == Number . MAX_VALUE / 10 && str [ i ] - ' ' > 7 ) ) { if ( sign == 1 ) return Number . MAX_VALUE ; else return Number . MAX_VALUE ; } base = 10 * base + ( str [ i ++ ] - ' ' ) ; } return base * sign ; } var str = "" "" ; var val = myAtoi ( str ) ; document . write ( "" "" , val ) ;";"Write your own atoi ( ) | A simple JavaScript program for implementation of atoi ; if whitespaces then ignore . ; sign of number ; checking for valid input ; handling overflow test case ; Driver code ; Function call"
Javascript;"let NO_OF_CHARS = 256 ; function areAnagram ( str1 , str2 ) { let count = new Array ( NO_OF_CHARS ) ; for ( let i = 0 ; i < NO_OF_CHARS ; i ++ ) { count [ i ] = 0 ; } let i ; for ( i = 0 ; i < str1 . length ; i ++ ) { count [ str1 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] ++ ; count [ str2 [ i ] . charCodeAt ( 0 ) - ' ' . charCodeAt ( 0 ) ] -- ; } if ( str1 . length != str2 . length ) return false ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) if ( count [ i ] != 0 ) { return false ; } return true ; } let str1 = "" "" . split ( "" "" ) ; let str2 = "" "" . split ( "" "" ) ; if ( areAnagram ( str1 , str2 ) ) document . write ( "" "" + "" "" ) ; else document . write ( "" "" + "" "" ) ;";"Check whether two strings are anagram of each other | Javascript program to check if two strings are anagrams of each other ; function to check if two strings are anagrams of each other ; Create a count array and initialize all values as 0 ; For each character in input strings , increment count in the corresponding count array ; If both strings are of different length . Removing this condition will make the program fail for strings like "" aaca "" and "" aca "" ; See if there is any non - zero value in count array ; Driver code ; Function call"
Javascript;"function areDistinct ( str , i , j ) { var visited = new [ 26 ] ; for ( var k = i ; k <= j ; k ++ ) { if ( visited [ str . charAt ( k ) - ' ' ] == true ) return false ; visited [ str . charAt ( k ) - ' ' ] = true ; } return true ; } function longestUniqueSubsttr ( str ) { var n = str . length ( ) ; var res = 0 ; for ( var i = 0 ; i < n ; i ++ ) for ( var j = i ; j < n ; j ++ ) if ( areDistinct ( str , i , j ) ) res = Math . max ( res , j - i + 1 ) ; return res ; } var str = "" "" ; document . write ( "" "" + str ) ; var len = longestUniqueSubsttr ( str ) ; document . write ( "" "" + "" "" + "" "" + len ) ;";"Length of the longest substring without repeating characters | This function returns true if all characters in str [ i . . j ] are distinct , otherwise returns false ; Note : Default values in visited are false ; Returns length of the longest substring with all distinct characters . ; Result ; Driver code"
Javascript;"function firstNonRepeating ( str ) { var fi = new Array ( 256 ) ; fi . fill ( - 1 ) ; for ( var i = 0 ; i < 256 ; i ++ ) fi [ i ] = - 1 ; for ( var i = 0 ; i < str . length ; i ++ ) { if ( fi [ str . charCodeAt ( i ) ] == - 1 ) { fi [ str . charCodeAt ( i ) ] = i ; } else { fi [ str . charCodeAt ( i ) ] = - 2 ; } } var res = Infinity ; for ( var i = 0 ; i < 256 ; i ++ ) { if ( fi [ i ] >= 0 ) res = Math . min ( res , fi [ i ] ) ; } if ( res == Infinity ) return - 1 ; else return res ; } var str ; str = "" "" ; var firstIndex = firstNonRepeating ( str ) ; if ( firstIndex === - 1 ) document . write ( "" "" ) ; else document . write ( "" "" + str . charAt ( firstIndex ) ) ;";"Given a string , find its first non | this function return the index of first non - repeating character if found , or else it returns - 1 ; initializing all elements to - 1 ; sets all repeating characters to - 2 and non - repeating characters contain the index where they occur ; If this character is not - 1 or - 2 then it means that this character occurred only once so find the min index of all characters that occur only once , that 's our first index ; if res remains INT_MAX , it means there are no characters that repeat only once or the string is empty"
Javascript;"function unique ( s ) { let str = "" "" ; let len = s . length ; for ( let i = 0 ; i < len ; i ++ ) { let c = s [ i ] ; if ( str . indexOf ( c ) < 0 ) { str += c ; } } return str ; } let s = "" "" ; document . write ( unique ( s ) ) ;";"Remove duplicates from a given string | Function to make the string unique ; loop to traverse the string and check for repeating chars using IndexOf ( ) method in Java ; character at i 'th index of s ; if c is present in str , it returns the index of c , else it returns - 1 ; adding c to str if - 1 is returned ; Input string with repeating chars"
Javascript;"function isPerfect ( x ) { var sum_div = 1 ; for ( i = 2 ; i <= x / 2 ; ++ i ) { if ( x % i == 0 ) { sum_div += i ; } } if ( sum_div == x ) { return 1 ; } else return 0 ; } function subsetSum ( arr , l , r , sum ) { if ( l > r ) { if ( isPerfect ( sum ) != 0 ) { document . write ( sum + "" "" ) ; } return ; } subsetSum ( arr , l + 1 , r , sum + arr [ l ] ) ; subsetSum ( arr , l + 1 , r , sum ) ; } var arr = [ 5 , 4 , 6 ] ; var N = arr . length ; subsetSum ( arr , 0 , N - 1 , 0 ) ;";"Sum of all subsets whose sum is a Perfect Number from a given array | Function to check is a given number is a perfect number or not ; Stores the sum of its divisors ; Add all divisors of x to sum_div ; If the sum of divisors is equal to the given number , return true ; Otherwise , return false ; Function to find sum of all subsets from an array whose sum is a perfect number ; Prvar the current subset sum if it is a perfect number ; Check if sum is a perfect number or not ; Calculate sum of the subset including arr [ l ] ; Calculate sum of the subset excluding arr [ l ] ; Driver code"
Javascript;"function PartitionSub ( arr , i , N , K , nos , v ) { if ( i >= N ) { if ( nos == K ) { for ( let x = 0 ; x < v . length ; x ++ ) { document . write ( "" "" ) ; for ( let y = 0 ; y < v [ x ] . length ; y ++ ) { document . write ( v [ x ] [ y ] ) ; if ( y == v [ x ] . length - 1 ) { document . write ( "" "" ) ; } else { document . write ( "" "" ) ; } } if ( x == v . length - 1 ) { document . write ( "" "" ) ; } else { document . write ( "" "" ) ; } } document . write ( "" "" ) ; } return ; } for ( let j = 0 ; j < K ; j ++ ) { if ( v [ j ] . length > 0 ) { v [ j ] . push ( arr [ i ] ) ; PartitionSub ( arr , i + 1 , N , K , nos , v ) ; v [ j ] . pop ( ) ; } else { v [ j ] . push ( arr [ i ] ) ; PartitionSub ( arr , i + 1 , N , K , nos + 1 , v ) ; v [ j ] . pop ( ) ; break ; } } } function partKSubsets ( arr , N , K ) { let v = [ ] ; for ( let i = 0 ; i < K ; i ++ ) v . push ( [ ] ) ; if ( K == 0 K > N ) { document . write ( "" "" + "" "" ) ; } else { document . write ( "" "" + "" "" ) ; PartitionSub ( arr , 0 , N , K , 0 , v ) ; } } let arr = [ 1 , 2 , 3 , 4 ] ; let K = 2 ; let N = arr . length ; partKSubsets ( arr , N , K ) ;";"Print all possible ways to split an array into K subsets | Utility function to find all possible ways to split array into K subsets ; If count of elements in K subsets are greater than or equal to N ; If count of subsets formed is equal to K ; Print K subsets by splitting array into K subsets ; Print current subset ; If current element is the last element of the subset ; Otherwise ; If any subset is occupied , then push the element in that first ; Recursively do the same for remaining elements ; Backtrack ; Otherwise , push it in an empty subset and increase the subset count by 1 ; Break to avoid the case of going in other empty subsets , if available , and forming the same combination ; Function to to find all possible ways to split array into K subsets ; Stores K subset by splitting array into K subsets ; Size of each subset must be less than the number of elements ; Given array ; Given K ; Size of the array ; Prints all possible splits into subsets"
Javascript;"let MAX = 100 ; let store = new Array ( MAX ) ; store . fill ( 0 ) ; let n ; let graph = new Array ( MAX ) ; for ( let i = 0 ; i < MAX ; i ++ ) { graph [ i ] = new Array ( MAX ) ; } let d = new Array ( MAX ) ; d . fill ( 0 ) ; let ans ; function SieveOfEratosthenes ( prime , p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( let p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( let i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } function is_clique ( b ) { for ( let i = 1 ; i < b ; i ++ ) { for ( let j = i + 1 ; j < b ; j ++ ) if ( graph [ store [ i ] ] [ store [ j ] ] == 0 ) { return false ; } } return true ; } function primeCliques ( i , l , prime ) { for ( let j = i + 1 ; j <= n ; j ++ ) { store [ l ] = j ; if ( is_clique ( l + 1 ) ) { if ( prime [ l ] ) ans ++ ; else { ans -= 1.3 ; } primeCliques ( j , l + 1 , prime ) ; } } } let edges = [ [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 1 ] , [ 4 , 3 ] , [ 4 , 5 ] , [ 5 , 3 ] ] ; let size = edges . length ; n = 5 ; let prime = new Array ( n + 1 ) ; for ( let i = 0 ; i < prime . length ; i ++ ) prime [ i ] = true ; SieveOfEratosthenes ( prime , n ) ; for ( let i = 0 ; i < size ; i ++ ) { graph [ edges [ i ] [ 0 ] , edges [ i ] [ 1 ] ] = 1 ; graph [ edges [ i ] [ 1 ] , edges [ i ] [ 0 ] ] = 1 ; d [ edges [ i ] [ 0 ] ] ++ ; d [ edges [ i ] [ 1 ] ] ++ ; } ans = 0 ; primeCliques ( 0 , 1 , prime ) ; document . write ( ans ) ;";"Count the number of Prime Cliques in an undirected graph | Javascript implementation to count the number of Prime Cliques in an undirected graph ; Stores the vertices ; Graph ; Degree of the vertices ; To store the count of prime cliques ; Function to create Sieve to check primes ; False here indicates that it is not prime ; Condition if prime [ p ] is not changed , then it is a prime ; Update all multiples of p , set them to non - prime ; Function to check if the given set of vertices in store array is a clique or not ; Run a loop for all set of edges ; If any edge is missing ; Function to find the count of all the cliques having prime size ; Check if any vertices from i + 1 can be inserted ; Add the vertex to store ; If the graph is not a clique of size k then it cannot be a clique by adding another edge ; Increase the count of prime cliques if the size of current clique is prime ; Check if another edge can be added ; Driver code"
Javascript;"var dim = 3 ; class Node { constructor ( ) { this . data = 0 ; this . next = null ; this . prev = null ; this . up = null ; this . down = null ; } } function createNode ( data ) { temp = new Node ( ) ; temp . data = data ; temp . next = null ; temp . prev = null ; temp . up = null ; temp . down = null ; return temp ; } function constructDoublyListUtil ( mtrx , i , j , curr ) { if ( i >= dim j >= dim ) { return null ; } var temp = createNode ( mtrx [ i ] [ j ] ) ; temp . prev = curr ; temp . up = curr ; temp . next = constructDoublyListUtil ( mtrx , i , j + 1 , temp ) ; temp . down = constructDoublyListUtil ( mtrx , i + 1 , j , temp ) ; return temp ; } function constructDoublyList ( mtrx ) { return constructDoublyListUtil ( mtrx , 0 , 0 , null ) ; } function display ( head ) { rPtr = null ; dPtr = head ; while ( dPtr != null ) { rPtr = dPtr ; while ( rPtr != null ) { document . write ( rPtr . data + "" "" ) ; rPtr = rPtr . next ; } document . write ( "" "" ) ; dPtr = dPtr . down ; } } var mtrx = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ; var list = constructDoublyList ( mtrx ) ; display ( list ) ;";"Construct a Doubly linked linked list from 2D Matrix | define dimension of matrix ; struct node of doubly linked list with four pointer next , prev , up , down ; function to create a new node ; function to construct the doubly linked list ; Create Node with value contain in matrix at index ( i , j ) ; Assign address of curr into the prev pointer of temp ; Assign address of curr into the up pointer of temp ; Recursive call for next pointer ; Recursive call for down pointer ; Return newly constructed node whose all four node connected at it 's appropriate position ; Function to construct the doubly linked list ; function call for construct the doubly linked list ; function for displaying doubly linked list data ; pointer to move right ; pointer to move down ; loop till node . down is not null ; loop till node . right is not null ; initialise matrix"
Javascript;"class Node { constructor ( key ) { this . left = null ; this . right = null ; this . key = key ; } } function newNode ( key ) { let temp = new Node ( key ) ; return ( temp ) ; } function find_x ( n ) { if ( n == 1 ) return 1 ; let num , den , p ; num = Math . log10 ( n ) ; let x = 0 , no = 0 ; for ( let i = 2 ; i <= n ; i ++ ) { den = Math . log10 ( i ) ; p = num / den ; no = parseInt ( Math . pow ( i , parseInt ( p , 10 ) ) , 10 ) ; if ( Math . abs ( no - n ) < 1e-6 ) { x = i ; break ; } } return x ; } function is_key ( n , x ) { let p ; p = Math . log10 ( n ) / Math . log10 ( x ) ; let no = parseInt ( Math . pow ( x , parseInt ( p , 10 ) ) , 10 ) ; if ( n == no ) return true ; return false ; } function evenPaths ( node , count , x ) { if ( node == null || ! is_key ( node . key , x ) ) { return count ; } if ( node . left == null && node . right == null ) { count ++ ; } count = evenPaths ( node . left , count , x ) ; return evenPaths ( node . right , count , x ) ; } function countExpPaths ( node , x ) { return evenPaths ( node , 0 , x ) ; } let root = newNode ( 27 ) ; root . left = newNode ( 9 ) ; root . right = newNode ( 81 ) ; root . left . left = newNode ( 3 ) ; root . left . right = newNode ( 10 ) ; root . right . left = newNode ( 70 ) ; root . right . right = newNode ( 243 ) ; root . right . right . left = newNode ( 81 ) ; root . right . right . right = newNode ( 909 ) ; let x = find_x ( root . key ) ; document . write ( countExpPaths ( root , x ) ) ;";"Count of exponential paths in a Binary Tree | Structure of a Tree node ; Function to create a new node ; Function to find x ; Take log10 of n ; Log ( n ) with base i ; Raising i to the power p ; Function to check whether the given node equals to x ^ y for some y > 0 ; Take logx ( n ) with base x ; Utility function to count the exponent path in a given Binary tree ; Base Condition , when node pointer becomes null or node value is not a number of pow ( x , y ) ; Increment count when encounter leaf node ; Left recursive call save the value of count ; Right recursive call and return value of count ; Function to count exponential paths ; Create Tree ; Retrieve the value of x ; Function call"
Javascript;"let N = 1000001 ; let c , n , m , a , b ; function dfs ( a , b , v , vis ) { vis [ a ] = 1 ; c ++ ; for ( let i of v [ a ] ) { if ( vis [ i ] == 0 && i != b ) dfs ( i , b , v , vis ) ; } } function Calculate ( v ) { let vis = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) vis [ i ] = 0 ; c = 0 ; dfs ( a , b , v , vis ) ; let ans1 = n - c - 1 ; for ( let i = 0 ; i < n + 1 ; i ++ ) vis [ i ] = 0 ; c = 0 ; dfs ( b , a , v , vis ) ; let ans2 = n - c - 1 ; document . write ( ( ans1 * ans2 ) + "" "" ) ; } n = 7 ; m = 7 ; a = 3 ; b = 5 ; let edges = [ [ 1 , 2 ] , [ 2 , 3 ] , [ 3 , 4 ] , [ 4 , 5 ] , [ 5 , 6 ] , [ 6 , 7 ] , [ 7 , 5 ] ] ; let v = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) { v [ i ] = [ ] ; } for ( let i = 0 ; i < m ; i ++ ) { v [ edges [ i ] [ 0 ] ] . push ( edges [ i ] [ 1 ] ) ; v [ edges [ i ] [ 1 ] ] . push ( edges [ i ] [ 0 ] ) ; } Calculate ( v ) ;";"Number of pairs such that path between pairs has the two vertices A and B | Javascript program to find the number of pairs such that the path between every pair contains two given vertices ; Function to perform DFS on the given graph by fixing the a vertex ; To mark a particular vertex as visited ; Variable to store the count of the vertices which can be reached from a ; Performing the DFS by iterating over the visited array ; If the vertex is not visited and removing the vertex b ; Function to return the number of pairs such that path between any two pairs consists of the given two vertices A and B ; Initializing the visited array and assigning it with 0 's ; Initially , the count of vertices is 0 ; Performing DFS by removing the vertex B ; Count the vertices which cannot be reached after removing the vertex B ; Again reinitializing the visited array ; Setting the count of vertices to 0 to perform the DFS again ; Performing the DFS by removing the vertex A ; Count the vertices which cannot be reached after removing the vertex A ; Multiplying both the vertices set ; Driver code ; Loop to store the graph"
Javascript;"var V = 4 ; var ans = 1000000000 ; function tsp ( graph , currPos , n , count , cost ) { if ( count == n && graph [ currPos ] [ 0 ] ) { ans = Math . min ( ans , cost + graph [ currPos ] [ 0 ] ) ; return ; } for ( var i = 0 ; i < n ; i ++ ) { if ( ! v [ i ] && graph [ currPos ] [ i ] ) { v [ i ] = true ; tsp ( graph , i , n , count + 1 , cost + graph [ currPos ] [ i ] ) ; v [ i ] = false ; } } } ; var n = 4 ; var graph = [ [ 0 , 10 , 15 , 20 ] , [ 10 , 0 , 35 , 25 ] , [ 15 , 35 , 0 , 30 ] , [ 20 , 25 , 30 , 0 ] ] ; var v = Array ( n ) . fill ( false ) ; v [ 0 ] = true ; tsp ( graph , 0 , n , 1 , 0 ) ; document . write ( ans ) ;";"Travelling Salesman Problem implementation using BackTracking | Javascript implementation of the approach ; Function to find the minimum weight Hamiltonian Cycle ; If last node is reached and it has a link to the starting node i . e the source then keep the minimum value out of the total cost of traversal and "" ans "" Finally return to check for more possible values ; BACKTRACKING STEP Loop to traverse the adjacency list of currPos node and increasing the count by 1 and cost by graph [ currPos ] [ i ] value ; Mark as visited ; Mark ith node as unvisited ; n is the number of nodes i . e . V ; Boolean array to check if a node has been visited or not ; Mark 0 th node as visited ; Find the minimum weight Hamiltonian Cycle ; ans is the minimum weight Hamiltonian Cycle"
Javascript;"function printTheArray ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { document . write ( arr [ i ] + "" "" ) ; } document . write ( "" "" ) ; } function generateAllBinaryStrings ( n , arr , i ) { if ( i == n ) { printTheArray ( arr , n ) ; return ; } arr [ i ] = 0 ; generateAllBinaryStrings ( n , arr , i + 1 ) ; arr [ i ] = 1 ; generateAllBinaryStrings ( n , arr , i + 1 ) ; } let n = 4 ; let arr = new Array ( n ) ; arr . fill ( 0 ) ; generateAllBinaryStrings ( n , arr , 0 ) ;";"Generate all the binary strings of N bits | Function to print the output ; Function to generate all binary strings ; First assign ""0"" at ith position and try for all other permutations for remaining positions ; And then assign ""1"" at ith position and try for all other permutations for remaining positions ; Driver Code ; Print all binary strings"
Javascript;"function printResult ( result , len ) { for ( var i = 0 ; i <= len ; i ++ ) document . write ( result [ i ] ) ; document . write ( "" "" ) ; } function stringCombination ( result , str , count , level , size , len ) { if ( level === size ) return ; for ( var i = 0 ; i < len ; i ++ ) { if ( count [ i ] === 0 ) continue ; count [ i ] -- ; result [ level ] = str [ i ] ; printResult ( result , level ) ; stringCombination ( result , str , count , level + 1 , size , len ) ; count [ i ] ++ ; } } function combination ( str ) { var i ; var mp = { } ; for ( i = 0 ; i < str . length ; i ++ ) if ( mp . hasOwnProperty ( str [ i ] ) ) mp [ str [ i ] ] = mp [ str [ i ] ] + 1 ; else mp [ str [ i ] ] = 1 ; var input = new Array ( Object . keys ( mp ) . length ) . fill ( 0 ) ; var count = new Array ( Object . keys ( mp ) . length ) . fill ( 0 ) ; var result = new Array ( str . length ) . fill ( 0 ) ; i = 0 ; for ( const [ key , value ] of Object . entries ( mp ) ) { input [ i ] = key ; count [ i ] = value ; i ++ ; } var len = Object . keys ( mp ) . length ; var size = str . length ; stringCombination ( result , input , count , 0 , size , len ) ; } var str = "" "" ; combination ( str ) ;";"Print all the combinations of a string in lexicographical order | function to print string ; Method to found all combination of string it is based in tree ; return if level is equal size of string ; if occurrence of char is 0 then skip the iteration of loop ; decrease the char occurrence by 1 ; store the char in result ; print the string till level ; call the function from level + 1 ; backtracking ; declare the map for store each char with occurrence ; initialize the input array with all unique char ; initialize the count array with occurrence the unique char ; temporary char array for store the result ; store the element of input array ; store the element of count array ; size of map ( no of unique char ) ; size of original string ; call function for print string combination ; Driver code"
Javascript;"function fillUtil ( res , curr , n ) { if ( curr == 0 ) return true ; let i ; for ( i = 0 ; i < 2 * n - curr - 1 ; i ++ ) { if ( res [ i ] == 0 && res [ i + curr + 1 ] == 0 ) { res [ i ] = res [ i + curr + 1 ] = curr ; if ( fillUtil ( res , curr - 1 , n ) ) return true ; res [ i ] = res [ i + curr + 1 ] = 0 ; } } return false ; } function fill ( n ) { let res = new Array ( 2 * n ) ; let i ; for ( i = 0 ; i < ( 2 * n ) ; i ++ ) res [ i ] = 0 ; if ( fillUtil ( res , n , n ) ) { for ( i = 0 ; i < 2 * n ; i ++ ) document . write ( res [ i ] + "" "" ) ; } else document . write ( "" "" ) ; } fill ( 7 ) ;";"Fill two instances of all numbers from 1 to n in a specific way | A recursive utility function to fill two instances of numbers from 1 to n in res [ 0. .2 n - 1 ] . ' curr ' is current value of n . ; If current number becomes 0 , then all numbers are filled ; Try placing two instances of ' curr ' at all possible locations till solution is found ; Two ' curr ' should be placed at ' curr + 1' distance ; Plave two instances of ' curr ' ; Recur to check if the above placement leads to a solution ; If solution is not possible , then backtrack ; This function prints the result for input number ' n ' using fillUtil ( ) ; Create an array of size 2 n and initialize all elements in it as 0 ; If solution is possible , then print it . ; Driver Code"
Javascript;"class node { constructor ( ) { this . color = 1 ; this . edges = new Set ( ) ; } } ; function canPaint ( nodes , n , m ) { var visited = [ ] ; for ( var i = 0 ; i < n + 1 ; i ++ ) { visited . push ( 0 ) ; } var maxColors = 1 ; for ( var sv = 1 ; sv <= n ; sv ++ ) { if ( visited [ sv ] > 0 ) continue ; visited [ sv ] = 1 ; var q = [ ] ; q . push ( sv ) ; while ( q . length != 0 ) { var top = q [ 0 ] ; q . shift ( ) ; for ( var it of nodes [ top ] . edges ) { if ( nodes [ top ] . color == nodes [ it ] . color ) nodes [ it ] . color += 1 ; maxColors = Math . max ( maxColors , Math . max ( nodes [ top ] . color , nodes [ it ] . color ) ) ; if ( maxColors > m ) return 0 ; if ( visited [ it ] == 0 ) { visited [ it ] = 1 ; q . push ( it ) ; } } } } return 1 ; } var n = 4 ; var graph = [ [ 0 , 1 , 1 , 1 ] , [ 1 , 0 , 1 , 0 ] , [ 1 , 1 , 0 , 1 ] , [ 1 , 0 , 1 , 0 ] ] ; var m = 3 ; var nodes = [ ] ; for ( var i = 0 ; i < n + 1 ; i ++ ) { nodes . push ( new node ( ) ) ; } for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < n ; j ++ ) { if ( graph [ i , j ] > 0 ) { nodes [ i ] . edges . push ( i ) ; nodes [ j ] . edges . push ( j ) ; } } } document . write ( canPaint ( nodes , n , m ) ) ;";"m Coloring Problem | Backtracking | Javascript program for the above approach ; A node class which stores the color and the edges connected to the node ; Create a visited array of n nodes , initialized to zero ; maxColors used till now are 1 as all nodes are painted color 1 ; Do a full BFS traversal from all unvisited starting points ; If the starting point is unvisited , mark it visited and push it in queue ; BFS Travel starts here ; Checking all adjacent nodes to "" top "" edge in our queue ; IMPORTANT : If the color of the adjacent node is same , increase it by 1 ; If number of colors used shoots m , return 0 ; If the adjacent node is not visited , mark it visited and push it in queue ; Driver code ; Number of colors ; Create a vector of n + 1 nodes of type "" node "" The zeroth position is just dummy ( 1 to n to be used ) ; Push edges to each node as per given input ; Connect the undirected graph ; Display final answer"
Javascript;"let a , b , c , d ; let MOD = 1000000007 ; function FastDoubling ( n , res ) { if ( n == 0 ) { res [ 0 ] = 0 ; res [ 1 ] = 1 ; return ; } FastDoubling ( parseInt ( n / 2 , 10 ) , res ) ; a = res [ 0 ] ; b = res [ 1 ] ; c = 2 * b - a ; if ( c < 0 ) c += MOD ; c = ( a * c ) % MOD ; d = ( a * a + b * b ) % MOD ; if ( n % 2 == 0 ) { res [ 0 ] = c ; res [ 1 ] = d ; } else { res [ 0 ] = d ; res [ 1 ] = c + d ; } } let N = 6 ; let res = new Array ( 2 ) ; res . fill ( 0 ) ; FastDoubling ( N , res ) ; document . write ( res [ 0 ] ) ;";"Fast Doubling method to find the Nth Fibonacci number | Javascript program to find the Nth Fibonacci number using Fast Doubling Method ; Function calculate the N - th fibanacci number using fast doubling method ; Base Condition ; Here a = F ( n ) ; Here b = F ( n + 1 ) ; As F ( 2 n ) = F ( n ) [ 2F ( n + 1 ) F ( n ) ] Here c = F ( 2 n ) ; As F ( 2 n + 1 ) = F ( n ) ^ 2 + F ( n + 1 ) ^ 2 Here d = F ( 2 n + 1 ) ; Check if N is odd or even ; Driver code"
Javascript;"function count ( arr , low , high , x ) { if ( ( low > high ) || ( low == high && arr [ low ] != x ) ) return 0 ; if ( low == high && arr [ low ] == x ) return 1 ; return count ( arr , low , Math . floor ( ( low + high ) / 2 ) , x ) + count ( arr , 1 + Math . floor ( ( low + high ) / 2 ) , high , x ) ; } let arr = [ 30 , 1 , 42 , 5 , 56 , 3 , 56 , 9 ] ; let n = arr . length ; let x = 56 ; document . write ( count ( arr , 0 , n - 1 , x ) ) ;";"Frequency of an integer in the given array using Divide and Conquer | Function to return the frequency of x in the subarray arr [ low ... high ] ; If the subarray is invalid or the element is not found ; If there 's only a single element  which is equal to x ; Divide the array into two parts and then find the count of occurrences of x in both the parts ; Driver code"
Javascript;"function firstDigit ( n ) { while ( n >= 10 ) { n = parseInt ( n / 10 , 10 ) ; } return n ; } function getCount ( n ) { let count = 1 ; while ( n != 0 ) { let leadDigit = firstDigit ( n ) ; n -= leadDigit ; count ++ ; } return count ; } function getLargestNumber ( k ) { let left = k ; let right = k * 10 ; let mid = parseInt ( ( left + right ) / 2 , 10 ) ; let len = getCount ( mid ) ; while ( len != k ) { mid = parseInt ( ( left + right ) / 2 , 10 ) ; len = getCount ( mid ) ; if ( len > k ) { right = mid ; } else { left = mid ; } } while ( len == k ) { if ( len != getCount ( mid + 1 ) ) { break ; } mid ++ ; } return ( mid ) ; } let k = 3 ; document . write ( getLargestNumber ( k ) ) ;";"Largest number N which can be reduced to 0 in K steps | Utility function to return the first digit of a number . ; Remove last digit from number till only one digit is left ; return the first digit ; Utility function that returns the count of numbers written down when starting from n ; Function to find the largest number N which can be reduced to 0 in K steps ; Get the sequence length of the mid point ; Until k sequence length is reached ; Update mid point ; Get count of the new mid point ; Update right to mid ; Update left to mid ; Increment mid point by one while count is equal to k to get the maximum value of mid point ; Driver Code"
Javascript;"string checkReachability ( int N , int X , int Y ) { if ( X == 0 && Y == 0 ) { return "" "" ; } if ( N % 2 == 0 ) { return "" "" ; } else { if ( X % 2 != Y % 2 ) { return "" "" ; } else { return "" "" ; } } } let N = 2 , X = 5 , Y = 4 ; document . write ( checkReachability ( N , X , Y ) ) ;";"Check if point ( X , Y ) can be reached from origin ( 0 , 0 ) with jump of 1 and N perpendicularly simultaneously | Function to check if ( X , Y ) is reachable from ( 0 , 0 ) using the jumps of given type ; Case where source & destination are the same ; Check for even N ( X , Y ) is reachable or not ; If N is odd and parity of X and Y is different return , no valid sequence of jumps exist ; Driver Code"
Javascript;"function closestsAngle ( N , A ) { let mi = Number . MAX_VALUE ; let ans = 0 ; for ( let i = 1 ; i < N - 1 ; i ++ ) { let angle = 180.0 * i / N ; if ( Math . abs ( angle - A ) < Math . abs ( mi - A ) ) { mi = angle ; ans = i ; } } document . write ( 2 + ' ' + 1 + ' ' + parseInt ( 2 + ans ) ) ; } let N = 3 , A = 15 ; closestsAngle ( N , A ) ;";"Find three vertices in an N | Function to find three vertices that subtends an angle closest to A ; Stores the closest angle to A ; Stores the count of edge which subtend an angle of A ; Iterate in the range [ 1 , N - 2 ] ; Stores the angle subtended ; If absolute ( angle - A ) is less than absolute ( mi - A ) ; Update angle to mi , and also update i to ans ; Print the vertices ; Driver Code"
Javascript;"function areaOftriangle ( side ) { let a = Math . sqrt ( Math . pow ( side / 2 , 2 ) + Math . pow ( side / 2 , 2 ) ) ; let b = Math . sqrt ( Math . pow ( side , 2 ) + Math . pow ( side / 2 , 2 ) ) ; let c = Math . sqrt ( Math . pow ( side , 2 ) + Math . pow ( side / 2 , 2 ) ) ; let s = ( a + b + c ) / 2 ; let area = Math . sqrt ( s * ( s - a ) * ( s - b ) * ( s - c ) ) ; return area . toFixed ( 1 ) ; } let N = 10 ; document . write ( areaOftriangle ( N ) ) ;";"Area of a triangle with two vertices at midpoints of opposite sides of a square and the other vertex lying on vertex of a square | Function to find the area of the triangle that inscribed in square ; Stores the length of the first side of triangle ; Stores the length of the second side of triangle ; Stores the length of the third side of triangle ; Stores the area of the triangle ; Return the resultant area ; Driver code"
Javascript;"function findLine ( distance , degree ) { let x = degree * 3.14159 / 180 ; if ( degree > 90 ) { document . write ( "" "" ) ; return ; } let result_1 = Math . sin ( x ) ; let result_2 = Math . cos ( x ) ; document . write ( result_2 . toPrecision ( 2 ) + "" "" + result_1 . toPrecision ( 2 ) + "" "" + distance ) ; } let D = 10 ; let A = 30 ; findLine ( D , A ) ;";"Equation of a straight line with perpendicular distance D from origin and an angle A between the perpendicular from origin and x | Function to find equation of a line whose distance from origin and angle made by the perpendicular from origin with x - axis is given ; Convert angle from degree to radian ; Handle the special case ; Calculate the sin and cos of angle ; Print the equation of the line ; Given Input ; Function Call"
Javascript;"function centralPoints ( arr , N ) { let count = 0 ; let c1 , c2 , c3 , c4 ; for ( let i = 0 ; i < N ; i ++ ) { c1 = 0 ; c2 = 0 ; c3 = 0 ; c4 = 0 ; let x = arr [ i ] [ 0 ] ; let y = arr [ i ] [ 1 ] ; for ( let j = 0 ; j < N ; j ++ ) { if ( arr [ j ] [ 0 ] > x && arr [ j ] [ 1 ] == y ) { c1 = 1 ; } if ( arr [ j ] [ 1 ] > y && arr [ j ] [ 0 ] == x ) { c2 = 1 ; } if ( arr [ j ] [ 0 ] < x && arr [ j ] [ 1 ] == y ) { c3 = 1 ; } if ( arr [ j ] [ 1 ] < y && arr [ j ] [ 0 ] == x ) { c4 = 1 ; } } if ( c1 + c2 + c3 + c4 == 4 ) { count ++ ; } } return count ; } let arr = [ [ 1 , 0 ] , [ 2 , 0 ] , [ 1 , 1 ] , [ 1 , - 1 ] ] ; let N = arr . length ; document . write ( centralPoints ( arr , N ) ) ;";"Count number of coordinates from an array satisfying the given conditions | Function to count the number of coordinates from a given set that satisfies the given conditions ; Stores the count of central points ; Store the count of each x and y coordinates ; Find all possible pairs ; Initialize variables c1 , c2 , c3 , c4 to define the status of conditions ; Stores value of each point ; Check the conditions for each point by generating all possible pairs ; If arr [ j ] [ 0 ] > x and arr [ j ] [ 1 ] == y ; If arr [ j ] [ 0 ] < x and arr [ j ] [ 1 ] = = y ; If arr [ j ] [ 1 ] > y and arr [ j ] [ 0 ] == x ; If arr [ j ] [ 1 ] < y and arr [ j ] [ 0 ] = = x ; If all conditions satisfy then point is central point ; Increment the count by 1 ; Return the count ; Driver Code"
Javascript;"function finalPosition ( a , b , M ) { let n = 0 , s = 0 , e = 0 , w = 0 ; let p = ' ' ; for ( let i = 0 ; i < M ; i ++ ) { if ( p == ' ' ) { if ( a [ i ] == ' ' ) { p = ' ' ; n = n + b [ i ] ; } else if ( a [ i ] == ' ' ) { p = ' ' ; s = s + b [ i ] ; } else if ( a [ i ] == ' ' ) { p = ' ' ; e = e + b [ i ] ; } else if ( a [ i ] == ' ' ) { p = ' ' ; w = w + b [ i ] ; } } else if ( p == ' ' ) { if ( a [ i ] == ' ' ) { p = ' ' ; s = s + b [ i ] ; } else if ( a [ i ] == ' ' ) { p = ' ' ; n = n + b [ i ] ; } else if ( a [ i ] == ' ' ) { p = ' ' ; w = w + b [ i ] ; } else if ( a [ i ] == ' ' ) { p = ' ' ; e = e + b [ i ] ; } } else if ( p == ' ' ) { if ( a [ i ] == ' ' ) { p = ' ' ; e = e + b [ i ] ; } else if ( a [ i ] == ' ' ) { p = ' ' ; w = w + b [ i ] ; } else if ( a [ i ] == ' ' ) { p = ' ' ; s = s + b [ i ] ; } else if ( a [ i ] == ' ' ) { p = ' ' ; n = n + b [ i ] ; } } else if ( p == ' ' ) { if ( a [ i ] == ' ' ) { p = ' ' ; w = w + b [ i ] ; } else if ( a [ i ] == ' ' ) { p = ' ' ; e = e + b [ i ] ; } else if ( a [ i ] == ' ' ) { p = ' ' ; n = n + b [ i ] ; } else if ( a [ i ] == ' ' ) { p = ' ' ; s = s + b [ i ] ; } } } let ver_disp = n - s ; let hor_disp = e - w ; let displacement = Math . ceil ( Math . sqrt ( ( ver_disp * ver_disp ) + ( hor_disp * hor_disp ) ) ) ; document . write ( displacement + "" "" + p ) ; } let A = [ ' ' , ' ' , ' ' , ' ' , ' ' ] ; let B = [ 1 , 1 , 1 , 1 , 0 ] ; let N = 1 ; finalPosition ( A , B , N ) ;";"Displacement from origin after N moves of given distances in specified directions | Function to find the displacement from the origin and direction after performing the given set of moves ; Stores the distances travelled in the directions North , South , East , and West respectively ; Store the initial position of robot ; Traverse the array B [ ] ; If the current direction is North ; If the current direction is South ; If the current direction is East ; If the current direction is West ; Stores the total vertical displacement ; Stores the total horizontal displacement ; Find the displacement ; Print the displacement and direction after N moves ; Driver Code"
Javascript;"function lengthOfLatusRectum ( A , B ) { var major = 2.0 * A ; var minor = 2.0 * B ; var latus_rectum = ( minor * minor ) / major ; return latus_rectum ; } var A = 3.0 , B = 2.0 ; document . write ( lengthOfLatusRectum ( A , B ) ) ;";"Program to find Length of Latus Rectum of an Ellipse | Function to calculate the length of the latus rectum of an ellipse ; Length of major axis ; Length of minor axis ; Length of the latus rectum ; Given lengths of semi - major and semi - minor axis ; Function call to calculate length of the latus rectum of a ellipse"
Javascript;"function coneSlantHeight ( cone_h , cone_r ) { var slant_height_cone = Math . sqrt ( Math . pow ( cone_h , 2 ) + Math . pow ( cone_r , 2 ) ) ; document . write ( "" "" + slant_height_cone + "" "" ) ; } function pyramidSlantHeight ( pyramid_h , pyramid_s ) { var slant_height_pyramid = Math . sqrt ( Math . pow ( pyramid_s / 2 , 2 ) + Math . pow ( pyramid_h , 2 ) ) ; document . write ( "" "" + slant_height_pyramid . toFixed ( 5 ) ) ; } var H1 = 4.5 , R = 6 ; coneSlantHeight ( H1 , R ) ; var H2 = 4 , S = 4.8 ; pyramidSlantHeight ( H2 , S ) ;";"Program to find slant height of cone and pyramid | Function to calculate slant height of a cone ; Store the slant height of cone ; Print the result ; Function to find the slant height of a pyramid ; Store the slant height of pyramid ; Print the result ; Dimensions of Cone ; Function Call for slant height of Cone ; Dimensions of Pyramid ; Function to calculate slant height of a pyramid"
Javascript;"function distance ( x1 , y1 , x2 , y2 ) { return Math . sqrt ( ( x2 - x1 ) * ( x2 - x1 ) + ( y2 - y1 ) * ( y2 - y1 ) ) ; } function lengthOfLatusRectum ( a , b , c ) { let vertex = [ ( - b / ( 2 * a ) ) , ( ( ( 4 * a * c ) - ( b * b ) ) / ( 4 * a ) ) ] ; let focus = [ ( - b / ( 2 * a ) ) , ( ( ( 4 * a * c ) - ( b * b ) + 1 ) / ( 4 * a ) ) ] ; document . write ( ( 4 * distance ( focus [ 0 ] , focus [ 1 ] , vertex [ 0 ] , vertex [ 1 ] ) ) . toFixed ( 6 ) ) ; } let a = 3 , b = 5 , c = 1 ; lengthOfLatusRectum ( a , b , c ) ;";"Program to find the length of Latus Rectum of a Parabola | Function to calculate distance between two points ; Calculating distance ; Function to calculate length of the latus rectum of a parabola ; Stores the co - ordinates of the vertex of the parabola ; Stores the co - ordinates of the focus of parabola ; Print the distance between focus and vertex ; Given a , b & c ; Function call"
Javascript;"function ConvertDegToRad ( degree ) { let pi = 3.14159 ; return ( degree * ( pi / 180.0 ) ) ; } function ConvertToCartesian ( polar ) { polar [ 1 ] = ConvertDegToRad ( polar [ 1 ] ) ; let cartesian = [ polar [ 0 ] * Math . cos ( polar [ 1 ] ) , polar [ 0 ] * Math . sin ( polar [ 1 ] ) ] ; document . write ( ( cartesian [ 0 ] ) . toFixed ( 3 ) + "" "" + ( cartesian [ 1 ] ) . toFixed ( 3 ) ) ; } let polar = [ 1.4142 , 45 ] ; ConvertToCartesian ( polar ) ;";"Program to convert polar co | Function to convert degree to radian ; Function to convert the polar coordinate to cartesian ; Convert degerees to radian ; Applying the formula : x = rcos ( theata ) , y = rsin ( theta ) ; Print cartesian coordinates ; Given polar coordinates ; Function to convert polar coordinates to equivalent cartesian coordinates"
Javascript;"function distance ( p1 , p2 ) { var x1 = p1 [ 0 ] , x2 = p2 [ 0 ] ; var y1 = p1 [ 1 ] , y2 = p2 [ 1 ] ; return Math . sqrt ( Math . pow ( x2 - x1 , 2 ) + Math . pow ( y2 - y1 , 2 ) * 1.0 ) ; } function find_orthocenter ( A , B , C ) { var AB = distance ( A , B ) ; var BC = distance ( B , C ) ; var CA = distance ( C , A ) ; if ( AB > BC && AB > CA ) return C ; if ( BC > AB && BC > CA ) return A ; return B ; } function find_circumcenter ( A , B , C ) { var AB = distance ( A , B ) ; var BC = distance ( B , C ) ; var CA = distance ( C , A ) ; if ( AB > BC && AB > CA ) return [ Math . floor ( ( A [ 0 ] + B [ 0 ] ) / 2 ) , Math . floor ( ( A [ 1 ] + B [ 1 ] ) / 2 ) ] ; if ( BC > AB && BC > CA ) return [ Math . floor ( ( B [ 0 ] + C [ 0 ] ) / 2 ) , Math . floor ( ( B [ 1 ] + C [ 1 ] ) / 2 ) ] ; return [ Math . floor ( ( C [ 0 ] + A [ 0 ] ) / 2 ) , Math . floor ( ( C [ 1 ] + A [ 1 ] ) / 2 ) ] ; } function findDistance ( A , B , C ) { circumcenter = find_circumcenter ( A , B , C ) ; orthocenter = find_orthocenter ( A , B , C ) ; var distance_between = distance ( circumcenter , orthocenter ) ; document . write ( distance_between + "" "" ) ; } var A , B , C ; A = [ 0 , 0 ] ; B = [ 6 , 0 ] ; C = [ 0 , 8 ] ; findDistance ( A , B , C ) ;";"Distance between orthocenter and circumcenter of a right | Function to calculate Euclidean distance between the points p1 and p2 ; Stores x coordinates of both points ; Stores y coordinates of both points ; Return the Euclid distance using distance formula ; Function to find orthocenter of the right angled triangle ; Find the length of the three sides ; Orthocenter will be the vertex opposite to the largest side ; Function to find the circumcenter of right angle triangle ; Circumcenter will be located at center of hypotenuse ; If AB is the hypotenuse ; If BC is the hypotenuse ; If AC is the hypotenuse ; Function to find distance between orthocenter and circumcenter ; Find circumcenter ; Find orthocenter ; Find the distance between the orthocenter and circumcenter ; Print distance between orthocenter and circumcenter ; Driver Code ; Given coordinates A , B , and C ; Function Call"
Javascript;"function noOfTriangles ( n ) { return Math . floor ( n * ( n + 2 ) * ( 2 * n + 1 ) / 8 ) ; } var n = 3 ; document . write ( noOfTriangles ( n ) ) ;";"Count triangles required to form a House of Cards of height N | Function to find the number of triangles ; Driver Code ; Function call"
Javascript;"function findNumberOfDigits ( n , base ) { var dig = ( Math . floor ( Math . log ( n ) / Math . log ( base ) ) + 1 ) ; return ( dig ) ; } function isAllKs ( n , b , k ) { var len = findNumberOfDigits ( n , b ) ; var sum = k * ( 1 - Math . pow ( b , len ) ) / ( 1 - b ) ; if ( sum == n ) { return ( sum ) ; } } var N = 13 ; var B = 3 ; var K = 1 ; if ( isAllKs ( N , B , K ) ) { document . write ( "" "" ) ; } else { document . write ( "" "" ) ; }";"Check if N contains all digits as K in base B | Function to print the number of digits ; Calculate log using base change property and then take its floor and then add 1 ; Return the output ; Function that returns true if n contains all one 's in base b ; Calculate the sum ; Given number N ; Given base B ; Given digit K ; Function call"
Javascript;"function checkRightAngled ( X1 , Y1 , X2 , Y2 , X3 , Y3 ) { var A = Math . pow ( X2 - X1 , 2 ) + Math . pow ( Y2 - Y1 , 2 ) ; var B = Math . pow ( X3 - X2 , 2 ) + Math . pow ( Y3 - Y2 , 2 ) ; var C = Math . pow ( X3 - X1 , 2 ) + Math . pow ( Y3 - Y1 , 2 ) ; if ( A > 0 && B > 0 && C > 0 && ( A === B + C B === A + C C === A + B ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ; } var X1 = 0 , Y1 = 2 ; var X2 = 0 , Y2 = 14 ; var X3 = 9 , Y3 = 2 ; checkRightAngled ( X1 , Y1 , X2 , Y2 , X3 , Y3 ) ;";"Check if a right | Function to check if right - angled triangle can be formed by the given coordinates ; Calculate the sides ; Check Pythagoras Formula ; Driver Code"
Javascript;"function createPrefixArray ( n , arr , prefSize , pref ) { for ( let i = 0 ; i < prefSize ; i ++ ) { pref [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { let x = arr [ i ] + 1000000 ; pref [ x ] ++ ; } for ( let i = 1 ; i < prefSize ; i ++ ) { pref [ i ] += pref [ i - 1 ] ; } } function poletsOfLetersection ( m , segments , size , pref ) { let ans = 0 ; for ( let i = 0 ; i < m ; i ++ ) { let x1 = segments [ i ] [ 0 ] ; let x2 = segments [ i ] [ 2 ] ; x1 = x1 + 1000000 ; x2 = x2 + 1000000 ; if ( x1 != x2 ) { if ( x1 > x2 ) { let temp = x1 ; x1 = x2 ; x2 = temp ; } let Occ_Till_Right = pref [ x2 - 1 ] ; let Occ_Till_Left = pref [ x1 ] ; ans = ans + ( Occ_Till_Right - Occ_Till_Left ) ; } } return ans ; } let N = 4 ; let M = 8 ; let size = 2000000 + 2 ; let pref = Array . from ( { length : size } , ( _ , i ) => 0 ) ; let lines = [ - 5 , - 3 , 2 , 3 ] ; let segments = [ [ - 2 , 5 , 5 , - 6 ] , [ - 5 , - 2 , - 3 , - 5 ] , [ - 2 , 3 , - 6 , 1 ] , [ - 1 , - 3 , 4 , 2 ] , [ 2 , 5 , 2 , 1 ] , [ 4 , 5 , 4 , - 5 ] , [ - 2 , - 4 , 5 , 3 ] , [ 1 , 2 , - 2 , 1 ] ] ; createPrefixArray ( N , lines , size , pref ) ; document . write ( poletsOfLetersection ( M , segments , size , pref ) + "" "" ) ;";"Count of intersections of M line segments with N vertical lines in XY plane | Function to create prefix sum array ; Initialize the prefix array to remove garbage values ; Marking the occurences of vertical lines ; x is the value after Index mapping ; Creating the prefix array ; Function returns the count of total letersection ; ans is the number of polets of letersection of the line segments with the vertical lines ; Index mapping ; We don 't consider a vertical  line segment because even if  it falls on a verticale line  then it just touches it and  not letersects. ; We have assumed that x1 will be left and x2 right but if not then we just swap them ; N is the number of vertical lines M is the number of line segments ; Format : x1 , y1 , x2 , y1 ; First create the prefix array ; Prlet the total number of letersections"
Javascript;"function count_rectangles ( N , M ) { let p_x = ( N * ( N - 1 ) ) / 2 ; let p_y = ( M * ( M - 1 ) ) / 2 ; return p_x * p_y ; } let N = 3 ; let M = 6 ; document . write ( count_rectangles ( N , M ) ) ;";"Count of rectangles possible from N and M straight lines parallel to X and Y axis respectively | Function to calculate number of rectangles ; Total number of ways to select two lines parallel to X axis ; Total number of ways to select two lines parallel to Y axis ; Total number of rectangles ; Driver Code"
Javascript;"var PI = 3.14 ; function calculateAngle ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) { var ABx = x1 - x2 ; var ABy = y1 - y2 ; var ABz = z1 - z2 ; var BCx = x3 - x2 ; var BCy = y3 - y2 ; var BCz = z3 - z2 ; var dotProduct = ABx * BCx + ABy * BCy + ABz * BCz ; var magnitudeAB = ABx * ABx + ABy * ABy + ABz * ABz ; var magnitudeBC = BCx * BCx + BCy * BCy + BCz * BCz ; var angle = dotProduct ; angle /= Math . sqrt ( magnitudeAB * magnitudeBC ) ; angle = ( angle * 180 ) / PI ; document . write ( Math . abs ( angle ) . toFixed ( 4 ) ) ; } var x1 = 1 , y1 = 3 , z1 = 3 ; var x2 = 3 , y2 = 4 , z2 = 5 ; var x3 = 5 , y3 = 6 , z3 = 9 ; calculateAngle ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 ) ;";"Angle between a Pair of Lines in 3D | Javascript program for the above approach ; Function to find the angle between the two lines ; Find direction ratio of line AB ; Find direction ratio of line BC ; Find the dotProduct of lines AB & BC ; Find magnitude of line AB and BC ; Find the cosine of the angle formed by line AB and BC ; Find angle in radian ; Prvar the angle ; Given coordinates Povars A ; Povars B ; Povars C ; Function Call"
Javascript;"function calcAngle ( h , m ) { if ( h < 0 m < 0 h > 12 m > 60 ) document . write ( "" "" ) ; if ( h == 12 ) h = 0 ; if ( m == 60 ) m = 0 ; var hour_angle = 0.5 * ( h * 60 + m ) ; var minute_angle = 6 * m ; var angle = Math . abs ( hour_angle - minute_angle ) ; angle = Math . min ( 360 - angle , angle ) ; return angle ; } function cal_cos ( n ) { var accuracy = 0.0001 , x1 , denominator , cosx , cosval ; n = n * ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = Math . cos ( n ) ; var i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= Math . abs ( cosval - cosx ) ) ; return cosx ; } function distanceEndpoints ( a , b , c ) { var angle = cal_cos ( c ) ; return Math . sqrt ( ( a * a ) + ( b * b ) - 2 * a * b * angle ) ; } var hour = 3 ; var min = 30 ; var hourHand = 3 ; var minHand = 4 ; var angle = calcAngle ( hour , min ) ; var distance = distanceEndpoints ( minHand , hourHand , angle ) ; document . write ( distance . toFixed ( 5 ) ) ;";"Distance between end points of Hour and minute hand at given time | Function to find the angle between Hour hand and minute hand ; Validate the input ; Calculate the angles moved by hour and minute hands with reference to 12 : 00 ; Find the difference between two angles ; Return the smaller angle of two possible angles ; Function to calculate cos value of angle c ; Converting degrees to radian ; Maps the sum along the series ; Holds the actual value of sin ( n ) ; Function to distance between the endpoints of the hour and minute hand ; Time ; Length of hour hand ; Length of minute hand ; calling Function for finding angle between hour hand and minute hand ; Function for finding distance between end points of minute hand and hour hand"
Javascript;"function Pentadecagonal_num ( n ) { return ( 13 * n * n - 11 * n ) / 2 ; } let n = 3 ; document . write ( Pentadecagonal_num ( n ) + "" "" ) ; n = 10 ; document . write ( Pentadecagonal_num ( n ) ) ;";"Pentadecagonal Number | Function to find N - th Pentadecagonal number ; Formula to calculate nth Pentadecagonal number ; Driver code"
Javascript;"function Octadecagonal_num ( n ) { return ( 16 * n * n - 14 * n ) / 2 ; } let n = 3 ; document . write ( Octadecagonal_num ( n ) + "" "" ) ; n = 10 ; document . write ( Octadecagonal_num ( n ) ) ;";"Octadecagonal Number | Function to find N - th Octadecagonal number ; Formula to calculate nth Octadecagonal number ; Driver code"
Javascript;"function Icositrigonal_num ( n ) { return ( 21 * n * n - 19 * n ) / 2 ; } let n = 3 ; document . write ( Icositrigonal_num ( n ) + "" "" ) ; n = 10 ; document . write ( Icositrigonal_num ( n ) ) ;";"Icositrigonal Number | Function to find N - th Icositrigonal number ; Formula to calculate nth Icositrigonal number ; Driver code"
Javascript;"function solve ( n , m , obstacles , range ) { var val = Math . min ( n , m ) ; range . sort ( ( a , b ) => a - b ) var c = 1 ; for ( var i = obstacles - 1 ; i >= 0 ; i -- ) { range [ i ] = 2 * range [ i ] ; val -= range [ i ] ; if ( val <= 0 ) { return c ; } else { c ++ ; } } if ( val > 0 ) { return - 1 ; } } var n = 4 , m = 5 , obstacles = 3 ; var range = [ 1.0 , 1.25 , 1.15 ] ; document . write ( solve ( n , m , obstacles , range ) + "" "" ) ;";"Minimum number of Circular obstacles required to obstruct the path in a Grid | Function to find the minimum number of obstacles required ; Find the minimum range required to put obstacles ; Sorting the radius ; If val is less than zero then we have find the number of obstacles required ; Driver function"
Javascript;"function area ( d1 , a ) { var d2 = Math . sqrt ( 4 * ( a * a ) - d1 * d1 ) ; var area = 0.5 * d1 * d2 ; return area ; } var d = 7.07 ; var a = 5 ; document . write ( area ( d , a ) ) ;";"Program to calculate area of a rhombus whose one side and diagonal are given | function to calculate the area of the rhombus ; Second diagonal ; area of rhombus ; return the area ; Driver code"
Javascript;"function pointsAreOnSameSideOfLine ( a , b , c , x1 , y1 , x2 , y2 ) { fx1 = a * x1 + b * y1 - c ; fx2 = a * x2 + b * y2 - c ; if ( ( fx1 * fx2 ) > 0 ) return true ; return false ; } let a = 1 , b = 1 , c = 1 ; let x1 = 1 , y1 = 1 ; let x2 = 2 , y2 = 1 ; if ( pointsAreOnSameSideOfLine ( a , b , c , x1 , y1 , x2 , y2 ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check whether two points ( x1 , y1 ) and ( x2 , y2 ) lie on same side of a given line or not | Function to check if two points lie on the same side or not ; let fx1 ; Variable to store a * x1 + b * y1 - c let fx2 ; Variable to store a * x2 + b * y2 - c ; If fx1 and fx2 have same sign ; Driver code"
Javascript;"function newvol ( x ) { document . write ( "" "" + "" "" + ( Math . pow ( x , 3 ) / 10000 + 3 * x + ( 3 * Math . pow ( x , 2 ) ) / 100 ) + "" "" ) ; } let x = 10 ; newvol ( x ) ;";"Percentage increase in volume of the cube if a side of cube is increased by a given percentage | javascript program to find percentage increase in the volume of the cube if a side of cube is increased by a given percentage ; Driver code"
Javascript;"function findTriangles ( n ) { var num = n ; document . write ( num + "" "" ) ; document . write ( num * ( num - 4 ) * ( num - 5 ) / 6 ) ; } var n ; n = 6 ; findTriangles ( n ) ;";"Number of triangles formed by joining vertices of n | Function to find the number of triangles ; print the number of triangles having two side common ; print the number of triangles having no side common ; initialize the number of sides of a polygon"
Javascript;"function radius ( n , d ) { document . write ( "" "" + d / ( 2 * n - 2 ) ) ; } var d = 42 , n = 4 ; radius ( n , d ) ;";"Find the radii of the circles which are lined in a row , and distance between the centers of first and last circle is given | javascript program to find radii of the circles which are lined in a row and distance between the centers of first and last circle is given ; Driver code"
Javascript;"function radius ( n , d ) { document . write ( "" "" + d / ( n - 1 ) ) ; } var d = 42 , n = 4 ; radius ( n , d ) ;";"Find the side of the squares which are lined in a row , and distance between the centers of first and last square is given | javascript program to find side of the squares which are lined in a row and distance between the centers of first and last squares is given ; Driver code"
Javascript;"function findTriangles ( n ) { var num ; num = n * ( n - 4 ) ; document . write ( num ) ; } var n ; n = 6 ; findTriangles ( n ) ;";"Number of triangles formed by joining vertices of n | Function to find the number of triangles ; print the number of triangles ; initialize the number of sides of a polygon"
Javascript;"function diameter ( r ) { document . write ( "" "" + "" "" + 2 * r ) ; } var r = 4 ; diameter ( r ) ;";"Find the Diameter or Longest chord of a Circle | Function to find the longest chord ; Get the radius ; Find the diameter"
Javascript;"function getSlope ( m ) { return m ; } var m = 2 ; document . write ( getSlope ( m ) ) ;";"Slope of the line parallel to the line with the given slope | Function to return the slope of the line which is parallel to the line with the given slope ; Driver code"
Javascript;"function totalTriangles ( h , v ) { if ( h == 0 && v == 0 ) return 1 ; if ( h == 0 ) return ( ( v + 1 ) * ( v + 2 ) / 2 ) ; if ( v == 0 ) return ( h + 1 ) ; var total = ( h + 1 ) * ( ( v + 1 ) * ( v + 2 ) / 2 ) ; return total ; } var h = 2 , v = 2 ; document . write ( totalTriangles ( h , v ) ) ;";"Total number of triangles formed when there are H horizontal and V vertical lines | Function to return total triangles ; Only possible triangle is the given triangle ; If only vertical lines are present ; If only horizontal lines are present ; Return total triangles ; Driver code"
Javascript;"function sph ( r , R , h ) { if ( r < 0 && R < 0 && h < 0 ) return - 1 ; var x = r ; var V = ( ( 4 * 3.14 * Math . pow ( r , 3 ) ) / 3 ) ; return V ; } var r = 5 , R = 8 , h = 11 ; document . write ( sph ( r , R , h ) . toFixed ( 5 ) ) ;";"Largest sphere that can be inscribed in a right circular cylinder inscribed in a frustum | Function to find the biggest sphere ; the radii and height cannot be negative ; radius of the sphere ; volume of the sphere ; Driver code"
Javascript;"function checkOrtho ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) { let m1 , m2 ; if ( x2 - x1 == 0 && x4 - x3 == 0 ) return false ; else if ( x2 - x1 == 0 ) { m2 = parseInt ( ( y4 - y3 ) / ( x4 - x3 ) , 10 ) ; if ( m2 == 0 ) return true ; else return false ; } else if ( x4 - x3 == 0 ) { m1 = parseInt ( ( y2 - y1 ) / ( x2 - x1 ) , 10 ) ; if ( m1 == 0 ) return true ; else return false ; } else { m1 = parseInt ( ( y2 - y1 ) / ( x2 - x1 ) , 10 ) ; m2 = parseInt ( ( y4 - y3 ) / ( x4 - x3 ) , 10 ) ; if ( m1 * m2 == - 1 ) return true ; else return false ; } } let x1 = 0 , y1 = 4 , x2 = 0 , y2 = - 9 ; let x3 = 2 , y3 = 0 , x4 = - 1 , y4 = 0 ; if ( checkOrtho ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) == true ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check whether two straight lines are orthogonal or not | Function to check if two straight lines are orthogonal or not ; Both lines have infinite slope ; Only line 1 has infinite slope ; Only line 2 has infinite slope ; Find slopes of the lines ; Check if their product is - 1 ; Driver code"
Javascript;"function pentdiagonal ( a ) { if ( a < 0 ) return - 1 ; let d = 1.22 * a ; return d ; } let a = 6 ; document . write ( pentdiagonal ( a ) ) ;";"Diagonal of a Regular Pentagon | Function to find the diagonal of a regular pentagon ; Side cannot be negative ; Length of the diagonal ; Driver code"
Javascript;"function hexagonArea ( d ) { return ( 3 * Math . sqrt ( 3 ) * Math . pow ( d , 2 ) ) / 8 ; } let d = 10 ; document . write ( "" "" + hexagonArea ( d ) . toFixed ( 3 ) ) ;";"Area of hexagon with given diagonal length | Function to calculate area ; Formula to find area ; Driver Code"
Javascript;"function Squares ( n , m , a ) { return parseInt ( ( ( m + a - 1 ) / a ) ) * parseInt ( ( ( n + a - 1 ) / a ) ) ; } var n = 6 , m = 6 , a = 4 ; document . write ( Squares ( n , m , a ) ) ;";"Number of squares of side length required to cover an N * M rectangle | function to find a number of squares of a * a required to cover n * m rectangle ; Driver code ; Function call"
Javascript;"function octadiagonal ( a ) { if ( a < 0 ) return - 1 ; return a * Math . sqrt ( 4 + ( 2 * Math . sqrt ( 2 ) ) ) ; } var a = 4 ; document . write ( octadiagonal ( a ) . toFixed ( 5 ) ) ;";"Length of the Diagonal of the Octagon | Function to find the diagonal of the octagon ; side cannot be negative ; diagonal of the octagon ; Driver code"
Javascript;"function CalPeri ( ) { var S = 5 , Perimeter ; Perimeter = 10 * S ; document . write ( "" "" + Perimeter ) ; } CalPeri ( ) ;";"Program to Calculate the Perimeter of a Decagon | Function for finding the perimeter ; Driver code"
Javascript;"function findEdges ( s1 , s2 , s3 ) { let a = Math . sqrt ( s1 * s2 / s3 ) ; let b = Math . sqrt ( s3 * s1 / s2 ) ; let c = Math . sqrt ( s3 * s2 / s1 ) ; let sum = a + b + c ; return 4 * sum ; } let s1 , s2 , s3 ; s1 = 65 ; s2 = 156 ; s3 = 60 ; document . write ( findEdges ( s1 , s2 , s3 ) ) ;";"Sum of lengths of all 12 edges of any rectangular parallelepiped | function to find the sum of all the edges of parallelepiped ; to calculate the length of one edge ; sum of all the edges of one side ; net sum will be equal to the summation of edges of all the sides ; initialize the area of three faces which has a common vertex"
Javascript;"function findMaximumPieces ( n ) { var x = parseInt ( n / 2 ) ; return ( ( x + 1 ) * ( n - x + 1 ) ) ; } var n = 3 ; document . write ( "" "" + n + "" "" + findMaximumPieces ( 3 ) ) ;";"Maximum number of pieces in N cuts | Function for finding maximum pieces with n cuts . ; to maximize number of pieces x is the horizontal cuts ; Now ( x ) is the horizontal cuts and ( n - x ) is vertical cuts , then maximum number of pieces = ( x + 1 ) * ( n - x + 1 ) ; Taking the maximum number of cuts allowed as 3 ; Finding and printing the max number of pieces"
Javascript;"function equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x , y , z ) { var a1 = x2 - x1 ; var b1 = y2 - y1 ; var c1 = z2 - z1 ; var a2 = x3 - x1 ; var b2 = y3 - y1 ; var c2 = z3 - z1 ; var a = b1 * c2 - b2 * c1 ; var b = a2 * c1 - a1 * c2 ; var c = a1 * b2 - b1 * a2 ; var d = ( - a * x1 - b * y1 - c * z1 ) ; if ( a * x + b * y + c * z + d == 0 ) document . write ( "" "" ) ; else document . write ( "" "" ) ; } var x1 = 3 ; var y1 = 2 ; var z1 = - 5 ; var x2 = - 1 ; var y2 = 4 ; var z2 = - 3 ; var x3 = - 3 ; var y3 = 8 ; var z3 = - 5 ; var x4 = - 3 ; var y4 = 2 ; var z4 = 1 ; equation_plane ( x1 , y1 , z1 , x2 , y2 , z2 , x3 , y3 , z3 , x4 , y4 , z4 ) ;";"Program to check whether 4 points in a 3 | Function to find equation of plane . ; checking if the 4 th povar satisfies the above equation ; Driver Code ; function calling"
Javascript;"function distance ( a1 , b1 , c1 , a2 , b2 , c2 ) { var d = a1 * a2 + b1 * b2 + c1 * c2 ; var e1 = Math . sqrt ( a1 * a1 + b1 * b1 + c1 * c1 ) ; var e2 = Math . sqrt ( a2 * a2 + b2 * b2 + c2 * c2 ) ; d = parseFloat ( d / ( e1 * e2 ) ) ; var pi = 3.14159 ; var A = ( 180 / pi ) * Math . acos ( d ) ; document . write ( "" "" + A . toFixed ( 1 ) + "" "" ) ; } var a1 = 1 ; var b1 = 1 ; var c1 = 2 ; var d1 = 1 ; var a2 = 2 ; var b2 = - 1 ; var c2 = 1 ; var d2 = - 4 ; distance ( a1 , b1 , c1 , a2 , b2 , c2 ) ;";"Angle between two Planes in 3D | Function to find Angle ; Driver Code"
Javascript;"function mirror_point ( a , b , c , d , x1 , y1 , z1 ) { var k = parseFloat ( ( - a * x1 - b * y1 - c * z1 - d ) / parseFloat ( a * a + b * b + c * c ) ) ; var x2 = parseFloat ( a * k + x1 ) ; var y2 = parseFloat ( b * k + y1 ) ; var z2 = parseFloat ( c * k + z1 ) ; var x3 = parseFloat ( 2 * x2 - x1 ) . toFixed ( 1 ) ; var y3 = parseFloat ( 2 * y2 - y1 ) . toFixed ( 1 ) ; var z3 = parseFloat ( 2 * z2 - z1 ) . toFixed ( 1 ) ; document . write ( "" "" + x3 ) ; document . write ( "" "" + y3 ) ; document . write ( "" "" + z3 ) ; } var a = 1 ; var b = - 2 ; var c = 0 ; var d = 0 ; var x1 = - 1 ; var y1 = 3 ; var z1 = 4 ; mirror_point ( a , b , c , d , x1 , y1 , z1 ) ;";"Mirror of a point through a 3 D plane | Function to mirror image ; Driver Code ; function call"
Javascript;"function countRectangles ( radius ) { let rectangles = 0 ; let diameter = 2 * radius ; let diameterSquare = diameter * diameter ; for ( let a = 1 ; a < 2 * radius ; a ++ ) { for ( let b = 1 ; b < 2 * radius ; b ++ ) { let diagonalLengthSquare = ( a * a + b * b ) ; if ( diagonalLengthSquare <= diameterSquare ) { rectangles ++ ; } } } return rectangles ; } let radius = 2 ; let totalRectangles ; totalRectangles = countRectangles ( radius ) ; document . write ( totalRectangles + "" "" + radius ) ;";"Number of rectangles in a circle of radius R | Function to return the total possible rectangles that can be cut from the circle ; Diameter = 2 * $Radius ; Square of diameter which is the square of the maximum length diagonal ; generate all combinations of a and b in the range ( 1 , ( 2 * Radius - 1 ) ) ( Both inclusive ) ; Calculate the Diagonal length of this rectangle ; If this rectangle 's Diagonal  Length is less than the  Diameter, it is a valid  rectangle, thus increment counter ; Radius of the circle"
Javascript;"function simi_aaa ( a1 , a2 ) { a1 . sort ( function ( a , b ) { return a - b } ) ; a2 . sort ( function ( a , b ) { return a - b } ) ; if ( a1 [ 0 ] == a2 [ 0 ] && a1 [ 1 ] == a2 [ 1 ] && a1 [ 2 ] == a2 [ 2 ] ) return 1 ; else return 0 ; } function simi_sas ( s1 , s2 , a1 , a2 ) { a1 . sort ( function ( a , b ) { return a - b } ) ; a2 . sort ( function ( a , b ) { return a - b } ) ; s1 . sort ( function ( a , b ) { return a - b } ) ; s2 . sort ( function ( a , b ) { return a - b } ) ; if ( s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] ) { if ( a1 [ 2 ] == a2 [ 2 ] ) return 1 ; } if ( s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] ) { if ( a1 [ 0 ] == a2 [ 0 ] ) return 1 ; } if ( s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] ) { if ( a1 [ 1 ] == a2 [ 1 ] ) return 1 ; } return 0 ; } function simi_sss ( s1 , s2 ) { s1 . sort ( function ( a , b ) { return a - b } ) ; s2 . sort ( function ( a , b ) { return a - b } ) ; if ( s1 [ 0 ] / s2 [ 0 ] == s1 [ 1 ] / s2 [ 1 ] && s1 [ 1 ] / s2 [ 1 ] == s1 [ 2 ] / s2 [ 2 ] && s1 [ 2 ] / s2 [ 2 ] == s1 [ 0 ] / s2 [ 0 ] ) return 1 ; return 0 ; } let s1 = [ 2 , 3 , 3 ] ; let s2 = [ 4 , 6 , 6 ] ; let a1 = [ 80 , 60 , 40 ] ; let a2 = [ 40 , 60 , 80 ] ; let aaa = simi_aaa ( a1 , a2 ) ; let sss = simi_sss ( s1 , s2 ) ; let sas = simi_sas ( s1 , s2 , a1 , a2 ) ; if ( aaa == 1 sss == 1 sas == 1 ) { document . write ( "" "" + "" "" ) ; if ( aaa == 1 ) document . write ( "" "" ) ; if ( sss == 1 ) document . write ( "" "" ) ; if ( sas == 1 ) document . write ( "" "" ) ; } else document . write ( "" "" ) ;";"Program to check similarity of given two triangles | Function for AAA similarity ; Check for AAA ; Function for SAS similarity ; angle b / w two smallest sides is largest . ; since we take angle b / w the sides . ; Function for SSS similarity ; Check for SSS ; Driver Code ; function call for AAA similarity ; function call for SSS similarity ; function call for SAS similarity ; Check if triangles are similar or not"
Javascript;"function center_pentadecagonal_num ( n ) { return ( 15 * n * n - 15 * n + 2 ) / 2 ; } var n = 3 ; document . write ( n + "" "" ) ; document . write ( center_pentadecagonal_num ( n ) + "" "" ) ; n = 10 ; document . write ( n + "" "" ) ; document . write ( center_pentadecagonal_num ( n ) ) ;";"Centered Pentadecagonal Number | centered pentadecagonal function ; Formula to calculate nth centered pentadecagonal number ; Driver Code"
Javascript;"function center_nonadecagon_num ( n ) { return ( 19 * n * n - 19 * n + 2 ) / 2 ; } var n = 2 ; document . write ( n + "" "" + "" "" ) ; document . write ( center_nonadecagon_num ( n ) + "" "" ) ; n = 7 ; document . write ( n + "" "" + "" "" ) ; document . write ( center_nonadecagon_num ( n ) ) ;";"Centered nonadecagonal number | centered nonadecagonal function ; Formula to calculate nth centered nonadecagonal number ; Driver Code"
Javascript;"function hendecagonal_num ( n ) { return ( 9 * n * n - 7 * n ) / 2 ; } let n = 3 ; document . write ( n + "" "" ) ; document . write ( hendecagonal_num ( n ) + "" "" ) ; n = 10 ; document . write ( n + "" "" ) ; document . write ( hendecagonal_num ( n ) ) ;";"Hendecagonal number | Function to find Hendecagonal number ; Formula to calculate nth Hendecagonal number ; Driver Code"
Javascript;"function centeredoctagonalNumber ( n ) { return 4 * n * ( n - 1 ) + 1 ; } var n = 6 ; document . write ( n + "" "" + "" "" ) ; document . write ( centeredoctagonalNumber ( n ) + "" "" ) ; n = 11 ; document . write ( n + "" "" + "" "" ) ; document . write ( centeredoctagonalNumber ( n ) ) ;";"Centered Octagonal Number | Function to find centered octagonal number ; Formula to calculate nth centered octagonal number and return it into main function ; Driver Code"
Javascript;"function isValid ( arr , i , j , m , c ) { if ( i == j ) return false ; var lhs = arr [ j ] ; var rhs = m * arr [ i ] + c ; return lhs == rhs ; } function findOrderedPoints ( arr , n , m , c ) { var counter = 0 ; for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j < n ; j ++ ) { var firstIndex = i , secondIndex = j ; if ( isValid ( arr , firstIndex , secondIndex , m , c ) ) counter ++ ; } } return counter ; } var arr = [ 1 , 2 , 3 , 4 , 2 ] ; var n = arr . length ; var m = 1 , c = 1 ; document . write ( findOrderedPoints ( arr , n , m , c ) ) ;";"Number of ordered points pair satisfying line equation | Checks if ( i , j ) is valid , a point ( i , j ) is valid if point ( arr [ i ] , arr [ j ] ) satisfies the equation y = mx + c And i is not equal to j ; check if i equals to j ; Equation LHS = y , and RHS = mx + c ; Returns the number of ordered pairs ( i , j ) for which point ( arr [ i ] , arr [ j ] ) satisfies the equation of the line y = mx + c ; for every possible ( i , j ) check if ( a [ i ] , a [ j ] ) satisfies the equation y = mx + c ; ( firstIndex , secondIndex ) is same as ( i , j ) ; check if ( firstIndex , secondIndex ) is a valid point ; Driver Code ; equation of line is y = mx + c"
Javascript;"function checkcircle ( r , R , r1 , x1 , y1 ) { let dis = Math . sqrt ( x1 * x1 + y1 * y1 ) ; return ( dis - r1 >= R && dis + r1 <= r ) ; } let r = 8 , R = 4 , r1 = 2 , x1 = 6 , y1 = 0 ; if ( checkcircle ( r , R , r1 , x1 , y1 ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check if a given circle lies completely inside the ring formed by two concentric circles | Function to check if circle lies in the ring ; distance between center of circle center of concentric circles ( origin ) using Pythagoras theorem ; Condition to check if circle is strictly inside the ring ; Both circle with radius ' r ' and ' R ' have center ( 0 , 0 )"
Javascript;"function surface_area_octahedron ( side ) { return ( 2 * ( Math . sqrt ( 3 ) ) * ( side * side ) ) ; } let side = 7 ; document . write ( "" "" + surface_area_octahedron ( side ) ) ;";"Program for Surface Area of Octahedron | Utility Function ; Driver Code"
Javascript;"function nCk ( n , k ) { let C = new Array ( k + 1 ) ; C . fill ( 0 ) ; for ( let i = 1 ; i <= n ; i ++ ) { for ( let j = Math . min ( i , k ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } return C [ k ] ; } function count_Straightlines ( n , m ) { return ( nCk ( n , 2 ) - nCk ( m , 2 ) + 1 ) ; } let n = 4 , m = 3 ; document . write ( count_Straightlines ( n , m ) ) ;";"Count of different straight lines with total n points with m collinear | Returns value of binomial coefficient Code taken from https : goo . gl / vhy4jp ; C [ 0 ] = 1 ; nC0 is 1 ; Compute next row of pascal triangle using the previous row ; function to calculate number of straight lines can be formed ; Driver Code"
Javascript;"function vol_of_dodecahedron ( side ) { return ( ( ( 15 + ( 7 * ( Math . sqrt ( 5 ) ) ) ) / 4 ) * ( Math . pow ( side , 3 ) ) ) ; } let side = 4 ; document . write ( "" "" + vol_of_dodecahedron ( side ) . toFixed ( 2 ) ) ;";"Calculate Volume of Dodecahedron | utility Function ; Driver Function"
Javascript;"function overflow ( H , r , h , N , R ) { let tank_cap = 3.14 * r * r * H ; let water_vol = 3.14 * r * r * h ; let balls_vol = N * ( 4 / 3 ) * 3.14 * R * R * R ; let vol = water_vol + balls_vol ; if ( vol > tank_cap ) { document . write ( "" "" ) ; } else { document . write ( "" "" ) ; } } let H = 10 , r = 5 , h = 5 , N = 2 , R = 2 ; overflow ( H , r , h , N , R ) ;";"Program to check if water tank overflows when n solid balls are dipped in the water tank | function to find if tak will overflow or not ; cylinder capacity ; volume of water in tank ; volume of n balls ; total volume of water and n dipped balls ; condition to check if tank is in overflow state or not ; giving dimensions ; calling function"
Javascript;"function volume ( radius , height ) { return ( ( 22 / 7 ) * radius * radius * height ) ; } function check_and_print ( required_time , given_time ) { if ( required_time < given_time ) document . write ( "" "" ) ; else if ( required_time > given_time ) document . write ( "" "" ) ; else document . write ( "" "" ) ; } let radius = 5 , height = 10 , rate_of_flow = 10 ; let given_time = 70.0 ; let required_time = volume ( radius , height ) / rate_of_flow ; check_and_print ( required_time , given_time ) ;";"Program to check if tank will overflow , underflow or filled in given time | function to calculate the volume of tank ; function to print overflow / filled / underflow accordingly ; radius of the tank ; height of the tank ; rate of flow of water ; time given ; calculate the required time ; printing the result"
Javascript;"function cal_cos ( n ) { let accuracy = 0.0001 , x1 ; let denominator , cosx , cosval ; n = n * ( 3.142 / 180.0 ) ; x1 = 1 ; cosx = x1 ; cosval = Math . cos ( n ) ; let i = 1 ; do { denominator = 2 * i * ( 2 * i - 1 ) ; x1 = - x1 * n * n / denominator ; cosx = cosx + x1 ; i = i + 1 ; } while ( accuracy <= Math . abs ( cosval - cosx ) ) ; return cosx ; } function third_side ( a , b , c ) { let angle = cal_cos ( c ) ; return Math . sqrt ( ( a * a ) + ( b * b ) - 2 * a * b * angle ) ; } let c = 49 ; let a = 5 , b = 8 ; document . write ( Math . round ( third_side ( a , b , c ) * 100000.0 ) / 100000.0 ) ;";"Program to find third side of triangle using law of cosines | Function to calculate cos value of angle c ; Converting degrees to radian ; Maps the sum alet the series ; Holds the actual value of sin ( n ) ; Function to find third side ; Driver code ; function call"
Javascript;"function fitOrNotFit ( R , r , x , y , rad ) { var val = Math . sqrt ( Math . pow ( x , 2 ) + Math . pow ( y , 2 ) ) ; if ( val + rad <= R && val - rad >= R - r ) document . write ( "" "" ) ; else document . write ( "" "" ) ; } var R = 8 , r = 4 ; var x = 5 , y = 3 , rad = 3 ; fitOrNotFit ( R , r , x , y , rad ) ;";"Check whether given circle resides in boundary maintained by two other circles | function to check if given circle fit in boundary or not ; Distance from the center ; Checking the corners of circle ; driver program Radius of outer circle and inner circle respectively ; Co - ordinates and radius of the circle to be checked"
Javascript;"const EPSILON = 1.0842e-19 ; function compareDoubles ( A , B ) { var diff = A - B ; return diff < EPSILON && - diff < EPSILON ; } function numberOfTringles ( a , b , c , n ) { var slope = [ ] ; for ( var i = 0 ; i < n ; i ++ ) slope . push ( parseFloat ( a [ i ] * 1.0 ) / b [ i ] ) ; slope . sort ( ) ; var count = new Array ( n ) . fill ( 0 ) ; var k = 0 ; var this_count = 1 ; for ( var i = 1 ; i < n ; i ++ ) { if ( compareDoubles ( parseFloat ( slope [ i ] ) , parseFloat ( slope [ i - 1 ] ) ) ) this_count ++ ; else { count [ k ++ ] = this_count ; this_count = 1 ; } } count [ k ++ ] = this_count ; var sum1 = 0 ; for ( var i = 0 ; i < k ; i ++ ) sum1 += count [ i ] ; var sum2 = 0 ; var temp = new Array ( n ) . fill ( 0 ) ; for ( var i = 0 ; i < k ; i ++ ) { temp [ i ] = count [ i ] * ( sum1 - count [ i ] ) ; sum2 += temp [ i ] ; } sum2 /= 2 ; var sum3 = 0 ; for ( var i = 0 ; i < k ; i ++ ) sum3 += count [ i ] * ( sum2 - temp [ i ] ) ; sum3 /= 3 ; return sum3 ; } var a = [ 1 , 2 , 3 , 4 ] ; var b = [ 2 , 4 , 5 , 5 ] ; var c = [ 5 , 7 , 8 , 6 ] ; var n = a . length ; document . write ( "" "" + "" "" + numberOfTringles ( a , b , c , n ) ) ;";"Number of Triangles that can be formed given a set of lines in Euclidean Plane | JavaScript program to find the number of triangles that can be formed using a set of lines in Euclidean Plane ; Double variables can ' t ▁ be ▁ checked ▁ precisely ▁ ▁ using ▁ ' == ' this function returns true if  the double variables are equal ; This function returns the number of triangles for a given set of lines ; Slope array stores the slope of lines ; Slope array is sorted so that all lines with same slope come together ; After sorting slopes , count different slopes . k is index in count [ ] . ; Count of current slope ; Calculating sum1 ( Sum of all slopes ) sum1 = m1 + m2 + ... ; Calculating sum2 . sum2 = m1 * m2 + m2 * m3 + ... ; Needed for sum3 ; Calculating sum3 which gives the final answer m1 * m2 * m3 + m2 * m3 * m4 + ... ; lines are stored as arrays of a , b and c for ' ax + by = c ' ; n is the number of lines"
Javascript;"function lineFromPoints ( P , Q ) { var a = Q [ 1 ] - P [ 1 ] var b = P [ 0 ] - Q [ 0 ] var c = a * ( P [ 0 ] ) + b * ( P [ 1 ] ) if ( b < 0 ) document . write ( "" "" + "" "" + a + "" "" + b + "" "" + c + "" "" ) else document . write ( "" "" + "" "" + a + "" "" + b + "" "" + c + "" "" ) } var P = [ 3 , 2 ] var Q = [ 2 , 6 ] lineFromPoints ( P , Q )";"Program to find line passing through 2 Points | Function to find the line given two points ; Driver code"
Javascript;"function checkPolygonWithMidpoints ( arr , N , midpoints ) { for ( let j = 0 ; j < midpoints ; j ++ ) { let val = 1 ; for ( let k = j ; k < N ; k += midpoints ) { val &= arr [ k ] ; } if ( val && parseInt ( N / midpoints ) > 2 ) { document . write ( "" "" + parseInt ( N / midpoints ) + "" "" ) ; return true ; } } return false ; } function isPolygonPossible ( arr , N ) { let limit = Math . sqrt ( N ) ; for ( let i = 1 ; i <= limit ; i ++ ) { if ( N % i == 0 ) { if ( checkPolygonWithMidpoints ( arr , N , i ) || checkPolygonWithMidpoints ( arr , N , parseInt ( N / i ) ) ) return ; } } document . write ( "" "" ) ; } let arr = [ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] ; let N = arr . length ; isPolygonPossible ( arr , N ) ;";"Regular polygon using only 1 s in a binary numbered circle | method returns true if polygon is possible with ' midpoints ' number of midpoints ; loop for getting first vertex of polygon ; loop over array values at ' midpoints ' distance ; and ( & ) all those values , if even one of them is 0 , val will be 0 ; if val is still 1 and ( N / midpoints ) or ( number of vertices ) are more than two ( for a polygon minimum ) print result and return true ; method prints sides in the polygon or print not possible in case of no possible polygon ; limit for iterating over divisors ; If i divides N then i and ( N / i ) will be divisors ; check polygon for both divisors ; Driver code to test above methods"
Javascript;"function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } function getReducedForm ( dy , dx ) { let g = gcd ( Math . abs ( dy ) , Math . abs ( dx ) ) ; let sign = ( dy < 0 ) ^ ( dx < 0 ) ; if ( sign ) { return [ Math . floor ( - Math . abs ( dy ) / g ) , Math . floor ( Math . abs ( dx ) / g ) ] ; } else return [ Math . floor ( Math . abs ( dy ) / g ) , Math . floor ( Math . abs ( dx ) / g ) ] ; } function minLinesToCoverPoints ( points , N , x0 , y0 ) { let st = new Set ( ) ; let temp ; let minLines = 0 ; for ( let i = 0 ; i < N ; i ++ ) { let curX = points [ i ] [ 0 ] ; let curY = points [ i ] [ 1 ] ; temp = getReducedForm ( curY - yO , curX - xO ) ; if ( ! st . has ( temp . join ( "" "" ) ) ) { st . add ( temp . join ( "" "" ) ) ; minLines ++ ; } } return minLines ; } let xO , yO ; xO = 1 ; yO = 0 ; let points = [ [ - 1 , 3 ] , [ 4 , 3 ] , [ 2 , 1 ] , [ - 1 , - 2 ] , [ 3 , - 3 ] ] ; let N = points . length ; document . write ( minLinesToCoverPoints ( points , N , xO , yO ) )";"Minimum lines to cover all points | Utility method to get gcd of a and b ; method returns reduced form of dy / dx as a pair ; get sign of result ; method returns minimum number of lines to cover all points where all lines goes through ( xO , yO ) ; set to store slope as a pair ; loop over all points once ; get x and y co - ordinate of current point ; if this slope is not there in set , increase ans by 1 and insert in set ; Driver code to test above methods"
Javascript;"function squareRoot ( n ) { let x = n ; let y = 1 ; let e = 0.000001 ; while ( x - y > e ) { x = ( x + y ) / 2 ; y = n / x ; } return x ; } function findMaximumHeight ( N ) { let n = 1 + 8 * N ; let maxH = ( - 1 + squareRoot ( n ) ) / 2 ; return Math . round ( maxH ) ; } let N = 12 ; document . write ( findMaximumHeight ( N ) ) ;";"Maximum height when coins are arranged in a triangle | Returns the square root of n . Note that the function ; We are using n itself as initial approximation . This can definitely be improved ; e decides the accuracy level ; Method to find maximum height of arrangement of coins ; calculating portion inside the square root ; Driver Code"
Javascript;"class Point { constructor ( a , b ) { this . x = a ; this . y = b ; } } function gcd ( a , b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } function getCount ( p , q ) { if ( p . x == q . x ) return Math . abs ( p . y - q . y ) - 1 ; if ( p . y == q . y ) return Math . abs ( p . x - q . x ) - 1 ; return gcd ( Math . abs ( p . x - q . x ) , Math . abs ( p . y - q . y ) ) - 1 ; } p = new Point ( 1 , 9 ) ; q = new Point ( 8 , 16 ) ; document . write ( "" "" + "" "" + p . x + "" "" + p . y + "" "" + q . x + "" "" + q . y + "" "" + getCount ( p , q ) ) ;";"Number of Integral Points between Two Points | Class to represent an Integral point on XY plane . ; Utility function to find GCD of two numbers GCD of a and b ; Finds the no . of Integral points between two given points . ; If line joining p and q is parallel to x axis , then count is difference of y values ; If line joining p and q is parallel to y axis , then count is difference of x values ; Driver program to test above"
Javascript;"function distSq ( p , q ) { return ( p . x - q . x ) * ( p . x - q . x ) + ( p . y - q . y ) * ( p . y - q . y ) ; } function isSquare ( p1 , p2 , p3 , p4 ) { if ( d2 == 0 d3 == 0 d4 == 0 ) return false ; if ( d2 == d3 && 2 * d2 == d4 && 2 * distSq ( p2 , p4 ) == distSq ( p2 , p3 ) ) { return true ; } if ( d3 == d4 && 2 * d3 == d2 && 2 * distSq ( p3 , p2 ) == distSq ( p3 , p4 ) ) { return true ; } if ( d2 == d4 && 2 * d2 == d3 && 2 * distSq ( p2 , p3 ) == distSq ( p2 , p4 ) ) { return true ; } return false ; } let p1 = { x : 20 , y : 10 } let p2 = { x : 10 , y : 20 } let p3 = { x : 20 , y : 20 } let p4 = { x : 10 , y : 10 } isSquare ( p1 , p2 , p3 , p4 ) ? document . write ( "" "" ) : document . write ( "" "" ) ;";"How to check if given four points form a square | A utility function to find square of distance from point ' p ' to point ' q ' ; This function returns true if ( p1 , p2 , p3 , p4 ) form a square , otherwise false ; let d2 = distSq ( p1 , p2 ) ; from p1 to p2 let d3 = distSq ( p1 , p3 ) ; from p1 to p3 let d4 = distSq ( p1 , p4 ) ; from p1 to p4 ; If lengths if ( p1 , p2 ) and ( p1 , p3 ) are same , then following conditions must met to form a square . 1 ) Square of length of ( p1 , p4 ) is same as twice the square of ( p1 , p2 ) 2 ) Square of length of ( p2 , p3 ) is same as twice the square of ( p2 , p4 ) ; The below two cases are similar to above case ; Driver program to test above function"
Javascript;"function countDivisors ( n ) { var divisors = 0 ; var i ; for ( i = 1 ; i * i < n ; i ++ ) { if ( n % i == 0 ) { divisors ++ ; } } if ( i - ( n / i ) == 1 ) { i -- ; } for ( ; i >= 1 ; i -- ) { if ( n % i == 0 ) { divisors ++ ; } } return divisors ; } function possibleTriplets ( N ) { var count = 0 ; for ( var i = 1 ; i < N ; i ++ ) { count += countDivisors ( N - i ) ; } return count ; } var N = 10 ; document . write ( possibleTriplets ( N ) ) ;";"Count triplets such that product of two numbers added with third number is N | Function to find the divisors of the number ( N - i ) ; Stores the resultant count of divisors of ( N - i ) ; Iterate over range [ 1 , sqrt ( N ) ] ; Return the total divisors ; Function to find the number of triplets such that A * B - C = N ; Loop to fix the value of C ; Adding the number of divisors in count ; Return count of triplets ; Driver Code"
Javascript;"function maxPlanes ( A , B ) { let St = new Set ( ) ; for ( let i = 0 ; i < A . length ; i ++ ) { let t = ( A [ i ] % B [ i ] > 0 ) ? 1 : 0 ; t += Math . floor ( A [ i ] / B [ i ] ) + t ; St . add ( t ) ; } return St . size ; } let A = [ 1 , 3 , 5 , 4 , 8 ] ; let B = [ 1 , 2 , 2 , 1 , 2 ] ; document . write ( maxPlanes ( A , B ) ) ;";"Maximize count of planes that can be stopped per second with help of given initial position and speed | Function to find maximum number of planes that can be stopped from landing ; Stores the times needed for landing for each plane ; Iterate over the arrays ; Stores the time needed for landing of current plane ; Update the value of t ; Append the t in set St ; Return the answer ; Driver Code"
Javascript;"function predictTheWinner ( K , N ) { if ( N % ( K + 1 ) == 0 ) document . write ( "" "" ) ; else document . write ( "" "" ) ; } var K = 7 , N = 50 ; predictTheWinner ( K , N ) ;";"Find the player who will win by choosing a number in range [ 1 , K ] with sum total N | Function to predict the winner ; Given Input ; Function call"
Javascript;"function maxRightmostElement ( N , k , p , arr ) { var ans = arr [ N - 1 ] ; for ( var i = N - 2 ; i >= 0 ; i -- ) { var d = Math . min ( arr [ i ] / p , k / ( N - 1 - i ) ) ; k -= d * ( N - 1 - i ) ; ans += d * p ; } return ans ; } var N = 4 , k = 3.5 , p = 2 ; var arr = [ 3 , 8 , 1 , 4 ] ; document . write ( maxRightmostElement ( N , k , p , arr ) ) ;";"Maximize the rightmost element of an array in k operations in Linear Time | Function to calculate maximum value of Rightmost element ; Initializing ans to store Maximum valued rightmost element ; Calculating maximum value of Rightmost element ; returning rightmost element ; Given Input ; Function Call"
Javascript;"function smallestMaximum ( N , K ) { let sum = Math . floor ( ( N + K - 1 ) / K ) * K ; if ( sum % N != 0 ) return Math . floor ( sum / N ) + 1 ; else return Math . floor ( sum / N ) ; } let N = 4 ; let K = 3 ; document . write ( smallestMaximum ( N , K ) ) ;";"Minimize the maximum element in constructed Array with sum divisible by K | Function to find smallest maximum number in an array whose sum is divisible by K . ; Minimum possible sum possible for an array of size N such that its sum is divisible by K ; If sum is not divisible by N ; If sum is divisible by N ; Driver code ."
Javascript;"function findIfPossible ( N , S , X ) { if ( S >= X && S % 2 == X % 2 ) { if ( N >= 3 ) { return "" "" ; } if ( N == 1 ) { if ( S == X ) { return "" "" ; } else { return "" "" ; } } if ( N == 2 ) { let C = ( S - X ) / 2 ; let A = C ; let B = C ; A = A + X ; if ( ( ( A ^ B ) == X ) ) { return "" "" ; } else { return "" "" ; } } } else { return "" "" ; } } let N = 3 , S = 10 , X = 4 ; document . write ( findIfPossible ( N , S , X ) ) ;";"Check if it is possible to construct an Array of size N having sum as S and XOR value as X | Function to find if any sequence is possible or not . ; Since , S is greater than equal to X , and either both are odd or even There always exists a sequence ; Only one case possible is S == X or NOT ; ; Considering the above conditions true , check if XOR of S ^ ( S - X ) is X or not ; Driver Code"
Javascript;"function isPossible ( arr , n ) { var mini = Number . MAX_VALUE ; for ( var i = 0 ; i < n ; i ++ ) mini = Math . min ( mini , arr [ i ] ) ; for ( var i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == mini ) continue ; var Max = ( arr [ i ] + 1 ) / 2 - 1 ; if ( mini < 0 mini > Max ) return "" "" ; } return "" "" ; } var arr = [ 1 , 1 , 3 , 4 ] ; var N = arr . length ; document . write ( isPossible ( arr , N ) ) ;";"Check whether each Array element can be reduced to minimum element by replacing it with remainder with some X | Function to check if every integer in the array can be reduced to the minimum array element ; Stores the minimum array element ; Find the minimum element ; Traverse the array arr [ ] ; Stores the maximum value in the range ; Check whether mini lies in the range or not ; Otherwise , return Yes ; Driver code"
Javascript;"function gcdOfTwoNos ( num1 , num2 ) { if ( num1 == 0 ) return num2 ; if ( num2 == 0 ) return num1 ; if ( num1 == num2 ) return num1 ; if ( num1 > num2 ) return gcdOfTwoNos ( num1 - num2 , num2 ) ; return gcdOfTwoNos ( num1 , num2 - num1 ) ; } function Min_sum ( arr , N ) { let min_sum = 1000000 , maxGcd = 1 ; for ( let i = 0 ; i < N ; i ++ ) { let gcd ; if ( i == 0 ) gcd = arr [ 1 ] ; else { gcd = arr [ i - 1 ] ; } for ( let j = 0 ; j < N ; j ++ ) { if ( j != i ) gcd = gcdOfTwoNos ( gcd , arr [ j ] ) ; } let c = arr [ i ] ; if ( gcd > maxGcd ) maxGcd = gcd ; } return maxGcd ; } let arr = [ 16 , 5 , 10 , 25 ] ; let N = arr . length ; document . write ( Min_sum ( arr , N ) ) ;";"Maximum number which can divide all array element after one replacement | Function to return gcd of two numbers ; If one of numbers is 0 then gcd is other number ; If both are equal then that value is gcd ; One is greater ; Function to return minimum sum ; Initialize min_sum with large value ; Initialize variable gcd ; Storing value of arr [ i ] in c ; Update maxGcd if gcd is greater than maxGcd ; returning the maximum divisor of all elements ; Driver Code"
Javascript;"function countOddIntegers ( arr , N ) { let Fact = new Array ( N ) ; Fact [ 0 ] = 1 ; for ( let i = 1 ; i < N ; i ++ ) { Fact [ i ] = i * Fact [ i - 1 ] ; } let freq = new Array ( 10 ) . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) { freq [ arr [ i ] ] ++ ; } let ans = 0 ; for ( let i = 1 ; i <= 9 ; i += 2 ) { if ( ! freq [ i ] ) { continue ; } freq [ i ] -- ; for ( let j = 1 ; j <= 9 ; j ++ ) { let cur_ans = 0 ; if ( freq [ j ] == 0 ) { continue ; } freq [ j ] -- ; cur_ans = Fact [ N - 2 ] ; for ( let k = 0 ; k <= 9 ; k ++ ) { cur_ans = Math . floor ( cur_ans / Fact [ freq [ k ] ] ) ; } ans = ans + cur_ans ; freq [ j ] ++ ; } freq [ i ] ++ ; } return ans ; } let A = [ 2 , 3 , 4 , 1 , 2 , 3 ] ; let N = A . length ; document . write ( countOddIntegers ( A , N ) ) ;";"Count of distinct N | Function to find the count of distinct odd integers with N digits using the given digits in the array arr [ ] ; Stores the factorial of a number ; Calculate the factorial of all numbers from 1 to N ; Stores the frequency of each digit ; Stores the final answer ; Loop to iterate over all values of Nth digit i and 1 st digit j ; If digit i does not exist in the given array move to next i ; Fixing i as Nth digit ; Stores the answer of a specific value of i and j ; If digit j does not exist move to the next j ; Fixing j as 1 st digit ; Calculate number of ways to arrange remaining N - 2 digits ; Including j back into the set of digits ; Including i back into the set of the digits ; Return Answer ; Driver Code ; Function Call"
Javascript;"function sumOfDigits ( N ) { let sum = 0 ; while ( N != 0 ) { sum = sum + ( N % 10 ) ; N = Math . floor ( N / 10 ) ; } return sum ; } function CountPair ( arr , n ) { let mp = new Map ( ) ; for ( let i = 0 ; i < n ; i ++ ) { let val = arr [ i ] + sumOfDigits ( arr [ i ] ) ; if ( mp . has ( val ) ) { mp . set ( val , mp . get ( val ) + 1 ) ; } else { mp . set ( val , 1 ) ; } } let count = 0 ; for ( let [ key , value ] of mp ) { count = count + ( value * ( value - 1 ) ) / 2 ; } return count ; } let arr = [ 105 , 96 , 20 , 2 , 87 , 96 ] ; let N = arr . length ; document . write ( CountPair ( arr , N ) )";"Count pairs in an array having sum of elements with their respective sum of digits equal | Function to find the sum of digits of the number N ; Stores the sum of digits ; If the number N is greater than 0 ; Return the sum ; Function to find the count of pairs such that arr [ i ] + sumOfDigits ( arr [ i ] ) is equal to ( arr [ j ] + sumOfDigits ( arr [ j ] ) ; Stores the frequency of value of arr [ i ] + sumOfDigits ( arr [ i ] ) ; Traverse the given array ; Find the value ; Increment the frequency ; Stores the total count of pairs ; Traverse the map mp ; Update the count of pairs ; Return the total count of pairs ; Driver Code"
Javascript;"function __gcd ( a , b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } function build_tree ( b , seg_tree , l , r , vertex ) { if ( l == r ) { seg_tree [ vertex ] = b [ l ] ; return ; } let mid = Math . floor ( ( l + r ) / 2 ) ; build_tree ( b , seg_tree , l , mid , 2 * vertex ) ; build_tree ( b , seg_tree , mid + 1 , r , 2 * vertex + 1 ) ; seg_tree [ vertex ] = __gcd ( seg_tree [ 2 * vertex ] , seg_tree [ 2 * vertex + 1 ] ) ; } function range_gcd ( seg_tree , v , tl , tr , l , r ) { if ( l > r ) return 0 ; if ( l == tl && r == tr ) return seg_tree [ v ] ; let tm = Math . floor ( ( tl + tr ) / 2 ) ; return __gcd ( range_gcd ( seg_tree , 2 * v , tl , tm , l , Math . min ( tm , r ) ) , range_gcd ( seg_tree , 2 * v + 1 , tm + 1 , tr , Math . max ( tm + 1 , l ) , r ) ) ; } function maxSubarrayLen ( arr , n ) { let seg_tree = new Array ( 4 * n + 1 ) . fill ( 0 ) ; build_tree ( arr , seg_tree , 0 , n - 1 , 1 ) ; let maxLen = 0 ; let l = 0 , r = 0 ; while ( r < n && l < n ) { if ( range_gcd ( seg_tree , 1 , 0 , n - 1 , l , r ) == 1 ) { l ++ ; } maxLen = Math . max ( maxLen , r - l + 1 ) ; r ++ ; } document . write ( maxLen ) ; } let arr = [ 410 , 52 , 51 , 180 , 222 , 33 , 33 ] ; let N = arr . length ; maxSubarrayLen ( arr , N ) ;";"Longest subarray with GCD greater than 1 | Javascript program of the above approach ; Function to build the Segment Tree from the given array to process range queries in log ( N ) time ; Termination Condition ; Find the mid value ; Left and Right Recursive Call ; Update the Segment Tree Node ; Function to return the GCD of the elements of the Array from index l to index r ; Base Case ; Find the middle range ; Find the GCD and return ; Function to print maximum length of the subarray having GCD > one ; Stores the Segment Tree ; Function call to build the Segment tree from array arr [ ] ; Store maximum length of subarray ; Starting and ending pointer of the current window ; Case where the GCD of the current window is 1 ; Update the maximum length ; Print answer ; Driver Code"
Javascript;"function findAandB ( N ) { let K = Math . log2 ( N ) ; let B = ( 1 << K ) ; let A = B ^ N ; document . write ( A + ' ' + B ) ; } let N = 26 ; findAandB ( N ) ;";"Smallest pair of integers with minimum difference whose Bitwise XOR is N | Function to find the numbers A and B whose Bitwise XOR is N and the difference between them is minimum ; Find the MSB of the N ; Find the value of B ; Find the value of A ; Print the result ; Driver Code"
Javascript;"function findValuesOfK ( g ) { var count = 0 ; for ( var i = 1 ; i * i <= g ; i ++ ) { if ( g % i == 0 ) { if ( i != g / i ) { if ( i % 2 == 1 ) { count ++ ; } if ( ( g / i ) % 2 == 1 ) { count ++ ; } } else if ( i % 2 == 1 ) { count ++ ; } } } document . write ( count ) ; } var G = 125 ; findValuesOfK ( G ) ;";"Find all possible values of K such that the sum of first N numbers starting from K is G | Function to find the count the value of K such that sum of the first N numbers from K is G ; Stores the total count of K ; Iterate till square root of g ; If the number is factor of g ; If the second factor is not equal to first factor ; Check if two factors are odd or not ; If second factor is the same as the first factor then check if the first factor is odd or not ; Print the resultant count ; Driver code"
Javascript;"function Avgdifference ( arr , N , K ) { let sum = 0 ; for ( let i = 0 ; i < K ; i ++ ) sum += arr [ i ] ; let min = sum ; let max = sum ; for ( let i = K ; i <= N - K + 1 ; i ++ ) { sum += arr [ i ] - arr [ i - K ] ; if ( min > sum ) min = sum ; if ( max < sum ) max = sum ; } return ( max - min ) / K ; } let arr = [ 3 , 8 , 9 , 15 ] ; let N = arr . length ; let K = 2 ; document . write ( Avgdifference ( arr , N , K ) ) ;";"Difference between maximum and minimum average of all K | Function to find the difference between the maximum and minimum subarrays of length K ; Stores the sum of subarray over the range [ 0 , K ] ; Iterate over the range [ 0 , K ] ; Store min and max sum ; Iterate over the range [ K , N - K ] ; Increment sum by arr [ i ] - arr [ i - K ] ; Update max and min moving sum ; Return difference between max and min average ; Given Input ; Function Call"
Javascript;"function findSet ( N , K ) { let a = [ ] ; for ( let i = 1 ; i <= N ; i ++ ) { if ( i != K ) a . push ( i ) ; } let MaxDistinct = ( N - K ) + parseInt ( K / 2 ) ; a . reverse ( ) ; for ( let i = 0 ; i < MaxDistinct ; i ++ ) document . write ( a [ i ] + "" "" ) ; } let N = 5 , K = 3 ; findSet ( N , K ) ;";"Count of distinct integers in range [ 1 , N ] that do not have any subset sum as K | Function to find maximum number of distinct integers in [ 1 , N ] having no subset with sum equal to K ; Declare a vector to store the required numbers ; Store all the numbers in [ 1 , N ] except K ; Store the maximum number of distinct numbers ; Reverse the array ; Print the required numbers ; Given Input ; Function Call"
Javascript;"function ExtendedEuclidAlgo ( a , b ) { if ( a == 0 ) { return [ b , 0 , 1 ] ; } else { let x1 = 1 , y1 = 1 ; let gcdy = ExtendedEuclidAlgo ( b % a , a ) ; let gcd = gcdy [ 0 ] ; x1 = gcdy [ 1 ] ; y1 = gcdy [ 2 ] ; let y = x1 ; let x = y1 - Math . floor ( b / a ) * x1 ; return [ gcd , x , y ] ; } } function linearCongruence ( A , B , N ) { A = A % N ; B = B % N ; let u = 0 , v = 0 ; let person = ExtendedEuclidAlgo ( A , N ) ; let d = person [ 0 ] ; u = person [ 1 ] ; v = person [ 2 ] ; if ( B % d != 0 ) { document . write ( - 1 ) ; return ; } let x0 = ( u * ( B / d ) ) % N ; if ( x0 < 0 ) x0 += N ; for ( let i = 0 ; i <= d - 1 ; i ++ ) { let an = ( x0 + i * ( N / d ) ) % N ; document . write ( an + "" "" ) ; } } let A = 15 ; let B = 9 ; let N = 18 ; linearCongruence ( A , B , N ) ;";"Solve Linear Congruences Ax = B ( mod N ) for values of x in range [ 0 , N | Function to stores the values of x and y and find the value of gcd ( a , b ) ; Base Case ; Store the result of recursive call ; Update x and y using results of recursive call ; Function to give the distinct solutions of ax = b ( mod n ) ; Function Call to find the value of d and u ; No solution exists ; Else , initialize the value of x0 ; Print all the answers ; Input ; Function Call"
Javascript;"function factorialWithoutMul ( N ) { let ans = N ; for ( let i = N - 1 ; i > 0 ; i -- ) { let sum = 0 ; for ( let j = 0 ; j < i ; j ++ ) sum += ans ; ans = sum ; } return ans ; } let N = 5 ; document . write ( factorialWithoutMul ( N ) ) ;";"Factorial of a number without using multiplication | Function to calculate factorial of the number without using multiplication operator ; variable to store the final factorial ; Outer loop ; Inner loop ; Input ; Function calling"
Javascript;"function tripletAndSum ( arr , n ) { let ans = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) { for ( let k = j + 1 ; k < n ; k ++ ) { ans += arr [ i ] & arr [ j ] & arr [ k ] ; } } } document . write ( ans ) ; } let arr = [ 3 , 5 , 4 , 7 ] ; let N = arr . length tripletAndSum ( arr , N ) ;";"Sum of Bitwise AND of all unordered triplets of an array | Function to calculate sum of Bitwise AND of all unordered triplets from a given array such that ( i < j < k ) ; Stores the resultant sum of Bitwise AND of all triplets ; Generate all triplets of ( arr [ i ] , arr [ j ] , arr [ k ] ) ; Add Bitwise AND to ans ; Print the result ; Driver Code"
Javascript;"function tripletAndSum ( arr , n ) { let ans = 0 ; for ( let bit = 0 ; bit < 32 ; bit ++ ) { let cnt = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( arr [ i ] & ( 1 << bit ) ) cnt ++ ; } ans += ( 1 << bit ) * cnt * ( cnt - 1 ) * ( cnt - 2 ) / 6 ; } return ans ; } let arr = [ 3 , 5 , 4 , 7 ] ; let N = arr . length ; document . write ( tripletAndSum ( arr , N ) ) ;";"Sum of Bitwise AND of all unordered triplets of an array | Function to calculate sum of Bitwise AND of all unordered triplets from a given array such that ( i < j < k ) ; Stores the resultant sum of Bitwise AND of all triplets ; Traverse over all the bits ; Count number of elements with the current bit set ; There are ( cnt ) C ( 3 ) numbers with the current bit set and each triplet contributes 2 ^ bit to the result ; Return the resultant sum ; Driver Code"
Javascript;"function smallestPermutation ( arr , N ) { let w = new Array ( 2 * N + 1 ) ; for ( let i = 0 ; i < N ; i ++ ) { w [ arr [ i ] ] = true ; } let S = new Set ( ) ; for ( let i = 1 ; i <= 2 * N ; i ++ ) { if ( ! w [ i ] ) S . add ( i ) ; } let found = true ; let P = [ ] ; let p = [ 4 , 5 , 1 , 2 , 3 , 6 ] ; for ( let i = 0 ; i < N ; i ++ ) { if ( S . has ( arr [ i ] ) ) { found = false ; break ; } P . push ( arr [ i ] ) ; P . push ( arr [ i ] ) ; S . delete ( arr [ i ] ) ; } if ( ! found ) { document . write ( "" "" ) ; } else { for ( let i = 0 ; i < 2 * N ; i ++ ) document . write ( p [ i ] + "" "" ) ; } } let arr = [ 4 , 1 , 3 ] ; let N = arr . length ; smallestPermutation ( arr , N ) ;";"Lexicographically smallest permutation of length 2 N that can be obtained from an N | Function to find the lexicographically smallest permutation of length 2 * N satisfying the given conditions ; Stores if i - th element is placed at odd position or not ; Traverse the array ; Mark arr [ i ] true ; Stores all the elements not placed at odd positions ; Iterate in the range [ 1 , 2 * N ] ; If w [ i ] is not marked ; Stores whether it is possible to obtain the required permutation or not ; Stores the permutation ; Traverse the array arr [ ] ; If it is S . end ( ) ; Mark found false ; Push arr [ i ] and * it into the array ; Erase the current element from the Set ; If found is not marked ; Otherwise , ; Print the permutation ; Given Input ; Function call"
Javascript;"function maximumSubsequenceSum ( A , N ) { var ans = 0 ; var mp = new Map ( ) ; var i ; for ( i = 0 ; i < N ; i ++ ) { if ( mp . has ( A [ i ] - i ) ) mp . set ( A [ i ] - i , mp . get ( A [ i ] - i ) + A [ i ] ) ; else mp . set ( A [ i ] - i , A [ i ] ) ; ans = Math . max ( ans , mp . get ( A [ i ] - i ) ) ; } document . write ( ans ) ; } var A = [ 10 , 7 , 1 , 9 , 10 , 1 ] ; var N = A . length ; maximumSubsequenceSum ( A , N ) ;";"Maximum sum of a subsequence having difference between their indices equal to the difference between their values | Function to find the maximum sum of a subsequence having difference between indices equal to difference in their values ; Stores the maximum sum ; Stores the value for each A [ i ] - i ; Traverse the array ; Update the value in map ; Update the answer ; Finally , print the answer ; Given Input ; Function Call"
Javascript;"function nearestPerfectSquare ( arr , N ) { for ( let i = 0 ; i < N ; i ++ ) { let sr = parseInt ( Math . sqrt ( arr [ i ] ) ) ; let a = sr * sr ; let b = ( sr + 1 ) * ( sr + 1 ) ; if ( ( arr [ i ] - a ) < ( b - arr [ i ] ) ) document . write ( a + "" "" ) ; else document . write ( b + "" "" ) ; } } let arr = [ 5 , 2 , 7 , 13 ] ; let N = arr . length ; nearestPerfectSquare ( arr , N ) ;";"Find the nearest perfect square for each element of the array | Function to find the nearest perfect square for every element in the given array ; Traverse the array ; Calculate square root of current element ; Calculate perfect square ; Find the nearest ; Driver Code"
Javascript;"let prime = new Array ( 100001 ) ; function SieveOfEratosthenes ( n ) { for ( let i = 0 ; i < prime . length ; i ++ ) { prime [ i ] = true ; } for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * p ; i <= n ; i += p ) prime [ i ] = false ; } } } function NumberofSets ( N ) { SieveOfEratosthenes ( N ) ; if ( N == 2 ) { document . write ( 1 ) ; } else if ( N == 3 ) { document . write ( 2 ) ; } else { let ans = 1 ; for ( let i = Math . floor ( N / 2 ) + 1 ; i <= N ; i ++ ) { if ( prime [ i ] ) { ans += 1 ; } } document . write ( ans ) ; } } let N = 9 ; NumberofSets ( N ) ;";"Count of sets possible using integers from a range [ 2 , N ] using given operations that are in Equivalence Relation | Javascript program for tha above approach ; Sieve of Eratosthenes to find primes less than or equal to N ; Function to find number of Sets ; Handle Base Case ; Set which contains less than or equal to N / 2 ; Number greater than N / 2 and are prime increment it by 1 ; If the number is prime Increment answer by 1 ; Input ; Function Call"
Javascript;"function floorDifference ( A , N , X ) { let totalSum = 0 ; let perElementSum = 0 ; for ( let i = 0 ; i < N ; i ++ ) { totalSum += A [ i ] ; perElementSum += Math . floor ( A [ i ] / X ) ; } let totalFloorSum = Math . floor ( totalSum / X ) ; return Math . abs ( totalFloorSum - perElementSum ) ; } let A = [ 1 , 2 , 3 , 4 , 5 , 6 ] ; let X = 4 ; let N = A . length ; document . write ( floorDifference ( A , N , X ) ) ;";"Absolute difference between floor of Array sum divided by X and floor sum of every Array element when divided by X | Function to find absolute difference between the two sum values ; Variable to store total sum ; Variable to store sum of A [ i ] / X ; Traverse the array ; Update totalSum ; Update perElementSum ; Floor of total sum divided by X ; Return the absolute difference ; Input ; Size of Array ; Function call to find absolute difference between the two sum values"
Javascript;"function val ( c ) { if ( c >= ' ' && c <= ' ' ) return c . charCodeAt ( 0 ) - 48 ; else return c . charCodeAt ( 0 ) - 65 + 10 ; } function toDeci ( str , base ) { var len = str . length ; var power = 1 ; var num = 0 ; for ( var i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str [ i ] ) >= base ) { document . write ( "" "" ) ; return - 1 ; } num += val ( str [ i ] ) * power ; power = power * base ; } return num ; } function reVal ( num ) { if ( num >= 0 && num <= 9 ) return String . fromCharCode ( num + 48 ) ; else return String . fromCharCode ( num - 10 + 65 ) ; } function fromDeci ( base , inputNum ) { var res = "" "" ; while ( inputNum > 0 ) { res += reVal ( inputNum % base ) ; inputNum = Math . floor ( inputNum / base ) ; } res = res . split ( "" "" ) . reverse ( ) . join ( "" "" ) ; return res ; } function convertBase ( s , a , b ) { var num = toDeci ( s , a ) ; var ans = fromDeci ( b , num ) ; document . write ( ans ) ; } var s = "" "" ; var a = 16 var b = 10 ; convertBase ( s , a , b ) ;";"Convert a number from base A to base B | Function to return ASCII value of a character ; Function to convert a number from given base to decimal number ; Stores the length of the var ; Initialize power of base ; Initialize result ; Decimal equivalent is str [ len - 1 ] * 1 + str [ len - 2 ] * base + str [ len - 3 ] * ( base ^ 2 ) + ... ; A digit in input number must be less than number 's base ; Update num ; Update power ; Function to return equivalent character of a given valueString . fromCharCode ; Function to convert a given decimal number to a given base ; Store the result ; Repeatedly divide inputNum by base and take remainder ; Update res ; Update inputNum ; Reverse the result ; Function to convert a given number from a base to another base ; Convert the number from base A to decimal ; Convert the number from decimal to base B ; Prvar the result ; Given input ; Function Call"
Javascript;"function fact ( N ) { if ( N == 1 N == 0 ) return 1 ; return N * fact ( N - 1 ) ; } function prefixFactorialArray ( arr , N ) { for ( let i = 1 ; i < N ; i ++ ) { arr [ i ] += arr [ i - 1 ] ; } for ( let i = 0 ; i < N ; i ++ ) { arr [ i ] = fact ( arr [ i ] ) ; } for ( let i = 0 ; i < N ; i ++ ) { document . write ( arr [ i ] + "" "" ) ; } } let arr = [ 1 , 2 , 3 , 4 ] ; let N = arr . length ; prefixFactorialArray ( arr , N ) ;";"Prefix Factorials of a Prefix Sum Array | Function to find the factorial of a number N ; Base Case ; Find the factorial recursively ; Function to find the prefix factorial array ; Find the prefix sum array ; Find the factorials of each array element ; Print the resultant array ; Driver Code"
Javascript;"function findAverage ( N ) { let avg = ( ( 6 * N * N * N * N ) + ( 15 * N * N * N ) + ( 10 * N * N ) - 1 ) / 30.0 ; return avg ; } let N = 3 ; document . write ( findAverage ( N ) . toFixed ( 4 ) ) ;";"Mean of fourth powers of first N natural numbers | Function to find the average of the fourth power of first N natural numbers ; Store the resultant average calculated using formula ; Return the average ; Driver Code"
Javascript;"function removeEveryKth ( l , k ) { for ( let i = 0 ; i < l . length ; i ++ ) { if ( i % k == 0 ) l [ i ] = 0 ; } let arr = [ 0 ] ; for ( let i = 1 ; i < l . length ; i ++ ) { if ( l [ i ] != 0 ) arr . push ( l [ i ] ) ; } return arr ; } function printArray ( l ) { for ( let i = 1 ; i < l . length ; i ++ ) document . write ( l [ i ] + "" "" ) ; } function printSequence ( n , k ) { let l = [ 0 ] ; for ( let i = 0 ; i < n + 1 ; i ++ ) l [ i ] = i ; let x = 1 ; for ( let i = 0 ; i < k ; i ++ ) { let p = l [ x ] + l [ x + 1 ] ; l = removeEveryKth ( l , p ) ; x += 1 ; } printArray ( l ) ; } let N = 8 ; let K = 2 ; printSequence ( N , K ) ;";"Modify array by removing ( arr [ i ] + arr [ i + 1 ] ) th element exactly K times | Function to modify array by removing every K - th element from the array ; Check if current element is the k - th element ; Stores the elements after removing every kth element ; Append the current element if it is not k - th element ; Return the new array after removing every k - th element ; Function to print the array ; Traverse the array l [ ] ; Function to print the array after performing the given operations exactly k times ; Store first N natural numbers ; Iterate over the range [ 0 , k - 1 ] ; Store sums of the two consecutive terms ; Remove every p - th element from the array ; Increment x by 1 for the next iteration ; Print the resultant array ; Given arrays ; Function Call"
Javascript;"function makeEqual ( arr , n ) { var fre0 = Array ( 33 ) . fill ( 0 ) ; var fre1 = Array ( 33 ) . fill ( 0 ) ; for ( i = 0 ; i < n ; i ++ ) { var x = arr [ i ] ; for ( j = 0 ; j < 33 ; j ++ ) { if ( ( x & 1 ) != 0 ) { fre1 [ j ] += 1 ; } else { fre0 [ j ] += 1 ; } x = x >> 1 ; } } var ans = 0 ; for ( i = 0 ; i < 33 ; i ++ ) { ans += Math . min ( fre0 [ i ] , fre1 [ i ] ) ; } return ans ; } var arr = [ 3 , 5 ] ; var N = arr . length ; document . write ( makeEqual ( arr , N ) ) ;";"Minimum number of bits of array elements required to be flipped to make all array elements equal | Function to count minimum number of bits required to be flipped to make all array elements equal ; Stores the count of unset bits ; Stores the count of set bits ; Traverse the array ; Traverse the bit of arr [ i ] ; If current bit is set ; Increment fre1 [ j ] ; Otherwise ; Increment fre0 [ j ] ; Right shift x by 1 ; Stores the count of total moves ; Traverse the range [ 0 , 32 ] ; Update the value of ans ; Return the minimum number of flips required ; Driver Code"
Javascript;"function sum ( arr , N , K ) { var sum = 0 ; var v = [ ] ; for ( var i = 0 ; i < N ; i ++ ) { v . push ( arr [ i ] ) ; } for ( var i = 0 ; i < v . length ; i ++ ) { if ( v [ i ] % K == 0 ) { var x = v [ i ] / K ; for ( var j = 0 ; j < K ; j ++ ) { v . push ( x ) ; } } else break ; } for ( var i = 0 ; i < v . length ; i ++ ) sum = sum + v [ i ] ; return sum ; } var arr = [ 4 , 6 , 8 , 2 ] ; var K = 2 ; var N = arr . length ; document . write ( sum ( arr , N , K ) ) ;";"Sum of array elements possible by appending arr [ i ] / K to the end of the array K times for array elements divisible by K | Function to calculate sum of array elements after adding arr [ i ] / K to the end of the array if arr [ i ] is divisible by K ; Stores the sum of the array ; Traverse the array arr [ ] ; Traverse the vector ; If v [ i ] is divisible by K ; Iterate over the range [ 0 , K ] ; Update v ; Otherwise ; Traverse the vector v ; Return the sum of the updated array ; Driver Code"
Javascript;"function check ( arr , N ) { var sum = 0 ; for ( i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum == 0 ) document . write ( "" "" ) ; else document . write ( "" "" ) ; } var arr = [ 1 , - 1 , 3 , - 2 , - 1 ] ; var N = arr . length ; check ( arr , N ) ;";"Check if sum of arr [ i ] / j for all possible pairs ( i , j ) in an array is 0 or not | Function to check if sum of all values of ( arr [ i ] / j ) for all 0 < i <= j < ( N - 1 ) is 0 or not ; Stores the required sum ; Traverse the array ; If the sum is equal to 0 ; Otherwise ; Driver Code"
Javascript;"function expectedValue ( P , a , b , N ) { var expValue = P + ( N * 0.5 * ( a + b ) ) ; return expValue ; } var P = 3000 var a = 20 var b = 10 var N = 30 document . write ( expectedValue ( P , a , b , N ) ) ;";"Program to calculate expected increase in price P after N consecutive days | Function to find the increased value of P after N days ; Expected value of the number P after N day ; Driver code"
Javascript;"function startingPoint ( A , N ) { var sum = 0 ; var it = 0 ; var min = Number . MAX_VALUE ; for ( i = 0 ; i < N ; i ++ ) { sum += A [ i ] ; if ( sum < min ) { min = sum ; it = i + 1 ; } } if ( sum < 0 ) { return - 1 ; } return it % N ; } var arr = [ 3 , - 6 , 7 , - 4 , - 4 , 6 , - 1 ] ; var N = arr . length ; document . write ( startingPoint ( arr , N ) ) ;";"Find the index in a circular array from which prefix sum is always non | Function to find the starting index of the given circular array s . t . prefix sum array is non negative ; Stores the sum of the array ; Stores the starting index ; Stores the minimum prefix sum of A [ 0. . i ] ; Traverse the array arr ; Update the value of sum ; If sum is less than min ; Update the min as the value of prefix sum ; Update in ; Otherwise , no such index is possible ; Driver Code"
Javascript;"class node { constructor ( ) { this . data = 0 ; this . next = null ; } } ; function EvalNearestMult ( N , K ) { var temp = N ; var t ; while ( N != null ) { if ( N . data < K ) N . data = 0 ; else { if ( N . data == K ) N . data = K ; else { N . data = parseInt ( N . data / K ) * K ; } } N = N . next ; } return temp ; } function printList ( N ) { while ( N != null ) { document . write ( N . data + "" "" ) ; N = N . next ; } } var head = null ; var second = null ; var third = null ; head = new node ( ) ; second = new node ( ) ; third = new node ( ) ; head . data = 3 ; head . next = second ; second . data = 4 ; second . next = third ; third . data = 8 ; third . next = null ; var t = EvalNearestMult ( head , 3 ) ; printList ( t ) ;";"Modify Linked List by replacing each node by nearest multiple of K | Structure of node ; Function to replace the node N by the nearest multiple of K ; Traverse the Linked List ; If data is less than K ; If the data of current node is same as K ; Otherwise change the value ; Move to the next node ; Return the updated LL ; Function to print the nodes of the Linked List ; Traverse the LL ; Print the node 's data ; Given Linked List"
Javascript;"function nearestPow ( x , y ) { if ( y == 1 ) return 1 var k = Math . floor ( Math . log ( x ) / Math . log ( y ) ) if ( Math . abs ( Math . pow ( y , k ) - x ) < Math . abs ( Math . pow ( y , ( k + 1 ) ) - x ) ) return Math . pow ( y , k ) return Math . pow ( y , ( k + 1 ) ) } function replacebyNearestPower ( arr ) { var prev = arr [ arr . length - 1 ] var lastNext = arr [ 0 ] for ( var i = 0 ; i < arr . length ; i ++ ) { var temp = arr [ i ] if ( i == arr . length - 1 ) var next = lastNext else var next = arr [ ( i + 1 ) % arr . length ] var prevPow = nearestPow ( arr [ i ] , prev ) var nextPow = nearestPow ( arr [ i ] , next ) if ( Math . abs ( arr [ i ] - prevPow ) < Math . abs ( arr [ i ] - nextPow ) ) arr [ i ] = prevPow else arr [ i ] = nextPow prev = temp } document . write ( arr ) } var arr = [ 2 , 3 , 4 , 1 , 2 ] replacebyNearestPower ( arr )";"Modify array by replacing elements with the nearest power of its previous or next element | Function to calculate the power of y which is nearest to x ; Base Case ; Stores the logarithmic value of x with base y ; Function to replace each array element by the nearest power of its previous or next element ; Stores the previous and next element ; Traverse the array ; Calculate nearest power for previous and next elements ; Replacing the array values ; Print the updated array ; Given array"
Javascript;"function makeSumX ( arr , X , S , i , N ) { if ( i === N ) { return S === X } let a = ( arr [ i ] ) . toString ( ) let l = parseInt ( ( a . substr ( 0 , a . length - 1 ) ) ) let r = parseInt ( ( a . substr ( 1 ) ) ) let x = makeSumX ( arr , X , S + l , i + 1 , N ) ; let y = makeSumX ( arr , X , S + r , i + 1 , N ) ; return ( x y ) ; } function Check ( arr , X , N ) { if ( makeSumX ( arr , X , 0 , 0 , N ) ) { document . write ( "" "" ) } else { document . write ( "" "" ) } } let arr = [ 545 , 433 , 654 , 23 ] ; let N = arr . length ; let X = 134 ; Check ( arr , X , N ) ;";"Check if sum of array can be made equal to X by removing either the first or last digits of every array element | Utility Function to check if the sum of the array elements can be made equal to X by removing either the first or last digits of every array element ; Base Case ; Convert arr [ i ] to string ; Remove last digit ; Remove first digit ; Recursive function call ; Function to check if sum of given array can be made equal to X or not ; Driver code ; Function Call"
Javascript;"function isPower ( m , y ) { let res1 = parseInt ( Math . log ( y ) / Math . log ( m ) ) ; let res2 = Math . log ( y ) / Math . log ( m ) ; return ( res1 == res2 ) ; } function numSub ( arr , n , m ) { let ans = 0 ; let cnt = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( isPower ( m , arr [ i ] ) ) { cnt ++ ; ans += parseInt ( ( cnt * ( cnt - 1 ) ) / 2 ) ; } else { cnt = 0 ; } } return ans ; } let arr = [ 1 , 1 , 1 , 3 ] ; let m = 3 ; let n = arr . length ; document . write ( numSub ( arr , n , m ) ) ;";"Count subarrays having product equal to the power of a given Prime Number | Function to check if y is a power of m or not ; Calculate log y base m and store it in a variable with integer datatype ; Calculate log y base m and store it in a variable with double datatype ; If res1 and res2 are equal , return True . Otherwise , return false ; Function to count the number of subarrays having product of elements equal to a power of m , where m is a prime number ; Stores the count of subarrays required ; Stores current sequence of consecutive array elements which are a multiple of m ; Traverse the array ; If arr [ i ] is a power of M ; Increment cnt ; Update ans ; Update cnt ; Return the count of subarrays ; Input"
Javascript;"function cntPairs ( arr , N ) { var res = 0 ; var bit = Array ( 32 ) . fill ( 0 ) ; var i ; for ( i = 0 ; i < N ; i ++ ) { var pos = Math . ceil ( Math . log2 ( arr [ i ] ) ) ; bit [ pos ] += 1 ; } for ( i = 0 ; i < 32 ; i ++ ) { res += Math . ceil ( ( bit [ i ] * ( bit [ i ] - 1 ) ) / 2 ) ; } return res ; } arr = [ 1 , 2 , 3 , 4 ] ; N = arr . length ; document . write ( cntPairs ( arr , N ) ) ;";"Count pairs whose Bitwise AND exceeds Bitwise XOR from a given array | Function to count pairs that satisfy the above condition ; Stores the count of pairs ; Stores the count of array elements having same positions of MSB ; Traverse the array ; Stores the index of MSB of array elements ; Calculate number of pairs ; Given Input ; Function call to count pairs satisfying the given condition"
Javascript;"function minimumMEX ( arr , N , K ) { let s = new Set ( ) ; for ( let i = 1 ; i <= N + 1 ; i ++ ) s . add ( i ) ; for ( let i = 0 ; i < K ; i ++ ) s . delete ( arr [ i ] ) ; let entry = s . entries ( ) ; let mex = 1 ; for ( let i = K ; i < N ; i ++ ) { s . delete ( arr [ i ] ) ; s . add ( arr [ i - K ] ) ; let firstElem = entry . next ( ) . value mex = Math . min ( mex , 1 ) ; } document . write ( mex + "" "" ) ; } let arr = [ 1 , 2 , 3 , 4 , 5 , 6 ] ; let K = 3 ; let N = arr . length ; minimumMEX ( arr , N , K ) ;";"Minimum MEX from all subarrays of length K | Function to return minimum MEX from all K - length subarrays ; Stores element from [ 1 , N + 1 ] which are not present in subarray ; Store number 1 to N + 1 in set s ; Find the MEX of K - length subarray starting from index 0 ; Find the MEX of all subarrays of length K by erasing arr [ i ] and inserting arr [ i - K ] ; Store first element of set ; Updating the mex ; Print minimum MEX of all K length subarray ; Driver code"
Javascript;"function smallerNumbers ( arr , N ) { let hash = new Array ( 100000 ) ; hash . fill ( 0 ) ; for ( let i = 0 ; i < N ; i ++ ) hash [ arr [ i ] ] ++ ; let sum = 0 ; for ( let i = 1 ; i < 100000 ; i ++ ) { hash [ i ] += hash [ i - 1 ] ; } for ( let i = 0 ; i < N ; i ++ ) { if ( arr [ i ] == 0 ) { document . write ( "" "" + "" "" ) ; continue ; } document . write ( hash [ arr [ i ] - 1 ] + "" "" ) ; } } let arr = [ 3 , 4 , 1 , 1 , 2 ] ; let N = arr . length ; smallerNumbers ( arr , N ) ;";"Count smaller elements present in the array for each array element | Function to count for each array element , the number of elements that are smaller than that element ; Stores the frequencies of array elements ; Traverse the array ; Update frequency of arr [ i ] ; Initialize sum with 0 ; Compute prefix sum of the array hash [ ] ; Traverse the array arr [ ] ; If current element is 0 ; Print the resultant count ; Driver Code"
Javascript;"function truncMod ( a , n ) { let q = Math . round ( a / n ) ; return a - ( n * q ) ; } let a , b ; a = 9 ; b = 4 ; document . write ( a + "" "" + b + "" "" + truncMod ( a , b ) + "" "" ) ; a = - 9 ; b = 4 ; document . write ( a + "" "" + b + "" "" + truncMod ( a , b ) + "" "" ) ; a = 9 ; b = - 4 ; document . write ( a + "" "" + b + "" "" + truncMod ( a , b ) + "" "" ) ; a = - 9 ; b = - 4 ; document . write ( a + "" "" + b + "" "" + truncMod ( a , b ) + "" "" ) ;";"Modulo Operations in Programming With Negative Results | Function to calculate and return the remainder of a % n ; ( a / n ) implicitly gives the truncated result ; Driver Code ; Modulo of two positive numbers ; Modulo of a negative number by a positive number ; Modulo of a positive number by a negative number ; Modulo of two negative numbers"
Javascript;"function average ( arr , N ) { var sum = 0 ; for ( var i = 0 ; i < N ; i ++ ) sum += arr [ i ] ; if ( sum > 2147483647 ) { sum = - 2147483647 + ( sum - 2147483649 ) } return parseInt ( sum / N ) ; } function mean ( arr , N ) { var avg = 0 ; for ( var i = 0 ; i < N ; i ++ ) { avg += parseFloat ( ( arr [ i ] - avg ) / ( i + 1 ) ) ; } return avg ; } var arr = [ 2147483647 , 1 , 2 ] ; var N = arr . length document . write ( "" "" + average ( arr , N ) . toFixed ( 10 ) + "" "" ) ; document . write ( "" "" + mean ( arr , N ) . toFixed ( 10 ) + "" "" ) ;";"Program for average of an array without running into overflow | Function to calculate average of an array using standard method ; Stores the sum of array ; Find the sum of the array ; Return the average ; Function to calculate average of an array using efficient method ; Store the average of the array ; Traverse the array arr [ ] ; Update avg ; Return avg ; Input ; Function call"
Javascript;"function countPairs ( arr , N ) { var count = 0 ; var mp = new Map ( ) ; for ( var i = 0 ; i < N ; i ++ ) { var val = 1.0 * arr [ i ] ; var idx = 1.0 * ( i + 1 ) ; count += mp . has ( val / idx ) ? mp . get ( val / idx ) : 0 if ( mp . has ( val / idx ) ) mp . set ( val / idx , mp . get ( val / idx ) + 1 ) else mp . set ( val / idx , 1 ) } document . write ( count ) ; } var arr = [ 1 , 3 , 5 , 6 , 5 ] ; var N = arr . length ; countPairs ( arr , N ) ;";"Count number of pairs ( i , j ) from an array such that arr [ i ] * j = arr [ j ] * i | Function to count pairs from an array satisfying given conditions ; Stores the total count of pairs ; Stores count of a [ i ] / i ; Traverse the array ; Updating count ; Update frequency in the Map ; Print count of pairs ; Given array ; Size of the array ; Function call to count pairs satisfying given conditions"
Javascript;"function add_edge ( adj , u , v ) { adj [ u ] . push ( v ) ; adj [ v ] . push ( u ) ; } function dfs ( parent , adj , u , par = - 1 ) { parent [ u ] = par ; adj [ u ] . forEach ( child => { if ( child != par ) dfs ( parent , adj , child , u ) ; } ) ; } function countSmallerAncestors ( adj , n ) { var parent = Array ( 100000 ) . fill ( 0 ) ; dfs ( parent , adj , 1 ) ; for ( var i = 1 ; i <= n ; i ++ ) { var node = i ; var cnt = 0 ; while ( parent [ node ] != - 1 ) { if ( parent [ node ] < i ) cnt += 1 ; node = parent [ node ] ; } document . write ( cnt + "" "" ) ; } } var N = 6 ; var adj = Array . from ( Array ( 100000 ) , ( ) => Array ( ) ) ; add_edge ( adj , 1 , 5 ) ; add_edge ( adj , 1 , 4 ) ; add_edge ( adj , 4 , 6 ) ; add_edge ( adj , 5 , 3 ) ; add_edge ( adj , 5 , 2 ) ; countSmallerAncestors ( adj , N ) ;";"Count ancestors with smaller value for each node of a Binary Tree | Function to add an edge between nodes u and v ; Function to perform the DFS Traversal and store parent of each node ; Store the immediate parent ; Traverse the children of the current node ; Recursively call for function dfs for the child node ; Function to count the number of ancestors with values smaller than that of the current node ; Stores the parent of each node ; Perform the DFS Traversal ; Traverse all the nodes ; Store the number of ancestors smaller than node ; Loop until parent [ node ] != - 1 ; If the condition satisfies , increment cnt by 1 ; Print the required result for the current node ; Driver Code ; Tree Formation"
Javascript;"function countSubsequences ( A ) { var odd = 0 ; var even = 0 ; for ( var e1 = 0 ; e1 < A . length ; e1 ++ ) { if ( A [ e1 ] % 2 == 1 ) odd ++ ; else even ++ ; } if ( odd == 0 ) document . write ( 0 ) ; else document . write ( ( 1 << ( A . length - 1 ) ) ) ; } var A = [ 1 , 3 , 4 ] ; countSubsequences ( A ) ;";"Count subsequences having odd Bitwise XOR values from an array | Function to count the subsequences having odd bitwise XOR value ; Stores count of odd elements ; Stores count of even elements ; Traverse the array A [ ] ; If el is odd ; If count of odd elements is 0 ; Given array A [ ] ; Function call to count subsequences having odd bitwise XOR value"
Javascript;"function maxModProdSubarr ( arr , n , M ) { var ans = 0 ; var length = n ; for ( i = 0 ; i < n ; i ++ ) { var product = 1 ; for ( j = i ; j < n ; j ++ ) { product = ( product * arr [ i ] ) % M ; if ( product > ans ) { ans = product ; if ( length > j - i + 1 ) { length = j - i + 1 ; } } } } document . write ( "" "" + ans + "" "" ) ; document . write ( "" "" + "" "" + length ) ; } var arr = [ 2 , 3 , 4 , 2 ] ; var N = arr . length ; var M = 5 ; maxModProdSubarr ( arr , N , M ) ;";"Maximum subarray product modulo M | Function to find maximum subarray product modulo M and minimum length of the subarray ; Stores maximum subarray product modulo M and minimum length of the subarray ; Stores the minimum length of subarray having maximum product ; Traverse the array ; Stores the product of a subarray ; Calculate Subarray whose start index is i ; Multiply product by arr [ i ] ; If product greater than ans ; Update ans ; Update length ; Print maximum subarray product mod M ; Print minimum length of subarray having maximum product ; Driver Code"
Javascript;"function GCD ( a , b ) { return b == 0 ? a : GCD ( b , a % b ) ; } function coprime ( a , b ) { if ( GCD ( a , b ) == 1 ) return true ; return false ; } function numOfPairs ( arr , N ) { let count = 0 ; for ( let i = 0 ; i < N - 1 ; i ++ ) { for ( let j = i + 1 ; j < N ; j ++ ) { if ( coprime ( parseInt ( arr [ i ] ) , parseInt ( arr [ j ] ) ) ) { count = count + 1 ; } } } return count ; } function noOfCoPrimePairs ( N , d1 , d2 ) { let l = [ ] ; l . push ( d1 . toString ( ) ) ; l . push ( d2 . toString ( ) ) ; l . sort ( ) ; if ( N < parseInt ( l [ 1 ] ) ) return ; let total = [ ... l ] ; let temp2 = [ ... l ] ; let flag = 0 ; let temp3 = [ ] ; while ( l [ 0 ] . length < 10 ) { for ( let i = 0 ; i < l . length ; i ++ ) { for ( let j = 0 ; j < 2 ; j ++ ) { if ( parseInt ( l [ i ] + temp2 [ j ] ) > N ) { flag = 1 ; break ; } total . push ( l [ i ] + temp2 [ j ] ) ; temp3 . push ( l [ i ] + temp2 [ j ] ) ; } if ( flag == 1 ) break ; } if ( flag == 1 ) break ; l = [ ... temp3 ] ; temp3 = [ ] ; } let lenOfTotal = total . length ; let ans = numOfPairs ( total , lenOfTotal ) ; document . write ( ans ) ; } let N = 30 , d1 = 2 , d2 = 3 ; noOfCoPrimePairs ( N , d1 , d2 ) ;";"Number of co | JavaScript program for the above approach ; Function to check whether given integers are co - prime or not ; Utility function to count number of co - prime pairs ; Traverse the array ; If co - prime ; Increment count ; Return count ; Function to count number of co - prime pairs ; Stores digits in string form ; Sort the list ; Keep two copies of list l ; Generate 2 digit numbers using d1 and d2 ; If current number does not exceed N ; Stores length of list ; Stores number of co - prime pairs ; Print number of co - prime pairs ; Given value of N , d1 , d2 ; Function call to count number of co - prime pairs"
Javascript;"function tile_placing ( grid , N ) { let dp = new Array ( N + 5 ) ; dp . fill ( 0 ) ; let orig_cost = 0 ; for ( let i = 0 ; i < 2 ; i ++ ) { for ( let j = 0 ; j < N ; j ++ ) { orig_cost += grid [ i ] [ j ] ; } } dp [ 0 ] = 0 ; dp [ 1 ] = Math . abs ( grid [ 0 ] [ 0 ] - grid [ 1 ] [ 0 ] ) ; for ( let i = 2 ; i <= N ; i ++ ) { dp [ i ] = Math . max ( dp [ i - 1 ] + Math . abs ( grid [ 0 ] [ i - 1 ] - grid [ 1 ] [ i - 1 ] ) , dp [ i - 2 ] + Math . abs ( grid [ 0 ] [ i - 2 ] - grid [ 0 ] [ i - 1 ] ) + Math . abs ( grid [ 1 ] [ i - 2 ] - grid [ 1 ] [ i - 1 ] ) ) ; } document . write ( ( orig_cost - dp [ N ] ) + "" "" ) ; } let M = [ [ 7 , 5 , 1 , 3 ] , [ 8 , 6 , 0 , 2 ] ] ; let N = M [ 0 ] . length ; tile_placing ( M , N ) ;";"Minimize cost of placing tiles of dimensions 2 * 1 over a Matrix | Function to find the minimum cost in placing N tiles in a grid M [ ] [ ] ; Stores the minimum profit after placing i tiles ; Traverse the grid [ ] [ ] ; Update the orig_cost ; Traverse over the range [ 2 , N ] ; Place tiles horizentally or vertically ; Print the answer ; Driver Code"
Javascript;"function findSplit ( arr , N ) { for ( let l = 1 ; l <= N - 4 ; l ++ ) { for ( let r = l + 2 ; r <= N - 2 ; r ++ ) { let lsum = 0 , rsum = 0 , msum = 0 ; for ( let i = 0 ; i <= l - 1 ; i ++ ) { lsum += arr [ i ] ; } for ( let i = l + 1 ; i <= r - 1 ; i ++ ) { msum += arr [ i ] ; } for ( let i = r + 1 ; i < N ; i ++ ) { rsum += arr [ i ] ; } if ( lsum == rsum && rsum == msum ) { document . write ( l + "" "" + r + "" "" ) ; return ; } } } document . write ( - 1 ) ; } let arr = [ 2 , 5 , 12 , 7 , 19 , 4 , 3 ] ; let N = arr . length ; findSplit ( arr , N ) ;";"Print indices of pair of array elements required to be removed to split array into 3 equal sum subarrays | Function to check if array can be split into three equal sum subarrays by removing two elements ; Stores sum of all three subarrays ; Sum of left subarray ; Sum of middle subarray ; Sum of right subarray ; Check if sum of subarrays are equal ; Print the possible pair ; If no pair exists , print - 1 ; Given array ; Size of the array"
Javascript;"function solve ( A , n , Q , q ) { var one = 0 ; for ( var i = 0 ; i < n ; i ++ ) if ( A [ i ] == 1 ) one ++ ; var glows = 0 , count = 0 ; if ( one >= Math . ceil ( n / 2 ) ) glows = 1 ; for ( var i = 0 ; i < q ; i ++ ) { var prev = glows ; if ( A [ Q [ i ] - 1 ] == 1 ) one -- ; if ( A [ Q [ i ] - 1 ] == 0 ) one ++ ; A [ Q [ i ] - 1 ] ^= 1 ; if ( one >= Math . ceil ( n / 2.0 ) ) { glows = 1 ; } else { glows = 0 ; } if ( prev != glows ) count ++ ; } return count ; } var n = 3 ; var arr = [ 1 , 1 , 0 ] ; var q = 3 ; var Q = [ 3 , 2 , 1 ] ; document . write ( solve ( arr , n , Q , q ) ) ;";"Count the number of times a Bulb switches its state | Function to find the number of times a bulb switches its state ; Count of 1 s ; Traverse the array ; Update count of 1 s ; Update the status of bulb ; Traverse the array Q [ ] ; Stores previous state of the bulb ; Toggle the switch and update count of 1 s ; If the bulb switches state ; Return count ; Input ; Queries ; Function call to find number of times the bulb toggles"
Javascript;"function sumOfDigits ( N ) { let sum = 0 ; while ( N != 0 ) { sum += N % 10 ; N = parseInt ( N / 10 , 10 ) ; } return sum ; } function elementsHavingDigitSumK ( arr , N , K ) { let count = 0 ; for ( let i = 0 ; i < N ; ++ i ) { if ( sumOfDigits ( arr [ i ] ) == K ) { count ++ ; } } document . write ( count ) ; } let arr = [ 23 , 54 , 87 , 29 , 92 , 62 ] ; let K = 11 ; let N = arr . length ; elementsHavingDigitSumK ( arr , N , K ) ;";"Count array elements having sum of digits equal to K | Function to calculate the sum of digits of the number N ; Stores the sum of digits ; Return the sum ; Function to count array elements ; Store the count of array elements having sum of digits K ; Traverse the array ; If sum of digits is equal to K ; Increment the count ; Print the count ; Given array ; Given value of K ; Size of the array ; Function call to count array elements having sum of digits equal to K"
Javascript;"function calculateSpan ( price , n , S ) { S [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { S [ i ] = 1 ; for ( let j = i - 1 ; ( j >= 0 ) && ( price [ i ] >= price [ j ] ) ; j -- ) S [ i ] ++ ; } } function printArray ( arr ) { let result = arr . join ( "" "" ) ; document . write ( result ) ; } let price = [ 10 , 4 , 5 , 90 , 120 , 80 ] ; let n = price . length ; let S = new Array ( n ) ; S . fill ( 0 ) ; calculateSpan ( price , n , S ) ; printArray ( S ) ;";"The Stock Span Problem | method to calculate stock span values ; Span value of first day is always 1 ; Calculate span value of remaining days by linearly checking previous days ; Initialize span value ; Traverse left while the next element on left is smaller than price [ i ] ; A utility function to print elements of array ; Driver code ; Fill the span values in array S [ ] ; print the calculated span values"
Javascript;"function printNGE ( arr , n ) { var next , i , j ; for ( i = 0 ; i < n ; i ++ ) { next = - 1 ; for ( j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] < arr [ j ] ) { next = arr [ j ] ; break ; } } document . write ( arr [ i ] + "" "" + next ) ; document . write ( "" "" ) ; } } var arr = [ 11 , 13 , 21 , 3 ] ; var n = arr . length ; printNGE ( arr , n ) ;";"Next Greater Element | prints element and NGE pair for all elements of arr [ ] of size n ; Driver Code"
Javascript;"function no_NGN ( arr , n ) { var nxt = [ ] ; var s = [ ] ; nxt . push ( 0 ) ; s . push ( n - 1 ) ; for ( var i = n - 2 ; i >= 0 ; i -- ) { while ( s . length != 0 && arr [ i ] >= arr [ s [ s . length - 1 ] ] ) s . pop ( ) ; if ( s . length == 0 ) nxt . push ( 0 ) ; else nxt . push ( nxt [ n - s [ s . length - 1 ] - 1 ] + 1 ) ; s . push ( i ) ; } nxt . reverse ( ) ; return nxt ; } var n = 8 ; var arr = [ 3 , 4 , 2 , 7 , 5 , 8 , 10 , 6 ] ; var nxt = no_NGN ( arr , n ) ; document . write ( nxt [ 3 ] + "" "" ) ; document . write ( nxt [ 6 ] + "" "" ) ; document . write ( nxt [ 1 ] + "" "" ) ;";"Number of NGEs to the right |  ; use of stl stack in c ++ ; push the ( n - 1 ) th index to the stack ; traverse in reverse order ; if no element is greater than arr [ i ] the number of NGEs to right is 0 ; number of NGEs to right of arr [ i ] is one greater than the number of NGEs to right of higher number to its right ; reverse again because values are in reverse order ; returns the vector of number of next greater elements to the right of each index . ; Driver code ; query 1 answered ; query 2 answered ; query 3 answered"
Javascript;"function sortStack ( input ) { var tmpStack = [ ] ; while ( input . length != 0 ) { var tmp = input [ input . length - 1 ] ; input . pop ( ) ; while ( tmpStack . length != 0 && tmpStack [ tmpStack . length - 1 ] < tmp ) { input . push ( tmpStack [ tmpStack . length - 1 ] ) ; tmpStack . pop ( ) ; } tmpStack . push ( tmp ) ; } return tmpStack ; } function sortArrayUsingStacks ( arr , n ) { var input = [ ] ; for ( var i = 0 ; i < n ; i ++ ) input . push ( arr [ i ] ) ; var tmpStack = sortStack ( input ) ; for ( var i = 0 ; i < n ; i ++ ) { arr [ i ] = tmpStack [ tmpStack . length - 1 ] ; tmpStack . pop ( ) ; } } var arr = [ 10 , 5 , 15 , 45 ] ; var n = arr . length ; sortArrayUsingStacks ( arr , n ) ; for ( var i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "" "" ) ;";"Sorting array using Stacks | This function return the sorted stack ; pop out the first element ; while temporary stack is not empty and top of stack is smaller than temp ; pop from temporary stack and push it to the input stack ; push temp in tempory of stack ; Push array elements to stack ; Sort the temporary stack ; Put stack elements in arrp [ ] ; main function"
Javascript;"function towerOfHanoi ( n , from_rod , to_rod , aux_rod ) { if ( n == 1 ) { document . write ( "" "" + from_rod + "" "" + to_rod + "" "" ) ; return ; } towerOfHanoi ( n - 1 , from_rod , aux_rod , to_rod ) ; document . write ( "" "" + n + "" "" + from_rod + "" "" + to_rod + "" "" ) ; towerOfHanoi ( n - 1 , aux_rod , to_rod , from_rod ) ; } var n = 4 ; towerOfHanoi ( n , ' ' , ' ' , ' ' ) ;";"Program for Tower of Hanoi | javascript recursive function to solve tower of hanoi puzzle ; Number of disks ; A , B and C are names of rods"
Javascript;"var arr = [ 10 , 20 , 30 , 50 , 10 , 70 , 30 ] ; function printMaxOfMin ( n ) { for ( k = 1 ; k <= n ; k ++ ) { var maxOfMin = Number . MIN_VALUE ; for ( i = 0 ; i <= n - k ; i ++ ) { var min = arr [ i ] ; for ( j = 1 ; j < k ; j ++ ) { if ( arr [ i + j ] < min ) min = arr [ i + j ] ; } if ( min > maxOfMin ) maxOfMin = min ; } document . write ( maxOfMin + "" "" ) ; } } printMaxOfMin ( arr . length ) ;";"Find maximum of minimum for every window size in a given array | A naive method to find maximum of minimum of all windows of different sizes ; Consider all windows of different sizes starting from size 1 ; Initialize max of min for current window size k ; Traverse through all windows of current size k ; Find minimum of current window ; Update maxOfMin if required ; Prvar max of min for current window size ; Driver method"
Javascript;"let arr = [ 10 , 20 , 30 , 50 , 10 , 70 , 30 ] ; function printMaxOfMin ( n ) { let s = [ ] ; let left = new Array ( n + 1 ) ; left . fill ( 0 ) ; let right = new Array ( n + 1 ) ; right . fill ( 0 ) ; for ( let i = 0 ; i < n ; i ++ ) { left [ i ] = - 1 ; right [ i ] = n ; } for ( let i = 0 ; i < n ; i ++ ) { while ( s . length > 0 && arr [ s [ s . length - 1 ] ] >= arr [ i ] ) { s . pop ( ) ; } if ( s . length > 0 ) { left [ i ] = s [ s . length - 1 ] ; } s . push ( i ) ; } while ( s . length > 0 ) { s . pop ( ) ; } for ( let i = n - 1 ; i >= 0 ; i -- ) { while ( s . length > 0 && arr [ s [ s . length - 1 ] ] >= arr [ i ] ) { s . pop ( ) ; } if ( s . length > 0 ) { right [ i ] = s [ s . length - 1 ] ; } s . push ( i ) ; } let ans = new Array ( n + 1 ) ; ans . fill ( 0 ) ; for ( let i = 0 ; i <= n ; i ++ ) { ans [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { let len = right [ i ] - left [ i ] - 1 ; ans [ len ] = Math . max ( ans [ len ] , arr [ i ] ) ; } for ( let i = n - 1 ; i >= 1 ; i -- ) { ans [ i ] = Math . max ( ans [ i ] , ans [ i + 1 ] ) ; } for ( let i = 1 ; i <= n ; i ++ ) { document . write ( ans [ i ] + "" "" ) ; } } printMaxOfMin ( arr . length ) ;";"Find maximum of minimum for every window size in a given array | An efficient Javascript program to find maximum of all minimums of windows of different size ; Used to find previous and next smaller ; Arrays to store previous and next smaller ; Initialize elements of left [ ] and right [ ] ; Fill elements of left [ ] using logic discussed on www . geeksforgeeks . org / next - greater - element / https : ; Empty the stack as stack is going to be used for right [ ] ; Fill elements of right [ ] using same logic ; Create and initialize answer array ; Fill answer array by comparing minimums of all lengths computed using left [ ] and right [ ] ; length of the interval ; arr [ i ] is a possible answer for this length ' len ' interval , check x if arr [ i ] is more than max for ' len ' ; Some entries in ans [ ] may not be filled yet . Fill them by taking values from right side of ans [ ] ; Print the result"
Javascript;"function solve ( s , n ) { let left = 0 , right = 0 , maxlength = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' ) left ++ ; else right ++ ; if ( left == right ) maxlength = max ( maxlength , 2 * right ) ; else if ( right > left ) left = right = 0 ; } left = right = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == ' ' ) left ++ ; else right ++ ; if ( left == right ) maxlength = Math . max ( maxlength , 2 * left ) ; else if ( left > right ) left = right = 0 ; } return maxlength ; } document . write ( solve ( "" "" , 16 ) ) ;";"Length of the longest valid substring | Function to return the length of the longest valid substring ; Variables for left and right counter . maxlength to store the maximum length found so far ; Iterating the string from left to right ; If "" ( "" is encountered , then left counter is incremented else right counter is incremented ; Whenever left is equal to right , it signifies that the subsequence is valid and ; Reseting the counters when the subsequence becomes invalid ; Iterating the string from right to left ; If "" ( "" is encountered , then left counter is incremented else right counter is incremented ; Whenever left is equal to right , it signifies that the subsequence is valid and ; Reseting the counters when the subsequence becomes invalid ; Function call"
Javascript;"function nextGreater ( arr , next , order ) { let stack = [ ] ; for ( let i = arr . length - 1 ; i >= 0 ; i -- ) { while ( stack . length != 0 && ( ( order == ' ' ) ? arr [ stack [ stack . length - 1 ] ] <= arr [ i ] : arr [ stack [ stack . length - 1 ] ] >= arr [ i ] ) ) stack . pop ( ) ; if ( stack . length != 0 ) next [ i ] = stack [ stack . length - 1 ] ; else next [ i ] = - 1 ; stack . push ( i ) ; } } function nextSmallerOfNextGreater ( arr ) { let NG = new Array ( arr . length ) ; let RS = new Array ( arr . length ) ; for ( let i = 0 ; i < arr . length ; i ++ ) { NG [ i ] = 0 ; RS [ i ] = 0 ; } nextGreater ( arr , NG , ' ' ) ; nextGreater ( arr , RS , ' ' ) ; for ( let i = 0 ; i < arr . length ; i ++ ) { if ( NG [ i ] != - 1 && RS [ NG [ i ] ] != - 1 ) document . write ( arr [ RS [ NG [ i ] ] ] + "" "" ) ; else document . write ( "" "" ) ; } } let arr = [ 5 , 1 , 9 , 2 , 5 , 1 , 7 ] ; nextSmallerOfNextGreater ( arr ) ;";"Find next Smaller of next Greater in an array | function find Next greater element ; create empty stack ; Traverse all array elements in reverse order order == ' G ' we compute next greater elements of every element order == ' S ' we compute right smaller element of every element ; Keep removing top element from S while the top element is smaller then or equal to arr [ i ] ( if Key is G ) element is greater then or equal to arr [ i ] ( if order is S ) ; store the next greater element of current element ; If all elements in S were smaller than arr [ i ] ; Push this element ; Function to find Right smaller element of next greater element ; stores indexes of next greater elements ; stores indexes of right smaller elements ; Find next greater element Here G indicate next greater element ; Find right smaller element using same function nextGreater ( ) Here S indicate right smaller elements ; If NG [ i ] = = - 1 then there is no smaller element on right side . We can find Right smaller of next greater by arr [ RS [ NG [ i ] ] ] ; Driver code"
Javascript;"class Node { constructor ( data ) { this . data = data ; this . left = this . right = null ; } } ; function flipBinaryTree ( root ) { if ( root == null ) return root ; if ( root . left == null && root . right == null ) return root ; let flippedRoot = flipBinaryTree ( root . left ) ; root . left . left = root . right ; root . left . right = root ; root . left = root . right = null ; return flippedRoot ; } function printLevelOrder ( root ) { if ( root == null ) return ; let q = [ ] ; q . push ( root ) ; while ( true ) { let nodeCount = q . length ; if ( nodeCount == 0 ) break ; while ( nodeCount > 0 ) { let node = q . shift ( ) ; document . write ( node . data + "" "" ) ; if ( node . left != null ) q . push ( node . left ) ; if ( node . right != null ) q . push ( node . right ) ; nodeCount -- ; } document . write ( "" "" ) ; } } let root = new Node ( 1 ) ; root . left = new Node ( 2 ) ; root . right = new Node ( 3 ) ; root . right . left = new Node ( 4 ) ; root . right . right = new Node ( 5 ) ; document . write ( "" "" ) ; printLevelOrder ( root ) ; root = flipBinaryTree ( root ) ; document . write ( "" "" ) ; printLevelOrder ( root ) ;";"Flip Binary Tree | A binary tree node structure ; method to flip the binary tree ; recursively call the same method ; rearranging main root Node after returning from recursive call ; Iterative method to do level order traversal line by line ; Base Case ; Create an empty queue for level order traversal ; Enqueue Root and initialize height ; nodeCount ( queue size ) indicates number of nodes at current lelvel . ; Dequeue all nodes of current level and Enqueue all nodes of next level ; Driver code"
Javascript;"function heapify ( arr , n , i ) { var largest = i ; var l = 2 * i + 1 ; var r = 2 * i + 2 ; if ( l < n && arr [ l ] > arr [ largest ] ) largest = l ; if ( r < n && arr [ r ] > arr [ largest ] ) largest = r ; if ( largest != i ) { var swap = arr [ i ] ; arr [ i ] = arr [ largest ] ; arr [ largest ] = swap ; heapify ( arr , n , largest ) ; } } function sort ( arr ) { var n = arr . length ; for ( var i = n / 2 - 1 ; i >= 0 ; i -- ) heapify ( arr , n , i ) ; for ( var i = n - 1 ; i > 0 ; i -- ) { var temp = arr [ 0 ] ; arr [ 0 ] = arr [ i ] ; arr [ i ] = temp ; heapify ( arr , i , 0 ) ; } } function printArray ( arr ) { var n = arr . length ; for ( var i = 0 ; i < n ; ++ i ) document . write ( arr [ i ] + "" "" ) ; } var arr = [ 12 , 11 , 13 , 5 , 6 , 7 ] ; var n = arr . length ; sort ( arr ) ; document . write ( "" "" ) ; printArray ( arr , n ) ;";"HeapSort | To heapify a subtree rooted with node i which is an index in arr [ ] . n is size of heap ; Initialize largest as root ; left = 2 * i + 1 ; right = 2 * i + 2 ; If left child is larger than root ; If right child is larger than largest so far ; If largest is not root ; Recursively heapify the affected sub - tree ; The main function to sort an array of given size ; Build heap ( rearrange array ) ; One by one extract an element from heap ; Move current root to end ; call max heapify on the reduced heap ; A utility function to print array of size n ; Driver code"
Javascript;"function isHeap ( arr , n ) { for ( let i = 0 ; i <= Math . floor ( ( n - 2 ) / 2 ) ; i ++ ) { if ( arr [ 2 * i + 1 ] > arr [ i ] ) return false ; if ( 2 * i + 2 < n && arr [ 2 * i + 2 ] > arr [ i ] ) return false ; } return true ; } let arr = [ 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ] ; let n = arr . length ; if ( isHeap ( arr , n ) ) { document . write ( "" "" ) ; } else { document . write ( "" "" ) ; }";"How to check if a given array represents a Binary Heap ? | Returns true if arr [ i . . n - 1 ] represents a max - heap ; Start from root and go till the last internal node ; If left child is greater , return false ; If right child is greater , return false ; driver code"
Javascript;"function mergeKArrays ( arr , a , output ) { var c = 0 ; for ( i = 0 ; i < a ; i ++ ) { for ( j = 0 ; j < 4 ; j ++ ) output [ c ++ ] = arr [ i ] [ j ] ; } output . sort ( ( a , b ) => a - b ) ; } function printArray ( arr , size ) { for ( i = 0 ; i < size ; i ++ ) document . write ( arr [ i ] + "" "" ) ; } var arr = [ [ 2 , 6 , 12 , 34 ] , [ 1 , 9 , 20 , 1000 ] , [ 23 , 34 , 90 , 2000 ] ] ; var k = 4 ; var n = 3 ; var output = Array ( n * k ) . fill ( 0 ) ; mergeKArrays ( arr , n , output ) ; document . write ( "" "" ) ; printArray ( output , n * k ) ;";"Merge k sorted arrays | Set 1 | This function takes an array of arrays as an argument and All arrays are assumed to be sorted . It merges them together and prints the final sorted output . ; traverse the matrix ; sort the array ; A utility function to print array elements ; Driver program to test above functions"
Javascript;"let n = 4 function mergeArrays ( arr1 , arr2 , n1 , n2 , arr3 ) { let i = 0 , j = 0 , k = 0 ; while ( i < n1 && j < n2 ) { if ( arr1 [ i ] < arr2 [ j ] ) arr3 [ k ++ ] = arr1 [ i ++ ] ; else arr3 [ k ++ ] = arr2 [ j ++ ] ; } while ( i < n1 ) arr3 [ k ++ ] = arr1 [ i ++ ] ; while ( j < n2 ) arr3 [ k ++ ] = arr2 [ j ++ ] ; } function printArray ( arr , size ) { for ( let i = 0 ; i < size ; i ++ ) document . write ( arr [ i ] + "" "" ) ; } function mergeKArrays ( arr , i , j , output ) { if ( i == j ) { for ( let p = 0 ; p < n ; p ++ ) output [ p ] = arr [ i ] [ p ] ; return ; } if ( j - i == 1 ) { mergeArrays ( arr [ i ] , arr [ j ] , n , n , output ) ; return ; } let out1 = new Array ( n * ( ( ( i + j ) / 2 ) - i + 1 ) ) let out2 = new Array ( n * ( j - ( ( i + j ) / 2 ) ) ) ; mergeKArrays ( arr , i , ( i + j ) / 2 , out1 ) ; mergeKArrays ( arr , ( i + j ) / 2 + 1 , j , out2 ) ; mergeArrays ( out1 , out2 , n * ( ( ( i + j ) / 2 ) - i + 1 ) , n * ( j - ( ( i + j ) / 2 ) ) , output ) ; } let arr = [ [ 2 , 6 , 12 , 34 ] , [ 1 , 9 , 20 , 1000 ] , [ 23 , 34 , 90 , 2000 ] ] ; let k = arr . length ; let output = new Array ( n * k ) ; mergeKArrays ( arr , 0 , 2 , output ) ; document . write ( "" "" + "" "" ) ; printArray ( output , n * k ) ;";"Merge k sorted arrays | Set 1 | Javascript program to merge k sorted arrays of size n each . ; Merge arr1 [ 0. . n1 - 1 ] and arr2 [ 0. . n2 - 1 ] into arr3 [ 0. . n1 + n2 - 1 ] ; Traverse both array ; Check if current element of first array is smaller than current element of second array . If yes , store first array element and increment first array index . Otherwise do same with second array ; Store remaining elements of first array ; Store remaining elements of second array ; A utility function to print array elements ; This function takes an array of arrays as an argument and all arrays are assumed to be sorted . It merges them together and prints the final sorted output . ; If one array is in range ; If only two arrays are left them merge them ; Output arrays ; Divide the array into halves ; Merge the output array ; Driver code Change n at the top to change number of elements in an array"
Javascript;"function generate_derangement ( N ) { let S = [ ] ; for ( let i = 1 ; i <= N ; i ++ ) S [ i ] = i ; let D = [ ] ; for ( let i = 1 ; i <= N ; i += 2 ) { if ( i == N ) { D [ N ] = S [ N - 1 ] ; D [ N - 1 ] = S [ N ] ; } else { D [ i ] = i + 1 ; D [ i + 1 ] = i ; } } for ( let i = 1 ; i <= N ; i ++ ) document . write ( D [ i ] + "" "" ) ; document . write ( "" "" ) ; } generate_derangement ( 10 ) ;";"Smallest Derangement of Sequence | Javascript program to find smallest derangement . ; Generate Sequence S ; Generate Derangement ; Only if i is odd Swap S [ N - 1 ] and S [ N ] ; Prlet Derangement ; Driver code"
Javascript;"function Profit ( costPrice , sellingPrice ) { let profit = ( sellingPrice - costPrice ) ; return profit ; } function Loss ( costPrice , ellingPrice ) { let Loss = ( costPrice - sellingPrice ) ; return Loss ; } let costPrice = 1500 , sellingPrice = 2000 ; if ( sellingPrice == costPrice ) document . write ( "" "" ) ; else if ( sellingPrice > costPrice ) document . write ( Profit ( costPrice , sellingPrice ) + "" "" ) ; else document . write ( Loss ( costPrice , sellingPrice ) + "" "" ) ;";"Program to calculate Profit Or Loss | Function to calculate Profit . ; Function to calculate Loss . ; Driver Code ."
Javascript;"function nextPerfectSquare ( N ) { let nextN = Math . floor ( Math . sqrt ( N ) ) + 1 ; return nextN * nextN ; } let n = 35 ; document . write ( nextPerfectSquare ( n ) ) ;";"Find the Next perfect square greater than a given number | Function to find the next perfect square ; Driver Code"
Javascript;"function printSubstrings ( n ) { var s = parseInt ( Math . log10 ( n ) ) ; var d = parseInt ( ( Math . pow ( 10 , s ) + 0.5 ) ) ; var k = d ; while ( n > 0 ) { while ( d > 0 ) { document . write ( parseInt ( n / d ) + "" "" ) ; d = parseInt ( d / 10 ) ; } n = n % k ; k = parseInt ( k / 10 ) ; d = k ; } } var n = 123 ; printSubstrings ( n ) ;";"Print all substring of a number without any conversion | Function to print the substrings of a number ; Calculate the total number of digits ; 0.5 has been added because of it will return double value like 99.556 ; Print all the numbers from starting position ; Update the no . ; Update the no . of digits ; Driver code"
Javascript;"let MOD = ( 1e9 + 7 ) ; function powerLL ( x , n ) { let result = 1 ; while ( n > 0 ) { if ( n % 2 == 1 ) { result = result * x % MOD ; } n = Math . floor ( n / 2 ) ; x = x * x % MOD ; } return result ; } function powerStrings ( sa , sb ) { let a = 0 , b = 0 ; for ( let i = 0 ; i < sa . length ; i ++ ) { a = ( a * 10 + ( sa [ i ] - ' ' ) ) % MOD ; } for ( let i = 0 ; i < sb . length ; i ++ ) { b = ( b * 10 + ( sb [ i ] - ' ' ) ) % ( MOD - 1 ) ; } return powerLL ( a , b ) ; } let sa = "" "" , sb = "" "" ; document . write ( powerStrings ( sa , sb ) ) ;";"Modulo power for large numbers represented as strings | Javascript program to find ( a ^ b ) % MOD where a and b may be very large and represented as strings . ; Returns modulo exponentiation for two numbers represented as long long let . It is used by powerStrings ( ) . Its complexity is log ( n ) ; Returns modulo exponentiation for two numbers represented as strings . It is used by powerStrings ( ) ; We convert strings to number ; calculating a % MOD ; calculating b % ( MOD - 1 ) ; Now a and b are long long let . We calculate a ^ b using modulo exponentiation ; As numbers are very large that is it may contains upto 10 ^ 6 digits . So , we use string ."
Javascript;"function isPowerOfTwo ( n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ; } function previousPowerOfTwo ( n ) { while ( ( n & n - 1 ) > 1 ) { n = n & n - 1 ; } return n ; } function checkSum ( n ) { if ( n == 0 n == 1 ) return false ; else if ( isPowerOfTwo ( n ) ) { document . write ( n / 2 + "" "" + n / 2 + "" "" ) ; } else { var x = previousPowerOfTwo ( n ) ; var y = n - x ; if ( isPowerOfTwo ( y ) ) { document . write ( x + "" "" + y + "" "" ) ; return true ; } } return false ; } var n1 = 20 ; if ( checkSum ( n1 ) == false ) document . write ( "" "" ) ; document . write ( ) ; var n2 = 11 ; if ( checkSum ( n2 ) == false ) document . write ( "" "" ) ;";"Check if a number can be expressed as 2 ^ x + 2 ^ y | Utility function to check if a number is power of 2 or not ; Utility function to determine the value of previous power of 2 ; function to check if n can be expressed as 2 ^ x + 2 ^ y or not ; if value of n is 0 or 1 it can not be expressed as 2 ^ x + 2 ^ y ; if a number is power of 2 it can be expressed as 2 ^ x + 2 ^ y ; if the remainder after subtracting previous power of 2 is also a power of 2 then it can be expressed as 2 ^ x + 2 ^ y ; driver code"
Javascript;"function complement ( num ) { var i , len = 0 , temp , comp ; temp = num ; while ( true ) { len ++ ; num = parseInt ( num / 10 ) ; if ( Math . abs ( num ) == 0 ) break ; } num = temp ; comp = parseInt ( Math . pow ( 10 , len ) - num ) ; return comp ; } document . write ( complement ( 25 ) + "" "" ) ; document . write ( complement ( 456 ) ) ;";"10 's Complement of a decimal number | Function to find 10 's complement ; Calculating total digits in num ; restore num ; calculate 10 's complement ; Driver code"
Javascript;"function gcd ( a , b ) { if ( a == 0 && b == 0 ) return 0 ; if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } var a = 98 , b = 56 ; document . write ( "" "" + a + "" "" + b + "" "" + gcd ( a , b ) ) ;";"Program to find HCF ( Highest Common Factor ) of 2 Numbers | Recursive function to return gcd of a and b ; Everything divides 0 ; Base case ; a is greater ; Driver code"
Javascript;"function countOddSum ( a , n ) { let c_odd = 0 , result = 0 ; let odd = false ; for ( let i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 1 ) { odd = ! odd ; } if ( odd ) { c_odd ++ ; } } for ( let i = 0 ; i < n ; i ++ ) { result += c_odd ; if ( a [ i ] % 2 == 1 ) { c_odd = ( n - i - c_odd ) ; } } return result ; } let ar = [ 5 , 4 , 4 , 5 , 1 , 3 ] ; let n = ar . length ; document . write ( "" "" + "" "" + countOddSum ( ar , n ) ) ;";"Number of sub arrays with odd sum | Function to find number of subarrays with odd sum ; ' odd ' stores number of odd numbers upto ith index ' c _ odd ' stores number of odd sum subarrays starting at ith index ' Result ' stores the number of odd sum subarrays ; First find number of odd sum subarrays starting at 0 th index ; Find number of odd sum subarrays starting at ith index add to result ; Driver code"
Javascript;"function findNthRoot ( x , n ) { let low , high ; if ( x >= 0 && x <= 1 ) { low = x ; high = 1 ; } else { low = 1 ; high = x ; } let epsilon = 0.00000001 ; let guess = parseInt ( ( low + high ) / 2 , 10 ) ; while ( Math . abs ( ( Math . pow ( guess , n ) ) - x ) >= epsilon ) { if ( Math . pow ( guess , n ) > x ) { high = guess ; } else { low = guess ; } guess = ( low + high ) / 2 ; } document . write ( guess ) ; } let x = 5 ; let n = 2 ; findNthRoot ( x , n ) ;";"Calculating n | Javascript Program to find n - th real root of x ; Initialize boundary values ; used for taking approximations of the answer ; Do binary search ; Driver code"
Javascript;"function calculateSum ( n ) { let sum = 0 ; for ( let row = 0 ; row < n ; row ++ ) { sum = sum + ( 1 << row ) ; } return sum ; } let n = 10 ; document . write ( "" "" + calculateSum ( n ) ) ;";"Sum of all elements up to Nth row in a Pascal triangle | Function to find sum of all elements upto nth row . ; Initialize sum with 0 ; Loop to calculate power of 2 upto n and add them ; Driver Code"
Javascript;"function findAllSequence ( N ) { if ( N % 2 == 0 ) { return ( Math . pow ( 2 , N / 2 + 1 ) + Math . pow ( 2 , N / 2 ) - 2 ) ; } else { return ( Math . pow ( 2 , ( N + 1 ) / 2 ) + Math . pow ( 2 , ( N + 1 ) / 2 ) - 2 ) ; } } let N = 2 ; document . write ( findAllSequence ( N ) ) ;";"Number of sequences which has HEAD at alternate positions to the right of the first HEAD | function to calculate total sequences possible ; Value of N is even ; Value of N is odd ; Driver code"
Javascript;"let N = 1000000 ; let phi = new Array ( N + 5 ) ; phi . fill ( 0 ) ; function computeTotient ( ) { for ( let i = 1 ; i <= N ; i ++ ) phi [ i ] = i ; for ( let p = 2 ; p <= N ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( let i = 2 * p ; i <= N ; i += p ) { phi [ i ] = ( phi [ i ] / p ) * ( p - 1 ) ; } } } } function power ( x , y , p ) { while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } function calculate ( x , k , mod ) { let arr = new Array ( N ) ; arr . fill ( 0 ) ; let count = 0 ; while ( mod > 1 ) { arr [ count ++ ] = mod ; mod = phi [ mod ] ; } let result = 1 ; let loop = count + 1 ; arr [ count ] = 1 ; for ( let i = Math . min ( k , loop ) - 1 ; i >= 0 ; i -- ) result = power ( x , result , arr [ i ] ) ; return result ; } computeTotient ( ) ; let x = 3 , k = 2 , m = 3 ; document . write ( calculate ( x , k , m ) ) ;";"Compute power of power k times % m | Create an array to store phi or totient values ; Function to calculate Euler Totient values ; indicates not evaluated yet and initializes for product formula . ; Compute other Phi values ; If phi [ p ] is not computed already , then number p is prime ; Phi of a prime number p is always equal to p - 1. ; Update phi values of all multiples of p ; Add contribution of p to its multiple i by multiplying with ( 1 - 1 / p ) ; Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; x = x % p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 ; y = y / 2 ; Function to calculate ( x ^ x ^ x ^ x ... k times ) % m ; to store different mod values ; run loop in reverse to calculate result ; compute euler totient function values ; Calling function to compute answer"
Javascript;"function countOnes ( n ) { let count = 1 ; let rem = 1 ; while ( rem != 0 ) { rem = ( rem * 10 + 1 ) % n ; count ++ ; } return count ; } let n = 13 ; document . write ( countOnes ( n ) ) ;";"Number of ones in the smallest repunit | Function to find number of 1 s in smallest repunit multiple of the number ; to store number of 1 s in smallest repunit multiple of the number . ; initialize rem with 1 ; run loop until rem becomes zero ; rem * 10 + 1 here represents the repunit modulo n ; when remainder becomes 0 return count ; Driver Code ; Calling function"
Javascript;"function largestNum ( a , b ) { return a * ( parseInt ( a / b ) > 0 ? 1 : 0 ) + b * ( parseInt ( b / a ) > 0 ? 1 : 0 ) ; } var a = 22 , b = 1231 ; document . write ( largestNum ( a , b ) ) ;";"Largest of two distinct numbers without using any conditional statements or operators | Function to find the largest number ; Driver code"
Javascript;"function gcd ( a , b ) { var c = a % b ; while ( c != 0 ) { a = b ; b = c ; c = a % b ; } return b ; } function numberOfmeet ( a , b ) { var ans ; if ( a > b ) ans = a - b ; else ans = b - a ; if ( a < 0 ) a = a * ( - 1 ) ; if ( b < 0 ) b = b * ( - 1 ) ; return ans / gcd ( a , b ) ; } var a = 1 , b = - 1 ; document . write ( numberOfmeet ( a , b ) ) ;";"Number of Distinct Meeting Points on a Circular Road | Returns the GCD of two number . ; Returns the number of distinct meeting points . ; Find the relative speed . ; convert the negative value to positive . ; Driver Code"
Javascript;"let MAX = 1005 ; function SieveOfEratosthenes ( primes ) { let prime = new Array ( MAX ) ; for ( let i = 0 ; i < prime . length ; i ++ ) { prime [ i ] = true ; } for ( let p = 2 ; p * p < MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i < MAX ; i += p ) { prime [ i ] = false ; } } } for ( let p = 2 ; p < MAX ; p ++ ) { if ( prime [ p ] ) { primes . push ( p ) ; } } } function minimumSquareFreeDivisors ( N ) { let primes = [ ] ; SieveOfEratosthenes ( primes ) ; let max_count = 0 ; for ( let i = 0 ; i < primes . length && primes [ i ] * primes [ i ] <= N ; i ++ ) { if ( N % primes [ i ] == 0 ) { let tmp = 0 ; while ( N % primes [ i ] == 0 ) { tmp ++ ; N = parseInt ( N / primes [ i ] , 10 ) ; } max_count = Math . max ( max_count , tmp ) ; } } if ( max_count == 0 ) { max_count = 1 ; } return max_count ; } let N = 24 ; document . write ( "" "" + minimumSquareFreeDivisors ( N ) + "" "" ) ; N = 6 ; document . write ( "" "" + minimumSquareFreeDivisors ( N ) ) ;";"Minimum number of Square Free Divisors | Initializing MAX with SQRT ( 10 ^ 6 ) ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is Not a prime , else true . ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Print all prime numbers ; This function returns the minimum number of Square Free divisors ; Precomputing Prime Factors ; holds max of max power of all prime factors ; holds the max power of current prime factor ; If number itself is prime , it will be included as answer and thus minimum required answer is 1 ; Driver Code to test above functions"
Javascript;"function findMaxGCD ( arr , n , k ) { arr . sort ( function ( a , b ) { return a - b ; } ) ; let high = arr [ n - 1 ] ; let divisors = new Array ( high + 1 ) ; for ( let i = 0 ; i < divisors . length ; i ++ ) { divisors [ i ] = 0 ; } for ( let i = 0 ; i < n ; i ++ ) { for ( let j = 1 ; j <= Math . sqrt ( arr [ i ] ) ; j ++ ) { if ( arr [ i ] % j == 0 ) { divisors [ j ] ++ ; if ( j != Math . floor ( arr [ i ] / j ) ) divisors [ Math . floor ( arr [ i ] / j ) ] ++ ; } } } for ( let i = high ; i >= 1 ; i -- ) if ( divisors [ i ] >= k ) return i ; return 0 ; } let arr = [ 1 , 2 , 4 , 8 , 8 , 12 ] ; let k = 3 ; let n = arr . length ; document . write ( findMaxGCD ( arr , n , k ) ) ;";"Subsequence of size k with maximum possible GCD | function to find GCD of sub sequence of size k with max GCD in the array ; Computing highest element ; Array to store the count of divisors i . e . Potential GCDs ; Iterating over every element ; Calculating all the divisors ; Divisor found ; Incrementing count for divisor ; Element / divisor is also a divisor Checking if both divisors are not same ; Checking the highest potential GCD ; If this divisor can divide at least k numbers , it is a GCD of at least one sub sequence of size k ; Array in which sub sequence with size k with max GCD is to be found"
Javascript;"function determinantOfMatrix ( mat ) { let ans ; ans = mat [ 0 ] [ 0 ] * ( mat [ 1 ] [ 1 ] * mat [ 2 ] [ 2 ] - mat [ 2 ] [ 1 ] * mat [ 1 ] [ 2 ] ) - mat [ 0 ] [ 1 ] * ( mat [ 1 ] [ 0 ] * mat [ 2 ] [ 2 ] - mat [ 1 ] [ 2 ] * mat [ 2 ] [ 0 ] ) + mat [ 0 ] [ 2 ] * ( mat [ 1 ] [ 0 ] * mat [ 2 ] [ 1 ] - mat [ 1 ] [ 1 ] * mat [ 2 ] [ 0 ] ) ; return ans ; } function findSolution ( coeff ) { let d = [ [ coeff [ 0 ] [ 0 ] , coeff [ 0 ] [ 1 ] , coeff [ 0 ] [ 2 ] ] , [ coeff [ 1 ] [ 0 ] , coeff [ 1 ] [ 1 ] , coeff [ 1 ] [ 2 ] ] , [ coeff [ 2 ] [ 0 ] , coeff [ 2 ] [ 1 ] , coeff [ 2 ] [ 2 ] ] ] ; let d1 = [ [ coeff [ 0 ] [ 3 ] , coeff [ 0 ] [ 1 ] , coeff [ 0 ] [ 2 ] ] , [ coeff [ 1 ] [ 3 ] , coeff [ 1 ] [ 1 ] , coeff [ 1 ] [ 2 ] ] , [ coeff [ 2 ] [ 3 ] , coeff [ 2 ] [ 1 ] , coeff [ 2 ] [ 2 ] ] ] ; let d2 = [ [ coeff [ 0 ] [ 0 ] , coeff [ 0 ] [ 3 ] , coeff [ 0 ] [ 2 ] ] , [ coeff [ 1 ] [ 0 ] , coeff [ 1 ] [ 3 ] , coeff [ 1 ] [ 2 ] ] , [ coeff [ 2 ] [ 0 ] , coeff [ 2 ] [ 3 ] , coeff [ 2 ] [ 2 ] ] ] ; let d3 = [ [ coeff [ 0 ] [ 0 ] , coeff [ 0 ] [ 1 ] , coeff [ 0 ] [ 3 ] ] , [ coeff [ 1 ] [ 0 ] , coeff [ 1 ] [ 1 ] , coeff [ 1 ] [ 3 ] ] , [ coeff [ 2 ] [ 0 ] , coeff [ 2 ] [ 1 ] , coeff [ 2 ] [ 3 ] ] ] ; let D = determinantOfMatrix ( d ) ; let D1 = determinantOfMatrix ( d1 ) ; let D2 = determinantOfMatrix ( d2 ) ; let D3 = determinantOfMatrix ( d3 ) ; document . write ( "" "" , D . toFixed ( 6 ) + "" "" ) ; document . write ( "" "" , D1 . toFixed ( 6 ) + "" "" ) ; document . write ( "" "" , D2 . toFixed ( 6 ) + "" "" ) ; document . write ( "" "" , D3 . toFixed ( 6 ) + "" "" ) ; if ( D != 0 ) { let x = D1 / D ; let y = D2 / D ; document . write ( "" "" , x . toFixed ( 6 ) + "" "" ) ; document . write ( "" "" , y . toFixed ( 6 ) + "" "" ) ; document . write ( "" "" , z . toFixed ( 6 ) + "" "" ) ; } else { if ( D1 == 0 && D2 == 0 && D3 == 0 ) document . write ( "" "" ) ; else if ( D1 != 0 D2 != 0 D3 != 0 ) document . write ( "" "" ) ; } } ' ' ' ' ' ' let coeff = [ [ 2 , - 1 , 3 , 9 ] , [ 1 , 1 , 1 , 6 ] , [ 1 , - 1 , 1 , 2 ] ] findSolution ( coeff ) ;";"System of Linear Equations in three variables using Cramer 's Rule | This functions finds the determinant of Matrix ; This function finds the solution of system of linear equations using cramer 's rule ; Matrix d using coeff as given in cramer 's rule ; Matrix d1 using coeff as given in cramer 's rule ; Matrix d2 using coeff as given in cramer 's rule  ; Matrix d3 using coeff as given in cramer 's rule ; Calculating Determinant of Matrices d , d1 , d2 , d3 ; Case 1 ; Coeff have a unique solution . Apply Cramer 's Rule ; let z = D3 / D ; calculating z using cramer 's rule ; Case 2 ;"
Javascript;"function printGreater ( x , y ) { let X = y * Math . log ( x ) ; let Y = x * Math . log ( y ) ; if ( Math . abs ( X - Y ) < 1e-9 ) { document . write ( "" "" ) ; } else if ( X > Y ) { document . write ( x + "" "" + y ) ; } else { document . write ( y + "" "" + x ) ; } } let x = 5 , y = 8 ; printGreater ( x , y ) ;";"Find larger of x ^ y and y ^ x | Javascript program to print greater of x ^ y and y ^ x ; Driver Code"
Javascript;"function sumOfSeries ( n ) { return n * ( n + 1 ) * ( 6 * n * n * n + 9 * n * n + n - 1 ) / 30 ; } let n = 4 ; document . write ( sumOfSeries ( n ) ) ;";"n | Function to find nth term ; Driver code"
Javascript;"function mulmod ( a , b , mod ) { a = a % mod ; while ( b > 0 ) { if ( b % 2 == 1 ) res = ( res + a ) % mod ; a = ( a * 2 ) % mod ; b = parseInt ( b / 2 , 10 ) ; } return res % mod ; } function findProduct ( N ) { let product = 1 , fact = 1 ; let MOD = ( 1e9 + 7 ) ; for ( let i = 1 ; i <= N ; i ++ ) { fact = mulmod ( fact , i , MOD ) ; product = mulmod ( product , fact , MOD ) ; if ( product == 0 ) return 0 ; } return product ; } let N = 3 ; document . write ( findProduct ( N ) + "" "" ) ; N = 5 ; document . write ( findProduct ( N ) ) ;";"Product of first N factorials | To compute ( a * b ) % MOD ; let res = 0 ; Initialize result ; If b is odd , add ' a ' to result ; Multiply ' a ' with 2 ; Divide b by 2 ; Return result ; This function computes factorials and product by using above function i . e . modular multiplication ; Initialize product and fact with 1 ; ith factorial ; product of first i factorials ; If at any iteration , product becomes divisible by MOD , simply return 0 ; ; Driver Code"
Javascript;"function divSum ( n ) { let sum = 1 ; for ( let i = 2 ; i * i <= n ; i ++ ) if ( n % i == 0 ) sum = sum + i + parseInt ( n / i , 10 ) ; return sum ; } function areEquivalent ( num1 , num2 ) { return divSum ( num1 ) == divSum ( num2 ) ; } let num1 = 559 ; let num2 = 703 ; if ( areEquivalent ( num1 , num2 ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check if sum of divisors of two numbers are same | Function to calculate sum of all proper divisors num -- > given natural number ; To store sum of divisors ; Find all divisors and add them ; Function to check if both numbers are equivalent or not ; Driver code"
Javascript;"function dodecahedral_num ( n ) { return n * ( 3 * n - 1 ) * ( 3 * n - 2 ) / 2 ; } var n = 5 ; document . write ( n + "" "" + "" "" ) ; document . write ( dodecahedral_num ( n ) ) ;";"Dodecahedral number | Function to find dodecahedral number ; Formula to calculate nth dodecahedral number and return it into main function . ; Driver code ; print result"
Javascript;"function bit ( x ) { let ans = 0 ; while ( x > 0 ) { x = parseInt ( x / 2 , 10 ) ; ans ++ ; } return ans ; } function check ( d , x ) { if ( bit ( parseInt ( x / d , 10 ) ) <= bit ( d ) ) return true ; return false ; } function bs ( n ) { let l = 1 , r = Math . sqrt ( n ) ; while ( l < r ) { let m = parseInt ( ( l + r ) / 2 , 10 ) ; if ( check ( m , n ) ) r = m ; else l = m + 1 ; } if ( ! check ( l , n ) ) return l + 1 ; else return l ; } function countDivisor ( n ) { return n - bs ( n ) + 1 ; } let n = 5 ; document . write ( countDivisor ( n ) ) ;";"Count of divisors having more set bits than quotient on dividing N | Return the count of set bit . ; check if q and d have same number of set bit . ; Binary Search to find the point at which number of set in q is less than or equal to d . ; while left index is less than right index ; finding the middle . ; check if q and d have same number of set it or not . ; Driver Code"
Javascript;"function swap ( a , b ) { let t = a ; a = b ; b = t ; } function everMeet ( x1 , x2 , v1 , v2 ) { if ( x1 < x2 && v1 <= v2 ) return false ; if ( x1 > x2 && v1 >= v2 ) return false ; if ( x1 < x2 ) { swap ( x1 , x2 ) ; swap ( v1 , v2 ) ; } while ( x1 >= x2 ) { if ( x1 == x2 ) return true ; x1 = x1 + v1 ; x2 = x2 + v2 ; } return false ; } let x1 = 5 , v1 = 8 , x2 = 4 , v2 = 7 ; if ( everMeet ( x1 , x2 , v1 , v2 ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check if two people starting from different points ever meet | Javascript program to find if two people starting from different positions ever meet or not . ; If speed of a person at a position before other person is smaller , then return false . ; Making sure that x1 is greater ; Until one person crosses other ; first person taking one jump in each iteration ; second person taking one jump in each iteration ; Driver code"
Javascript;"function check ( k , d0 , d1 ) { let s = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 + ( 6 * ( d0 + d1 ) ) % 10 ; let a = ( k - 3 ) % 4 ; let x ; switch ( a ) { case 0 : x = 0 ; break ; case 1 : x = ( 2 * ( d0 + d1 ) ) % 10 ; break ; case 2 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 ; break ; case 3 : x = ( 2 * ( d0 + d1 ) ) % 10 + ( 4 * ( d0 + d1 ) ) % 10 + ( 8 * ( d0 + d1 ) ) % 10 ; break ; } let sum = d0 + d1 + parseInt ( ( k - 3 ) / 4 ) * s + x ; if ( sum % 3 == 0 ) return "" "" ; return "" "" ; } let k , d0 , d1 ; k = 13 ; d0 = 8 ; d1 = 1 ; document . write ( check ( k , d0 , d1 ) + "" "" ) ; k = 5 ; d0 = 3 ; d1 = 4 ; document . write ( check ( k , d0 , d1 ) + "" "" ) ;";"Divisibility by 3 where each digit is the sum of all prefix digits modulo 10 | Function to check the divisibility ; Cycle ; no of residual terms ; sum of residual terms ; if no of residue term = 0 ; if no of residue term = 1 ; if no of residue term = 2 ; if no of residue term = 3 ; sum of all digits ; divisibility check ; Driver code"
Javascript;"var a = 4 ; var b = 3 , val = 0 ; if ( ( a % b ) != 0 ) val = parseInt ( a / b ) + ( a % b ) ; else val = parseInt ( a / b ) ; document . write ( "" "" + "" "" + val + "" "" ) ; a = 6 ; b = 3 ; if ( ( a % b ) != 0 ) val = parseInt ( a / b ) + ( a % b ) ; else val = parseInt ( a / b ) ; document . write ( "" "" + "" "" + val ) ;";"Find ceil of a / b without using ceil ( ) function | taking input 1 ; example of perfect division taking input 2"
Javascript;"function printCollatz ( n ) { while ( n != 1 ) { document . write ( n + "" "" ) ; if ( ( n & 1 ) != 0 ) n = 3 * n + 1 ; else n = parseInt ( n / 2 , 10 ) ; } document . write ( n ) ; } printCollatz ( 6 ) ;";"Program to print Collatz Sequence | Javascript program to print Collatz sequence ; We simply follow steps while we do not reach 1 ; If n is odd ; If even ; Print 1 at the end ; Driver code"
Javascript;"function block ( x ) { let v = [ ] ; document . write ( "" "" + x + "" "" ) ; while ( x > 0 ) { v . push ( x % 2 ) ; x = parseInt ( x / 2 , 10 ) ; } for ( let i = 0 ; i < v . length ; i ++ ) { if ( v [ i ] == 1 ) { document . write ( i ) ; if ( i != v . length - 1 ) document . write ( "" "" ) ; } } document . write ( "" "" ) ; } block ( 71307 ) ; block ( 1213 ) ; block ( 29 ) ; block ( 100 ) ;";"Powers of 2 to required sum | Javascript program to find the blocks for given number . ; Convert decimal number to its binary equivalent ; Displaying the output when the bit is '1' in binary equivalent of number . ; Driver code"
Javascript;"function findNumberOfDigits ( n , base ) { var dig = parseInt ( Math . floor ( Math . log ( n ) / Math . log ( base ) ) + 1 ) ; document . write ( "" "" + "" "" + n + "" "" + base + "" "" + dig ) ; } var n = 1446 ; var base = 7 ; findNumberOfDigits ( n , base ) ;";"Given a number N in decimal base , find number of its digits in any base ( base b ) | function to print number of digits ; Calculating log using base changing property and then taking it floor and then adding 1. ; printing output ; taking inputs ; calling the method"
Javascript;"function isValidNesbitt ( a , b , c ) { let A = a / ( b + c ) ; let B = b / ( a + c ) ; let C = c / ( a + b ) ; let inequality = A + B + C ; return ( inequality >= 1.5 ) ; } let a = 1.0 , b = 2.0 , c = 3.0 ; if ( isValidNesbitt ( a , b , c ) == true ) { document . write ( "" "" + "" "" ) ; document . write ( "" "" + a + "" "" + b + "" "" + c ) ; } else document . write ( "" "" + "" "" ) ;";"Nesbitt 's Inequality | Javascript code to verify Nesbitt 's Inequality ; 3 parts of the inequality sum ; Driver code"
Javascript;"function printCubeFree ( n ) { var cubFree = Array ( n + 1 ) . fill ( false ) ; for ( i = 0 ; i <= n ; i ++ ) cubFree [ i ] = true ; for ( i = 2 ; i * i * i <= n ; i ++ ) { if ( cubFree [ i ] ) { for ( multiple = 1 ; i * i * i * multiple <= n ; multiple ++ ) { cubFree [ i * i * i * multiple ] = false ; } } } for ( i = 2 ; i <= n ; i ++ ) { if ( cubFree [ i ] == true ) document . write ( i + "" "" ) ; } } printCubeFree ( 20 ) ;";"Cube Free Numbers smaller than n | Efficient Javascript program to print all cube free numbers smaller than or equal to n . ; Initialize all numbers as not cube free ; Traverse through all possible cube roots ; If i itself is cube free ; Mark all multiples of i as not cube free ; Print all cube free numbers ; Driver code"
Javascript;"function heapify ( arr , n , i ) { var smallest = i ; var l = 2 * i + 1 ; var r = 2 * i + 2 ; if ( l < n && arr [ l ] < arr [ smallest ] ) smallest = l ; if ( r < n && arr [ r ] < arr [ smallest ] ) smallest = r ; if ( smallest != i ) { [ arr [ i ] , arr [ smallest ] ] = [ arr [ smallest ] , arr [ i ] ] heapify ( arr , n , smallest ) ; } } function heapSort ( arr , n ) { for ( var i = parseInt ( n / 2 - 1 ) ; i >= 0 ; i -- ) heapify ( arr , n , i ) ; for ( var i = n - 1 ; i >= 0 ; i -- ) { [ arr [ 0 ] , arr [ i ] ] = [ arr [ i ] , arr [ 0 ] ] heapify ( arr , i , 0 ) ; } } function printArray ( arr , n ) { for ( var i = 0 ; i < n ; ++ i ) document . write ( arr [ i ] + "" "" ) ; document . write ( "" "" ) ; } var arr = [ 4 , 6 , 3 , 2 , 9 ] ; var n = arr . length ; heapSort ( arr , n ) ; document . write ( "" "" ) ; printArray ( arr , n ) ;";"Heap Sort for decreasing order using min heap | To heapify a subtree rooted with node i which is an index in arr [ ] . n is size of heap ; Initialize smalles as root ; left = 2 * i + 1 ; right = 2 * i + 2 ; If left child is smaller than root ; If right child is smaller than smallest so far ; If smallest is not root ; Recursively heapify the affected sub - tree ; main function to do heap sort ; Build heap ( rearrange array ) ; One by one extract an element from heap ; Move current root to end ; call max heapify on the reduced heap ; A utility function to print array of size n ; Driver program"
Javascript;"function isTriangular ( num ) { if ( num < 0 ) return 0 ; var c = ( - 2 * num ) ; var b = 1 , a = 1 ; var d = ( b * b ) - ( 4 * a * c ) ; if ( d < 0 ) return - 1 ; var root1 = ( - b + Math . sqrt ( d ) ) / ( 2 * a ) ; var root2 = ( - b - Math . sqrt ( d ) ) / ( 2 * a ) ; if ( parseInt ( ( root1 ) ) > 0 && parseInt ( ( Math . floor ( root1 ) ) ) == parseInt ( ( root1 ) ) ) return parseInt ( root1 ) ; if ( parseInt ( ( root2 ) ) > 0 && parseInt ( ( Math . floor ( root2 ) ) ) == parseInt ( ( root2 ) ) ) return parseInt ( ( root2 ) ) ; return - 1 ; } function isPerfectSquare ( x ) { var sr = Math . sqrt ( x ) ; if ( ( sr - Math . floor ( sr ) ) == 0 ) return parseInt ( ( Math . floor ( sr ) ) ) ; else return - 1 ; } function findS ( s ) { var sr = isPerfectSquare ( s ) ; if ( sr == - 1 ) return - 1 ; return isTriangular ( sr ) ; } var s = 9 ; var n = findS ( s ) ; if ( n == - 1 ) document . write ( "" "" ) ; else document . write ( n ) ;";"Squared triangular number ( Sum of cubes ) | Returns root of n ( n + 1 ) / 2 = num if num is triangular ( or integer root exists ) . Else returns - 1. ; Considering the equation n * ( n + 1 ) / 2 = num . The equation is : a ( n ^ 2 ) + bn + c = 0 ""; ; Find roots of equation ; checking if root1 is natural ; checking if root2 is natural ; Returns square root of x if it is perfect square . Else returns - 1. ; Find floating point value of square root of x . ; If square root is an integer ; Function to find if the given number is sum of the cubes of first n natural numbers ; Driver code"
Javascript;"function trickyCase ( s , index ) { let index1 = - 1 ; for ( let i = index - 1 ; i >= 0 ; i -- ) { let digit = s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ; if ( digit != 8 ) { index1 = i ; break ; } } if ( index1 == - 1 ) return 2 * Math . pow ( 10 , s . length ) ; let num = 0 ; for ( let i = 0 ; i < index1 ; i ++ ) num = num * 10 + ( s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; if ( s [ index1 ] . charCodeAt ( ) % 2 == 0 ) num = num * 10 + ( s [ index1 ] . charCodeAt ( ) - ' ' . charCodeAt ( ) + 2 ) ; else num = num * 10 + ( s [ index1 ] . charCodeAt ( ) - ' ' . charCodeAt ( ) + 1 ) ; for ( let i = index1 + 1 ; i < s . length ; i ++ ) num = num * 10 ; return num ; } function smallestNumber ( n ) { let num = 0 ; let s = "" "" ; let duplicate = n ; while ( n > 0 ) { s = String . fromCharCode ( n % 10 + 48 ) + s ; n = parseInt ( n / 10 , 10 ) ; } let index = - 1 ; for ( let i = 0 ; i < s . length ; i ++ ) { let digit = s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ; let val = digit & 1 ; if ( val == 1 ) { index = i ; break ; } } if ( index == - 1 ) return duplicate ; if ( s [ index ] == ' ' ) { num = trickyCase ( s , index ) ; return num ; } for ( let i = 0 ; i < index ; i ++ ) num = num * 10 + ( s [ i ] . charCodeAt ( ) - ' ' . charCodeAt ( ) ) ; num = num * 10 + ( s [ index ] . charCodeAt ( ) - ' ' . charCodeAt ( ) + 1 ) ; for ( let i = index + 1 ; i < s . length ; i ++ ) num = num * 10 ; return num ; } let N = 2397 ; document . write ( smallestNumber ( N ) ) ;";"Smallest even digits number not less than N | function to return the answer when the first odd digit is 9 ; traverse towwars the left to find the non - 8 digit ; index digit ; if digit is not 8 , then break ; if on the left side of the '9' , no 8 is found then we return by adding a 2 and 0 's ; till non - 8 digit add all numbers ; if non - 8 is even or odd than add the next even . ; add 0 to right of 9 ; function to return the smallest number with all digits even ; convert the number to string to perform operations ; find out the first odd number ; if no odd numbers are there , than n is the answer ; if the odd number is 9 , than tricky case handles it ; add all digits till first odd ; increase the odd digit by 1 ; add 0 to the right of the odd number ; Driver Code"
Javascript;"function findNth ( n ) { let count = 0 ; for ( let curr = 19 ; ; curr += 9 ) { let sum = 0 ; for ( let x = curr ; x > 0 ; x = parseInt ( x / 10 ) ) sum = sum + x % 10 ; if ( sum == 10 ) count ++ ; if ( count == n ) return curr ; } return - 1 ; } document . write ( findNth ( 5 ) ) ;";"n | Simple Javascript program to find n - th number with sum of digits as 10. ; Find sum of digits in current no . ; If sum is 10 , we increment count ; If count becomes n , we return current number . ; Driver Code"
Javascript;"function findSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) for ( let j = i ; j <= n ; j ++ ) sum = sum + i * j ; return sum ; } let n = 5 ; document . write ( findSum ( n ) ) ;";"Sum of pairwise products | Simple JavaScript program to find sum of given series . ; Driver Code"
Javascript;"function findSum ( n ) { let multiTerms = n * ( n + 1 ) / 2 ; let sum = multiTerms ; for ( let i = 2 ; i <= n ; i ++ ) { multiTerms = multiTerms - ( i - 1 ) ; sum = sum + multiTerms * i ; } return sum ; } let n = 5 ; document . write ( findSum ( n ) ) ;";"Sum of pairwise products | Javascript program to find sum of given series . ; Sum of multiples of 1 is 1 * ( 1 + 2 + . . ) ; Adding sum of multiples of numbers other than 1 , starting from 2. ; Subtract previous number from current multiple . ; For example , for 2 , we get sum as ( 2 + 3 + 4 + ... . ) * 2 ; Driver code"
Javascript;"function totalSumDivisibleByNum ( digit , number ) { let firstnum = Math . pow ( 10 , digit - 1 ) ; let lastnum = Math . pow ( 10 , digit ) ; firstnum = ( firstnum - firstnum % number ) + number ; lastnum = ( lastnum - lastnum % number ) ; let count = ( ( lastnum - firstnum ) / number + 1 ) ; return ( ( lastnum + firstnum ) * count ) / 2 ; } let n = 3 , number = 7 ; document . write ( totalSumDivisibleByNum ( n , number ) ) ;";"Sum of n digit numbers divisible by a given number | Find the Sum of having n digit and divisible by the number ; Compute the first and last term ; First number which is divisible by given number ; Last number which is divisible by given number ; Total divisible number ; Return the total sum ; Driver Code"
Javascript;"function Nth_of_AP ( a , d , N ) { return ( a + ( N - 1 ) * d ) ; } let a = 2 ; let d = 1 ; let N = 5 ; document . write ( "" "" + N + "" "" + Nth_of_AP ( a , d , N ) ) ;";"Program for N | JavaScript Program to find nth term of Arithmetic progression ; using formula to find the Nth term t ( n ) = a ( 1 ) + ( n - 1 ) * d ; starting number ; Common difference ; N th term to be find ; Display the output"
Javascript;"function checkFibinnary ( n ) { var prev_last = 0 ; while ( n != 0 ) { if ( ( n & 1 ) != 0 && prev_last != 0 ) return false ; prev_last = n & 1 ; n >>= 1 ; } return true ; } var n = 10 ; if ( checkFibinnary ( n ) == true ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Fibbinary Numbers ( No consecutive 1 s in binary ) | function to check if binary representation of an integer has consecutive 1 s ; stores the previous last bit initially as 0 ; if current last bit and previous last bit is 1 ; stores the last bit ; right shift the number ; Driver code to check above function"
Javascript;"function sumOfSeries ( n ) { return parseInt ( ( 0.6172 * ( Math . pow ( 10 , n ) - 1 ) - 0.55 * n ) ) ; } var n = 2 ; document . write ( sumOfSeries ( n ) ) ;";"Sum of the series 5 + 55 + 555 + . . up to n terms | function which return the the sum of series ; Driver code"
Javascript;"function Nonagonal ( n ) { return parseInt ( n * ( 7 * n - 5 ) / 2 ) ; } let n = 10 ; document . write ( Nonagonal ( n ) ) ;";"Nonagonal number | Function to find nth nonagonal number . ; Formula to find nth nonagonal number . ; Driver function ."
Javascript;"function divisibleBy20 ( num ) { let lastTwoDigits = parseInt ( num . slice ( - 2 , num . length ) ) console . log ( num . slice ( - 2 , 1 ) ) return ( ( lastTwoDigits % 5 == 0 ) && ( lastTwoDigits % 4 == 0 ) ) } let num = "" "" ; if ( divisibleBy20 ( num ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check if a large number is divisible by 20 | Javascript program to check if a large number is divisible by 20. ; Get number with last two digits ; Check if the number formed by last two digits is divisible by 5 and 4. ; Driver Code"
Javascript;"function isDvisibleBy12 ( num ) { if ( num . length >= 3 ) { let d1 = num [ num . length - 1 ] . charCodeAt ( ) ; if ( d1 % 2 != 0 ) return false ; let d2 = num [ num . length - 2 ] . charCodeAt ( ) ; let sum = 0 ; for ( let i = 0 ; i < num . length ; i ++ ) sum += num [ i ] . charCodeAt ( ) ; return ( ( sum % 3 == 0 ) && ( d2 * 10 + d1 ) % 4 == 0 ) ; } else { let number = parseInt ( num , 10 ) ; document . write ( number ) ; return ( number % 12 == 0 ) ; } } let num = "" "" ; if ( isDvisibleBy12 ( num ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Divisibility by 12 for a large number | Javascript program to check if number is divisible by 12 ; If number greater then 3 ; Find last digit ; No is odd ; Find second last digit ; Find sum of all digits ; If number is less then or equal to 100 ; Driver code"
Javascript;"function check ( n ) { let d = Math . sqrt ( n ) ; if ( d * d == n ) return true ; return false ; } function largestNonPerfectSquareNumber ( a , n ) { let maxi = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { if ( ! check ( a [ i ] ) ) maxi = Math . max ( a [ i ] , maxi ) ; } return maxi ; } let a = [ 16 , 20 , 25 , 2 , 3 , 10 ] ; let n = a . length ; document . write ( largestNonPerfectSquareNumber ( a , n ) ) ;";"Largest number that is not a perfect square | JavaScript program to find the largest non perfect square number among n numbers ; takes the sqrt of the number ; checks if it is a perfect square number ; function to find the largest non perfect square number ; stores the maximum of all non perfect square numbers ; traverse for all elements in the array ; store the maximum if not a perfect square ; Driver Code ; function call"
Javascript;"function printAP ( a , d , n ) { let curr_term ; curr_term = a ; for ( let i = 1 ; i <= n ; i ++ ) { document . write ( curr_term + "" "" ) ; curr_term = curr_term + d ; } } let a = 2 ; let d = 1 ; let n = 5 ; printAP ( a , d , n ) ;";"Program to print Arithmetic Progression series | JavaScript Program to print an arithmetic progression series ; Printing AP by simply adding d to previous term . ; starting number ; Common difference ; N th term to be find"
Javascript;"function printNonSquare ( n ) { let curr_count = 2 , num = 2 , count = 0 ; while ( count < n ) { for ( let i = 0 ; i < curr_count && count < n ; i ++ ) { document . write ( num + "" "" ) ; count ++ ; num ++ ; } num ++ ; curr_count += 2 ; } } let n = 10 ; printNonSquare ( n ) ;";"Program to print non square numbers | Javascript program to print first n non - square numbers . ; Print curr_count numbers . curr_count is current gap between two square numbers . ; Skip a square number . ; Count of next non - square numbers is next even number . ; Driver code"
Javascript;"function countZeros ( a , n ) { let count2 = 0 , count5 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { while ( a [ i ] % 2 == 0 ) { a [ i ] = parseInt ( a [ i ] / 2 ) ; count2 ++ ; } while ( a [ i ] % 5 == 0 ) { a [ i ] = parseInt ( a [ i ] / 5 ) ; count5 ++ ; } } return ( count2 < count5 ) ? count2 : count5 ; } let a = [ 10 , 100 , 20 , 30 , 50 , 90 , 12 , 80 ] ; let n = a . length ; document . write ( countZeros ( a , n ) ) ;";"Count number of trailing zeros in product of array | Returns count of zeros in product of array ; Count number of 2 s in each element ; Count number of 5 s in each element ; Return the minimum ; Driver code"
Javascript;"function squareSum ( n ) { let sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) sum += ( 2 * i ) * ( 2 * i ) ; return sum ; } document . write ( squareSum ( 8 ) ) ;";"Sum of square of first n even numbers | JavaScript program to find sum of square of first n even numbers . ; Driver code"
Javascript;"var pwr ; function isMunchhausen ( n ) { var sum = 0 ; var temp = n ; while ( temp > 0 ) { var index = temp % 10 ; sum = sum + pwr [ index ] ; temp = parseInt ( temp / 10 ) ; } return ( sum == n ) ; } function printMunchhausenNumbers ( n ) { pwr = Array . from ( { length : 10 } , ( _ , i ) => 0 ) ; for ( var i = 0 ; i < 10 ; i ++ ) pwr [ i ] = Math . pow ( i , i ) ; for ( var i = 1 ; i <= n ; i ++ ) if ( isMunchhausen ( i ) == true ) document . write ( i + "" "" ) ; } var n = 10000 ; printMunchhausenNumbers ( n ) ;";"MÃ ¼ nchhausen Number | power i . ; Function to check out whether the number is Munchhausen Number or not ; Precompute i raised to power i for every i ; The input here is fixed i . e . it will check up to n ; check the integer for Munchhausen Number , if yes then prvar out the number ; Driver code"
Javascript;"function kthdigit ( a , b , k ) { let p = Math . pow ( a , b ) ; let count = 0 ; while ( p > 0 && count < k ) { let rem = p % 10 ; count ++ ; if ( count == k ) return rem ; p = p / 10 ; } return 0 ; } let a = 5 , b = 2 ; let k = 1 ; document . write ( kthdigit ( a , b , k ) ) ;";"K | To compute k - th digit in a ^ b ; Computing a ^ b ; Getting last digit ; Increasing count by 1 ; If current number is required digit ; Remove last digit ; Driver code"
Javascript;"function digSum ( n ) { if ( n == 0 ) return 0 ; return ( n % 9 == 0 ) ? 9 : ( n % 9 ) ; } function PowDigSum ( n , x ) { let sum = digSum ( n ) ; let rem = x % 6 ; if ( ( sum == 3 sum == 6 ) && x > 1 ) return 9 ; else if ( x == 1 ) return sum ; else if ( x == 0 ) return 1 ; else if ( rem == 0 ) return digSum ( Math . pow ( sum , 6 ) ) ; else return digSum ( Math . pow ( sum , rem ) ) ; } let n = 33333 ; let x = 332654 ; document . write ( PowDigSum ( n , x ) ) ;";"Recursive sum of digit in n ^ x , where n and x are very large | function to get sum of digits of a number ; function to return sum ; Find sum of digits in n ; Find remainder of exponent ; Driver code"
Javascript;"function maxArea ( A , len ) { let l = 0 ; let r = len - 1 ; let area = 0 ; while ( l < r ) { area = Math . max ( area , Math . min ( A [ l ] , A [ r ] ) * ( r - l ) ) ; if ( A [ l ] < A [ r ] ) l += 1 ; else r -= 1 ; } return area ; } let a = [ 1 , 5 , 4 , 3 ] ; let b = [ 3 , 1 , 2 , 4 , 5 ] ; let len1 = a . length ; document . write ( maxArea ( a , len1 ) + "" "" ) ; let len2 = b . length ; document . write ( maxArea ( b , len2 ) ) ;";"Container with Most Water | Javascript code for Max Water Container ; Calculating the max area ; Driver code"
Javascript;"function mobius ( n ) { let p = 0 ; if ( n % 2 == 0 ) { n = parseInt ( n / 2 , 10 ) ; p ++ ; if ( n % 2 == 0 ) return 0 ; } for ( let i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { n = parseInt ( n / i , 10 ) ; p ++ ; if ( n % i == 0 ) return 0 ; } } return ( p % 2 == 0 ) ? - 1 : 1 ; } let N = 17 ; document . write ( "" "" + "" "" + N + "" "" + mobius ( N ) + "" "" ) ; document . write ( "" "" + "" "" + 25 + "" "" + mobius ( 25 ) + "" "" ) ; document . write ( "" "" + "" "" + 6 + "" "" + mobius ( 6 ) ) ;";"Program for Mobius Function | Returns value of mobius ( ) ; Handling 2 separately ; If 2 ^ 2 also divides N ; Check for all other prime factors ; If i divides n ; If i ^ 2 also divides N ; Driver Code"
Javascript;"function factorial ( start , end ) { let res = 1 ; for ( let i = start ; i <= end ; i ++ ) res *= i ; return res ; } function sumofsquare ( n ) { return parseInt ( factorial ( n + 1 , 2 * n ) / factorial ( 1 , n ) , 10 ) ; } let n = 4 ; document . write ( sumofsquare ( n ) ) ;";"Sum of squares of binomial coefficients | function to return product of number from start to end . ; Return the sum of square of binomial coefficient ; Driven Program"
Javascript;"let PHI = 1.6180339 ; let f = [ 0 , 1 , 1 , 2 , 3 , 5 ] ; function fib ( n ) { if ( n < 6 ) return f [ n ] ; let t = 5 , fn = 5 ; while ( t < n ) { fn = Math . round ( fn * PHI ) ; t ++ ; } return fn ; } let n = 9 ; document . write ( n + "" "" + fib ( n ) + "" "" ) ;";"Find nth Fibonacci number using Golden ratio | Approximate value of golden ratio ; Fibonacci numbers upto n = 5 ; Function to find nth Fibonacci number ; Fibonacci numbers for n < 6 ; Else start counting from 5 th term ; driver code"
Javascript;"function func ( x , y ) { return ( x + y + x * y ) ; } function euler ( x0 , y , h , x ) { let temp = - 0 ; while ( x0 < x ) { temp = y ; y = y + h * func ( x0 , y ) ; x0 = x0 + h ; } document . write ( "" "" + x + "" "" + y ) ; } let x0 = 0 ; let y0 = 1 ; let h = 0.025 ; let x = 0.1 ; euler ( x0 , y0 , h , x ) ;";"Euler Method for solving differential equation | Consider a differential equation dy / dx = ( x + y + xy ) ; Function for Euler formula ; Iterating till the point at which we need approximation ; Printing approximation ; Initial Values ; Value of x at which we need approximation"
Javascript;"function solution ( a , b , n ) { for ( let i = 0 ; i * a <= n ; i ++ ) { if ( ( n - ( i * a ) ) % b == 0 ) { document . write ( "" "" + i + "" "" + ( n - ( i * a ) ) / b ) ; return ; } } document . write ( "" "" ) ; } let a = 2 , b = 3 , n = 7 ; solution ( a , b , n ) ;";"Find x and y satisfying ax + by = n | function to find the solution ; traverse for all possible values ; check if it is satisfying the equation ; Driver code"
Javascript;"function binomialCoeffSum ( n ) { return ( 1 << n ) ; } let n = 4 ; document . write ( binomialCoeffSum ( n ) ) ;";"Sum of Binomial coefficients | Returns value of Binomial Coefficient Sum which is 2 raised to power n . ; Driver Code"
Javascript;"function precisionCompute ( x , y , n ) { if ( y == 0 ) { document . write ( "" "" ) ; return ; } if ( x == 0 ) { document . write ( "" "" ) ; return ; } if ( n <= 0 ) { document . write ( x / y ) ; return ; } if ( ( ( x > 0 ) && ( y < 0 ) ) || ( ( x < 0 ) && ( y > 0 ) ) ) { document . write ( "" "" ) ; x = x > 0 ? x : - x ; y = y > 0 ? y : - y ; } let d = x / y ; for ( let i = 0 ; i <= n ; i ++ ) { document . write ( d ) ; x = x - ( y * d ) ; if ( x == 0 ) break ; x = x * 10 ; d = x / y ; if ( i == 0 ) document . write ( "" "" ) ; } } let x = 22 , y = 7 , n = 15 ; precisionCompute ( x , y , n ) ;";"Program to compute division upto n decimal places | JavaScript program to compute division upto n decimal places . ; Base cases ; Since n <= 0 , don 't compute after  the decimal ; Handling negative numbers ; Integral division ; Now one by print digits after dot using school division method . ; Driver code"
Javascript;"function quadrant ( x , y ) { if ( x > 0 && y > 0 ) document . write ( "" "" ) ; else if ( x < 0 && y > 0 ) document . write ( "" "" ) ; else if ( x < 0 && y < 0 ) document . write ( "" "" ) ; else if ( x > 0 && y < 0 ) document . write ( "" "" ) ; else if ( x == 0 && y > 0 ) document . write ( "" "" ) ; else if ( x == 0 && y < 0 ) document . write ( "" "" ) ; else if ( y == 0 && x < 0 ) document . write ( "" "" ) ; else if ( y == 0 && x > 0 ) document . write ( "" "" ) ; else document . write ( "" "" ) ; } let x = 1 , y = 1 ; quadrant ( x , y ) ;";"Program to determine the quadrant of the cartesian plane | Function to check quadrant ; Driver code ; Function Calling"
Javascript;"function checkDigits ( n ) { while ( n > 0 ) { let dig = n % 10 ; if ( dig != 2 && dig != 3 && dig != 5 && dig != 7 ) return false ; n = parseInt ( n / 10 , 10 ) ; } return true ; } function prime ( n ) { if ( n == 1 ) return false ; for ( let i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } function isFullPrime ( n ) { return ( checkDigits ( n ) && prime ( n ) ) ; } let n = 53 ; if ( isFullPrime ( n ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check if a number is Full Prime | function to check digits ; check all digits are prime or not ; check if digits are prime or not ; To check if n is prime or not ; check for all factors ; To check if n is Full Prime ; The order is important here for efficiency ; Driver Code"
Javascript;"function getResult ( st ) { let sum = 0 ; let length = st . length ; for ( let i = 0 ; i < length ; i ++ ) { sum = sum + Math . pow ( st [ i ] - ' ' , length ) ; } let number = parseInt ( st , 10 ) ; if ( number == sum ) return "" "" ; else return "" "" ; } let st = "" "" ; document . write ( getResult ( st ) ) ;";"Narcissistic number | Javascript program for checking of Narcissistic number ; Traversing through the string ; Since ascii value of numbers starts from 48 so we subtract it from sum ; Converting string to integer ; Comparing number and sum ; Driver Code"
Javascript;"let MAX = 500 ; function nthSHN ( n , dp ) { if ( n == 1 n == 2 ) return dp [ n ] = 1 ; if ( dp [ n ] != - 1 ) return dp [ n ] ; return dp [ n ] = ( ( 6 * n - 9 ) * nthSHN ( n - 1 , dp ) - ( n - 3 ) * nthSHN ( n - 2 , dp ) ) / n ; } let n = 6 ; let dp = new Array ( MAX ) ; for ( let i = 0 ; i < dp . length ; i ++ ) dp [ i ] = - 1 ; document . write ( nthSHN ( n , dp ) ) ;";"SchrÃ ¶ derâ €“ Hipparchus number | A memoization based optimized Javascript program to find n - th Schroder - Hipparchus number ; Driver code"
Javascript;"function evenSum ( n ) { let curr = 2 , sum = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { sum += curr ; curr += 2 ; } return sum ; } let n = 20 ; document . write ( "" "" + n + "" "" + evenSum ( n ) ) ;";"Sum of first n even numbers | function to find sum of first n even numbers ; sum of first n even numbers ; next even number ; required sum ; Driver program to test above"
Javascript;"function evenSum ( n ) { return ( n * ( n + 1 ) ) ; } let n = 20 ; document . write ( "" "" + n + "" "" , evenSum ( n ) ) ;";"Sum of first n even numbers | function to find sum of first n even numbers ; required sum ; Driver Code"
Javascript;"function kmphTOmph ( kmph ) { return ( 0.6214 * kmph ) ; } function mphTOkmph ( mph ) { return ( 1.60934 * mph ) ; } var kmph = 150 var mph = 100 document . write ( "" "" + kmphTOmph ( kmph ) + "" "" ) ; document . write ( "" "" + mphTOkmph ( mph ) ) ;";"Program to Convert Km / hr to miles / hr and vice versa | Function to convert kmph to mph ; Function to convert mph to kmph ; Driver Code"
Javascript;"function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function findNumber ( arr , n ) { let ans = arr [ 0 ] ; for ( let i = 0 ; i < n ; i ++ ) ans = gcd ( ans , arr [ i ] ) ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] == ans ) return ans ; return - 1 ; } let arr = [ 2 , 2 , 4 ] ; let n = arr . length ; document . write ( findNumber ( arr , n ) ) ;";"Find element in array that divides all array elements | Returns gcd of two numbers . ; Function to return the desired number if exists ; Find GCD of array ; Check if GCD is present in array ; Driver Code"
Javascript;"let primes = [ ] ; function SieveofEratosthenes ( n ) { let visited = new Array ( n ) ; visited . fill ( false ) ; for ( let i = 2 ; i <= n + 1 ; i ++ ) if ( ! visited [ i ] ) { for ( let j = i * i ; j <= n + 1 ; j += i ) visited [ j ] = true ; primes . push ( i ) ; } } function specialPrimeNumbers ( n , k ) { SieveofEratosthenes ( n ) ; let count = 0 ; for ( let i = 0 ; i < primes . length ; i ++ ) { for ( let j = 0 ; j < i - 1 ; j ++ ) { if ( primes [ j ] + primes [ j + 1 ] + 1 == primes [ i ] ) { count ++ ; break ; } } if ( count == k ) return true ; } return false ; } let n = 27 , k = 2 ; if ( specialPrimeNumbers ( n , k ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Special prime numbers | Javascript program to check whether there exist at least k or not in range [ 2. . n ] ; Generating all the prime numbers from 2 to n . ; If a prime number is Special prime number , then we increments the value of k . ; If at least k Special prime numbers are present , then we return 1. else we return 0 from outside of the outer loop . ; Driver function"
Javascript;"function factorize ( n ) { var count = 0 ; while ( ( n % 2 ) == 0 ) { count ++ ; } if ( count ) document . write ( 2 + "" "" + count + "" "" ) ; for ( var i = 3 ; i <= parseInt ( Math . sqrt ( n ) ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n = parseInt ( n / i ) ; } if ( count != 0 ) document . write ( i + "" "" + count + "" "" ) ; } if ( n > 2 ) document . write ( n + "" "" + 1 + "" "" ) ; } var n = 1000000000000000000 ; factorize ( n ) ;";"Prime factors of a big number | function to calculate all the prime factors and count of every prime factor ; count the number of times 2 divides ; n = parseInt ( n / 2 ) equivalent to n = n / 2 ; ; if 2 divides it ; check for all the possible numbers that can divide it ; if n at the end is a prime number . ; driver program to test the above function"
Javascript;"function __gcd ( a , b ) { if ( a == 0 ) return b ; return __gcd ( b % a , a ) ; } function minimumMoves ( A , N ) { let one = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( A [ i ] == 1 ) one ++ ; if ( one != 0 ) return N - one ; let minimum = Number . MAX_SAFE_INTEGER ; for ( let i = 0 ; i < N ; i ++ ) { let g = A [ i ] ; for ( let j = i + 1 ; j < N ; j ++ ) { g = __gcd ( A [ j ] , g ) ; if ( g == 1 ) { minimum = Math . min ( minimum , j - i ) ; break ; } } } if ( minimum == Number . MAX_SAFE_INTEGER ) return - 1 ; else return N + minimum - 1 ; } let A = [ 2 , 4 , 3 , 9 ] ; let N = A . length ; document . write ( minimumMoves ( A , N ) ) ;";"Minimum gcd operations to make all array elements one | __gcd function ; Function to count number of moves . ; Counting Number of ones . ; If there is a one ; Find smallest subarray with GCD equals to one . ; to calculate GCD ; Not Possible ; Final answer ; Driver code"
Javascript;"function series ( n , d ) { if ( d == 0 ) { for ( let i = 0 ; i < n ; i ++ ) document . write ( "" "" ) ; document . write ( ) ; return ; } if ( n % 2 == 0 ) { for ( let i = 1 ; i <= n ; i ++ ) { document . write ( Math . pow ( - 1 , i ) * d + "" "" ) ; } document . write ( ) ; } else { let m = n ; let r = ( m / ( m - 1 ) ) ; let g = ( d * ( Math . sqrt ( r ) ) ) ; document . write ( "" "" ) ; for ( let i = 1 ; i < n ; i ++ ) { document . write ( Math . pow ( - 1 , i ) * g + "" "" ) ; } document . write ( ) ; } } let n = 3 , d = 3 ; series ( n , d ) ;";"Given N and Standard Deviation , find N elements | Function to print series of n elements ; If S . D . is 0 then print all elements as 0. ; Print n 0 's ; If S . D . is even ; Print - SD , + SD , - SD , + SD ; If odd ; Convert n to a float integer ; Print one element to be 0 ; Print ( n - 1 ) elements as xi derived from the formula ; Driver Code"
Javascript;"function countDigitOne ( n ) { let countr = 0 ; for ( let i = 1 ; i <= n ; i ++ ) { let str = i . toString ( ) ; countr += str . split ( "" "" ) . length - 1 ; } return countr ; } let n = 13 ; document . write ( countDigitOne ( n ) + "" "" ) ; n = 131 ; document . write ( countDigitOne ( n ) + "" "" ) ; n = 159 ; document . write ( countDigitOne ( n ) + "" "" ) ;";"Total no of 1 's in numbers | Javascript code to count the frequency of 1 in numbers less than or equal to the given number . ; Driver Code"
Javascript;"function factorial ( x ) { if ( x <= 1 ) return 1 ; var res = 2 ; for ( i = 3 ; i <= x ; i ++ ) res = res * i ; return res ; } function gcdOfFactorial ( m , n ) { var min = m < n ? m : n ; return factorial ( min ) ; } var m = 5 , n = 9 ; document . write ( gcdOfFactorial ( m , n ) ) ;";"GCD of factorials of two numbers | JavaScript program to find GCD of factorial of two numbers . ; Driver program to test above functions"
Javascript;"function recDigSum ( n ) { if ( n == 0 ) return 0 ; else { if ( n % 9 == 0 ) return 9 ; else return n % 9 ; } } function check ( n ) { n = recDigSum ( n ) ; if ( n == 2 n == 3 n == 5 n == 7 ) document . write ( "" "" ) ; else document . write ( "" "" ) ; } let n = 5602 ; check ( n ) ;";"Recursive sum of digits of a number is prime or not | Function for recursive digit sum ; Function to check if prime or not the single digit ; Calls function which returns sum till single digit ; Checking prime ; Driver code"
Javascript;"function findNumber ( n ) { let x = Math . floor ( ( - 1 + Math . sqrt ( 1 + 8 * n - 8 ) ) / 2 ) ; let base = ( x * ( x + 1 ) ) / 2 + 1 ; return n - base + 1 ; } let n = 55 ; document . write ( findNumber ( n ) ) ;";"Find n | Definition of findNumber function ; Finding x from equation n = x ( x + 1 ) / 2 + 1 ; Base of current block ; Value of n - th element ; Driver code"
Javascript;"function weightedMean ( n ) { return parseInt ( ( 2 * n + 1 ) / 3 , 10 ) ; } let n = 10 ; document . write ( weightedMean ( n ) ) ;";"Program for weighted mean of natural numbers . | Returns weighted mean assuming for numbers { 1 , 2 , . . n } and weights { 1 , 2 , . . n } ; Driver Code"
Javascript;"function calculate ( a , b , n , m ) { let mul = 1 ; for ( let i = 0 ; i < m ; i ++ ) if ( b [ i ] != 0 ) mul = mul * b [ i ] ; for ( let i = 0 ; i < n ; i ++ ) { let x = Math . floor ( a [ i ] / mul ) ; document . write ( x + "" "" ) ; } } let a = [ 5 , 100 , 8 ] ; let b = [ 2 , 3 ] ; let n = a . length ; let m = b . length ; calculate ( a , b , n , m ) ;";"Divide every element of one array by other array elements | Function to calculate the quotient of every element of the array ; Calculate the product of all elements ; To calculate the quotient of every array element ; Driver code"
Javascript;"class pair { constructor ( first , second ) { this . first = first ; this . second = second ; } } function findPowerOfP ( n , p ) { let count = 0 ; let r = p ; while ( r <= n ) { count += Math . floor ( n / r ) ; r = r * p ; } return count ; } function primeFactorsofK ( k ) { let ans = [ ] ; for ( let i = 2 ; k != 1 ; i ++ ) { if ( k % i == 0 ) { let count = 0 ; while ( k % i == 0 ) { k = Math . floor ( k / i ) ; count ++ ; } ans . push ( new pair ( i , count ) ) ; } } return ans ; } function largestPowerOfK ( n , k ) { let vec = [ ] ; vec = primeFactorsofK ( k ) ; let ans = Number . MAX_VALUE ; for ( let i = 0 ; i < vec . length ; i ++ ) ans = Math . min ( ans , findPowerOfP ( n , vec [ i ] . first ) / vec [ i ] . second ) ; return ans ; } document . write ( largestPowerOfK ( 7 , 2 ) + "" "" ) ; document . write ( largestPowerOfK ( 10 , 9 ) + "" "" ) ;";"Largest power of k in n ! ( factorial ) where k may not be prime | JavaScript program to find the largest power of k that divides n ! ; To find the power of a prime p in factorial N ; calculating Math . floor ( n / r ) and adding to the count ; increasing the power of p from 1 to 2 to 3 and so on ; returns all the prime factors of k ; vector to store all the prime factors along with their number of occurrence in factorization of k ; Returns largest power of k that divides n ! ; calculating minimum power of all the prime factors of k ; Driver code"
Javascript;"function print ( n ) { document . write ( n + parseInt ( n / 2 ) + "" "" ) ; for ( i = 2 ; i <= n ; i += 2 ) document . write ( i + "" "" ) ; for ( i = 1 ; i <= n ; i += 2 ) document . write ( i + "" "" ) ; for ( i = 2 ; i <= n ; i += 2 ) document . write ( i + "" "" ) ; } var n = 3 ; print ( n ) ;";"Minimum number of bombs | function to prvar where to shoot ; no . of bombs required ; bomb all the even positions ; bomb all the odd positions ; bomb all the even positions again ; Driver code"
Javascript;"function lcm_fun ( a , b ) { if ( b == 0 ) return a ; return lcm_fun ( b , a % b ) ; } function digitLCM ( n ) { let lcm = 1 ; while ( n > 0 ) { lcm = ( n % 10 * lcm ) / lcm_fun ( n % 10 , lcm ) ; if ( lcm == 0 ) return 0 ; n = parseInt ( n / 10 ) ; } return lcm ; } let n = 397 ; document . write ( digitLCM ( n ) ) ;";"LCM of digits of a given number | define lcm function ; If at any point LCM become 0. return it ; Driver code"
Javascript;"function u_cal ( u , n ) { var temp = u ; for ( var i = 1 ; i < n ; i ++ ) temp = temp * ( u + i ) ; return temp ; } function fact ( n ) { var f = 1 ; for ( var i = 2 ; i <= n ; i ++ ) f *= i ; return f ; } var n = 5 ; var x = [ 1891 , 1901 , 1911 , 1921 , 1931 ] ; var y = Array ( n ) . fill ( 0.0 ) . map ( x => Array ( n ) . fill ( 0.0 ) ) ; y [ 0 ] [ 0 ] = 46 ; y [ 1 ] [ 0 ] = 66 ; y [ 2 ] [ 0 ] = 81 ; y [ 3 ] [ 0 ] = 93 ; y [ 4 ] [ 0 ] = 101 ; for ( var i = 1 ; i < n ; i ++ ) { for ( var j = n - 1 ; j >= i ; j -- ) y [ j ] [ i ] = y [ j ] [ i - 1 ] - y [ j - 1 ] [ i - 1 ] ; } for ( var i = 0 ; i < n ; i ++ ) { for ( var j = 0 ; j <= i ; j ++ ) document . write ( y [ i ] [ j ] + "" "" ) ; document . write ( ' ' ) ; ; } var value = 1925 ; var sum = y [ n - 1 ] [ 0 ] ; var u = ( value - x [ n - 1 ] ) / ( x [ 1 ] - x [ 0 ] ) ; for ( var i = 1 ; i < n ; i ++ ) { sum = sum + ( u_cal ( u , i ) * y [ n - 1 ] [ i ] ) / fact ( i ) ; } document . write ( "" "" + value + "" "" + sum ) ;";"Newton Forward And Backward Interpolation | Calculation of u mentioned in formula ; Calculating factorial of given n ; number of values given ; y is used for difference table and y [ 0 ] used for input ; Calculating the backward difference table ; Displaying the backward difference table ; Value to interpolate at ; Initializing u and sum"
Javascript;"function sumDigitSquare ( n ) { let sq = 0 ; while ( n != 0 ) { let digit = n % 10 ; sq += digit * digit ; n = parseInt ( n / 10 , 10 ) ; } return sq ; } function isHappy ( n ) { while ( true ) { if ( n == 1 ) return true ; n = sumDigitSquare ( n ) ; if ( n == 4 ) return false ; } } let n = 23 ; if ( isHappy ( n ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Happy Numbers | Returns sum of squares of digits of a number n . For example for n = 12 it returns 1 + 4 = 5 ; Returns true if n is Happy number else returns false . ; Keep replacing n with sum of squares of digits until we either reach 1 or we end up in a cycle ; Number is Happy if we reach 1 ; Replace n with sum of squares of digits ; Number is not Happy if we reach 4 ; Driver code"
Javascript;"function findSumSubsets ( n ) { return ( n * ( n + 1 ) / 2 ) * ( 1 << ( n - 1 ) ) ; } let n = 3 ; document . write ( findSumSubsets ( n ) ) ;";"Sum of all subsets of a set formed by first n natural numbers | javascript program to find sum of all subsets of a set . ; sum of subsets is ( n * ( n + 1 ) / 2 ) * pow ( 2 , n - 1 ) ; Driven Program"
Javascript;"function findMin ( a , n ) { var sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += Math . log ( a [ i ] ) ; var x = parseInt ( Math . exp ( sum / n ) ) ; return x + 1 ; } var a = [ 3 , 2 , 1 , 4 ] ; var n = a . length ; document . write ( findMin ( a , n ) ) ;";"Minimum element whose n | function to find the minimum element ; loop to traverse and store the sum of log ; computes sum ; calculates the elements according to formula . ; returns the minimal element ; initialised array ; computes the size of array ; prints out the minimal element"
Javascript;"function countdigits ( N ) { var count = 0 ; while ( N > 0 ) { count ++ ; N = parseInt ( N / 10 ) ; } return count ; } function cyclic ( N ) { var num = N ; var n = countdigits ( N ) ; while ( true ) { document . write ( num + "" "" ) ; var rem = num % 10 ; var dev = parseInt ( num / 10 ) ; num = parseInt ( ( ( Math . pow ( 10 , n - 1 ) ) * rem + dev ) ) ; if ( num == N ) break ; } } var N = 5674 ; cyclic ( N ) ;";"Generate all cyclic permutations of a number | Function to count the total number of digits in a number . ; Function to generate all cyclic permutations of a number ; Following three lines generates a circular pirmutation of a number . ; If all the permutations are checked and we obtain original number exit from loop . ; Driver Program"
Javascript;"function isPrime ( n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 n % 3 == 0 ) return false ; for ( let i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } function checkCircular ( N ) { let count = 0 , temp = N ; while ( temp > 0 ) { count ++ ; temp = parseInt ( temp / 10 , 10 ) ; } let num = N ; while ( isPrime ( num ) ) { let rem = num % 10 ; let div = parseInt ( num / 10 , 10 ) ; num = ( ( Math . pow ( 10 , count - 1 ) ) * rem ) + div ; if ( num == N ) return true ; } return false ; } let N = 1193 ; if ( checkCircular ( N ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check whether a number is circular prime or not | Function to check if a number is prime or not . ; Corner cases ; This is checked so that we can skip middle five numbers in below loop ; Function to check if the number is circular prime or not . ; Count digits . ; Following three lines generate the next circular permutation of a number . We move last digit to first position . ; If all the permutations are checked and we obtain original number exit from loop . ; Driver Code"
Javascript;"function sackRace ( p1 , s1 , p2 , s2 ) { return ( ( s1 > s2 && ( p2 - p1 ) % ( s1 - s2 ) == 0 ) || ( s2 > s1 && ( p1 - p2 ) % ( s2 - s1 ) == 0 ) ) ; } let p1 = 4 , s1 = 4 , p2 = 8 , s2 = 2 ; if ( sackRace ( p1 , s1 , p2 , s2 ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Find if two people ever meet after same number of jumps | function to find if any one of them can overtake the other ; Since starting points are always different , they will meet if following conditions are met . ( 1 ) Speeds are not same ( 2 ) Difference between speeds divide the total distance between initial points . ; Driver Code"
Javascript;"function solve ( n ) { let a = n / 2 ; if ( n % 2 != 0 ) { document . write ( ( Math . ceil ( a ) - 1 ) + "" "" + ( Math . floor ( a ) + 1 ) ) ; } else { if ( parseInt ( a , 10 ) % 2 == 0 ) { document . write ( ( Math . ceil ( a ) - 1 ) + "" "" + ( Math . floor ( a ) + 1 ) ) ; } else { document . write ( ( Math . ceil ( a ) - 2 ) + "" "" + ( Math . floor ( a ) + 2 ) ) ; } } } let n = 34 ; solve ( n ) ;";"Largest proper fraction with sum of numerator and denominator equal to a given number | Javascript program to find the largest fraction a / b such that a + b is equal to given number and a < b . ; Calculate N / 2 ; ; Check if N is odd or even ; If N is odd answer will be ceil ( n / 2 ) - 1 and floor ( n / 2 ) + 1 ; If N is even check if N / 2 i . e a is even or odd ; If N / 2 is even apply the previous formula ; If N / 2 is odd answer will be ceil ( N / 2 ) - 2 and floor ( N / 2 ) + 2 ; Driver code"
Javascript;"let P = 1 , R = 1 , T = 1 ; let SI = ( P * T * R ) / 100 ; document . write ( "" "" + SI ) ;";"Program to find simple interest | We can change values here for different inputs ; Calculate simple interest ; Print the resultant value of SI"
Javascript;"function countDigits ( a , b ) { let count = 0 ; let p = Math . abs ( a * b ) ; if ( p == 0 ) return 1 ; while ( p > 0 ) { count ++ ; p = parseInt ( p / 10 , 10 ) ; } return count ; } let a = 33 ; let b = - 24 ; document . write ( "" "" + countDigits ( a , b ) ) ;";"Number of digits in the product of two numbers | function to count number of digits in the product of two numbers ; absolute value of the product of two numbers ; if product is 0 ; count number of digits in the product ' p ' ; required count of digits ; Driver program to test above"
Javascript;"function multiple ( a , b , x ) { if ( b < 0 ) { if ( a == 1 && x == 1 ) document . write ( "" "" ) ; else document . write ( "" "" ) ; } var mul = parseInt ( Math . pow ( a , b ) ) ; var ans = mul / x ; var ans1 = x * ans ; var ans2 = x * ( ans + 1 ) ; document . write ( ( ( mul - ans1 ) <= ( ans2 - mul ) ) ? ans1 : ans2 ) ; } var a = 349 , b = 1 , x = 4 ; multiple ( a , b , x ) ;";"Find multiple of x closest to or a ^ b ( a raised to power b ) | function to find closest multiple of x to a ^ b ; calculate a ^ b / x ; Answer is either ( ans * x ) or ( ans + 1 ) * x ; Printing nearest answer ; Driver Program"
Javascript;"function maxSum ( n ) { if ( n == 1 ) return 1 ; else return ( parseInt ( n * ( n - 1 ) / 2 , 10 ) - 1 + parseInt ( n / 2 , 10 ) ) ; } let n = 3 ; document . write ( maxSum ( n ) ) ;";"Maximum sum of difference of adjacent elements | To find max sum of permutation ; Base case ; Otherwise max sum will be ( n * ( n - 1 ) / 2 ) - 1 + n / 2 ; Driver code"
Javascript;"const INT_MAX = 2147483647 ; function compute_average ( a , b ) { return Math . floor ( ( a + b ) / 2 ) ; } let a = INT_MAX ; let b = - INT_MAX - 1 ; document . write ( "" "" + INT_MAX + "" "" ) ; document . write ( "" "" + compute_average ( a , b ) + "" "" ) ;";"Compute average of two numbers without overflow | Javascript code to compute average of two numbers ; Function to compute average of two numbers ; Assigning maximum integer value ; Average of two equal numbers is the same number ; Function to get the average of 2 numbers"
Javascript;"function minNum ( arr , n ) { let odd = false ; for ( let i = 0 ; i < n ; i ++ ) if ( arr [ i ] % 2 != 0 ) odd = ! odd ; if ( odd ) return 1 ; return 2 ; } let arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ] ; let n = arr . length ; document . write ( minNum ( arr , n ) ) ;";"Add minimum number to an array so that the sum becomes even | Function to find out minimum number ; Count odd number of terms in array ; Driver Code"
Javascript;"function checkJumbled ( num ) { if ( parseInt ( num / 10 , 10 ) == 0 ) return true ; while ( num != 0 ) { if ( parseInt ( num / 10 , 10 ) == 0 ) return true ; let digit1 = num % 10 ; let digit2 = parseInt ( num / 10 , 10 ) % 10 ; if ( Math . abs ( digit2 - digit1 ) > 1 ) return false ; num = parseInt ( num / 10 , 10 ) ; } return true ; } let num = - 1234 ; if ( checkJumbled ( num ) ) document . write ( "" "" + "" "" ) ; else document . write ( "" "" + "" "" ) ; num = - 1247 ; if ( checkJumbled ( num ) ) document . write ( "" "" + "" "" ) ; else document . write ( "" "" + "" "" ) ;";"Check if a number is jumbled or not | Function to check if a number is jumbled or not ; Single digit number ; Checking every digit through a loop ; All digits were checked ; Digit at index i ; Digit at index i - 1 ; If difference is greater than 1 ; Number checked ; - 1234 to be checked ; 287 to be checked"
Javascript;"function msbPos ( n ) { var pos = 0 ; while ( n != 0 ) { pos ++ ; n = n >> 1 ; } return pos ; } function josephify ( n ) { var position = msbPos ( n ) ; var j = 1 << ( position - 1 ) ; n = n ^ j ; n = n << 1 ; n = n | 1 ; return n ; } var n = 41 ; document . write ( josephify ( n ) ) ;";"Josephus Problem Using Bit Magic | method to find the position of the Most Significant Bit ; keeps shifting bits to the right until we are left with 0 ; method to return at which place Josephus should sit to avoid being killed ; Getting the position of the Most Significant Bit ( MSB ) . The leftmost '1' . If the number is '41' then its binary is '101001' . So msbPos ( 41 ) = 6 ; ' j ' stores the number with which to XOR the number ' n ' . Since we need '100000' We will do 1 << 6 - 1 to get '100000' ; Toggling the Most Significant Bit . Changing the leftmost '1' to '0' . 101001 ^ 100000 = 001001 ( 9 ) ; Left - shifting once to add an extra '0' to the right end of the binary number 001001 = 010010 ( 18 ) ; Toggling the '0' at the end to '1' which is essentially the same as putting the MSB at the rightmost place . 010010 | 1 = 010011 ( 19 ) ; Driver Method"
Javascript;"function countXorPair ( arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) { for ( let j = i + 1 ; j < n ; j ++ ) if ( ( arr [ i ] ^ arr [ j ] ) % 2 == 1 ) count ++ ; } return count ; } let arr = [ 1 , 2 , 3 ] ; document . write ( countXorPair ( arr , arr . length ) ) ;";"Count pairs with Odd XOR | A function will return number of pair whose XOR is odd ; To store count of XOR pair ; If XOR is odd increase count ; Return count ; Driver Code"
Javascript;"function powmod ( x , y , p ) { let res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } function discreteLogarithm ( a , b , m ) { let n = ( parseInt ( Math . sqrt ( m ) , 10 ) + 1 ) ; let value = new Array ( m ) ; value . fill ( 0 ) ; for ( let i = n ; i >= 1 ; -- i ) value [ powmod ( a , i * n , m ) ] = i ; for ( let j = 0 ; j < n ; ++ j ) { let cur = ( powmod ( a , j , m ) * b ) % m ; if ( value [ cur ] > 0 ) { let ans = value [ cur ] * n - j ; if ( ans < m ) return ans ; } } return - 1 ; } let a = 2 , b = 3 , m = 5 ; document . write ( discreteLogarithm ( a , b , m ) + "" "" ) ; a = 3 ; b = 7 ; m = 11 ; document . write ( discreteLogarithm ( a , b , m ) + "" "" ) ;";"Discrete logarithm ( Find an integer k such that a ^ k is congruent modulo b ) | Iterative Function to calculate ( x ^ y ) % p in O ( log y ) ; Initialize result ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 ; y = y / 2 ; Function to calculate k for given a , b , m ; Store all values of a ^ ( n * i ) of LHS ; Calculate ( a ^ j ) * b and check for collision ; If collision occurs i . e . , LHS = RHS ; Check whether ans lies below m or not ; Driver code"
Javascript;"function discreteLogarithm ( a , b , m ) { let n = parseInt ( Math . sqrt ( m ) , 10 ) + 1 ; let an = 1 ; for ( let i = 0 ; i < n ; ++ i ) an = ( an * a ) % m ; let value = new Array ( m ) ; value . fill ( 0 ) ; for ( let i = 1 , cur = an ; i <= n ; ++ i ) { if ( value [ cur ] == 0 ) value [ cur ] = i ; cur = ( cur * an ) % m ; } for ( let i = 0 , cur = b ; i <= n ; ++ i ) { if ( value [ cur ] > 0 ) { let ans = value [ cur ] * n - i ; if ( ans < m ) return ans ; } cur = ( cur * a ) % m ; } return - 1 ; } let a = 2 , b = 3 , m = 5 ; document . write ( discreteLogarithm ( a , b , m ) + "" "" ) ; a = 3 ; b = 7 ; m = 11 ; document . write ( discreteLogarithm ( a , b , m ) ) ;";"Discrete logarithm ( Find an integer k such that a ^ k is congruent modulo b ) | Javascript program to calculate discrete logarithm ; Calculate a ^ n ; Store all values of a ^ ( n * i ) of LHS ; Calculate ( a ^ j ) * b and check for collision ; Driver code"
Javascript;"function nthprimedigitsnumber ( number ) { let rem ; let num = "" "" ; while ( number > 0 ) { rem = number % 4 ; switch ( rem ) { case 1 : num += ' ' ; break ; case 2 : num += ' ' ; break ; case 3 : num += ' ' ; break ; case 0 : num += ' ' ; break ; } if ( number % 4 == 0 ) number -- ; number = parseInt ( number / 4 , 10 ) ; } let st = num . split ( ' ' ) ; st . reverse ( ) ; return ( st . join ( "" "" ) ) ; } let number = 21 ; document . write ( nthprimedigitsnumber ( 10 ) + "" "" ) ; document . write ( nthprimedigitsnumber ( number ) ) ;";"Finding n | Javascript program to find n - th number with prime digits 2 , 3 and 7 ; remainder for check element position ; if number is 1 st position in tree ; if number is 2 nd position in tree ; if number is 3 rd position in tree ; if number is 4 th position in tree ; Driver code"
Javascript;"function countPairs ( N ) { let count = 0 ; for ( let i = 1 ; i <= parseInt ( Math . pow ( N , ( 1.0 / 3.0 ) ) , 10 ) ; i ++ ) { let cb = i * i * i ; let diff = N - cb ; let cbrtDiff = parseInt ( Math . pow ( diff , ( 1.0 / 3.0 ) ) , 10 ) ; if ( cbrtDiff * cbrtDiff * cbrtDiff == diff ) count ++ ; } return count ; } for ( let i = 1 ; i <= 10 ; i ++ ) document . write ( "" "" + i + "" "" + countPairs ( i ) + "" "" + "" "" ) ;";"Count pairs ( a , b ) whose sum of cubes is N ( a ^ 3 + b ^ 3 = N ) | method to count the pairs satisfying a ^ 3 + b ^ 3 = N ; Check for each number 1 to cbrt ( N ) ; Store cube of a number ; Subtract the cube from given N ; Check if the difference is also a perfect cube ; If yes , then increment count ; Return count ; Loop to Count no . of pairs satisfying a ^ 3 + b ^ 3 = i for N = 1 to 10"
Javascript;"function printEqualModNumbers ( arr , n ) { arr . sort ( ( a , b ) => a - b ) ; d = arr [ n - 1 ] - arr [ 0 ] ; if ( d == 0 ) { document . write ( "" "" ) ; return ; } v = new Array ( ) ; for ( i = 1 ; i * i <= d ; i ++ ) { if ( d % i == 0 ) { v . push ( i ) ; if ( i != d / i ) v . push ( d / i ) ; } } for ( i = 0 ; i < v . length ; i ++ ) { temp = arr [ 0 ] % v [ i ] ; j = 1 ; for ( ; j < n ; j ++ ) if ( arr [ j ] % v [ i ] != temp ) break ; if ( j == n ) document . write ( v [ i ] + "" "" ) ; } } let arr = new Array ( 38 , 6 , 34 ) ; printEqualModNumbers ( arr , arr . length ) ;";"Finding ' k ' such that its modulus with each array element is same | Prints all k such that arr [ i ] % k is same for all i ; sort the numbers ; max difference will be the difference between first and last element of sorted array ; Case when all the array elements are same ; Find all divisors of d and store in a vector v [ ] ; check for each v [ i ] if its modulus with each array element is same or not ; checking for each array element if its modulus with k is equal to k or not ; if check is true print v [ i ] ; Driver method"
Javascript;"function FirstDigit ( arr , n ) { let S = 0 ; for ( let i = 0 ; i < n ; i ++ ) S = S + Math . log10 ( arr [ i ] * 1.0 ) ; let fract_S = S - Math . floor ( S ) ; let ans = parseInt ( Math . pow ( 10 , fract_S ) , 10 ) ; return ans ; } let arr = [ 5 , 8 , 3 , 7 ] ; let n = arr . length ; document . write ( FirstDigit ( arr , n ) ) ;";"First digit in product of an array of numbers | returns the first digit of product of elements of arr [ ] ; stores the logarithm of product of elements of arr [ ] ; fractional ( s ) = s - floor ( s ) ; ans = 10 ^ fract_s ; Driver Code"
Javascript;"function countDigit ( n ) { var temp = n , count = 0 ; while ( temp != 0 ) { var d = temp % 10 ; temp /= 10 ; if ( d > 0 && n % d == 0 ) count ++ ; } return count ; } var n = 1012 ; document . write ( countDigit ( n ) ) ;";"Find count of digits in a number that divide the number | Return the number of digits that divides the number . ; Fetching each digit of the number ; Checking if digit is greater than 0 and can divides n . ; Driver method"
Javascript;"function makeOdd ( n ) { if ( n % 2 != 0 ) return 1 ; var ans = 1 ; while ( n % 2 == 0 ) { n = parseInt ( n / 2 ) ; ans *= 2 ; } return ans ; } var n = 36 ; var res = makeOdd ( n ) ; document . write ( res ) ;";"Minimum positive integer to divide a number such that the result is an odd | Function to find the value ; Return 1 if already odd ; Check how many times it is divided by 2 ; Driver code"
Javascript;"function closestMultiple ( n , x ) { if ( x > n ) return x ; n = n + parseInt ( x / 2 , 10 ) ; n = n - ( n % x ) ; return n ; } let n = 56287 , x = 27 ; document . write ( closestMultiple ( n , x ) ) ;";"Multiple of x closest to n | Function to calculate the smallest multiple ; Driver program"
Javascript;"function printCubes ( a , b ) { let acrt = parseInt ( Math . pow ( a , 1 / 3 ) , 10 ) ; let bcrt = parseInt ( Math . pow ( b , 1 / 3 ) , 10 ) ; for ( let i = acrt ; i <= bcrt ; i ++ ) if ( i * i * i >= a && i * i * i <= b ) document . write ( ( i * i * i ) + "" "" ) ; } let a = 24 ; let b = 576 ; document . write ( "" "" + "" "" + "" "" ) ; printCubes ( a , b ) ;";"Perfect cubes in a range | An efficient solution to print perfect cubes between a and b ; Find cube root of both a and b ; Print cubes between acrt and bcrt ; Driver Code"
Javascript;"function number0f2s ( n ) { let count = 0 ; while ( n > 0 ) { if ( n % 10 == 2 ) count ++ ; n = parseInt ( n / 10 , 10 ) ; } return count ; } function numberOf2sinRange ( n ) { let count = 0 ; for ( let i = 2 ; i <= n ; i ++ ) count += number0f2s ( i ) ; return count ; } document . write ( numberOf2sinRange ( 22 ) + "" "" ) ; document . write ( numberOf2sinRange ( 100 ) ) ;";"Number of occurrences of 2 as a digit in numbers from 0 to n | Counts the number of '2' digits in a single number ; Counts the number of '2' digits between 0 and n ; Initialize result ; Count 2 's in every number  from 2 to n ; Driver code"
Javascript;"function minToggle ( arr , n ) { let zero = new Array ( n + 1 ) ; zero [ 0 ] = 0 ; for ( let i = 1 ; i <= n ; ++ i ) { if ( arr [ i - 1 ] == 0 ) zero [ i ] = zero [ i - 1 ] + 1 ; else zero [ i ] = zero [ i - 1 ] ; } let ans = n ; for ( let i = 1 ; i <= n ; ++ i ) ans = Math . min ( ans , i - zero [ i ] + zero [ n ] - zero [ i ] ) ; return ans ; } let arr = [ 1 , 0 , 1 , 1 , 0 ] ; let n = arr . length ; document . write ( minToggle ( arr , n ) ) ;";"Minimum toggles to partition a binary array so that it has first 0 s then 1 s | Function to calculate minimum toggling required by using Dynamic programming ; Fill entries in zero [ ] such that zero [ i ] stores count of zeroes to the left of i ( exl ; If zero found update zero [ ] array ; Finding the minimum toggle required from every index ( 0 to n - 1 ) ; Driver Program"
Javascript;"function check ( str ) { let n = str . length ; if ( ( str [ n - 1 ] - ' ' ) % 2 != 0 ) return false ; let digitSum = 0 ; for ( let i = 0 ; i < n ; i ++ ) digitSum += ( str [ i ] - ' ' ) ; return ( digitSum % 3 == 0 ) ; } let str = "" "" ; if ( check ( str ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check if a large number is divisible by 6 or not | Function to find that number divisible by 6 or not ; Return false if number is not divisible by 2. ; Compute sum of digits ; Check if sum of digits is divisible by 3 ; Driver Code"
Javascript;"let res = 0 ; function checkRecursive ( num , x , k , n ) { if ( x == 0 ) res ++ ; let r = Math . floor ( Math . pow ( num , 1.0 / n ) ) ; for ( let i = k + 1 ; i <= r ; i ++ ) { let a = x - Math . pow ( i , n ) ; if ( a >= 0 ) checkRecursive ( num , x - Math . pow ( i , n ) , i , n ) ; } return res ; } function check ( x , n ) { return checkRecursive ( x , x , 0 , n ) ; } document . write ( check ( 10 , 2 ) ) ;";"Find ways an Integer can be expressed as sum of n | JavaScript program for the above approach ; Wrapper over checkRecursive ( ) ; Driver Code"
Javascript;"function reverseNum ( n ) { let rem , rev = 0 ; while ( n > 0 ) { rem = n % 10 ; rev = rev * 10 + rem ; n = parseInt ( n / 10 ) ; } return rev ; } function isPalindrom ( num ) { return num == reverseNum ( num ) ; } function nthPalindrome ( n , k ) { let num = Math . pow ( 10 , k - 1 ) ; while ( true ) { if ( isPalindrom ( num ) ) -- n ; if ( n == 0 ) break ; ++ num ; } return num ; } let n = 6 , k = 5 ; document . write ( n + "" "" + k + "" "" + nthPalindrome ( n , k ) + "" "" ) ; n = 10 ; k = 6 ; document . write ( n + "" "" + k + "" "" + nthPalindrome ( n , k ) ) ;";"N 'th palindrome of K digits | Utility function to reverse the number n ; Boolean Function to check for palindromic number ; Function for finding nth palindrome of k digits ; Get the smallest k digit number ; check the number is palindrom or not ; if n 'th palindrome found  break the loop ; Increment number for checking next palindrome ; Driver code"
Javascript;"function nthPalindrome ( n , k ) { let temp = ( k & 1 ) != 0 ? parseInt ( k / 2 , 10 ) : ( parseInt ( k / 2 , 10 ) - 1 ) ; let palindrome = parseInt ( Math . pow ( 10 , temp ) , 10 ) ; palindrome += n - 1 ; document . write ( palindrome ) ; if ( ( k & 1 ) > 0 ) palindrome = parseInt ( palindrome / 10 , 10 ) ; while ( palindrome > 0 ) { document . write ( palindrome % 10 ) ; palindrome = parseInt ( palindrome / 10 , 10 ) ; } document . write ( "" "" + "" "" ) ; } let n = 6 , k = 5 ; document . write ( n + "" "" + k + "" "" ) ; nthPalindrome ( n , k ) ; n = 10 ; k = 6 ; document . write ( n + "" "" + k + "" "" ) ; nthPalindrome ( n , k ) ;";"N 'th palindrome of K digits | Javascript program of finding nth palindrome of k digit ; Determine the first half digits ; Print the first half digits of palindrome ; If k is odd , truncate the last digit ; print the last half digits of palindrome ; Driver code"
Javascript;"function findMax ( n , a , b , k , m ) { let arr = new Array ( n ) ; arr . fill ( 0 ) ; for ( let i = 0 ; i < m ; i ++ ) { let lowerbound = a [ i ] ; let upperbound = b [ i ] ; for ( let j = lowerbound ; j <= upperbound ; j ++ ) arr [ j ] += k [ i ] ; } let res = Number . MIN_VALUE ; for ( let i = 0 ; i < n ; i ++ ) res = Math . max ( res , arr [ i ] ) ; return res ; } let n = 5 ; let a = [ 0 , 1 , 2 ] ; let b = [ 1 , 4 , 3 ] ; let k = [ 100 , 100 , 100 ] ; let m = a . length ; document . write ( "" "" + "" "" + findMax ( n , a , b , k , m ) ) ;";"Maximum value in an array after m range increment operations | Function to find the maximum element after m operations ; Start performing m operations ; Store lower and upper index i . e . range ; Add ' k [ i ] ' value at this operation to whole range ; Find maximum value after all operations and return ; Number of values ; Value of k to be added at each operation"
Javascript;"function solve ( v ) { var res = [ ] ; var all3 = v [ 0 ] + v [ 1 ] + v [ 2 ] ; res . push ( all3 - v [ 1 ] * 2 ) ; res . push ( all3 - v [ 2 ] * 2 ) ; res . push ( all3 - v [ 0 ] * 2 ) ; return res ; } function findVertex ( xmid , ymid ) { var V1 = solve ( xmid ) ; var V2 = solve ( ymid ) ; for ( var i = 0 ; i < 3 ; i ++ ) { document . write ( V1 [ i ] + "" "" + V2 [ i ] + "" "" ) ; } } var xmid = [ 5 , 4 , 5 ] ; var ymid = [ 3 , 4 , 5 ] ; findVertex ( xmid , ymid ) ;";"Find coordinates of the triangle given midpoint of each side | Return after solving the equations and finding the vertices coordinate . ; Finding sum of all three coordinate . ; Solving the equation . ; Finds vertices of a triangles from given middle vertices . ; Find X coordinates of vertices . ; Find Y coordinates of vertices . ; Output the solution . ; Driver code"
Javascript;"function nthElement ( a , b , n ) { let seq = [ ] ; for ( let i = 1 ; i <= n ; i ++ ) seq . push ( a * i ) ; seq . sort ( function ( a , b ) { return a - b } ) ; for ( let i = 1 , k = n ; i <= n && k > 0 ; i ++ ) { if ( ! seq . includes ( b * i ) ) { seq . push ( b * i ) ; seq . sort ( function ( a , b ) { return a - b } ) ; k -- ; } } return seq [ n - 1 ] ; } let a = 3 , b = 5 , n = 5 ; document . write ( nthElement ( a , b , n ) ) ;";"N | Return the n - th number in the sorted list of multiples of two numbers . ; Generating first n multiple of a . ; Sorting the sequence . ; Generating and storing first n multiple of b and storing if not present in the sequence . ; If not present in the sequence ; Storing in the sequence . ; Driver Code"
Javascript;"function gcd ( a , b ) { return b > 0 ? gcd ( b , a % b ) : a ; } function countGCD ( L , R , g ) { L = parseInt ( ( L + g - 1 ) / g , 10 ) ; R = parseInt ( R / g , 10 ) ; let ans = 0 ; for ( let i = L ; i <= R ; i ++ ) for ( let j = L ; j <= R ; j ++ ) if ( gcd ( i , j ) == 1 ) ans ++ ; return ans ; } let L = 1 , R = 11 , g = 5 ; document . write ( countGCD ( L , R , g ) ) ;";"Count pairs of natural numbers with GCD equal to given number | Return the GCD of two numbers . ; Return the count of pairs having GCD equal to g . ; Setting the value of L , R . ; For each possible pair check if GCD is 1. ; Driver Code"
Javascript;"let dig = [ 1 , 1 , 2 , 6 , 4 , 2 , 2 , 4 , 2 , 8 ] ; function lastNon0Digit ( n ) { if ( n < 10 ) return dig [ n ] ; if ( ( parseInt ( n / 10 , 10 ) % 10 ) % 2 == 0 ) return ( 6 * lastNon0Digit ( parseInt ( n / 5 , 10 ) ) * dig [ n % 10 ] ) % 10 ; else return ( 4 * lastNon0Digit ( parseInt ( n / 5 , 10 ) ) * dig [ n % 10 ] ) % 10 ; } let n = 14 ; document . write ( lastNon0Digit ( n ) ) ;";"Last non | Initialize values of last non - zero digit of numbers from 0 to 9 ; Check whether tens ( or second last ) digit is odd or even If n = 375 , So n / 10 = 37 and ( n / 10 ) % 10 = 7 Applying formula for even and odd cases . ; Driver code"
Javascript;"function gcd ( a , b ) { if ( ( a % b ) == 0 ) return b ; return gcd ( b , a % b ) ; } function firstFactorialDivisibleNumber ( x ) { let new_x = x ; for ( i = 1 ; i < x ; i ++ ) { new_x = parseInt ( new_x / gcd ( i , new_x ) , 10 ) ; if ( new_x == 1 ) break ; } return i ; } let x = 16 ; document . write ( firstFactorialDivisibleNumber ( x ) ) ;";"Find the first natural number whose factorial is divisible by x | GCD function to compute the greatest divisor among a and b ; Returns first number whose factorial divides x . ; let i = 1 ; Result ; Remove common factors ; We found first i . ; Driver code"
Javascript;"function sieve ( prime , n ) { for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == false ) for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = true ; } } function maxDigitInPrimes ( L , R ) { let prime = new Array ( R + 1 ) ; for ( let i = 0 ; i < R + 1 ; i ++ ) { prime [ i ] = false ; } sieve ( prime , R ) ; let freq = new Array ( 10 ) ; for ( let i = 0 ; i < 10 ; i ++ ) { freq [ i ] = 0 ; } let val ; for ( let i = L ; i <= R ; i ++ ) { if ( ! prime [ i ] ) { while ( p > 0 ) { freq [ p % 10 ] ++ ; p = Math . floor ( p / 10 ) ; } } } let max = freq [ 0 ] , ans = 0 ; for ( let j = 1 ; j < 10 ; j ++ ) { if ( max <= freq [ j ] ) { max = freq [ j ] ; ans = j ; } } return ans ; } let L = 1 , R = 20 ; document . write ( maxDigitInPrimes ( L , R ) ) ;";"Find the highest occurring digit in prime numbers in a range | Sieve of Eratosthenes ; Returns maximum occurring digits in primes from l to r . ; Finding the prime number up to R . ; Initialise frequency of all digit to 0. ; For all number between L to R , check if prime or not . If prime , incrementing the frequency of digits present in the prime number . ; let p = i ; If i is prime ; Finding digit with highest frequency . ; Driver code"
Javascript;"function simpleSieve ( ) { let arr = Array ( 1001 ) . fill ( true ) ; for ( let p = 2 ; p * p < 1001 ; p ++ ) { if ( arr [ p ] ) { for ( let i = p * 2 ; i < 1001 ; i = i + p ) arr [ i ] = false ; } } } function find_sphene ( N ) { var arr1 = Array ( 8 ) . fill ( 0 ) ; var count = 0 ; var j = 0 ; for ( let i = 1 ; i <= N ; i ++ ) { if ( N % i == 0 && count < 8 ) { count ++ ; arr1 [ j ++ ] = i ; } } if ( count == 8 && ( arr [ arr1 [ 1 ] ] && arr [ arr1 [ 2 ] ] && arr [ arr1 [ 3 ] ] ) ) return 1 ; return 0 ; } var n = 60 ; simpleSieve ( ) ; var ans = find_sphene ( n ) ; if ( ans == 1 ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Sphenic Number | This functions finds all primes smaller than ' limit ' using simple sieve of eratosthenes . ; create a global array of size 10001 ; initialize all entries of it as true . A value in mark [ p ] will finally be false if ' p ' is Not a prime , else true . ; One by one traverse all numbers so that their multiples can be marked as composite . ; If p is not changed , then it is a prime ; Update all multiples of p ; to store the 8 divisors ; to count the number of divisor ; finally check if there re 8 divisor and all the numbers are distinct prime no return 1 else return 0 ) ; ; Driver code"
Javascript;"function gcd ( a , b ) { if ( a == 0 ) return b ; return gcd ( b % a , a ) ; } function commDiv ( a , b ) { let n = gcd ( a , b ) ; let result = 0 ; for ( let i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) result += 1 ; else result += 2 ; } } return result ; } let a = 12 , b = 24 ; document . write ( commDiv ( a , b ) ) ;";"Common Divisors of Two Numbers | Function to calculate gcd of two numbers ; Function to calculate all common divisors of two given numbers a , b -- > input integer numbers ; find gcd of a , b ; Count divisors of n . ; if ' i ' is factor of n ; check if divisors are equal ; Driver Code"
Javascript;"function spellsCount ( num ) { let n = num . length ; let result = 1 ; for ( let i = 0 ; i < n ; i ++ ) { let count = 1 ; while ( i < n - 1 && num [ i + 1 ] == num [ i ] ) { count ++ ; i ++ ; } result = result * Math . pow ( 2 , count - 1 ) ; } return result ; } let num = "" "" ; document . write ( spellsCount ( num ) ) ;";"Count ways to spell a number with repeated digits | Function to calculate all possible spells of a number with repeated digits num -- > string which is favourite number ; Final count of total possible spells ; Iterate through complete number ; Count contiguous frequency of particular digit num [ i ] ; Compute 2 ^ ( count - 1 ) and multiply with result ; Driver code"
Javascript;"function numSquareSum ( n ) { var squareSum = 0 ; while ( n != 0 ) { squareSum += ( n % 10 ) * ( n % 10 ) ; n = parseInt ( n / 10 ) ; } return squareSum ; } function isHappynumber ( n ) { var slow , fast ; slow = fast = n ; do { slow = numSquareSum ( slow ) ; fast = numSquareSum ( numSquareSum ( fast ) ) ; } while ( slow != fast ) ; return ( slow == 1 ) ; } var n = 13 ; if ( isHappynumber ( n ) ) document . write ( n + "" "" ) ; else document . write ( n + "" "" ) ;";"Happy Number | Utility method to return sum of square of digit of n ; method return true if n is Happy number ; initialize slow and fast by n ; move slow number by one iteration ; move fast number by two iteration ; if both number meet at 1 , then return true ; Driver code to test above methods"
Javascript;"let allPrimes = [ ] ; function sieve ( n ) { let prime = new Array ( n + 1 ) ; for ( let i = 0 ; i <= n ; i ++ ) prime [ i ] = true ; for ( let p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] == true ) { for ( let i = p * 2 ; i <= n ; i += p ) prime [ i ] = false ; } } for ( let p = 2 ; p <= n ; p ++ ) if ( prime [ p ] ) allPrimes . push ( p ) ; } function factorialDivisors ( n ) { let result = 1 ; for ( let i = 0 ; i < allPrimes . length ; i ++ ) { let p = allPrimes [ i ] ; let exp = 0 ; while ( p <= n ) { exp = exp + parseInt ( n / p , 10 ) ; p = p * allPrimes [ i ] ; } result = result * ( exp + 1 ) ; } return result ; } document . write ( factorialDivisors ( 6 ) ) ;";"Count Divisors of Factorial | allPrimes [ ] stores all prime numbers less than or equal to n . ; Fills above vector allPrimes [ ] for a given n ; Create a boolean array "" prime [ 0 . . n ] "" and initialize all entries it as true . A value in prime [ i ] will finally be false if i is not a prime , else true . ; Loop to update prime [ ] ; If prime [ p ] is not changed , then it is a prime ; Update all multiples of p ; Store primes in the vector allPrimes ; Function to find all result of factorial number ; Initialize result ; find exponents of all primes which divides n and less than n ; Current divisor ; Find the highest power ( stored in exp ) ' ▁ ▁ of ▁ allPrimes [ i ] ▁ that ▁ divides ▁ n ▁ using ▁ ▁ Legendre ' s formula . ; Multiply exponents of all primes less than n ; return total divisors ; Driver code"
Javascript;"function nonFibonacci ( n ) { let prevPrev = 1 , prev = 2 , curr = 3 ; while ( n > 0 ) { prevPrev = prev ; prev = curr ; curr = prevPrev + prev ; n = n - ( curr - prev - 1 ) ; } n = n + ( curr - prev - 1 ) ; return prev + n ; } document . write ( nonFibonacci ( 5 ) ) ;";"Non Fibonacci Numbers | Returns n 'th Non-Fibonacci number ; curr is to keep track of current fibonacci number , prev is previous , prevPrev is previous of previous . ; While count of non - fibonacci numbers doesn 't become negative or zero ; Simple Fibonacci number logic ; ( curr - prev - 1 ) is count of non - Fibonacci numbers between curr and prev . ; n might be negative now . Make sure it becomes positive by removing last added gap . ; Now add the positive n to previous Fibonacci number to find the n 'th non-fibonacci. ; Driver code"
Javascript;"function gcd ( a , b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; let k ; for ( k = 0 ; ( ( a b ) & 1 ) == 0 ; ++ k ) { a >>= 1 ; b >>= 1 ; } while ( ( a & 1 ) == 0 ) a >>= 1 ; do { while ( ( b & 1 ) == 0 ) b >>= 1 ; if ( a > b ) { let t = a ; a = b ; b = t ; } b = ( b - a ) ; } while ( b != 0 ) ; return a << k ; } let a = 34 , b = 17 ; document . write ( "" "" + gcd ( a , b ) ) ;";"Stein 's Algorithm for finding GCD | Function to implement Stein 's Algorithm ; GCD ( 0 , b ) == b ; GCD ( a , 0 ) == a , GCD ( 0 , 0 ) == 0 ; Finding K , where K is the greatest power of 2 that divides both a and b . ; Dividing a by 2 until a becomes odd ; From here on , ' a ' is always odd . ; If b is even , remove all factor of 2 in b ; Now a and b are both odd . Swap if necessary so a <= b , then set b = b - a ( which is even ) . ; restore common factors of 2 ; Driver code"
Javascript;"function findNDigitNumsUtil ( n , out , index , evenSum , oddSum ) { if ( index > n ) return ; if ( index == n ) { if ( Math . abs ( evenSum - oddSum ) == 1 ) { out [ index ] = ' ' ; for ( let i = 0 ; i < out . length ; i ++ ) { document . write ( out [ i ] ) ; } document . write ( "" "" ) ; } return ; } if ( index % 2 != 0 ) { for ( let i = 0 ; i <= 9 ; i ++ ) { out [ index ] = String . fromCharCode ( i + ' ' . charCodeAt ( 0 ) ) ; findNDigitNumsUtil ( n , out , index + 1 , evenSum , oddSum + i ) ; } } { for ( let i = 0 ; i <= 9 ; i ++ ) { out [ index ] = String . fromCharCode ( i + ' ' . charCodeAt ( 0 ) ) ; findNDigitNumsUtil ( n , out , index + 1 , evenSum + i , oddSum ) ; } } } function findNDigitNums ( n ) { let out = new Array ( n + 1 ) ; for ( let i = 0 ; i < n + 1 ; i ++ ) { out [ i ] = 0 ; } let index = 0 ; let evenSum = 0 , oddSum = 0 ; for ( let i = 1 ; i <= 9 ; i ++ ) { out [ index ] = String . fromCharCode ( i + ' ' . charCodeAt ( 0 ) ) ; findNDigitNumsUtil ( n , out , index + 1 , evenSum + i , oddSum ) ; } } let n = 3 ; findNDigitNums ( n ) ;";"Print all n | n -- > value of input out -- > output array index -- > index of next digit to be filled in output array evenSum , oddSum -- > sum of even and odd digits so far ; Base case ; If number becomes n - digit ; if absolute difference between sum of even and odd digits is 1 , print the number ; If current index is odd , then add it to odd sum and recurse ; else else add to even sum and recurse ; This is mainly a wrapper over findNDigitNumsUtil . It explicitly handles leading digit and calls findNDigitNumsUtil ( ) for remaining indexes ; output array to store n - digit numbers ; Initialize number index considered so far ; Initialize even and odd sums ; Explicitly handle first digit and call recursive function findNDigitNumsUtil for remaining indexes . Note that the first digit is considered to be present in even position ; Driver program"
Javascript;"var one = [ "" "" , "" "" , "" "" , "" "" , "" "" , "" "" , "" "" , "" "" , "" "" , "" "" , "" "" , "" "" , "" "" , "" "" , "" "" , "" "" , "" "" , "" "" , "" "" , "" "" ] ; var ten = [ "" "" , "" "" , "" "" , "" "" , "" "" , "" "" , "" "" , "" "" , "" "" , "" "" ] ; function numToWords ( n , s ) { var str = "" "" ; if ( n > 19 ) { str += ten [ parseInt ( n / 10 ) ] + one [ n % 10 ] ; } else { str += one [ n ] ; } if ( n != 0 ) { str += s ; } return str ; } function convertToWords ( n ) { var out = "" "" ; out += numToWords ( parseInt ( n / 10000000 ) , "" "" ) ; out += numToWords ( parseInt ( ( n / 100000 ) % 100 ) , "" "" ) ; out += numToWords ( parseInt ( ( n / 1000 ) % 100 ) , "" "" ) ; out += numToWords ( parseInt ( ( n / 100 ) % 10 ) , "" "" ) ; if ( n > 100 && n % 100 > 0 ) { out += "" "" ; } out += numToWords ( parseInt ( n % 100 ) , "" "" ) ; return out ; } var n = 438237764 ; document . write ( convertToWords ( n ) ) ;";"Program to convert a given number to words | Set 2 | Strings at index 0 is not used , it is to make array indexing simple ; Strings at index 0 and 1 are not used , they is to make array indexing simple ; n is 1 - or 2 - digit number ; if n is more than 19 , divide it ; if n is non - zero ; Function to prvar a given number in words ; stores word representation of given number n ; handles digits at ten millions and hundred millions places ( if any ) ; handles digits at hundred thousands and one millions places ( if any ) ; handles digits at thousands and tens thousands places ( if any ) ; handles digit at hundreds places ( if any ) ; handles digits at ones and tens places ( if any ) ; var handles upto 9 digit no change to unsigned var var var to handle more digit number ; convert given number in words"
Javascript;"function countEvenSum ( a , n ) { let res = 0 ; let s = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] % 2 == 1 ) { s = n - i - 1 - s ; } else { s = s + 1 ; } res = res + s ; } return res ; } let arr = [ 1 , 2 , 2 , 3 , 4 , 1 ] ; let n = arr . length ; document . write ( "" "" + "" "" + countEvenSum ( arr , n ) ) ;";"Find number of subarrays with even sum | Javascript program to count number of sub - arrays with even sum using an efficient algorithm Time Complexity - O ( N ) Space Complexity - O ( 1 ) ; result may be large enough not to fit in int ; ; to keep track of subarrays with even sum starting from index i ; if a [ i ] is odd then all subarrays starting from index i + 1 which was odd becomeseven when a [ i ] gets added to it . ; if a [ i ] is even then all subarrays starting from index i + 1 which was even remainseven and one extra a [ i ] even subarray gets added to it . ; Driver Code"
Javascript;"function gcd ( a , b ) { return ( a % b == 0 ) ? Math . abs ( b ) : gcd ( b , a % b ) ; } function isPossible ( a , b , c ) { return ( c % gcd ( a , b ) == 0 ) ; } let a = 3 , b = 6 , c = 9 ; if ( isPossible ( a , b , c ) ) document . write ( "" "" + "" "" ) ; else document . write ( "" "" + "" "" ) ; a = 3 ; b = 6 ; c = 8 ; if ( isPossible ( a , b , c ) ) document . write ( "" "" + "" "" ) ; else document . write ( "" "" + "" "" ) ; a = 2 ; b = 5 ; c = 1 ; if ( isPossible ( a , b , c ) ) document . write ( "" "" + "" "" ) ; else document . write ( "" "" + "" "" ) ;";"Linear Diophantine Equations | Utility function to find the GCD of two numbers ; This function checks if integral solutions are possible ; First example ; Second example ; Third example"
Javascript;"function farey ( n ) { var x1 = 0 , y1 = 1 , x2 = 1 , y2 = n ; document . write ( x1 + "" "" + y1 + "" "" + x2 + "" "" + y2 + "" "" ) ; while ( y != 1.0 ) { x = Math . floor ( ( y1 + n ) / y2 ) * x2 - x1 ; y = Math . floor ( ( y1 + n ) / y2 ) * y2 - y1 ; document . write ( x + "" "" + y + "" "" ) ; x1 = x2 ; x2 = x ; y1 = y2 ; y2 = y ; } } var n = 7 ; document . write ( "" "" + n + "" "" ) ; farey ( n ) ;";"Farey Sequence | Optimized function to print Farey sequence of order n ; We know first two terms are 0 / 1 and 1 / n ; var x , y = 0 ; For next terms to be evaluated ; Using recurrence relation to find the next term ; Print next term ; Update x1 , y1 , x2 and y2 for next iteration ; Driver program"
Javascript;"function gcd ( a , b ) { if ( b == 0 ) return a ; return ( gcd ( b , a % b ) ) ; } function findSmallest ( a , b ) { let lcm = parseInt ( ( a * b ) / gcd ( a , b ) , 10 ) ; document . write ( "" "" + parseInt ( lcm / a , 10 ) + "" "" + parseInt ( lcm / b , 10 ) ) ; } let a = 25 , b = 35 ; findSmallest ( a , b ) ;";"Find smallest values of x and y such that ax | To find GCD using Eculcid 's algorithm ; Prints smallest values of x and y that satisfy "" ax ▁ - ▁ by ▁ = ▁ 0"" ; Find LCM ; Driver code"
Javascript;"function power ( x , y , p ) { while ( y > 0 ) { if ( ( y & 1 ) > 0 ) res = ( res * x ) % p ; x = ( x * x ) % p ; } return res ; } function modInverse ( a , p ) { return power ( a , p - 2 , p ) ; } function modFact ( n , p ) { if ( p <= n ) return 0 ; let res = ( p - 1 ) ; for ( let i = n + 1 ; i < p ; i ++ ) res = ( res * modInverse ( i , p ) ) % p ; return res ; } let n = 25 , p = 29 ; document . write ( modFact ( n , p ) ) ;";"Compute n ! under modulo p | Utility function to do modular exponentiation . It returns ( x ^ y ) % p ; let res = 1 ; Initialize result x = x % p ; Update x if it is more than or equal to p ; If y is odd , multiply x with result ; y must be even now y = y >> 1 ; y = y / 2 ; Function to find modular inverse of a under modulo p using Fermat 's  method. Assumption: p is prime ; Returns n ! % p using Wilson 's Theorem ; n ! % p is 0 if n >= p ; Initialize result as ( p - 1 ) ! which is - 1 or ( p - 1 ) ; Multiply modulo inverse of all numbers from ( n + 1 ) to p ; Driver Code"
Javascript;"function countWays ( n ) { for ( let i = 1 ; i < n ; i ++ ) for ( let j = i ; j < n ; j ++ ) for ( let k = j ; k < n ; k ++ ) for ( let l = k ; l < n ; l ++ ) if ( i + j + k + l == n ) counter ++ ; return counter ; } let n = 8 ; document . write ( countWays ( n ) ) ;";"Count number of ways to divide a number in 4 parts | Returns count of ways ; Generate all possible quadruplet and increment counter when sum of a quadruplet is equal to n ; Driver Code"
Javascript;"function pairAndSum ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) for ( let j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] & arr [ j ] ; return ans ; } let arr = [ 5 , 10 , 15 ] ; let n = arr . length ; document . write ( pairAndSum ( arr , n ) ) ;";"Sum of Bitwise And of all pairs in a given array | Returns value of "" arr [ 0 ] ▁ & ▁ arr [ 1 ] ▁ + ▁ ▁ arr [ 0 ] ▁ & ▁ arr [ 2 ] ▁ + ▁ . . . ▁ arr [ i ] ▁ & ▁ arr [ j ] ▁ + ▁ ▁ . . . . . ▁ arr [ n - 2 ] ▁ & ▁ arr [ n - 1 ] "" ; Consider all pairs ( arr [ i ] , arr [ j ) such that i < j ; Driver Code"
Javascript;"function pairAndSum ( arr , n ) { for ( let i = 0 ; i < 32 ; i ++ ) { let k = 0 ; for ( let j = 0 ; j < n ; j ++ ) { if ( ( arr [ j ] & ( 1 << i ) ) != 0 ) k ++ ; } ans += ( 1 << i ) * ( k * ( k - 1 ) / 2 ) ; } return ans ; } let arr = [ 5 , 10 , 15 ] ; let n = arr . length ; document . write ( pairAndSum ( arr , n ) ) ;";"Sum of Bitwise And of all pairs in a given array | Returns value of "" arr [ 0 ] ▁ & ▁ arr [ 1 ] ▁ + ▁ ▁ arr [ 0 ] ▁ & ▁ arr [ 2 ] ▁ + ▁ . . . ▁ arr [ i ] ▁ & ▁ arr [ j ] ▁ + ▁ ▁ . . . . . ▁ arr [ n - 2 ] ▁ & ▁ arr [ n - 1 ] "" ; Traverse over all bits ; Count number of elements with i 'th bit set Initialize the count ; There are k set bits , means k ( k - 1 ) / 2 pairs . Every pair adds 2 ^ i to the answer . Therefore , we add ""2 ^ i ▁ * ▁ ▁ [ k * ( k - 1 ) / 2 ] "" to the answer . ; Driver Code"
Javascript;"function isPrime ( n ) { if ( n <= 1 ) return false ; for ( let i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } isPrime ( 11 ) ? document . write ( "" "" + "" "" ) : document . write ( "" "" + "" "" ) ; isPrime ( 15 ) ? document . write ( "" "" + "" "" ) : document . write ( "" "" + "" "" ) ;";"Primality Test | Set 1 ( Introduction and School Method ) | A school method based Javascript program to check if a number is prime ; Corner case ; Check from 2 to n - 1 ; Driver Program to test above function"
Javascript;"function computeTotient ( n ) { let phi = new Array ( n + 1 ) ; for ( let i = 1 ; i <= n ; i ++ ) phi [ i ] = i ; for ( let p = 2 ; p <= n ; p ++ ) { if ( phi [ p ] == p ) { phi [ p ] = p - 1 ; for ( let i = 2 * p ; i <= n ; i += p ) { phi [ i ] = parseInt ( phi [ i ] / p , 10 ) * ( p - 1 ) ; } } } for ( let i = 1 ; i <= n ; i ++ ) document . write ( "" "" + i + "" "" + phi [ i ] + "" "" ) ; } let n = 12 ; computeTotient ( n ) ;";"Euler 's Totient function for all numbers smaller than or equal to n | Computes and prints totient of all numbers smaller than or equal to n ; Create and initialize an array to store phi or totient values ; indicates not evaluated yet and initializes for product formula . ; Compute other Phi values ; If phi [ p ] is not computed already , then number p is prime ; Phi of a prime number p is always equal to p - 1. ; Update phi values of all multiples of p ; Add contribution of p to its multiple i by multiplying with ( 1 - 1 / p ) ; Print precomputed phi values ; Driver code"
Javascript;"function Euler_totient_function ( n ) { let result = 1 ; for ( let i = 2 ; i * i <= n ; i ++ ) { let c = 0 ; if ( n % i == 0 ) { while ( n % i == 0 ) { c ++ ; n = parseInt ( n / i ) ; } } if ( c > 0 ) { let power = Math . pow ( i , c - 1 ) ; let sm = Math . pow ( i , c - 1 ) * ( i - 1 ) ; result *= sm ; } } if ( n > 1 ) { result *= ( n - 1 ) ; } return result ; } for ( let i = 1 ; i < 13 ; i ++ ) { document . write ( "" "" + i + "" "" ) ; document . write ( Euler_totient_function ( i ) + "" "" ) ; }";"Euler 's Totient function for all numbers smaller than or equal to n | Javascript program for the above approach ; driver code"
Javascript;"function isPower ( n ) { let p ; if ( n <= 1 ) { return true ; } for ( let i = 2 ; i <= parseInt ( Math . sqrt ( n ) , 10 ) ; i ++ ) { p = ( Math . log ( n ) / Math . log ( i ) ) . toFixed ( 14 ) ; if ( ( Math . ceil ( p ) == Math . floor ( p ) ) && ( p > 1 ) ) { return true ; } } return false ; } for ( let i = 2 ; i < 100 ; i ++ ) { if ( isPower ( i ) ) document . write ( i + "" "" ) ; }";"Check if a number can be expressed as x ^ y ( x raised to power y ) | Returns true if n can be written as x ^ y ; Driver code"
Javascript;"function sumBetweenTwoKth ( arr , k1 , k2 ) { arr . sort ( function ( a , b ) { return a - b } ) ; var result = 0 ; for ( var i = k1 ; i < k2 - 1 ; i ++ ) result += arr [ i ] ; return result ; } var arr = [ 20 , 8 , 22 , 4 , 12 , 10 , 14 ] ; var k1 = 3 , k2 = 6 ; var n = arr . length ; document . write ( sumBetweenTwoKth ( arr , k1 , k2 ) ) ;";"Sum of all elements between k1 ' th ▁ and ▁ k2' th smallest elements | Returns sum between two kth smallest element of array ; Sort the given array ; Below code is equivalent to ; Driver code"
Javascript;"function countSquares ( n ) { return ( n * ( n + 1 ) / 2 ) * ( 2 * n + 1 ) / 3 ; } let n = 4 ; document . write ( "" "" + countSquares ( n ) ) ;";"Puzzle | Program to find number of squares in a chessboard | Function to return count of squares ; ; A better way to write n * ( n + 1 ) * ( 2 n + 1 ) / 6 ; Driver Code"
Javascript;"function nthMagicNo ( n ) { let pow = 1 , answer = 0 ; while ( n != 0 ) { pow = pow * 5 ; if ( ( n & 1 ) == 1 ) answer += pow ; n >>= 1 ; } return answer ; } let n = 5 ; document . write ( "" "" + "" "" + nthMagicNo ( n ) ) ;";"Find nth Magic Number | Function to find nth magic number ; Go through every bit of n ; If last bit of n is set ; proceed to next bit or n = n / 2 ; Driver Code"
Javascript;"function countOfMultiples ( n ) { return ( parseInt ( n / 3 , 10 ) + parseInt ( n / 5 , 10 ) - parseInt ( n / 15 , 10 ) ) ; } document . write ( countOfMultiples ( 6 ) + "" "" ) ; document . write ( countOfMultiples ( 16 ) + "" "" ) ;";"Given a number n , count all multiples of 3 and / or 5 in set { 1 , 2 , 3 , ... n } | Javascript program to find count of multiples of 3 and 5 in { 1 , 2 , 3 , . . n } ; Add multiples of 3 and 5. Since common multiples are counted twice in n / 3 + n / 15 , subtract common multiples ; Driver Code"
Javascript;"function gcd ( a , b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } let a = 98 , b = 56 ; document . write ( "" "" + a + "" "" + b + "" "" + gcd ( a , b ) ) ;";"Program to find GCD or HCF of two numbers | Recursive function to return gcd of a and b ; Everything divides 0 ; base case ; a is greater ; Driver program to test above function"
Javascript;"function XorSum ( A , B , N , M ) { let ans1 = 0 , ans2 = 0 ; for ( let i = 0 ; i < N ; i ++ ) ans1 = ans1 ^ A [ i ] ; for ( let i = 0 ; i < M ; i ++ ) ans2 = ans2 ^ B [ i ] ; return ( ans1 & ans2 ) ; } let A = [ 3 , 5 ] ; let B = [ 2 , 3 ] ; let N = A . length ; let M = B . length ; document . write ( XorSum ( A , B , N , M ) ) ;";"Find XOR sum of Bitwise AND of all pairs from given two Arrays | Function to calculate the XOR sum of all ANDS of all pairs on A [ ] and B [ ] ; variable to store xor sums of first array and second array respectively . ; Xor sum of first array ; Xor sum of second array ; required answer ; Input ; Function call"
Javascript;"class TreeNode { constructor ( x ) { this . val = x ; this . left = null ; this . right = null ; } } function uniqueLevels ( root ) { let uniqueLevels = 0 ; let que = [ ] ; que . push ( root ) ; while ( que . length > 0 ) { let length = que . length ; let prefix_XOR = 0 ; let prefix_OR = 0 ; let flag = true ; for ( let i = 0 ; i < length ; i ++ ) { let temp = que [ 0 ] ; que . shift ( ) ; prefix_OR |= temp . val ; prefix_XOR ^= temp . val ; if ( prefix_XOR != prefix_OR ) flag = false ; if ( temp . left != null ) que . push ( temp . left ) ; if ( temp . right != null ) que . push ( temp . right ) ; } if ( flag ) uniqueLevels += 1 ; } document . write ( uniqueLevels ) ; } let root = new TreeNode ( 5 ) ; root . left = new TreeNode ( 6 ) ; root . right = new TreeNode ( 9 ) ; root . left . left = new TreeNode ( 1 ) ; root . left . right = new TreeNode ( 4 ) ; root . right . right = new TreeNode ( 7 ) ; uniqueLevels ( root ) ;";"Count levels in a Binary Tree consisting of node values having set bits at different positions | Structure of a node in the binary tree ; Function to find total unique levels ; Stores count of levels , where the set bits of all the nodes are at different positions ; Store nodes at each level of the tree using BFS ; Performing level order traversal ; Stores count of nodes at current level ; Stores prefix XOR of all the nodes at current level ; Stores prefix OR of all the nodes at current level ; Check if set bit of all the nodes at current level is at different positions or not ; Traverse nodes at current level ; Stores front element of the que ; Update prefix_OR ; Update prefix_XOR ; If left subtree not null ; If right subtree not null ; If bitwise AND is zero ; Driver Code ; Function Call"
Javascript;"var N = 5 var M = 2 function ConstructList ( Q ) { var xr = 0 ; var ans = [ ] ; for ( var i = N - 1 ; i >= 0 ; i -- ) { if ( Q [ i ] [ 0 ] == 0 ) ans . push ( Q [ i ] [ 1 ] ^ xr ) ; else xr ^= Q [ i ] [ 1 ] ; } ans . push ( xr ) ; ans . sort ( ( a , b ) => a - b ) ; return ans ; } var Q = [ [ 0 , 6 ] , [ 0 , 3 ] , [ 0 , 2 ] , [ 1 , 4 ] , [ 1 , 5 ] ] ; var ans = ConstructList ( Q ) ; ans . forEach ( element => { document . write ( "" "" + element ) ; } ) ;";"Construct a List using the given Q XOR queries | Javascript program for the above approach ; Function to return required list after performing all the queries ; Store cumulative Bitwise XOR ; Initialize final list to return ; Perform each query ; The initial value of 0 ; Sort the list ; Return final list ; Given Queries ; Function Call"
Javascript;"function build_num ( bit ) { let ans = 0 ; for ( let i = 0 ; i < 32 ; i ++ ) if ( bit [ i ] > 0 ) ans += ( 1 << i ) ; return ans ; } function maximumOR ( arr , n , k ) { let bit = new Array ( 32 ) ; bit . fill ( 0 ) ; for ( let i = 0 ; i < k ; i ++ ) { for ( let j = 0 ; j < 32 ; j ++ ) { if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) bit [ j ] ++ ; } } let max_or = build_num ( bit ) ; for ( let i = k ; i < n ; i ++ ) { for ( let j = 0 ; j < 32 ; j ++ ) { if ( ( arr [ i - k ] & ( 1 << j ) ) > 0 ) bit [ j ] -- ; } for ( let j = 0 ; j < 32 ; j ++ ) { if ( ( arr [ i ] & ( 1 << j ) ) > 0 ) bit [ j ] ++ ; } max_or = Math . max ( build_num ( bit ) , max_or ) ; } return max_or ; } let arr = [ 2 , 5 , 3 , 6 , 11 , 13 ] ; let k = 3 ; let n = arr . length ; document . write ( maximumOR ( arr , n , k ) ) ;";"Bitwise operations on Subarrays of size K | Function to convert bit array to decimal number ; Function to find maximum values of each bitwise OR operation on element of subarray of size K ; Maintain an integer array bit [ ] of size 32 all initialized to 0 ; Create a sliding window of size k ; Function call ; Perform operation for removed element ; Perform operation for added_element ; Taking maximum value ; Return the result ; Given array [ ] arr ; Given subarray size K ; Function Call"
Javascript;"class Node { constructor ( ) { this . data = 0 ; this . left = null ; this . right = null ; } } ; function newNode ( data ) { var newNode = new Node ; newNode . data = data ; newNode . left = newNode . right = null ; return ( newNode ) ; } function Solve ( root , xr , max_xor ) { xr = xr ^ root . data ; if ( root . left == null && root . right == null ) { max_xor = Math . max ( max_xor , xr ) ; return max_xor ; } if ( root . left != null ) { max_xor = Solve ( root . left , xr , max_xor ) ; } if ( root . right != null ) { max_xor = Solve ( root . right , xr , max_xor ) ; } return max_xor ; } function findMaxXor ( root ) { var xr = 0 , max_xor = 0 ; max_xor = Solve ( root , xr , max_xor ) ; return max_xor ; } var root = newNode ( 2 ) ; root . left = newNode ( 1 ) ; root . right = newNode ( 4 ) ; root . left . left = newNode ( 10 ) ; root . left . right = newNode ( 8 ) ; root . right . left = newNode ( 5 ) ; root . right . right = newNode ( 10 ) ; document . write ( findMaxXor ( root ) ) ;";"Maximum XOR path of a Binary Tree | Binary tree node ; Function to create a new node ; Function calculate the value of Math . max - xor ; Updating the xor value with the xor of the path from root to the node ; Check if node is leaf node ; Check if the left node exist in the tree ; Check if the right node exist in the tree ; Function to find the required count ; Recursively traverse the tree and compute the max_xor ; Return the result ; Create the binary tree"
Javascript;"function constructXORArray ( A , n , K ) { let B = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) B [ i ] = A [ i ] ^ K ; for ( let i = 0 ; i < n ; i ++ ) document . write ( B [ i ] + "" "" ) ; document . write ( "" "" ) } let A = [ 2 , 4 , 1 , 3 , 5 ] ; let K = 5 ; let n = A . length ; constructXORArray ( A , n , K ) ; let B = [ 4 , 75 , 45 , 42 ] ; K = 2 ; n = B . length ; constructXORArray ( B , n , K ) ;";"XOR of every element of an Array with a given number K | Function to construct new array ; Traverse the array and compute XOR with K ; Print new array ; Driver code"
Javascript;"function find_and ( arr ) { let ans = arr [ 0 ] ; for ( let i = 0 ; i < arr . length ; i ++ ) { ans = ( ans & arr [ i ] ) ; } return ans ; } let arr = [ 1 , 3 , 5 , 9 , 11 ] ; document . write ( find_and ( arr ) ) ;";"Bitwise AND of all the elements of array | Function to calculate bitwise AND ; Initialise ans variable is arr [ 0 ] ; Traverse the array compute AND ; Return ans ; Driver Code ; Function Call to find AND"
Javascript;"var maxsize = 100005 ; var xor_tree = Array ( maxsize ) ; function construct_Xor_Tree_Util ( current , start , end , x ) { if ( start == end ) { xor_tree [ x ] = current [ start ] ; return ; } var left = x * 2 + 1 ; var right = x * 2 + 2 ; var mid = start + parseInt ( ( end - start ) / 2 ) ; construct_Xor_Tree_Util ( current , start , mid , left ) ; construct_Xor_Tree_Util ( current , mid + 1 , end , right ) ; xor_tree [ x ] = ( xor_tree [ left ] ^ xor_tree [ right ] ) ; } function construct_Xor_Tree ( arr , n ) { construct_Xor_Tree_Util ( arr , 0 , n - 1 , 0 ) ; } var leaf_nodes = [ 40 , 32 , 12 , 1 , 4 , 3 , 2 , 7 ] ; var n = leaf_nodes . length ; construct_Xor_Tree ( leaf_nodes , n ) ; var x = ( Math . ceil ( Math . log2 ( n ) ) ) ; var max_size = 2 * Math . pow ( 2 , x ) - 1 ; document . write ( "" "" ) ; for ( var i = 0 ; i < max_size ; i ++ ) { document . write ( xor_tree [ i ] + "" "" ) ; } var root = 0 ; document . write ( "" "" + xor_tree [ root ] ) ;";"Construct XOR tree by Given leaf nodes of Perfect Binary Tree | Maximum size for xor tree ; Allocating space to xor tree ; A recursive function that constructs xor tree for vector array [ start ... . . end ] . x is index of current node in XOR tree ; If there is one element in vector array , store it in current node of XOR tree ; cout << xor_tree [ x ] << "" ▁ x "" ; ; for left subtree ; for right subtree ; for getting the middle index from corner indexes . ; Build the left and the right subtrees by xor operation ; merge the left and right subtrees by XOR operation ; Function to construct XOR tree from the given vector array . This function calls construct_Xor_Tree_Util ( ) to fill the allocated memory of xor_tree vector array ; leaf nodes of Perfect Binary Tree ; Build the xor tree ; Height of xor tree ; Maximum size of xor tree ; Root node is at index 0 considering 0 - based indexing in XOR Tree ; print value at root node"
Javascript;"function check ( arr , n , m , d ) { var i = 0 ; while ( i < n && m > 0 ) { m -- ; i += d ; } return m == 0 ? true : false ; } function maximumDistance ( arr , n , m ) { var low = 1 , high = n - 1 ; var ans = 0 ; while ( low <= high ) { var mid = parseInt ( ( low + high ) / 2 ) ; var flag = check ( arr , n , m , mid ) ; if ( flag ) { ans = mid ; low = mid + 1 ; } else { high = mid - 1 ; } } return ans ; } var n = 5 , m = 3 ; var arr = new Array ( n ) ; arr . fill ( 0 ) ; document . write ( maximumDistance ( arr , n , m ) ) ;";"Maximize distance between any two consecutive 1 ' s ▁ after ▁ flipping ▁ M ▁ 0' s | Function to return the count ; Flipping zeros at distance "" d "" ; Function to implement binary search ; Check for valid distance i . e mid ; Driver code"
Javascript;"function maximumXor ( arr , n ) { let sForward = [ ] ; let sBackward = [ ] ; let ans = - 1 ; for ( let i = 0 ; i < n ; i ++ ) { while ( sForward . length != 0 && arr [ i ] < arr [ sForward [ sForward . length - 1 ] ] ) { ans = Math . max ( ans , arr [ i ] ^ arr [ sForward [ sForward . length - 1 ] ] ) ; sForward . pop ( ) ; } sForward . push ( i ) ; while ( sBackward . length != 0 && arr [ n - i - 1 ] < arr [ sBackward [ sBackward . length - 1 ] ] ) { ans = Math . max ( ans , arr [ n - i - 1 ] ^ arr [ sBackward [ sBackward . length - 1 ] ] ) ; sBackward . pop ( ) ; } sBackward . push ( n - i - 1 ) ; } return ans ; } let arr = [ 8 , 1 , 2 ] ; let n = arr . length ; document . write ( maximumXor ( arr , n ) ) ;";"Maximum XOR value of maximum and second maximum element among all possible subarrays | Function to return the maximum possible xor ; To store the readonly answer ; Borward traversal ; Backward traversal ; Driver code"
Javascript;"function minTrees ( n ) { let count = 0 ; while ( n > 0 ) { n &= ( n - 1 ) ; count ++ ; } return count ; } let n = 7 ; document . write ( minTrees ( n ) ) ;";"Minimum count of Full Binary Trees such that the count of leaves is N | Function to return the minimum count of trees required ; To store the count of set bits in n ; Driver code"
Javascript;"function getMinSteps ( K ) { return countSetBits ( K ) ; } function countSetBits ( x ) { let setBits = 0 ; while ( x != 0 ) { x = x & ( x - 1 ) ; setBits ++ ; } return setBits ; } let n = 343 ; document . write ( getMinSteps ( n ) ) ;";"Count number of steps to cover a distance if steps can be taken in powers of 2 | Function to count the minimum number of steps ; count the number of set bits in a number ; Driver Code"
Javascript;"function isDefeat ( s1 , s2 , n ) { for ( let i = 0 ; i < n ; i ++ ) { if ( ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) || ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) ) continue ; else if ( ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) || ( s1 [ i ] == ' ' && s2 [ i ] == ' ' ) ) continue ; else { return true ; } } return false ; } let s1 = ( "" "" ) ; let s2 = ( "" "" ) ; let n = 10 ; if ( isDefeat ( s1 , s2 , n ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Game Theory in Balanced Ternary Numeral System | ( Moving 3 k steps at a time ) | Function that returns true if the game cannot be won ; Driver Code ; Common length"
Javascript;"var N = 3 , M = 3 ; function check ( a , b ) { for ( i = 1 ; i < N ; i ++ ) { for ( j = 1 ; j < M ; j ++ ) { if ( a [ i ] [ j ] != b [ i ] [ j ] ) { a [ i ] [ j ] ^= 1 ; a [ 0 ] [ 0 ] ^= 1 ; a [ 0 ] [ j ] ^= 1 ; a [ i ] [ 0 ] ^= 1 ; } } } for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < M ; j ++ ) { if ( a [ i ] [ j ] != b [ i ] [ j ] ) return false ; } } return true ; } var a = [ [ 0 , 1 , 0 ] , [ 0 , 1 , 0 ] , [ 1 , 0 , 0 ] ] ; var b = [ [ 1 , 0 , 0 ] , [ 1 , 0 , 0 ] , [ 1 , 0 , 0 ] ] ; if ( check ( a , b ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check if matrix A can be converted to B by changing parity of corner elements of any submatrix | javascript implementation of the above approach ; Boolean function that returns true or false ; Traverse for all elements ; If both are not equal ; Change the parity of all corner elements ; Check if A is equal to B ; Not equal ; First binary matrix ; Second binary matrix"
Javascript;"function FindIndexKthBit ( n , k ) { let cnt = 0 ; let ind = 0 ; while ( n > 0 ) { if ( n & 1 > 0 ) cnt ++ ; if ( cnt == k ) return ind ; ind ++ ; n = n >> 1 ; } return - 1 ; } let n = 15 , k = 3 ; let ans = FindIndexKthBit ( n , k ) ; if ( ans != - 1 ) document . write ( ans ) ; else document . write ( "" "" ) ;";"Position of the K | Function that returns the Kth set bit ; Traverse in the binary ; Check if the last bit is set or not ; Check if count is equal to k then return the index ; Increase the index as we move right ; Right shift the number by 1 ; Driver Code"
Javascript;"function hasEqualBlockFrequency ( N ) { let S = N . toString ( 2 ) ; let p = new Set ( ) ; let c = 1 ; for ( let i = 0 ; i < S . length - 1 ; i ++ ) { if ( S [ i ] == S [ i + 1 ] ) c += 1 ; else { p . add ( c ) ; c = 1 ; } p . add ( c ) ; } if ( p . size == 1 ) document . write ( "" "" ) ; else document . write ( "" "" ) ; } let N = 5 ; hasEqualBlockFrequency ( N ) ;";"Check if the binary representation of a number has equal number of 0 s and 1 s in blocks | Function to check ; Converting integer to its equivalent binary number ; If adjacent character are same then increase counter ; Driver Code"
Javascript;"function minDistance ( n1 , n2 ) { var bitCount1 = Math . floor ( Math . log2 ( n1 ) ) + 1 ; var bitCount2 = Math . floor ( Math . log2 ( n2 ) ) + 1 ; var bitDiff = Math . abs ( bitCount1 - bitCount2 ) ; var maxBitCount = Math . max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * Math . pow ( 2 , bitDiff ) ; } else { n1 = n1 * Math . pow ( 2 , bitDiff ) ; } var xorValue = n1 ^ n2 ; var bitCountXorValue ; if ( xorValue == 0 ) bitCountXorValue = 1 ; else { bitCountXorValue = Math . floor ( Math . log2 ( xorValue ) ) + 1 ; } var disSimilarBitPosition = maxBitCount - bitCountXorValue ; var result = bitCount1 + bitCount2 - 2 * disSimilarBitPosition ; return result ; } var n1 = 12 , n2 = 5 ; document . write ( minDistance ( n1 , n2 ) ) ;";"Distance between two nodes of binary tree with node values from 1 to N | Function to get minimum path distance ; count bit length of n1 and n2 ; find bit difference and maxBit ; calculate result by formula ; Driver program"
Javascript;"function printMaxAfterRemoval ( s ) { let flag = false ; let n = s . length ; for ( let i = 0 ; i < n ; i ++ ) { if ( s [ i ] == ' ' && flag == false ) { flag = true ; continue ; } else document . write ( s [ i ] ) ; } return 0 ; } let s = "" "" ; printMaxAfterRemoval ( s ) ;";"Remove one bit from a binary number to get maximum value | Function to find the maximum binary number ; Traverse the binary number ; Try finding a 0 and skip it ; Get the binary number ; Find the maximum binary number"
Javascript;"function bitPos ( n1 , n2 ) { if ( n1 == n2 ) return 0 ; let bitCount1 = Math . floor ( Math . log2 ( n1 ) ) + 1 ; let bitCount2 = Math . floor ( Math . log2 ( n2 ) ) + 1 ; let bitDiff = Math . abs ( bitCount1 - bitCount2 ) ; let maxBitCount = Math . max ( bitCount1 , bitCount2 ) ; if ( bitCount1 > bitCount2 ) { n2 = n2 * Math . pow ( 2 , bitDiff ) ; } else { n1 = n1 * Math . pow ( 2 , bitDiff ) ; } let xorValue = n1 ^ n2 ; let bitCountXorValue = Math . floor ( Math . log2 ( xorValue ) ) + 1 ; let disSimilarBitPosition = maxBitCount - bitCountXorValue + 1 ; return disSimilarBitPosition ; } let n1 = 53 , n2 = 55 ; document . write ( bitPos ( n1 , n2 ) ) ;";"Find position of left most dis | Function to find first dis - similar bit ; Return zero for equal number ; Find the 1 st dis - similar bit count bit length of n1 and n2 ; find bit difference and maxBit ; Driver code"
Javascript;"function countOddPair ( A , N ) { let count = 0 ; for ( let i = 0 ; i < N ; i ++ ) if ( ! ( A [ i ] & 1 ) ) count ++ ; let evenPairCount = parseInt ( count * ( count - 1 ) / 2 ) ; let totPairs = parseInt ( N * ( N - 1 ) / 2 ) ; return totPairs - evenPairCount ; } let A = [ 5 , 6 , 2 , 8 ] ; let N = A . length ; document . write ( countOddPair ( A , N ) ) ;";"Number of pairs with Bitwise OR as Odd number | Function to count pairs with odd OR ; Count total even numbers in array ; Even pair count ; Total pairs ; Return Odd pair count ; Driver main"
Javascript;"function ReplaceElements ( arr , n ) { if ( n <= 1 ) return ; let prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( let i = 1 ; i < n - 1 ; i ++ ) { let curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; } let arr = [ 2 , 3 , 4 , 5 , 6 ] ; let n = arr . length ; ReplaceElements ( arr , n ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "" "" ) ;";"Replace every array element by Bitwise Xor of previous and next element | Javascript program to update every array element with sum of previous and next numbers in array ; Nothing to do when array size is 1 ; Store current value of arr [ 0 ] and update it ; Update rest of the array elements ; Store current value of next interaction ; Update current value using previous value ; Update previous value ; Update last array element separately ; Driver code ; Print the modified array"
Javascript;"function luckiest_person ( n ) { let len = parseInt ( Math . log ( n ) / Math . log ( 2 ) ) + 1 ; let n2 = n ; for ( let i = 0 ; i < len ; i ++ ) { n2 = n2 ^ ( 1 << i ) ; } return Math . abs ( n - n2 ) ; } let N = 3 ; let lucky_p = luckiest_person ( N ) ; document . write ( lucky_p ) ;";"Lucky alive person in a circle | Set | JavaScript implementation of the above approach ; to calculate the number of bits in the binary equivalent of n ; Finding complement by inverting the bits one by one from last ; XOR of n2 with ( 1 << i ) to flip the last ( i + 1 ) th bit of binary equivalent of n2 ; n2 will be the one 's complement of n ; Driver Code"
Javascript;"function maxTriplet ( a , n ) { let f = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { f [ i ] = true ; } let bits = new Array ( n ) ; for ( let i = 0 ; i < n ; i ++ ) { bits [ i ] = new Array ( 33 ) ; for ( let j = 0 ; j < 33 ; j ++ ) { bits [ i ] [ j ] = 0 ; } } for ( let i = 0 ; i < n ; ++ i ) { let num = a [ i ] ; let j = 32 ; while ( num > 0 ) { if ( num % 2 == 1 ) { bits [ i ] [ j ] = 1 ; } j -- ; num >>= 1 ; } } let ans = 0 ; for ( let i = 0 ; i <= 32 ; ++ i ) { let cnt = 0 ; for ( let j = 0 ; j < n ; ++ j ) { if ( bits [ j ] [ i ] == 1 & f [ j ] ) { cnt ++ ; } } if ( cnt >= 3 ) { ans += Math . pow ( 2 , 32 - i ) ; for ( let j = 0 ; j < n ; ++ j ) { if ( bits [ j ] [ i ] != 1 ) { f [ j ] = false ; } } } } let cnt = 0 ; for ( let i = 0 ; i < n ; ++ i ) { if ( f [ i ] ) { cnt ++ ; } } let NumberOfTriplets = ( cnt * ( cnt - 1 ) * ( cnt - 2 ) ) / 6 ; document . write ( NumberOfTriplets + "" "" + ans ) ; } let a = [ 4 , 11 , 10 , 15 , 26 ] ; let n = a . length ; maxTriplet ( a , n ) ;";"Find triplets in an array whose AND is maximum | Javascript program to find triplet with maximum bitwise AND . ; Flag Array initially set to true for all numbers ; 2D array for bit representation of all the numbers . Initially all bits are set to 0. ; Finding bit representation of every number and storing it in bits array . ; Checking last bit of the number ; Dividing number by 2. ; maximum And number initially 0. ; Traversing the 2d binary representation . 0 th index represents 32 th bits while 32 th index represents 0 th bit . ; If cnt greater than 3 then ( 32 - i ) th bits of the number will be set . ; Setting flags of the numbers whose ith bit is not set . ; Counting the numbers whose flag are true . ; Driver code"
Javascript;"function OR ( a , n ) { var ans = a [ 0 ] ; for ( var i = 1 ; i < n ; ++ i ) ans |= a [ i ] ; return ans ; } var a = [ 1 , 4 , 6 ] ; var n = a . length ; document . write ( OR ( a , n ) ) ;";"Find bitwise OR of all possible sub | function to return OR of sub - arrays ; Driver Code ; print OR of all subarrays"
Javascript;"function bit ( n ) { let count = 0 ; while ( n > 0 ) { count ++ ; n = n & ( n - 1 ) ; } return count ; } function maxSumOfBits ( arr , n ) { for ( let i = 0 ; i < n ; i ++ ) { arr [ i ] = bit ( arr [ i ] ) ; } let incl = arr [ 0 ] ; let excl = 0 ; let excl_new ; for ( let i = 1 ; i < n ; i ++ ) { excl_new = ( incl > excl ) ? incl : excl ; incl = excl + arr [ i ] ; excl = excl_new ; } return ( ( incl > excl ) ? incl : excl ) ; } let arr = [ 1 , 2 , 4 , 5 , 6 , 7 , 20 , 25 ] ; let n = arr . length ; document . write ( maxSumOfBits ( arr , n ) ) ;";"Maximum set bit sum in array without considering adjacent elements | Function to count total number of set bits in an integer ; Maximum sum of set bits ; Calculate total number of set bits for every element of the array ; find total set bits for each number and store back into the array ; current max excluding i ; current max including i ; return max of incl and excl ; Driver code"
Javascript;"function increment ( i ) { let i1 = - ( ~ ( i ) . charCodeAt ( ) ) ; return String . fromCharCode ( i1 ) ; } let n = ' ' ; document . write ( increment ( n ) ) ;";"Increment a number without using ++ or + | function that increment the value . ; Invert bits and apply negative sign ; Driver code"
Javascript;"function findOddPair ( A , N ) { let i , count = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 == 0 ) count ++ ; } return count * ( N - count ) ; } let a = [ 5 , 4 , 7 , 2 , 1 ] ; let n = a . length ; document . write ( findOddPair ( a , n ) ) ;";"Count pairs with Bitwise XOR as ODD number | Function to count number of odd pairs ; find all pairs ; return number of odd pair ; Driver Code ; calling function findOddPair and print number of odd pair"
Javascript;"function MSBPosition ( N ) { let msb_p = - 1 ; while ( N > 0 ) { N = N >> 1 ; msb_p ++ ; } return msb_p ; } function findBitwiseOR ( L , R ) { let res = 0 ; let msb_p1 = MSBPosition ( L ) ; let msb_p2 = MSBPosition ( R ) ; while ( msb_p1 == msb_p2 ) { let res_val = ( 1 << msb_p1 ) ; res += res_val ; L -= res_val ; R -= res_val ; msb_p1 = MSBPosition ( L ) ; msb_p2 = MSBPosition ( R ) ; } msb_p1 = Math . max ( msb_p1 , msb_p2 ) ; for ( let i = msb_p1 ; i >= 0 ; i -- ) { let res_val = ( 1 << i ) ; res += res_val ; } return res ; } let L = 12 , R = 18 ; document . write ( findBitwiseOR ( L , R ) ) ;";"Bitwise OR ( or | ) of a range | Returns the Most Significant Bit Position ( MSB ) ; Returns the Bitwise OR of all integers between L and R ; Find the MSB position in L ; Find the MSB position in R ; Add this value until msb_p1 and msb_p2 are same ; ; Calculate msb_p1 and msb_p2 ; Find the max of msb_p1 and msb_p2 ; Set all the bits from msb_p1 upto 0 th bit in the result ; Driver Code"
Javascript;"function maxOR ( arr , n , k , x ) { let preSum = new Array ( n + 1 ) ; let suffSum = new Array ( n + 1 ) ; let res = 0 , pow = 1 ; for ( let i = 0 ; i < k ; i ++ ) pow *= x ; preSum [ 0 ] = 0 ; for ( let i = 0 ; i < n ; i ++ ) preSum [ i + 1 ] = preSum [ i ] | arr [ i ] ; suffSum [ n ] = 0 ; for ( let i = n - 1 ; i >= 0 ; i -- ) suffSum [ i ] = suffSum [ i + 1 ] | arr [ i ] ; res = 0 ; for ( let i = 0 ; i < n ; i ++ ) res = Math . max ( res , preSum [ i ] | ( arr [ i ] * pow ) suffSum [ i + 1 ] ) ; return res ; } let arr = [ 1 , 2 , 4 , 8 ] ; let n = 4 ; let k = 2 , x = 3 ; let ans = maxOR ( arr , n , k , x ) ; document . write ( ans ) ;";"Maximize the bitwise OR of an array | Function to maximize the bitwise OR sum ; Compute x ^ k ; Find prefix bitwise OR ; Find suffix bitwise OR ; Find maximum OR value ; Drivers code"
Javascript;"function turnOnK ( n , k ) { if ( k <= 0 ) return n ; return ( n | ( 1 << ( k - 1 ) ) ) ; } let n = 4 ; let k = 2 ; document . write ( turnOnK ( n , k ) ) ;";"How to turn on a particular bit in a number ? | Returns a number that has all bits same as n except the k 'th  bit which is made 1 ; k must be greater than 0 ; Do | of n with a number with all unset bits except the k 'th bit ; Driver Code"
Javascript;"function minSum ( a , n ) { a . sort ( ) ; let num1 = 0 ; let num2 = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( i % 2 == 0 ) num1 = num1 * 10 + a [ i ] ; else num2 = num2 * 10 + a [ i ] ; } return num2 + num1 ; } let arr = [ 5 , 3 , 0 , 7 , 4 ] ; let n = arr . length ; document . write ( "" "" + minSum ( arr , n ) ) ;";"Minimum sum of two numbers formed from digits of an array | Returns sum of two numbers formed from all digits in a [ ] ; sort the elements ; Driver code"
Javascript;"function printKthBit ( n , k ) { document . write ( ( n & ( 1 << ( k - 1 ) ) ) >> ( k - 1 ) ) ; } var n = 13 , k = 2 ; printKthBit ( n , k ) ;";"Find value of k | JavaScript program to find k - th bit from right ; Driver Code ; Function Call"
Javascript;"let N = 100010 ; let id = new Array ( N ) ; let sz = new Array ( N ) ; function Root ( idx ) { let i = idx ; while ( i != id [ i ] ) { id [ i ] = id [ id [ i ] ] ; i = id [ i ] ; } return i ; } function Union ( a , b ) { let i = Root ( a ) , j = Root ( b ) ; if ( i != j ) { if ( sz [ i ] >= sz [ j ] ) { id [ j ] = i ; sz [ i ] += sz [ j ] ; sz [ j ] = 0 ; } else { id [ i ] = j ; sz [ j ] += sz [ i ] ; sz [ i ] = 0 ; } } } function UnionUtil ( e , W , q ) { for ( let i = 0 ; i < q ; i ++ ) { let u , v ; u = e [ i ] [ 0 ] ; v = e [ i ] [ 1 ] ; u -- ; v -- ; if ( W [ u ] % 2 == 0 && W [ v ] % 2 == 0 ) Union ( u , v ) ; } } function findMax ( n , W ) { let maxi = 0 ; for ( let i = 1 ; i < n ; i ++ ) if ( W [ i ] % 2 == 0 ) maxi = Math . max ( maxi , sz [ i ] ) ; return maxi ; } let W = [ 1 , 2 , 6 , 4 , 2 , 0 , 3 ] ; let n = W . length ; for ( let i = 0 ; i < n ; i ++ ) { id [ i ] = i ; sz [ i ] = 1 ; } let e = [ [ 1 , 2 ] , [ 1 , 3 ] , [ 2 , 4 ] , [ 2 , 5 ] , [ 4 , 6 ] , [ 6 , 7 ] ] ; let q = e . length ; UnionUtil ( e , W , q ) ; let maxi = findMax ( n , W ) ; document . write ( "" "" ) ; document . write ( "" "" + maxi ) ;";"Disjoint Set Union on trees | Set 1 | Javascript code to find maximum subtree such that all nodes are even in weight ; ' id ' : stores parent of a node . ' sz ' : stores size of a DSU tree . ; Function to assign root ; Function to find Union ; Utility function for Union ; Edge between ' u ' and ' v ' ; 0 - indexed nodes ; If weights of both ' u ' and ' v ' are even then we make union of them . ; Function to find maximum size of DSU tree ; Weights of nodes ; Number of nodes in a tree ; Initializing every node as a tree with single node . ; Find maximum size of DSU tree ."
Javascript;"function countSetBits ( n ) { let count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; } function countOfOddsPascal ( n ) { let c = countSetBits ( n ) ; return Math . pow ( 2 , c ) ; } let n = 20 ; document . write ( countOfOddsPascal ( n ) ) ;";"Odd numbers in N | Function to get no of set bits in binary representation of positive integer n ; Count number of 1 's in binary  representation of n. ; Number of odd numbers in n - th row is 2 raised to power the count . ; Driver code"
Javascript;"function ansQueries ( prefeven , prefodd , l , r ) { if ( ( r - l + 1 ) % 2 == 0 ) document . write ( "" "" ) ; else { if ( l % 2 == 0 ) document . write ( prefeven [ r ] ^ prefeven [ l - 1 ] ) ; else document . write ( prefodd [ r ] ^ prefodd [ l - 1 ] ) ; } document . write ( "" "" ) ; } function wrapper ( arr , n , l , r , q ) { let prefodd = [ ] ; let prefeven = [ ] ; for ( let i = 1 ; i <= n ; i ++ ) { if ( ( i ) % 2 == 0 ) { prefeven [ i ] = arr [ i - 1 ] ^ prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ; } else { prefeven [ i ] = prefeven [ i - 1 ] ; prefodd [ i ] = prefodd [ i - 1 ] ^ arr [ i - 1 ] ; } } let i = 0 ; while ( i != q ) { ansQueries ( prefeven , prefodd , l [ i ] , r [ i ] ) ; i ++ ; } } let arr = [ 1 , 2 , 3 , 4 , 5 ] ; let n = arr . length ; let l = [ 1 , 1 , 2 ] ; let r = [ 2 , 3 , 4 ] ; let q = l . length ; wrapper ( arr , n , l , r , q ) ;";"Queries on XOR of XORs of all subarrays | Output for each query ; If number of element is even . ; If number of element is odd . ; if l is even ; if l is odd ; Wrapper Function ; Evaluating prefixodd and prefixeven ; Driver code"
Javascript;"function solve ( p , n ) { let G = 0 ; for ( let i = 0 ; i < n ; i ++ ) { if ( p [ i ] % 2 != 0 ) G ^= ( p [ i ] + 1 ) ; else G ^= ( p [ i ] - 1 ) ; } return G ; } let n = 3 ; let p = [ 32 , 49 , 58 ] ; let res = solve ( p , n ) ; if ( res == 0 ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Variation in Nim Game | Function to return final grundy Number ( G ) of game ; If pile size is odd ; We XOR pile size + 1 ; If pile size is even ; We XOR pile size - 1 ; Game with 3 piles ; Pile with different sizes ; Function to return result of game ; If G is zero ; If G is non zero"
Javascript;"function checkBit ( pattern , arr , n ) { let count = 0 ; for ( let i = 0 ; i < n ; i ++ ) if ( ( pattern & arr [ i ] ) == pattern ) count ++ ; return count ; } function maxAND ( arr , n ) { let res = 0 , count ; for ( let bit = 31 ; bit >= 0 ; bit -- ) { count = checkBit ( res | ( 1 << bit ) , arr , n ) ; if ( count >= 2 ) res |= ( 1 << bit ) ; } return res ; } let arr = [ 4 , 8 , 6 , 2 ] ; let n = arr . length ; document . write ( "" "" + maxAND ( arr , n ) ) ;";"Maximum AND value of a pair in an array | Utility function to check number of elements having set msb as of pattern ; Function for finding maximum and value pair ; iterate over total of 30 bits from msb to lsb ; find the count of element having set msb ; if count >= 2 set particular bit in result ; Driver Code"
Javascript;"function findMiniFlip ( nums ) { let n = nums . length ; let s = "" "" ; for ( let i = 0 ; i < n ; i ++ ) s += nums [ i ] ; let num = parseInt ( s , 2 ) ; let minXor = n ; let mask = ( 1 << ( n - 1 ) ) ; while ( n - 1 > 0 ) { let temp = ( num ^ mask ) ; minXor = Math . min ( minXor , countones ( temp ) ) ; n -- ; mask = ( mask | ( 1 << n - 1 ) ) ; } return minXor ; } function countones ( n ) { let c = 0 ; while ( n > 0 ) { n = n & ( n - 1 ) ; c ++ ; } return c ; } let nums = [ 1 , 0 , 1 , 1 , 0 , 0 , 0 ] ; let n = findMiniFlip ( nums ) ; document . write ( n ) ;";"Minimum flips to make all 1 s in left and 0 s in right | Set 1 ( Using Bitmask ) | Function to count minimum number of flips ; This is converting string s into integer of base 2 ( if s = '100' then num = 4 ) ; Initialize minXor with n that can be maximum number of flips ; Right shift 1 by ( n - 1 ) bits ; Calculate bitwise XOR of num and mask ; Math . min ( a , b ) returns minimum of a and b return minimum number of flips till that digit ; Function to count number of 1 s ; Driver Code"
Javascript;"function checkPowerof8 ( n ) { let i = Math . log ( n ) / Math . log ( 8 ) ; return ( i - Math . floor ( i ) < 0.000001 ) ; } let n = 65 ; if ( checkPowerof8 ( n ) ) document . write ( "" "" ) ; else document . write ( "" "" ) ;";"Check if a number is power of 8 or not | function to check if power of 8 ; calculate log8 ( n ) ; check if i is an integer or not ; Driver Code"
Javascript;"function convertStringToInt ( s ) { let ans = 0 ; for ( let i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == ' ' ) ans += 1 << i ; } return ans ; } function getNthNumber ( n ) { let q = [ ] ; if ( n == 1 ) return 1 ; n = n - 1 ; q . push ( "" "" ) ; while ( n -- > 0 ) { let curr = q . shift ( ) ; if ( n == 0 ) return convertStringToInt ( curr ) ; let len = curr . length ; let len2 = Math . floor ( len / 2 ) ; if ( len % 2 == 0 ) { q . push ( curr . substring ( 0 , len2 ) + "" "" + curr . substring ( len2 ) ) ; q . push ( curr . substring ( 0 , len2 ) + "" "" + curr . substring ( len2 ) ) ; } else { let midChar = curr [ len2 ] ; q . push ( curr . substring ( 0 , len2 ) + midChar + curr . substring ( len2 ) ) ; } } return - 1 ; } let n = 9 ; document . write ( getNthNumber ( n ) ) ;";"Find the n | utility function which is used to convert binary string into integer ; convert binary string into integer ; function to find nth binary palindrome number ; stores the binary palindrome string ; base case ; add 2 nd binary palindrome string ; runs till the nth binary palindrome number ; remove curr binary palindrome string from queue ; if n == 0 then we find the n 'th binary  palindrome so we return our answer ; calculate length of curr binary palindrome string ; if length is even . so it is our first case we have two choices ; if length is odd . so it is our second case we have only one choice ; Driver code ; Function Call"
Javascript;"var longSize = 8 ; var ULL_SIZE = 8 * longSize ; function bit_anagram_check ( a ) { var ans = a . toString ( 2 ) . split ( ' ' ) . join ( ' ' ) . length == ( ULL_SIZE >> 1 ) ? 1 : 0 ; return ans ; } var a = 4294967295 ; document . write ( bit_anagram_check ( a ) ) ;";"Check if binary representation of a given number and its complement are anagram | An efficient javascript program to check if binary representations of a number and it 's complement are anagram. ; Returns true if binary representations of a and b are anagram . ; _popcnt64 ( a ) gives number of 1 's present  in binary representation of a. If number  of 1s is half of total bits, return true. ; Driver code"
Javascript;"function findSum ( n ) { let sum = 0 ; for ( let i = 1 ; 1 << i < n ; i ++ ) { for ( let j = 0 ; j < i ; j ++ ) { let num = ( 1 << i ) + ( 1 << j ) ; if ( num <= n ) sum += num ; } } return sum ; } let n = 10 ; document . write ( findSum ( n ) ) ;";"Sum of numbers with exactly 2 bits set | To calculate sum of numbers ; Find numbers whose 2 bits are set ; If number is greater then n we don 't include this in sum ; Return sum of numbers ; Driver Code"
Javascript;"function posOfRightMostDiffBit ( m , n ) { return parseInt ( Math . floor ( Math . log10 ( Math . pow ( m ^ n , 2 ) ) ) , 10 ) + 2 ; } let m = 52 , n = 4 ; document . write ( "" "" + posOfRightMostDiffBit ( m , n ) ) ;";"Position of rightmost different bit | function to find rightmost different bit in two numbers . ; Driver code"
Javascript;"function setKthBit ( n , k ) { return ( ( 1 << k ) n ) ; } let n = 10 , k = 2 ; document . write ( "" "" + setKthBit ( n , k ) ) ;";"Set the K | function to set the kth bit ; kth bit of n is being set by this operation ; Driver code"
Javascript;"function reversearray ( arr , n ) { let x = parseInt ( - 2147483648 / 2147483647 , 10 ) ; for ( let i = 0 ; i < parseInt ( n / 2 , 10 ) ; i ++ ) { let temp = arr [ i ] ; arr [ i ] = arr [ n + ( x * i ) + x ] ; arr [ n + ( x * i ) + x ] = temp ; } } let arr = [ 5 , 3 , 7 , 2 , 1 , 6 ] ; let n = arr . length ; reversearray ( arr , n ) ; for ( let i = 0 ; i < n ; i ++ ) document . write ( arr [ i ] + "" "" ) ;";"Reverse an array without using subtract sign â €˜ | Function to reverse array ; Trick to assign - 1 to a variable ; Reverse array in simple manner ; Swap ith index value with ( n - i - 1 ) th index value ; Drivers code ; print the reversed array"
Javascript;"function reverseArray ( arr , n ) { for ( let i = 0 ; i < parseInt ( n / 2 , 10 ) ; i ++ ) { swap ( arr , i , ( n + ~ i + 1 ) + ~ 1 + 1 ) ; } } function swap ( arr , i , j ) { let temp = arr [ i ] ; arr [ i ] = arr [ j ] ; arr [ j ] = temp ; return arr ; } let arr = [ 5 , 3 , 7 , 2 , 1 , 6 ] ; let n = arr . length ; reverseArray ( arr , n ) ; for ( let i = 0 ; i < n ; i ++ ) { document . write ( arr [ i ] + "" "" ) ; }";"Reverse an array without using subtract sign â €˜ | Function to reverse array ; Reverse array in simple manner ; Swap ith index value with ( n - i - 1 ) th index value Note : A - B = A + ~ B + 1 So n - i = n + ~ i + 1 then n - i - 1 = ( n + ~ i + 1 ) + ~ 1 + 1 ; Driver code ; print the reversed array"
Javascript;"function maxXORInRange ( L , R ) { let LXR = L ^ R ; let msbPos = 0 ; while ( LXR > 0 ) { msbPos ++ ; LXR >>= 1 ; } let maxXOR = 0 ; let two = 1 ; while ( msbPos -- > 0 ) { maxXOR += two ; two <<= 1 ; } return maxXOR ; } let L = 8 ; let R = 20 ; document . write ( maxXORInRange ( L , R ) ) ;";"Maximum XOR value of a pair from a range | method to get maximum xor value in range [ L , R ] ; get xor of limits ; loop to get msb position of L ^ R ; construct result by adding 1 , msbPos times ; Driver code"
Javascript;"function CountZeroBit ( n ) { let count = 0 ; while ( n > 0 ) { if ( n % 2 != 0 ) count ++ ; n >>= 1 ; } return count ; } function CountORandSumEqual ( N ) { let count = CountZeroBit ( N ) ; return ( 1 << count ) ; } let N = 10 ; document . write ( CountORandSumEqual ( N ) ) ;";"Numbers whose bitwise OR and sum with N are equal | Function to find total 0 bit in a number ; Function to find Count of non - negative numbers less than or equal to N , whose bitwise OR and SUM with N are equal . ; count number of zero bit in N ; power of 2 to count ; Driver code"
Javascript;"function countNumbers ( n ) { let k = 0 ; let count = 0 ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) count += ( Math . pow ( 2 , k ) ) ; k += 1 ; n >>= 1 ; } return count ; } let n = 11 ; document . write ( countNumbers ( n ) ) ;";"Count smaller numbers whose XOR with n produces greater value | Javascript program to count numbers whose XOR with n produces a value more than n . ; Position of current bit in n ; Traverse bits from LSB ( least significant bit ) to MSB ; Initialize result ; If the current bit is 0 , then there are 2 ^ k numbers with current bit 1 and whose XOR with n produces greater value ; Increase position for next bit ; Reduce n to find next bit ; Driver Code"
Javascript;"function xorPairCount ( arr , n , x ) { let s = new Set ( ) ; for ( let i = 0 ; i < n ; i ++ ) { if ( s . has ( x ^ arr [ i ] ) ) { result ++ ; } s . add ( arr [ i ] ) ; } return result ; } let arr = [ 5 , 4 , 10 , 15 , 7 , 6 ] ; let n = arr . length ; let x = 5 ; document . write ( "" "" + xorPairCount ( arr , n , x ) ) ;";"Count all pairs with given XOR | Returns count of pairs in arr [ 0. . n - 1 ] with XOR value equals to x . ; create empty set that stores the visiting element of array . Refer below post for details of unordered_set https : www . geeksforgeeks . org / unorderd_set - stl - uses / ; If there exist an element in set s with XOR equals to x ^ arr [ i ] , that means there exist an element such that the XOR of element with arr [ i ] is equal to x , then increment count . ; Make element visited ; return total count of pairs with XOR equal to x ; Driver code"
Javascript;"function isMultipleOf4 ( n ) { if ( n == 1 ) return false ; let XOR = 0 ; for ( let i = 1 ; i <= n ; i ++ ) XOR = XOR ^ i ; return ( XOR == n ) ; } for ( let n = 0 ; n <= 42 ; n ++ ) document . write ( isMultipleOf4 ( n ) ? n : "" "" ) ;";"Multiples of 4 ( An Interesting Method ) | Returns true if n is a multiple of 4. ; Find XOR of all numbers from 1 to n ; If XOR is equal n , then return true ; Printing multiples of 4 using above method"
Javascript;"function isMultipleOf4 ( n ) { if ( n == 0 ) return true ; return ( ( ( n >> 2 ) << 2 ) == n ) ; } for ( let n = 0 ; n <= 42 ; n ++ ) if ( isMultipleOf4 ( n ) ) document . write ( n + "" "" ) ;";"Multiples of 4 ( An Interesting Method ) | Returns true if n is a multiple of 4. ; Printing multiples of 4 using above method"
Javascript;"function countSetBits ( x ) { let count = 0 ; while ( x != 0 ) { x &= ( x - 1 ) ; count ++ ; } return count ; } function ceilLog2 ( x ) { let count = 0 ; x -- ; while ( x > 0 ) { x = x >> 1 ; count ++ ; } return count ; } function isBleak ( n ) { for ( let x = n - ceilLog2 ( n ) ; x < n ; x ++ ) if ( x + countSetBits ( x ) == n ) return false ; return true ; } if ( isBleak ( 3 ) ) document . write ( "" "" + "" "" ) ; else document . write ( "" "" + "" "" ) ; if ( isBleak ( 4 ) ) document . write ( "" "" + "" "" ) ; else document . write ( "" "" + "" "" ) ;";"Check if a number is Bleak | Function to get no of set bits in binary representation of passed binary no . ; A function to return ceiling of log x in base 2. For example , it returns 3 for 8 and 4 for 9. ; Returns true if n is Bleak ; Check for all numbers ' x ' smaller than n . If x + countSetBits ( x ) becomes n , then n can 't be Bleak ; Driver code"
Javascript;"function countStrings ( n ) { let a = [ ] , b = [ ] ; a [ 0 ] = b [ 0 ] = 1 ; for ( let i = 1 ; i < n ; i ++ ) { a [ i ] = a [ i - 1 ] + b [ i - 1 ] ; b [ i ] = a [ i - 1 ] ; } return ( 1 << n ) - a [ n - 1 ] - b [ n - 1 ] ; } document . write ( countStrings ( 5 ) ) ;";"Count strings with consecutive 1 's | Returns count of n length binary strings with consecutive 1 's ; Count binary strings without consecutive 1 's.  See the approach discussed on be  ( http:goo.gl/p8A3sW ) ; Subtract a [ n - 1 ] + b [ n - 1 ] from 2 ^ n ; Driver Code"
Javascript;"function swapBits ( n , p1 , p2 ) { n ^= 1 << p1 ; n ^= 1 << p2 ; return n ; } document . write ( "" "" + swapBits ( 28 , 0 , 3 ) ) ;";"How to swap two bits in a given integer ? | JavaScript code for swapping given bits of a number ; left - shift 1 p1 and p2 times and using XOR ; Driver code"
Javascript;"function maxLength ( a , n ) { let maxLen = 0 ; let prev_cnt = 0 , curr_cnt = 1 ; for ( let i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) curr_cnt ++ ; else { prev_cnt = curr_cnt ; curr_cnt = 1 ; } maxLen = Math . max ( maxLen , Math . min ( prev_cnt , curr_cnt ) ) ; } return ( 2 * maxLen ) ; } let arr = [ 1 , 1 , 1 , 0 , 0 , 1 , 1 ] ; let n = arr . length ; document . write ( maxLength ( arr , n ) ) ;";"Maximum length sub | Function to return the maximum length of the required sub - array ; To store the maximum length for a valid subarray ; To store the count of contiguous similar elements for previous group and the current group ; If current element is equal to the previous element then it is a part of the same group ; Else update the previous group and start counting elements for the new group ; Update the maximum possible length for a group ; Return the maximum length of the valid subarray ; Driver code"
Javascript;"function stack_push ( stack ) { for ( var i = 0 ; i < 5 ; i ++ ) { stack . push ( i ) ; } return stack ; } function stack_pop ( stack ) { document . write ( "" "" ) ; for ( var i = 0 ; i < 5 ; i ++ ) { var y = parseInt ( stack [ stack . length - 1 ] ) ; stack . pop ( ) ; document . write ( y + "" "" ) ; } return stack ; } function stack_peek ( stack ) { var element = parseInt ( stack [ stack . length - 1 ] ) ; document . write ( "" "" + element + "" "" ) ; } function stack_search ( stack , element ) { var pos = - 1 , co = 0 ; while ( stack . length > 0 ) { co ++ ; if ( stack [ stack . length - 1 ] == element ) { pos = co ; break ; } stack . pop ( ) ; } if ( pos == - 1 ) document . write ( "" "" + "" "" ) ; else document . write ( "" "" + pos + "" "" ) ; } stack = [ ] ; stack = stack_push ( stack ) ; stack = stack_pop ( stack ) ; stack = stack_push ( stack ) ; stack_peek ( stack ) ; stack_search ( stack , 2 ) ; stack_search ( stack , 6 ) ;";"LIFO ( Last | Pushing element on the top of the stack ; Popping element from the top of the stack ; Displaying element on the top of the stack ; Searching element in the stack ; Driver code"
